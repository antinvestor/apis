name: Changelog CI

on:
  pull_request:
    types: [opened, reopened, synchronize]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect Changed Packages
        id: set-matrix
        run: |
          # Fetch base branch refs
          git fetch origin ${{ github.base_ref }}
          
          # Get the list of changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}..HEAD)
          else
            CHANGED_FILES=$(git diff --name-only HEAD^..HEAD)
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Initialize arrays for each language
          declare -A packages
          
          # Define all packages
          ALL_PACKAGES=("chat" "common" "device" "files" "ledger" "lostid" "notification" "ocr" "partition" "payment" "profile" "property" "settings")
          LANGUAGES=("dart" "go" "java")
          
          # Check each language/package combination
          for lang in "${LANGUAGES[@]}"; do
            for pkg in "${ALL_PACKAGES[@]}"; do
              if echo "$CHANGED_FILES" | grep -q "^${lang}/${pkg}/"; then
                packages["${lang}/${pkg}"]=1
              fi
            done
          done
          
          # Build JSON array for matrix
          matrix_json="["
          first=true
          for key in "${!packages[@]}"; do
            lang="${key%%/*}"
            pkg="${key##*/}"
            if [ "$first" = true ]; then
              first=false
            else
              matrix_json+=","
            fi
            matrix_json+="{\"language\":\"${lang}\",\"package\":\"${pkg}\"}"
          done
          matrix_json+="]"
          
          # If no changes detected, create empty matrix
          if [ "$matrix_json" = "[]" ]; then
            echo "No package changes detected"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
          else
            echo "matrix={\"include\":${matrix_json}}" >> $GITHUB_OUTPUT
          fi
          
          echo "Matrix: {\"include\":${matrix_json}}"

  changelog:
    needs: detect-changes
    if: needs.detect-changes.outputs.matrix != '{"include":[]}'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Fetch base branch ref
        run: |
          if [ -n "${{ github.base_ref }}" ]; then
            git fetch --no-tags --depth=1 origin "${{ github.base_ref }}:${{ github.base_ref }}" || true
            git branch --track "${{ github.base_ref }}" "origin/${{ github.base_ref }}" 2>/dev/null || true
            git show-ref | grep "refs/remotes/origin/${{ github.base_ref }}" || git fetch origin "${{ github.base_ref }}"
          fi

      - name: Get Release Version
        id: release-version
        run: |
          
          # Get the most recent tag that matches the module
          TAGS=$(git tag --sort=-creatordate | grep "^v" | head -n 1)
          echo "Found tag: $TAGS"
          if [[ -z "$TAGS" ]]; then
            echo "not_enough_tags=true" >> $GITHUB_OUTPUT
            echo "No tags found"
          else
            LATEST_TAG=$(echo "$TAGS" | head -n 1)
            echo "latest_tag=$LATEST_TAG" >> $GITHUB_ENV
            echo "not_enough_tags=false" >> $GITHUB_OUTPUT
          fi
          
          # Fetch the latest release (draft or published)
          LATEST_RELEASE=$(gh release list --limit 1 --json tagName,isDraft --jq '.[0] | .tagName')
          
          if [ -n "$LATEST_RELEASE" ]; then
            # If we have a release, check if it's a draft
            IS_DRAFT=$(gh release view "$LATEST_RELEASE" --json isDraft --jq '.isDraft')
            
            if [ "$IS_DRAFT" = "true" ]; then
              # Use draft version as is
              VERSION="${LATEST_RELEASE#v}"
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "Using draft release version: $VERSION"
            else
              # Increment patch version for non-draft releases
              IFS='.' read -r major minor patch <<< "${LATEST_RELEASE#v}"
              NEW_PATCH=$((patch + 1))
              VERSION="${major}.${minor}.${NEW_PATCH}"
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "Incremented patch version: ${LATEST_RELEASE} -> $VERSION"
            fi
          else
            # No releases found, check PR title for version
            PR_TITLE="${{ github.event.pull_request.title }}"
            VERSION=$(echo "$PR_TITLE" | grep -oP 'v?\K[0-9]+\.[0-9]+\.[0-9]+' || echo "")
            if [ -n "$VERSION" ]; then
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "Using version from PR title: $VERSION"
            else
              # Default to 0.1.0 if no version found
              VERSION="0.1.0"
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "No releases found, using default version: $VERSION"
            fi
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute changelog range
        run: |
          if [ -n "${{ env.latest_tag }}" ]; then
            echo "FROM_REF=${{ env.latest_tag }}" >> $GITHUB_ENV
            echo "Using latest tag as fromRef: ${{ env.latest_tag }}"
          else
            BASE_REF="origin/${{ github.base_ref }}"
            git fetch origin "${{ github.base_ref }}" --depth=1 || true
            BASE_SHA=$(git rev-parse "$BASE_REF" 2>/dev/null || echo "")
            if [ -n "$BASE_SHA" ]; then
              MERGE_BASE=$(git merge-base "$BASE_SHA" "${{ github.event.pull_request.head.sha }}" 2>/dev/null || echo "")
            else
              MERGE_BASE=$(git merge-base "origin/${{ github.base_ref }}" "${{ github.event.pull_request.head.sha }}" 2>/dev/null || echo "")
            fi
            if [ -z "$MERGE_BASE" ]; then
              MERGE_BASE=$(git rev-list --max-parents=0 HEAD | tail -n 1)
            fi
            echo "FROM_REF=$MERGE_BASE" >> $GITHUB_ENV
            echo "Using merge-base as fromRef: $MERGE_BASE"
          fi

      - name: Generate Changelog for ${{ matrix.language }}/${{ matrix.package }}
        uses: mikepenz/release-changelog-builder-action@v6.0.0
        id: changelog
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          mode: "HYBRID"
          includeOpen: "true"
          fetchViaCommits: "true"
          fromTag: ${{ env.FROM_REF }}
          toTag: ${{ github.event.pull_request.head.sha }}
          includeOnlyPaths: |
            ${{ matrix.language }}/${{ matrix.package }}/
            proto/${{ matrix.package }}/
          ignorePreReleases: "false"
          configurationJson: |
            {
              "template": "#{{CHANGELOG}}",
              "categories": [
                {
                    "title": "## Feature",
                    "labels": ["feat", "feature"]
                },
                {
                    "title": "## Fix",
                    "labels": ["fix", "bug"]
                },
                {
                    "title": "## Other",
                    "labels": []
                }
              ],
              "label_extractor": [
                {
                  "pattern": "^(build|chore|ci|docs|feat|fix|perf|refactor|revert|style|test){1}(\\([\\w\\-\\.]+\\))?(!)?: ([\\w ])+([\\s\\S]*)",
                  "on_property": "title",
                  "target": "$1"
                }
              ]
            }
          outputFile: "${{ matrix.language }}/${{ matrix.package }}/CHANGELOG.md"
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Display Changelog for ${{ matrix.language }}/${{ matrix.package }}
        if: steps.changelog.outputs.failed != 'true' && steps.changelog.outputs.changelog != ''
        run: |
          echo "## 📝 Changelog for ${{ matrix.language }}/${{ matrix.package }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat "${{ matrix.language }}/${{ matrix.package }}/CHANGELOG.md" | head -n 20 >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*[View full changelog](${{ github.server_url }}/${{ github.repository }}/blob/${{ github.sha }}/${{ matrix.language }}/${{ matrix.package }}/CHANGELOG.md)*" >> $GITHUB_STEP_SUMMARY

      - name: Debug changelog outputs
        run: |
          echo "## 🔎 Changelog debug for ${{ matrix.language }}/${{ matrix.package }}" >> $GITHUB_STEP_SUMMARY
          echo "fromTag: ${{ steps.changelog.outputs.fromTag }}" >> $GITHUB_STEP_SUMMARY
          echo "toTag:   ${{ steps.changelog.outputs.toTag }}" >> $GITHUB_STEP_SUMMARY
          echo "categorized_prs: ${{ steps.changelog.outputs.categorized_prs }}" >> $GITHUB_STEP_SUMMARY
          echo "open_prs:        ${{ steps.changelog.outputs.open_prs }}" >> $GITHUB_STEP_SUMMARY
          echo "commits:         ${{ steps.changelog.outputs.commits }}" >> $GITHUB_STEP_SUMMARY
          echo "changes:         ${{ steps.changelog.outputs.changes }}" >> $GITHUB_STEP_SUMMARY
          echo "failed:  ${{ steps.changelog.outputs.failed }}" >> $GITHUB_STEP_SUMMARY
          echo "cache:   ${{ steps.changelog.outputs.cache }}" >> $GITHUB_STEP_SUMMARY

      - name: Update pubspec.yaml version for Dart
        if: steps.changelog.outputs.failed != 'true' && steps.changelog.outputs.changelog != '' && matrix.language == 'dart'
        run: |
          VERSION="${{ steps.release-version.outputs.version }}"
          PUBSPEC_FILE="${{ matrix.language }}/${{ matrix.package }}/pubspec.yaml"
          
          if [ -f "$PUBSPEC_FILE" ]; then
            CURRENT_VERSION=$(grep '^version:' "$PUBSPEC_FILE" | sed 's/version: //')
            echo "Current version in pubspec.yaml: $CURRENT_VERSION"
            
            if [ "$CURRENT_VERSION" != "$VERSION" ]; then
              echo "Updating pubspec.yaml version to $VERSION"
              sed -i "s/^version: .*/version: $VERSION/" "$PUBSPEC_FILE"
              git add "$PUBSPEC_FILE"
            else
              echo "Version already up to date: $VERSION"
            fi
          else
            echo "Warning: pubspec.yaml not found at $PUBSPEC_FILE"
          fi

      - name: Commit Changelog
        if: steps.changelog.outputs.failed != 'true' && steps.changelog.outputs.changelog != '' && (github.event_name != 'pull_request' || github.event.pull_request.head.repo.fork == false)
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          BRANCH="${GITHUB_HEAD_REF:-$(git rev-parse --abbrev-ref HEAD)}"
          # Ensure we are up to date with the remote to avoid non-fast-forward issues
          git fetch origin "$BRANCH"
          git config --global pull.rebase true
          git pull --rebase origin "$BRANCH" || true

          git add "${{ matrix.language }}/${{ matrix.package }}/CHANGELOG.md"

          # Add pubspec.yaml if it exists and was modified (for Dart packages)
          if [ -f "${{ matrix.language }}/${{ matrix.package }}/pubspec.yaml" ]; then
            git add "${{ matrix.language }}/${{ matrix.package }}/pubspec.yaml" 2>/dev/null || true
          fi

          # Create commit if there are staged changes
          if git diff --cached --quiet; then
            echo "No changes to commit. Skipping push."
            exit 0
          fi

          git commit -m "chore(${{ matrix.package }}): update changelog and version to v${{ steps.release-version.outputs.version }}"

          # Try pushing; if non-fast-forward, rebase again and retry with lease
          if git push origin "$BRANCH"; then
            echo "Push succeeded."
          else
            echo "Initial push failed. Attempting rebase and retry..."
            git fetch origin "$BRANCH"
            git rebase "origin/$BRANCH" || true
            git push origin "$BRANCH" || git push --force-with-lease origin "$BRANCH"
          fi
