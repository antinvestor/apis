/*
 * Ant Investor Files
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@antinvestor.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.antinvestor.apis.files.api;

import com.antinvestor.apis.files.invoker.ApiClient;
import com.antinvestor.apis.files.invoker.ApiException;
import com.antinvestor.apis.files.invoker.ApiResponse;
import com.antinvestor.apis.files.invoker.Configuration;
import com.antinvestor.apis.files.invoker.Pair;

import com.antinvestor.apis.files.model.CreateContent200Response;
import com.antinvestor.apis.files.model.Error;
import com.antinvestor.apis.files.model.GetConfig200Response;
import com.antinvestor.apis.files.model.GetUrlPreview200Response;
import com.antinvestor.apis.files.model.InlineObject;
import java.net.URI;
import com.antinvestor.apis.files.model.UploadContent200Response;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.14.0")
public class MediaApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public MediaApi() {
    this(Configuration.getDefaultApiClient());
  }

  public MediaApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Create a new &#x60;mxc://&#x60; URI without uploading the content.
   * Creates a new &#x60;mxc://&#x60; URI, independently of the content being uploaded. The content must be provided later via [&#x60;PUT /_matrix/media/v3/upload/{serverName}/{mediaId}&#x60;](/client-server-api/#put_matrixmediav3uploadservernamemediaid).  The server may optionally enforce a maximum age for unused IDs, and delete media IDs when the client doesn&#39;t start the upload in time, or when the upload was interrupted and not resumed in time. The server should include the maximum POSIX millisecond timestamp to complete the upload in the &#x60;unused_expires_at&#x60; field in the response JSON. The recommended default expiration is 24 hours which should be enough time to accommodate users on poor connection who find a better connection to complete the upload.  As well as limiting the rate of requests to create &#x60;mxc://&#x60; URIs, the server should limit the number of concurrent *pending media uploads* a given user can have. A pending media upload is a created &#x60;mxc://&#x60; URI where (a) the media has not yet been uploaded, and (b) has not yet expired (the &#x60;unused_expires_at&#x60; timestamp has not yet passed). In both cases, the server should respond with an HTTP 429 error with an errcode of &#x60;M_LIMIT_EXCEEDED&#x60;.
   * @return CreateContent200Response
   * @throws ApiException if fails to make API call
   */
  public CreateContent200Response createContent() throws ApiException {
    ApiResponse<CreateContent200Response> localVarResponse = createContentWithHttpInfo();
    return localVarResponse.getData();
  }

  /**
   * Create a new &#x60;mxc://&#x60; URI without uploading the content.
   * Creates a new &#x60;mxc://&#x60; URI, independently of the content being uploaded. The content must be provided later via [&#x60;PUT /_matrix/media/v3/upload/{serverName}/{mediaId}&#x60;](/client-server-api/#put_matrixmediav3uploadservernamemediaid).  The server may optionally enforce a maximum age for unused IDs, and delete media IDs when the client doesn&#39;t start the upload in time, or when the upload was interrupted and not resumed in time. The server should include the maximum POSIX millisecond timestamp to complete the upload in the &#x60;unused_expires_at&#x60; field in the response JSON. The recommended default expiration is 24 hours which should be enough time to accommodate users on poor connection who find a better connection to complete the upload.  As well as limiting the rate of requests to create &#x60;mxc://&#x60; URIs, the server should limit the number of concurrent *pending media uploads* a given user can have. A pending media upload is a created &#x60;mxc://&#x60; URI where (a) the media has not yet been uploaded, and (b) has not yet expired (the &#x60;unused_expires_at&#x60; timestamp has not yet passed). In both cases, the server should respond with an HTTP 429 error with an errcode of &#x60;M_LIMIT_EXCEEDED&#x60;.
   * @return ApiResponse&lt;CreateContent200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CreateContent200Response> createContentWithHttpInfo() throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createContentRequestBuilder();
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createContent", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<CreateContent200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<CreateContent200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CreateContent200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createContentRequestBuilder() throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/create";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get the configuration for the content repository.
   * This endpoint allows clients to retrieve the configuration of the content repository, such as upload limitations. Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available.  {{% boxes/note %}} Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint. {{% /boxes/note %}}
   * @return GetConfig200Response
   * @throws ApiException if fails to make API call
   */
  public GetConfig200Response getConfig() throws ApiException {
    ApiResponse<GetConfig200Response> localVarResponse = getConfigWithHttpInfo();
    return localVarResponse.getData();
  }

  /**
   * Get the configuration for the content repository.
   * This endpoint allows clients to retrieve the configuration of the content repository, such as upload limitations. Clients SHOULD use this as a guide when using content repository endpoints. All values are intentionally left optional. Clients SHOULD follow the advice given in the field description when the field is not available.  {{% boxes/note %}} Both clients and server administrators should be aware that proxies between the client and the server may affect the apparent behaviour of content repository APIs, for example, proxies may enforce a lower upload size limit than is advertised by the server on this endpoint. {{% /boxes/note %}}
   * @return ApiResponse&lt;GetConfig200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetConfig200Response> getConfigWithHttpInfo() throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getConfigRequestBuilder();
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getConfig", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<GetConfig200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<GetConfig200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetConfig200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getConfigRequestBuilder() throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/config";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Download content from the content repository.
   * {{% boxes/note %}} Clients SHOULD NOT generate or use URLs which supply the access token in the query string. These URLs may be copied by users verbatim and provided in a chat message to another user, disclosing the sender&#39;s access token. {{% /boxes/note %}}  Clients MAY be redirected using the 307/308 responses below to download the request object. This is typical when the homeserver uses a Content Delivery Network (CDN).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param timeoutMs The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository SHOULD impose a maximum value for this parameter. The content repository MAY respond before the timeout.  (optional, default to 20000)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object getContent(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nullable Long timeoutMs) throws ApiException {
    ApiResponse<Object> localVarResponse = getContentWithHttpInfo(serverName, mediaId, timeoutMs);
    return localVarResponse.getData();
  }

  /**
   * Download content from the content repository.
   * {{% boxes/note %}} Clients SHOULD NOT generate or use URLs which supply the access token in the query string. These URLs may be copied by users verbatim and provided in a chat message to another user, disclosing the sender&#39;s access token. {{% /boxes/note %}}  Clients MAY be redirected using the 307/308 responses below to download the request object. This is typical when the homeserver uses a Content Delivery Network (CDN).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param timeoutMs The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository SHOULD impose a maximum value for this parameter. The content repository MAY respond before the timeout.  (optional, default to 20000)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Object> getContentWithHttpInfo(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nullable Long timeoutMs) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getContentRequestBuilder(serverName, mediaId, timeoutMs);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getContent", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<Object>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<Object>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<Object>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getContentRequestBuilder(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nullable Long timeoutMs) throws ApiException {
    // verify the required parameter 'serverName' is set
    if (serverName == null) {
      throw new ApiException(400, "Missing the required parameter 'serverName' when calling getContent");
    }
    // verify the required parameter 'mediaId' is set
    if (mediaId == null) {
      throw new ApiException(400, "Missing the required parameter 'mediaId' when calling getContent");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/download/{serverName}/{mediaId}"
        .replace("{serverName}", ApiClient.urlEncode(serverName.toString()))
        .replace("{mediaId}", ApiClient.urlEncode(mediaId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "timeout_ms";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timeout_ms", timeoutMs));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/octet-stream, application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Download content from the content repository overriding the file name.
   * This will download content from the content repository (same as the previous endpoint) but replaces the target file name with the one provided by the caller.  {{% boxes/note %}} Clients SHOULD NOT generate or use URLs which supply the access token in the query string. These URLs may be copied by users verbatim and provided in a chat message to another user, disclosing the sender&#39;s access token. {{% /boxes/note %}}  Clients MAY be redirected using the 307/308 responses below to download the request object. This is typical when the homeserver uses a Content Delivery Network (CDN).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param fileName A filename to give in the &#x60;Content-Disposition&#x60; header. (required)
   * @param timeoutMs The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository SHOULD impose a maximum value for this parameter. The content repository MAY respond before the timeout.  (optional, default to 20000)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object getContentOverrideName(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nonnull String fileName, @javax.annotation.Nullable Long timeoutMs) throws ApiException {
    ApiResponse<Object> localVarResponse = getContentOverrideNameWithHttpInfo(serverName, mediaId, fileName, timeoutMs);
    return localVarResponse.getData();
  }

  /**
   * Download content from the content repository overriding the file name.
   * This will download content from the content repository (same as the previous endpoint) but replaces the target file name with the one provided by the caller.  {{% boxes/note %}} Clients SHOULD NOT generate or use URLs which supply the access token in the query string. These URLs may be copied by users verbatim and provided in a chat message to another user, disclosing the sender&#39;s access token. {{% /boxes/note %}}  Clients MAY be redirected using the 307/308 responses below to download the request object. This is typical when the homeserver uses a Content Delivery Network (CDN).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param fileName A filename to give in the &#x60;Content-Disposition&#x60; header. (required)
   * @param timeoutMs The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository SHOULD impose a maximum value for this parameter. The content repository MAY respond before the timeout.  (optional, default to 20000)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Object> getContentOverrideNameWithHttpInfo(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nonnull String fileName, @javax.annotation.Nullable Long timeoutMs) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getContentOverrideNameRequestBuilder(serverName, mediaId, fileName, timeoutMs);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getContentOverrideName", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<Object>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<Object>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<Object>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getContentOverrideNameRequestBuilder(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nonnull String fileName, @javax.annotation.Nullable Long timeoutMs) throws ApiException {
    // verify the required parameter 'serverName' is set
    if (serverName == null) {
      throw new ApiException(400, "Missing the required parameter 'serverName' when calling getContentOverrideName");
    }
    // verify the required parameter 'mediaId' is set
    if (mediaId == null) {
      throw new ApiException(400, "Missing the required parameter 'mediaId' when calling getContentOverrideName");
    }
    // verify the required parameter 'fileName' is set
    if (fileName == null) {
      throw new ApiException(400, "Missing the required parameter 'fileName' when calling getContentOverrideName");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/download/{serverName}/{mediaId}/{fileName}"
        .replace("{serverName}", ApiClient.urlEncode(serverName.toString()))
        .replace("{mediaId}", ApiClient.urlEncode(mediaId.toString()))
        .replace("{fileName}", ApiClient.urlEncode(fileName.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "timeout_ms";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timeout_ms", timeoutMs));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/octet-stream, application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Download a thumbnail of content from the content repository
   * Download a thumbnail of content from the content repository. See the [Thumbnails](/client-server-api/#thumbnails) section for more information.  {{% boxes/note %}} Clients SHOULD NOT generate or use URLs which supply the access token in the query string. These URLs may be copied by users verbatim and provided in a chat message to another user, disclosing the sender&#39;s access token. {{% /boxes/note %}}  Clients MAY be redirected using the 307/308 responses below to download the request object. This is typical when the homeserver uses a Content Delivery Network (CDN).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param width The *desired* width of the thumbnail. The actual thumbnail may be larger than the size specified. (required)
   * @param height The *desired* height of the thumbnail. The actual thumbnail may be larger than the size specified. (required)
   * @param method The desired resizing method. See the [Thumbnails](/client-server-api/#thumbnails) section for more information. (optional)
   * @param timeoutMs The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository SHOULD impose a maximum value for this parameter. The content repository MAY respond before the timeout.  (optional, default to 20000)
   * @param animated Indicates preference for an animated thumbnail from the server, if possible. Animated thumbnails typically use the content types &#x60;image/gif&#x60;, &#x60;image/png&#x60; (with APNG format), &#x60;image/apng&#x60;, and &#x60;image/webp&#x60; instead of the common static &#x60;image/png&#x60; or &#x60;image/jpeg&#x60; content types.  When &#x60;true&#x60;, the server SHOULD return an animated thumbnail if possible and supported. When &#x60;false&#x60;, the server MUST NOT return an animated thumbnail. For example, returning a static &#x60;image/png&#x60; or &#x60;image/jpeg&#x60; thumbnail. When not provided, the server SHOULD NOT return an animated thumbnail.  Servers SHOULD prefer to return &#x60;image/webp&#x60; thumbnails when supporting animation.  When &#x60;true&#x60; and the media cannot be animated, such as in the case of a JPEG or PDF, the server SHOULD behave as though &#x60;animated&#x60; is &#x60;false&#x60;.  (optional)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object getContentThumbnail(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nonnull Integer width, @javax.annotation.Nonnull Integer height, @javax.annotation.Nullable String method, @javax.annotation.Nullable Long timeoutMs, @javax.annotation.Nullable Boolean animated) throws ApiException {
    ApiResponse<Object> localVarResponse = getContentThumbnailWithHttpInfo(serverName, mediaId, width, height, method, timeoutMs, animated);
    return localVarResponse.getData();
  }

  /**
   * Download a thumbnail of content from the content repository
   * Download a thumbnail of content from the content repository. See the [Thumbnails](/client-server-api/#thumbnails) section for more information.  {{% boxes/note %}} Clients SHOULD NOT generate or use URLs which supply the access token in the query string. These URLs may be copied by users verbatim and provided in a chat message to another user, disclosing the sender&#39;s access token. {{% /boxes/note %}}  Clients MAY be redirected using the 307/308 responses below to download the request object. This is typical when the homeserver uses a Content Delivery Network (CDN).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param width The *desired* width of the thumbnail. The actual thumbnail may be larger than the size specified. (required)
   * @param height The *desired* height of the thumbnail. The actual thumbnail may be larger than the size specified. (required)
   * @param method The desired resizing method. See the [Thumbnails](/client-server-api/#thumbnails) section for more information. (optional)
   * @param timeoutMs The maximum number of milliseconds that the client is willing to wait to start receiving data, in the case that the content has not yet been uploaded. The default value is 20000 (20 seconds). The content repository SHOULD impose a maximum value for this parameter. The content repository MAY respond before the timeout.  (optional, default to 20000)
   * @param animated Indicates preference for an animated thumbnail from the server, if possible. Animated thumbnails typically use the content types &#x60;image/gif&#x60;, &#x60;image/png&#x60; (with APNG format), &#x60;image/apng&#x60;, and &#x60;image/webp&#x60; instead of the common static &#x60;image/png&#x60; or &#x60;image/jpeg&#x60; content types.  When &#x60;true&#x60;, the server SHOULD return an animated thumbnail if possible and supported. When &#x60;false&#x60;, the server MUST NOT return an animated thumbnail. For example, returning a static &#x60;image/png&#x60; or &#x60;image/jpeg&#x60; thumbnail. When not provided, the server SHOULD NOT return an animated thumbnail.  Servers SHOULD prefer to return &#x60;image/webp&#x60; thumbnails when supporting animation.  When &#x60;true&#x60; and the media cannot be animated, such as in the case of a JPEG or PDF, the server SHOULD behave as though &#x60;animated&#x60; is &#x60;false&#x60;.  (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Object> getContentThumbnailWithHttpInfo(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nonnull Integer width, @javax.annotation.Nonnull Integer height, @javax.annotation.Nullable String method, @javax.annotation.Nullable Long timeoutMs, @javax.annotation.Nullable Boolean animated) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getContentThumbnailRequestBuilder(serverName, mediaId, width, height, method, timeoutMs, animated);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getContentThumbnail", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<Object>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<Object>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<Object>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getContentThumbnailRequestBuilder(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nonnull Integer width, @javax.annotation.Nonnull Integer height, @javax.annotation.Nullable String method, @javax.annotation.Nullable Long timeoutMs, @javax.annotation.Nullable Boolean animated) throws ApiException {
    // verify the required parameter 'serverName' is set
    if (serverName == null) {
      throw new ApiException(400, "Missing the required parameter 'serverName' when calling getContentThumbnail");
    }
    // verify the required parameter 'mediaId' is set
    if (mediaId == null) {
      throw new ApiException(400, "Missing the required parameter 'mediaId' when calling getContentThumbnail");
    }
    // verify the required parameter 'width' is set
    if (width == null) {
      throw new ApiException(400, "Missing the required parameter 'width' when calling getContentThumbnail");
    }
    // verify the required parameter 'height' is set
    if (height == null) {
      throw new ApiException(400, "Missing the required parameter 'height' when calling getContentThumbnail");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/thumbnail/{serverName}/{mediaId}"
        .replace("{serverName}", ApiClient.urlEncode(serverName.toString()))
        .replace("{mediaId}", ApiClient.urlEncode(mediaId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "width";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("width", width));
    localVarQueryParameterBaseName = "height";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("height", height));
    localVarQueryParameterBaseName = "method";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("method", method));
    localVarQueryParameterBaseName = "timeout_ms";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timeout_ms", timeoutMs));
    localVarQueryParameterBaseName = "animated";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("animated", animated));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "image/jpeg, image/png, image/apng, image/gif, image/webp, application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get information about a URL for a client
   * Get information about a URL for the client. Typically this is called when a client sees a URL in a message and wants to render a preview for the user.  {{% boxes/note %}} Clients should consider avoiding this endpoint for URLs posted in encrypted rooms. Encrypted rooms often contain more sensitive information the users do not want to share with the homeserver, and this can mean that the URLs being shared should also not be shared with the homeserver. {{% /boxes/note %}}
   * @param url The URL to get a preview of. (required)
   * @param ts The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available. (optional)
   * @return GetUrlPreview200Response
   * @throws ApiException if fails to make API call
   */
  public GetUrlPreview200Response getUrlPreview(@javax.annotation.Nonnull URI url, @javax.annotation.Nullable Long ts) throws ApiException {
    ApiResponse<GetUrlPreview200Response> localVarResponse = getUrlPreviewWithHttpInfo(url, ts);
    return localVarResponse.getData();
  }

  /**
   * Get information about a URL for a client
   * Get information about a URL for the client. Typically this is called when a client sees a URL in a message and wants to render a preview for the user.  {{% boxes/note %}} Clients should consider avoiding this endpoint for URLs posted in encrypted rooms. Encrypted rooms often contain more sensitive information the users do not want to share with the homeserver, and this can mean that the URLs being shared should also not be shared with the homeserver. {{% /boxes/note %}}
   * @param url The URL to get a preview of. (required)
   * @param ts The preferred point in time to return a preview for. The server may return a newer version if it does not have the requested version available. (optional)
   * @return ApiResponse&lt;GetUrlPreview200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetUrlPreview200Response> getUrlPreviewWithHttpInfo(@javax.annotation.Nonnull URI url, @javax.annotation.Nullable Long ts) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getUrlPreviewRequestBuilder(url, ts);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getUrlPreview", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<GetUrlPreview200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<GetUrlPreview200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetUrlPreview200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getUrlPreviewRequestBuilder(@javax.annotation.Nonnull URI url, @javax.annotation.Nullable Long ts) throws ApiException {
    // verify the required parameter 'url' is set
    if (url == null) {
      throw new ApiException(400, "Missing the required parameter 'url' when calling getUrlPreview");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/preview_url";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "url";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("url", url));
    localVarQueryParameterBaseName = "ts";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ts", ts));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Upload some content to the content repository.
   * 
   * @param body  (required)
   * @param contentType **Optional.** The content type of the file being uploaded.  Clients SHOULD always supply this header.  Defaults to &#x60;application/octet-stream&#x60; if it is not set. This header became explicitly optional with a default value.  (optional)
   * @param filename The name of the file being uploaded (optional)
   * @return UploadContent200Response
   * @throws ApiException if fails to make API call
   */
  public UploadContent200Response uploadContent(@javax.annotation.Nullable Object body, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable String filename) throws ApiException {
    ApiResponse<UploadContent200Response> localVarResponse = uploadContentWithHttpInfo(body, contentType, filename);
    return localVarResponse.getData();
  }

  /**
   * Upload some content to the content repository.
   * 
   * @param body  (required)
   * @param contentType **Optional.** The content type of the file being uploaded.  Clients SHOULD always supply this header.  Defaults to &#x60;application/octet-stream&#x60; if it is not set. This header became explicitly optional with a default value.  (optional)
   * @param filename The name of the file being uploaded (optional)
   * @return ApiResponse&lt;UploadContent200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UploadContent200Response> uploadContentWithHttpInfo(@javax.annotation.Nullable Object body, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable String filename) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = uploadContentRequestBuilder(body, contentType, filename);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("uploadContent", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<UploadContent200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<UploadContent200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UploadContent200Response>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder uploadContentRequestBuilder(@javax.annotation.Nullable Object body, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable String filename) throws ApiException {
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling uploadContent");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/upload";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filename";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filename", filename));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (contentType != null) {
      localVarRequestBuilder.header("Content-Type", contentType.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/octet-stream");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Upload content to an &#x60;mxc://&#x60; URI that was created earlier.
   * This endpoint permits uploading content to an &#x60;mxc://&#x60; URI that was created earlier via [POST /_matrix/media/v1/create](/client-server-api/#post_matrixmediav1create).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param body  (required)
   * @param contentType **Optional.** The content type of the file being uploaded.  Clients SHOULD always supply this header.  Defaults to &#x60;application/octet-stream&#x60; if it is not set. This header became explicitly optional with a default value.  (optional)
   * @param filename The name of the file being uploaded (optional)
   * @return Object
   * @throws ApiException if fails to make API call
   */
  public Object uploadContentToMXC(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nullable Object body, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable String filename) throws ApiException {
    ApiResponse<Object> localVarResponse = uploadContentToMXCWithHttpInfo(serverName, mediaId, body, contentType, filename);
    return localVarResponse.getData();
  }

  /**
   * Upload content to an &#x60;mxc://&#x60; URI that was created earlier.
   * This endpoint permits uploading content to an &#x60;mxc://&#x60; URI that was created earlier via [POST /_matrix/media/v1/create](/client-server-api/#post_matrixmediav1create).
   * @param serverName The server name from the &#x60;mxc://&#x60; URI (the authority component).  (required)
   * @param mediaId The media ID from the &#x60;mxc://&#x60; URI (the path component).  (required)
   * @param body  (required)
   * @param contentType **Optional.** The content type of the file being uploaded.  Clients SHOULD always supply this header.  Defaults to &#x60;application/octet-stream&#x60; if it is not set. This header became explicitly optional with a default value.  (optional)
   * @param filename The name of the file being uploaded (optional)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Object> uploadContentToMXCWithHttpInfo(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nullable Object body, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable String filename) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = uploadContentToMXCRequestBuilder(serverName, mediaId, body, contentType, filename);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("uploadContentToMXC", localVarResponse);
        }
        if (localVarResponse.body() == null) {
          return new ApiResponse<Object>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        String responseBody = new String(localVarResponse.body().readAllBytes());
        localVarResponse.body().close();

        return new ApiResponse<Object>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<Object>() {})
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder uploadContentToMXCRequestBuilder(@javax.annotation.Nonnull String serverName, @javax.annotation.Nonnull String mediaId, @javax.annotation.Nullable Object body, @javax.annotation.Nullable String contentType, @javax.annotation.Nullable String filename) throws ApiException {
    // verify the required parameter 'serverName' is set
    if (serverName == null) {
      throw new ApiException(400, "Missing the required parameter 'serverName' when calling uploadContentToMXC");
    }
    // verify the required parameter 'mediaId' is set
    if (mediaId == null) {
      throw new ApiException(400, "Missing the required parameter 'mediaId' when calling uploadContentToMXC");
    }
    // verify the required parameter 'body' is set
    if (body == null) {
      throw new ApiException(400, "Missing the required parameter 'body' when calling uploadContentToMXC");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/media/upload/{serverName}/{mediaId}"
        .replace("{serverName}", ApiClient.urlEncode(serverName.toString()))
        .replace("{mediaId}", ApiClient.urlEncode(mediaId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "filename";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("filename", filename));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (contentType != null) {
      localVarRequestBuilder.header("Content-Type", contentType.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/octet-stream");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
