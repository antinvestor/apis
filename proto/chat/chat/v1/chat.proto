// Copyright 2023-2024 Ant Investor Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package chat.v1;

import "buf/validate/validate.proto";
// -----------------------------------------------------
// Core notes (normative):
// - All timestamps are RFC3339 / google.protobuf.Timestamp.
// - All flows should be idempotent / accept idempotency keys where relevant.
// - Servers must enforce permission checks for each RPC (see AuthClaims below).
// -----------------------------------------------------
import "common/v1/common.proto";
import "gnostic/openapi/v3/annotations.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/antinvestor/apis/go/chat/v1;chatv1";
option java_multiple_files = true;
option java_package = "chatv1";
option (gnostic.openapi.v3.document) = {
  info: {
    title: "Chat Service"
    version: "v1.0.0"
    description: "The Chat Service provides endpoints for real-time, secure messaging between users and devices. It supports sending, receiving, and synchronizing messages across rooms, direct chats, and group conversations, with optional end-to-end encryption. The service is designed for mobile, desktop, and web clients, supporting both streaming and standard request-response operations. APIs are consistent, well-structured, and optimized for low-latency delivery, even on limited network connections."
    contact: {
      name: "Ant Investor Ltd"
      url: "https://github.com/antinvestor/service-chat"
      email: "info@antinvestor.com"
    }
    license: {
      name: "Apache License"
      url: "https://github.com/antinvestor/apis/blob/master/LICENSE"
    }
  }
  components: {
    security_schemes: {
      additional_properties: [
        {
          name: "BearerAuth"
          value: {
            security_scheme: {
              type: "http"
              scheme: "bearer"
              bearer_format: "JWT"
            }
          }
        }
      ]
    }
  }
};

// -----------------------------------------------------
// Authentication & Authorization (claims):
// - Clients authenticate using JWT from OIDC provider (short TTL).
// - Server-side/machine clients use mTLS + service account token or OAuth2 client creds.
// - Required claims in JWT: tenant_id, sub (profile_id), scope (space-separated or array).
// - Role-based scopes: "room.send", "room.manage", "room.read", "presence.write", "device.manage", "bot.*"
// - Servers MUST reject tokens missing tenant_id or sub.
// -----------------------------------------------------

// -----------------------------------------------------
// STREAM SERVICE: StreamService
// - Connect: BiDi streaming for a unified event timeline.
// - Handles real-time bidirectional communication.
// -----------------------------------------------------

service GatewayService {
  // Bi-directional, long-lived connection. Client sends StreamRequest (initial auth + acks/commands).
  // Server streams StreamResponse objects in chronological order for rooms the client is subscribed to.
  // Stream resume: client may provide last_received_event_id or resume_token to continue after reconnect.
  rpc Stream(stream StreamRequest) returns (stream StreamResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "stream"
      summary: "Establish bi-directional streaming connection"
      description: "Opens a persistent bi-directional stream for real-time chat events. Clients send StreamRequest messages (auth, acks, commands) and receive ServerEvent messages in chronological order. Supports session resumption via resume_token."
      tags: "Real-time"
    };
  }
}

// -----------------------------------------------------
// MAIN SERVICE: ChatService
// - Message ops: SendEvent (unified), GetHistory (cursor-based).
// - Room ops: create/update/manage members/roles.
// - Device & presence: register device, presence updates.
// - BotService included below for integration (service accounts).
// -----------------------------------------------------

service ChatService {
  // Send an event (unified message model). Idempotent if idempotency_key is provided.
  rpc SendEvent(SendEventRequest) returns (SendEventResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "sendEvent"
      summary: "Send an event to a room"
      description: "Sends one or more events to chat rooms. Supports text, attachments, reactions, and system messages. Idempotent when idempotency_key header is provided."
      tags: "Messages"
    };
  }

  // Fetch history for a room. Cursor-based paging (cursor = opaque server token).
  rpc GetHistory(GetHistoryRequest) returns (GetHistoryResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
    option (gnostic.openapi.v3.operation) = {
      operation_id: "getHistory"
      summary: "Retrieve message history for a room"
      description: "Fetches paginated message history for a specified room using cursor-based navigation. Supports forward and backward pagination."
      tags: "Messages"
    };
  }

  // Room lifecycle & management
  rpc CreateRoom(CreateRoomRequest) returns (CreateRoomResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "createRoom"
      summary: "Create a new chat room"
      description: "Creates a new chat room with specified configuration. The creator is automatically added as a member with owner privileges. Supports both public and private rooms."
      tags: "Rooms"
    };
  }
  rpc SearchRooms(SearchRoomsRequest) returns (stream SearchRoomsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
    option (gnostic.openapi.v3.operation) = {
      operation_id: "searchRooms"
      summary: "Search for chat rooms"
      description: "Searches for chat rooms matching the specified criteria. Returns a stream of matching rooms. Supports filtering by query, date range, and custom properties."
      tags: "Rooms"
    };
  }
  rpc UpdateRoom(UpdateRoomRequest) returns (UpdateRoomResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updateRoom"
      summary: "Update a chat room"
      description: "Updates the configuration of an existing chat room including name, topic, and metadata. Only room owners and moderators can update room settings."
      tags: "Rooms"
    };
  }
  rpc DeleteRoom(DeleteRoomRequest) returns (DeleteRoomResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "deleteRoom"
      summary: "Delete a chat room"
      description: "Permanently deletes a chat room and all its messages. This action cannot be undone. Only room owners can delete rooms."
      tags: "Rooms"
    };
  }

  // Subscriptionship & roles
  rpc AddRoomSubscriptions(AddRoomSubscriptionsRequest) returns (AddRoomSubscriptionsResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "addRoomSubscriptions"
      summary: "Add members to a room"
      description: "Adds one or more users to a chat room with specified roles. The requesting user must have owner or moderator privileges in the room."
      tags: "Subscriptions"
    };
  }
  rpc RemoveRoomSubscriptions(RemoveRoomSubscriptionsRequest) returns (RemoveRoomSubscriptionsResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "removeRoomSubscriptions"
      summary: "Remove members from a room"
      description: "Removes one or more users from a chat room. The requesting user must have owner or moderator privileges in the room, unless removing themselves."
      tags: "Subscriptions"
    };
  }
  rpc UpdateSubscriptionRole(UpdateSubscriptionRoleRequest) returns (UpdateSubscriptionRoleResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updateSubscriptionRole"
      summary: "Update a member's role in a room"
      description: "Updates the role(s) of a user in a chat room. The requesting user must have owner or moderator privileges in the room."
      tags: "Subscriptions"
    };
  }
  rpc SearchRoomSubscriptions(SearchRoomSubscriptionsRequest) returns (SearchRoomSubscriptionsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
    option (gnostic.openapi.v3.operation) = {
      operation_id: "searchRoomSubscriptions"
      summary: "List room members"
      description: "Retrieves a paginated list of users subscribed to a room, along with their roles and activity information."
      tags: "Subscriptions"
    };
  }

  // Real-time Activity APIs
  // -----------------------------------------------------

  // Update different states that the client can be in for room subscriptions awareness
  rpc UpdateClientState(UpdateClientStateRequest) returns (UpdateClientStateResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updateClientState"
      summary: "Update state from client"
      description: "Updates the state of an event in a specific room and optionally Broadcasts to all active participants."
      tags: "Real-time"
    };
  }

  // Get client state for a set of profiles in a room
  rpc GetClientState(GetClientStateRequest) returns (GetClientStateResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
    option (gnostic.openapi.v3.operation) = {
      operation_id: "getClientStates"
      summary: "Get client states for profiles in a room"
      description: "Retrieves client states for profiles in a room showing either which messages users have read, or presence state of the users in a room."
      tags: "Real-time"
    };
  }
}

// -----------------------------------------------------
// Events & Payloads
// -----------------------------------------------------

// Unified message (user / bot / system / signalling)
message RoomEvent {
  // NOTE:
  // Event IDs are XIDs and MUST be lexicographically sortable by creation time.
  // Clients MUST NOT assume any other ordering mechanism.
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // client-supplied or server-generated UUID
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // room_id
  string sender_id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // profile_id or service/bot id

  // The `type` MUST correspond to the populated payload.
  // Servers MUST reject mismatches.
  RoomEventType type = 4; // text, attachment, call_offer, etc.

  google.protobuf.Timestamp sent_at = 7;
  bool edited = 8;
  bool redacted = 9;
  optional string parent_id = 10 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // if this message is a followup event on an original message

  oneof payload {
    // type = ROOM_EVENT_TYPE_TEXT
    TextContent text = 15;

    // type = ROOM_EVENT_TYPE_ATTACHMENT
    AttachmentContent attachment = 16;

    // type = ROOM_EVENT_TYPE_REACTION
    ReactionContent reaction = 17;

    // type = ROOM_EVENT_TYPE_ENCRYPTED
    EncryptedContent encrypted = 18;

    // type = ROOM_EVENT_TYPE_CALL
    CallContent call = 19;
  }
}

// Allowed message types. Extendable via new enum values; clients must ignore unknown values.
enum RoomEventType {
  ROOM_EVENT_TYPE_UNSPECIFIED = 0;
  ROOM_EVENT_TYPE_EVENT = 1;
  ROOM_EVENT_TYPE_TEXT = 2;
  ROOM_EVENT_TYPE_ATTACHMENT = 3;
  ROOM_EVENT_TYPE_REACTION = 7;
  ROOM_EVENT_TYPE_ENCRYPTED = 6; // opaque ciphertext
  ROOM_EVENT_TYPE_EDIT = 8; // represents event overriding another
  ROOM_EVENT_TYPE_REDACTION = 9; // represents event deleting another
  ROOM_EVENT_TYPE_CALL = 21;
}

// Presence event affecting a user (and visible to rooms the user is a member of)
message PresenceEvent {
  string profile_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  PresenceStatus status = 2;
  string status_msg = 3;
  google.protobuf.Timestamp last_active = 4;
}

enum PresenceStatus {
  PRESENCE_STATUS_UNSPECIFIED = 0;
  PRESENCE_STATUS_OFFLINE = 1;
  PRESENCE_STATUS_ONLINE = 2;
}

// ReceiptEvent is OPTIONAL and ephemeral.
// Servers MAY ignore it.
// Clients SHOULD prefer ReadMarker for durable state.
// Servers MUST NOT persist ReceiptEvent.
// Servers MAY drop ReceiptEvent without acknowledgment.
message ReceiptEvent {
  string profile_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  repeated string event_id = 3 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.items = {
      string: {
        min_len: 3
        max_len: 40
        pattern: "[0-9a-z_-]{3,40}"
      }
    }
  ];
}

message ReadMarker {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string profile_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string up_to_event_id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
}

// Typing indicator
message TypingEvent {
  string profile_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  bool typing = 3;
  google.protobuf.Timestamp since = 5;
}

// -----------------------------------------------------
// Connect stream: client -> server low-level requests inside stream
// -----------------------------------------------------

// Acknowledgement for event(s) received; server uses it to free ephemeral delivery buffers.
// ack_event_id: last event_id client processed (inclusive).
// If error is set, indicates the event failed to send/process correctly.
message StreamAck {
  string event_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  google.protobuf.Timestamp ack_at = 3;
  google.protobuf.Struct metadata = 6;
  optional common.v1.ErrorDetail error = 7; // if set, indicates failure reason for this event
}

// StreamHello message sent by client to server to initiate a connection.
// resume_token: server-supplied resume_token from previous session.
// capabilities: list of capabilities supported by the client.
// StreamHello MUST be the first message sent by the client.
// Servers MUST reject any other message types before StreamHello.
message StreamHello {
  string resume_token = 1;
  map<string, string> capabilities = 2;
  google.protobuf.Timestamp client_time = 3;
}

// Generic client signal (typing, read markers that aren't receipts)
message ClientSignal {
  oneof signal {
    StreamAck ack = 3;
    TypingEvent typing = 4;
    ReceiptEvent receipt = 2; // receipt acknowledgement for message delivery
    PresenceEvent presence = 5; // send a presence message to a room
  }
}

// ClientCommand represents durable state changes initiated by the client.
// Commands are validated, persisted, and broadcast as needed.
// ClientCommand results in at least one RoomEvent being emitted.
message ClientCommand {
  oneof state {
    ReadMarker read_marker = 3;
    RoomEvent event = 10;
  }
}

// Client message over Connect stream. After initial connect frame, client sends acks/commands.
message StreamRequest {
  // The client can send various payloads inside the stream after initial auth:
  oneof payload {
    StreamHello hello = 1;
    ClientSignal signal_update = 11;
    ClientCommand command = 12;
  }
}

// Server -> Client event payload. All events in a room are delivered over Connect stream.
// event_id: globally unique id (opaque string) assigned by server, strictly monotonically increasing per room.
// sequence: strictly increasing 64-bit integer per-room sequence number (useful for resume & ordering).
message StreamResponse {
  // NOTE:
  // Stream IDs are XIDs and MUST be lexicographically sortable by creation time.
  // Clients MUST NOT assume any other ordering mechanism.
  string id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  google.protobuf.Timestamp timestamp = 5;
  oneof payload {
    RoomEvent message = 10;
    PresenceEvent presence_event = 12; // user presence change affecting the room
    ReceiptEvent receipt_event = 13;
    ReadMarker read_event = 15;
    TypingEvent typing_event = 17;

    // error:
    // - If present, represents a server-side error related to the stream or event.
    // - MAY be recoverable (client should continue stream) or fatal.
    // - Fatal errors MUST be followed by stream termination.
    common.v1.ErrorDetail error = 20;
  }
}

// -----------------------------------------------------
// Message RPCs (unified send + get history)
// -----------------------------------------------------

message SendEventRequest {
  repeated RoomEvent event = 4; // message payload (server will assign final event_id if empty)
}

message SendEventResponse {
  repeated StreamAck ack = 1;
}

// History request: paging via opaque cursor. 'limit' is capped by server (e.g. 100).
// Ordering is determined by XID lexicographic order.
// Cursor encapsulates last seen event ID.
message GetHistoryRequest {
  string room_id = 2;
  common.v1.PageCursor cursor = 3;
  // direction: FORWARD means older -> newer; BACKWARD newer -> older (default BACKWARD).
  bool forward = 5;
}

message GetHistoryResponse {
  repeated StreamResponse events = 1;
  string next_cursor = 2; // opaque; empty when no more pages
  string prev_cursor = 3;
}

// -----------------------------------------------------
// Room APIs
// -----------------------------------------------------

message Room {
  string id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string name = 3 [
    (buf.validate.field).string.min_len = 2,
    (buf.validate.field).string.max_len = 200
  ];
  string description = 4;
  bool is_private = 5;
  google.protobuf.Struct metadata = 6;
  google.protobuf.Timestamp created_at = 7;
  google.protobuf.Timestamp updated_at = 8;
  string creator_id = 9;
}

message CreateRoomRequest {
  string id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // optional client-provided idempotency key
  string name = 4 [
    (buf.validate.field).string.min_len = 2,
    (buf.validate.field).string.max_len = 200
  ];
  string description = 5;
  bool is_private = 6;
  repeated common.v1.ContactLink members = 7; // optional
  google.protobuf.Struct metadata = 8;
}

message CreateRoomResponse {
  Room room = 1;
  common.v1.ErrorDetail error = 2;
}

message SearchRoomsRequest {
  string query = 1;
  repeated string properties = 6;
  google.protobuf.Struct extras = 7;
  common.v1.PageCursor cursor = 10;
}

message SearchRoomsResponse {
  repeated Room data = 1;
}

message UpdateRoomRequest {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string name = 3;
  string topic = 4;
  google.protobuf.Struct metadata = 5;
}

message UpdateRoomResponse {
  Room room = 1;
  common.v1.ErrorDetail error = 2;
}

message DeleteRoomRequest {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
}

message DeleteRoomResponse {
  string room_id = 1;
  common.v1.ErrorDetail error = 2;
}

// -----------------------------------------------------
// Subscriptionship & roles
// -----------------------------------------------------

message RoomSubscription {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  common.v1.ContactLink member = 3;
  repeated string roles = 4; // e.g. ["owner","moderator","member","guest"]
  google.protobuf.Timestamp joined_at = 5;
  google.protobuf.Timestamp last_active = 6;
}

message AddRoomSubscriptionsRequest {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  repeated RoomSubscription members = 3; // include roles if desired
}

message AddRoomSubscriptionsResponse {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  common.v1.ErrorDetail error = 3;
}

message RemoveRoomSubscriptionsRequest {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  repeated string profile_ids = 3;
}

message RemoveRoomSubscriptionsResponse {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  common.v1.ErrorDetail error = 3;
}

message UpdateSubscriptionRoleRequest {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string profile_id = 3;
  repeated string roles = 4;
}

message UpdateSubscriptionRoleResponse {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  common.v1.ErrorDetail error = 3;
}

message SearchRoomSubscriptionsRequest {
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  int32 limit = 3;
  string cursor = 4;
}
message SearchRoomSubscriptionsResponse {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  repeated RoomSubscription members = 2;
  string next_cursor = 3;
}

// -----------------------------------------------------
// Real-time Activity Request/Response Messages
// -----------------------------------------------------

message UpdateClientStateRequest {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string profile_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  repeated ClientCommand client_states = 3;
}

message UpdateClientStateResponse {
  common.v1.ErrorDetail error = 1;
}

// GetClientState obtains the state of a set of profiles in a room
message GetClientStateRequest {
  string room_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  repeated string profile_ids = 2;

  enum ClientStateType {
    CLIENT_STATE_TYPE_UNSPECIFIED = 0;
    CLIENT_STATE_TYPE_PRESENCE = 1;
    CLIENT_STATE_TYPE_READ_MARKER = 2;
  }
  ClientStateType state_type = 3;
}

message GetClientStateResponse {
  string room_id = 1;
  repeated ClientCommand client_state = 2;
}

message TextContent {
  // Required human-readable message body
  string body = 1 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 10000
  ];

  // Content format identifier (NOT MIME type)
  // Examples: "plain", "markdown", "html-lite"
  string format = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 32
  ];

  // Structured annotations for clients (mentions, links, emojis)
  repeated TextAnnotation annotations = 3;

  // Optional language hint (BCP-47), e.g. "en", "fr-CA"
  optional string lang = 4;
}

message TextAnnotation {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_MENTION_USER = 1;
    TYPE_MENTION_ROOM = 2;
    TYPE_LINK = 3;
    TYPE_EMOJI = 4;
    TYPE_HASHTAG = 5;
  }

  Type type = 1;

  // UTF-16 offset & length for cross-platform compatibility
  int32 offset = 2;
  int32 length = 3;

  // Target identifier (e.g., profile_id, room_id, URL)
  string value = 4;
}

message AttachmentContent {
  // Logical identifier of the attachment
  string attachment_id = 1;

  // Original filename (optional, user-facing)
  string filename = 2;

  // MIME type (e.g. image/png, application/pdf)
  string mime_type = 3;

  // Size in bytes (for quota enforcement & UX)
  int64 size_bytes = 4;

  // Content location (signed URL or opaque locator)
  string uri = 5;

  // Optional previews / thumbnails
  repeated AttachmentPreview previews = 6;

  // Optional caption text
  optional TextContent caption = 7;

  // Indicates whether attachment is end-to-end encrypted
  bool encrypted = 8;

  // Optional content hash (e.g. sha256:base64)
  optional string checksum = 9;
}

message AttachmentPreview {
  string mime_type = 1;
  int32 width = 2;
  int32 height = 3;
  string uri = 4;
  int64 size_bytes = 5;
}

message ReactionContent {
  // Target message being reacted to
  string target_event_id = 1 [(buf.validate.field).string.min_len = 3];

  // Reaction key (e.g. üëç, ‚ù§Ô∏è, :custom_emoji:)
  string reaction = 2 [
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64
  ];

  // add=true ‚Üí ensure reaction exists
  // add=false ‚Üí ensure reaction does not exist
  bool add = 3;
}

message EncryptedContent {
  // Encryption scheme identifier
  // Examples: "olm.v2", "megolm.v1", "x25519-aesgcm"
  string algorithm = 1;

  // Base64 or binary-safe encoded ciphertext
  bytes ciphertext = 2;

  // Optional per-message nonce / IV
  optional bytes nonce = 3;

  // Optional sender key identifier
  optional string sender_key_id = 4;

  // Optional recipient key references (for fan-out)
  repeated string recipient_key_ids = 5;

  // Additional authenticated data (AAD)
  optional bytes aad = 6;

  // Optional key agreement context identifier
  optional string session_id = 7;
}

message CallContent {
  enum CallType {
    CALL_TYPE_UNSPECIFIED = 0;
    CALL_TYPE_AUDIO = 1;
    CALL_TYPE_VIDEO = 2;
    CALL_TYPE_SCREEN_SHARE = 3;
  }

  enum CallAction {
    CALL_ACTION_UNSPECIFIED = 0;
    CALL_ACTION_OFFER = 1;
    CALL_ACTION_ANSWER = 2;
    CALL_ACTION_ICE_CANDIDATE = 3;
    CALL_ACTION_END = 4;
  }

  string call_id = 1;
  CallType type = 2;

  // OFFER, ANSWER ‚Üí sdp required
  // ICE_CANDIDATE ‚Üí ice_candidate required
  // END ‚Üí no payload required
  CallAction action = 3;

  // WebRTC payload (SDP or ICE candidate)
  optional string sdp = 4;

  // Optional ICE candidate (when action = ICE_CANDIDATE)
  optional string ice_candidate = 5;

  // Optional metadata (bitrate, codecs, device hints)
  google.protobuf.Struct metadata = 8;
}
