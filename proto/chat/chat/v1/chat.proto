// Copyright 2023-2024 Ant Investor Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package chat.v1;

// -----------------------------------------------------
// Core notes (normative):
// - All timestamps are RFC3339 / google.protobuf.Timestamp.
// - All flows should be idempotent / accept idempotency keys where relevant.
// - Servers must enforce permission checks for each RPC (see AuthClaims below).
// -----------------------------------------------------


import "buf/validate/validate.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "gnostic/openapi/v3/annotations.proto";

option go_package = "github.com/antinvestor/apis/go/chat/v1;chatv1";
option java_multiple_files = true;
option java_package = "chatv1";

option (gnostic.openapi.v3.document) = {
  info: {
    title: "Chat Service";
    version: "v1.0.0";
    description: "The Chat Service provides endpoints for real-time, secure messaging between users and devices. It supports sending, receiving, and synchronizing messages across rooms, direct chats, and group conversations, with optional end-to-end encryption. The service is designed for mobile, desktop, and web clients, supporting both streaming and standard request-response operations. APIs are consistent, well-structured, and optimized for low-latency delivery, even on limited network connections.";
    contact: {
      name: "Ant Investor Ltd";
      url: "https://github.com/antinvestor/service-chat";
      email: "info@antinvestor.com";
    }
    license: {
      name: "Apache License";
      url: "https://github.com/antinvestor/apis/blob/master/LICENSE";
    }
  }
  components: {
    security_schemes: {
      additional_properties: [
        {
          name: "BearerAuth";
          value: {
            security_scheme: {
              type: "http";
              scheme: "bearer";
              bearer_format: "JWT";
            }
          }
        }
      ]
    }
  }
};


// Standard error codes used by API responses.
// Use gRPC status codes; the application-level ErrorDetail below may carry more.
message ErrorDetail {
  int32 code = 1;         // application code (see doc)
  string message = 2;     // human readable
  map<string,string> meta = 3; // additional machine-readable data
}

// -----------------------------------------------------
// Authentication & Authorization (claims):
// - Clients authenticate using JWT from OIDC provider (short TTL).
// - Server-side/machine clients use mTLS + service account token or OAuth2 client creds.
// - Required claims in JWT: tenant_id, sub (profile_id), scope (space-separated or array).
// - Role-based scopes: "room.send", "room.manage", "room.read", "presence.write", "device.manage", "bot.*"
// - Servers MUST reject tokens missing tenant_id or sub.
// -----------------------------------------------------

// -----------------------------------------------------
// STREAM SERVICE: StreamService
// - Connect: BiDi streaming for a unified event timeline.
// - Handles real-time bidirectional communication.
// -----------------------------------------------------

service StreamService {
  // Bi-directional, long-lived connection. Client sends ConnectRequest (initial auth + acks/commands).
  // Server streams ServerEvent objects in chronological order for rooms the client is subscribed to.
  // Stream resume: client may provide last_received_event_id or resume_token to continue after reconnect.
  rpc Connect(stream ConnectRequest) returns (stream ServerEvent){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "connect"
      summary: "Establish bi-directional streaming connection"
      description: "Opens a persistent bi-directional stream for real-time chat events. Clients send ConnectRequest messages (auth, acks, commands) and receive ServerEvent messages in chronological order. Supports session resumption via resume_token."
      tags: "Real-time"
    };
  }
}

// -----------------------------------------------------
// MAIN SERVICE: ChatService
// - Message ops: SendEvent (unified), GetHistory (cursor-based).
// - Room ops: create/update/manage members/roles.
// - Device & presence: register device, presence updates.
// - BotService included below for integration (service accounts).
// -----------------------------------------------------

service ChatService {

  // Send an event (unified message model). Idempotent if idempotency_key is provided.
  rpc SendEvent(SendEventRequest) returns (SendEventResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "sendEvent"
      summary: "Send an event to a room"
      description: "Sends one or more events to chat rooms. Supports text, attachments, reactions, and system messages. Idempotent when idempotency_key header is provided."
      tags: "Messages"
    };
  }

  // Fetch history for a room. Cursor-based paging (cursor = opaque server token).
  rpc GetHistory(GetHistoryRequest) returns (GetHistoryResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "getHistory"
      summary: "Retrieve message history for a room"
      description: "Fetches paginated message history for a specified room using cursor-based navigation. Supports forward and backward pagination."
      tags: "Messages"
    };
  }

  // Room lifecycle & management
  rpc CreateRoom(CreateRoomRequest) returns (CreateRoomResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "createRoom"
      summary: "Create a new chat room"
      description: "Creates a new chat room with specified configuration. The creator is automatically added as a member with owner privileges. Supports both public and private rooms."
      tags: "Rooms"
    };
  }
  rpc SearchRooms(SearchRoomsRequest) returns (stream SearchRoomsResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "searchRooms"
      summary: "Search for chat rooms"
      description: "Searches for chat rooms matching the specified criteria. Returns a stream of matching rooms. Supports filtering by query, date range, and custom properties."
      tags: "Rooms"
    };
  }
  rpc UpdateRoom(UpdateRoomRequest) returns (UpdateRoomResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updateRoom"
      summary: "Update a chat room"
      description: "Updates the configuration of an existing chat room including name, topic, and metadata. Only room owners and moderators can update room settings."
      tags: "Rooms"
    };
  }
  rpc DeleteRoom(DeleteRoomRequest) returns (DeleteRoomResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "deleteRoom"
      summary: "Delete a chat room"
      description: "Permanently deletes a chat room and all its messages. This action cannot be undone. Only room owners can delete rooms."
      tags: "Rooms"
    };
  }

  // Subscriptionship & roles
  rpc AddRoomSubscriptions(AddRoomSubscriptionsRequest) returns (AddRoomSubscriptionsResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "addRoomSubscriptions"
      summary: "Add members to a room"
      description: "Adds one or more users to a chat room with specified roles. The requesting user must have owner or moderator privileges in the room."
      tags: "Subscriptions"
    };
  }
  rpc RemoveRoomSubscriptions(RemoveRoomSubscriptionsRequest) returns (RemoveRoomSubscriptionsResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "removeRoomSubscriptions"
      summary: "Remove members from a room"
      description: "Removes one or more users from a chat room. The requesting user must have owner or moderator privileges in the room, unless removing themselves."
      tags: "Subscriptions"
    };
  }
  rpc UpdateSubscriptionRole(UpdateSubscriptionRoleRequest) returns (UpdateSubscriptionRoleResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updateSubscriptionRole"
      summary: "Update a member's role in a room"
      description: "Updates the role(s) of a user in a chat room. The requesting user must have owner or moderator privileges in the room."
      tags: "Subscriptions"
    };
  }
  rpc SearchRoomSubscriptions(SearchRoomSubscriptionsRequest) returns (SearchRoomSubscriptionsResponse){
    option (gnostic.openapi.v3.operation) = {
      operation_id: "searchRoomSubscriptions"
      summary: "List room members"
      description: "Retrieves a paginated list of users subscribed to a room, along with their roles and activity information."
      tags: "Subscriptions"
    };
  }
}

// -----------------------------------------------------
// Events & Payloads
// -----------------------------------------------------

// Server -> Client event payload. All events in a room are delivered over Connect stream.
// event_id: globally unique id (opaque string) assigned by server, strictly monotonically increasing per room.
// sequence: strictly increasing 64-bit integer per-room sequence number (useful for resume & ordering).
message ServerEvent {
  string id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,20}"
  ];
  google.protobuf.Timestamp timestamp = 5;
  oneof payload {
    RoomEvent message = 10;
    PresenceEvent presence_event = 12; // user presence change affecting the room
    ReceiptEvent receipt_event = 13;
    TypingEvent typing_event = 14;
  }
}
// Unified message (user / bot / system / signalling)
message RoomEvent {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,20}"
  ];                           // client-supplied or server-generated UUID
  string room_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,20}"
  ];         // room_id
  string sender_id = 3;         // profile_id or service/bot id
  RoomEventType type = 4;         // text, attachment, call_offer, etc.
  google.protobuf.Struct payload = 6; // e.g. {"format":"markdown","mime":"image/png","attachment_id":"..."}
  google.protobuf.Timestamp sent_at = 7;
  bool edited = 8;
  bool redacted = 9;
  string replaces_event_id = 10; // if this message replaces another (edit)
  string relates_to_event_id = 11; // for reactions / replies
}

// Allowed message types. Extendable via new enum values; clients must ignore unknown values.
enum RoomEventType {
  MESSAGE_TYPE_UNSPECIFIED = 0;
  MESSAGE_TYPE_EVENT = 1;
  MESSAGE_TYPE_TEXT = 2;
  MESSAGE_TYPE_ATTACHMENT = 3;
  MESSAGE_TYPE_REACTION = 7;
  MESSAGE_TYPE_ENCRYPTED = 6; // opaque ciphertext
  MESSAGE_TYPE_SYSTEM = 10;
  MESSAGE_TYPE_CALL_OFFER = 21;
  MESSAGE_TYPE_CALL_ANSWER = 22;
  MESSAGE_TYPE_CALL_ICE = 23;
  MESSAGE_TYPE_CALL_END = 24;

  MESSAGE_TYPE_CUSTOM = 100;  // vendor/app specific; metadata must indicate schema
}

// Presence event affecting a user (and visible to rooms the user is a member of)
message PresenceEvent {
  string profile_id = 1;
  PresenceStatus status = 2;
  string status_msg = 3;
  google.protobuf.Timestamp last_active = 4;
}

enum PresenceStatus {
  PRESENCE_UNKNOWN = 0;
  PRESENCE_OFFLINE = 1;
  PRESENCE_ONLINE = 2;
  PRESENCE_AWAY = 3;
  PRESENCE_BUSY = 4;
}

// Read receipts
message ReceiptEvent {
  string profile_id = 1;
  string room_id = 2;
  string message_id = 3;
  google.protobuf.Timestamp read_at = 5;
}

// Typing indicator
message TypingEvent {
  string profile_id = 1;
  string room_id = 2;
  bool typing = 3;
  google.protobuf.Timestamp since = 5;
}

// -----------------------------------------------------
// Connect stream: client -> server low-level requests inside stream
// -----------------------------------------------------

// Client message over Connect stream. After initial connect frame, client sends acks/commands.
message ConnectRequest {
  // Servers should validate auth token before accepting further payload.
  string session_id = 2;
  string device_id = 3;
  string auth_token = 4; // JWT or short-lived token; also accepted via metadata at the transport layer

  // Optional resume token: server-supplied resume_token from previous session.
  // Server will validate and accept resume only if resume window allows it.
  string resume_token = 5;

  // The client can send various payloads inside the stream after initial auth:
  oneof payload {
    StreamAck ack = 10;
    ClientCommand command = 12;
  }
}

// Acknowledgement for event(s) received; server uses it to free ephemeral delivery buffers.
// ack_event_id: last event_id client processed (inclusive).
// If error is set, indicates the event failed to send/process correctly.
message StreamAck {
  string event_id = 1;
  google.protobuf.Timestamp ack_at = 3;
  google.protobuf.Struct metadata = 6;
  optional ErrorDetail error = 7; // if set, indicates failure reason for this event
}

// Generic client commands (typing, read markers that aren't receipts, and room events)
message ClientCommand {
  oneof cmd {
    TypingUpdate typing = 1;
    ReadMarker read_marker = 2; // marker for "read up to X"
    RoomEvent room_event = 3;    // send a room event (message) via the stream
  }
}
message TypingUpdate {
  string room_id = 1;
  bool typing = 2;
}
message ReadMarker {
  string room_id = 1;
  string up_to_event_id = 2;
}

// -----------------------------------------------------
// Message RPCs (unified send + get history)
// -----------------------------------------------------

message SendEventRequest {
  repeated RoomEvent message = 4;          // message payload (server will assign final message_id if empty)
}

message SendEventResponse {
  repeated StreamAck ack = 1;
}

// History request: paging via opaque cursor. 'limit' is capped by server (e.g. 100).
message GetHistoryRequest {
  string room_id = 2;
  string cursor = 3; // opaque token from prior GetHistoryResponse
  int32 limit = 4;
  // direction: FORWARD means older -> newer; BACKWARD newer -> older (default BACKWARD).
  bool forward = 5;
}

message GetHistoryResponse {
  repeated ServerEvent events = 1;
  string next_cursor = 2; // opaque; empty when no more pages
  string prev_cursor = 3;
}

// -----------------------------------------------------
// Room APIs
// -----------------------------------------------------

message Room {
  string id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,20}"
  ];
  string name = 3;
  string description = 4;
  bool is_private = 5;
  google.protobuf.Struct metadata = 6;
  google.protobuf.Timestamp created_at = 7;
  google.protobuf.Timestamp updated_at = 8;
  string creator_id = 9;
}

message CreateRoomRequest {
  string id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,20}"
  ]; // optional client-provided idempotency key
  string name = 4;
  string description = 5;
  bool is_private = 6;
  repeated string members = 7; // optional
  google.protobuf.Struct metadata = 8;
}

message CreateRoomResponse {
  Room room = 1;
  ErrorDetail error = 2;
}

message SearchRoomsRequest {
  string query = 1;
  int32 page = 2;
  int32 count = 3;
  string start_date = 4;
  string end_date = 5;
  repeated string properties = 6;
  google.protobuf.Struct extras = 7;
}

message SearchRoomsResponse {
  repeated Room data = 1;
}


message UpdateRoomRequest {
  string room_id = 2;
  string name = 3;
  string topic = 4;
  google.protobuf.Struct metadata = 5;
}

message UpdateRoomResponse {
  Room room = 1;
  ErrorDetail error = 2;
}

message DeleteRoomRequest {
  string room_id = 2;
}

message DeleteRoomResponse {
  string room_id = 1;
  ErrorDetail error = 2;
}

// -----------------------------------------------------
// Subscriptionship & roles
// -----------------------------------------------------

message RoomSubscription {
  string room_id = 2;
  string profile_id = 3;
  repeated string roles = 4; // e.g. ["owner","moderator","member","guest"]
  google.protobuf.Timestamp joined_at = 5;
  google.protobuf.Timestamp last_active = 6;
}

message AddRoomSubscriptionsRequest {
  string room_id = 2;
  repeated RoomSubscription members = 3; // include roles if desired
}

message AddRoomSubscriptionsResponse {
  string room_id = 1;
  ErrorDetail error = 3;
}

message RemoveRoomSubscriptionsRequest {
  string room_id = 2;
  repeated string profile_ids = 3;
}

message RemoveRoomSubscriptionsResponse {
  string room_id = 1;
  ErrorDetail error = 3;
}

message UpdateSubscriptionRoleRequest {
  string room_id = 2;
  string profile_id = 3;
  repeated string roles = 4;
}

message UpdateSubscriptionRoleResponse {
  string room_id = 1;
  ErrorDetail error = 3;
}

message SearchRoomSubscriptionsRequest {
  string room_id = 2;
  int32 limit = 3;
  string cursor = 4;
}
message SearchRoomSubscriptionsResponse {
  string room_id = 1;
  repeated RoomSubscription members = 2;
  string next_cursor = 3;
}