// Copyright (c) 2023 Ant Investor Ltd. Licensed under the Apache License 2.0. See https://www.apache.org/licenses/LICENSE-2.0

syntax = "proto3";

package device.v1;

// -----------------------------------------------------
// Core notes (normative):
// - Device Service manages device registration, tracking, and key/token management
// - All devices must be registered before use and linked to a profile
// - Supports device logs for session tracking and security auditing
// - KeyObject is used for all key types (FCM tokens, encryption keys, etc.)
// - All timestamps are RFC3339 / google.protobuf.Timestamp
// -----------------------------------------------------

import "buf/validate/validate.proto";
import "gnostic/openapi/v3/annotations.proto";
import "google/protobuf/struct.proto";

option go_package = "github.com/antinvestor/apis/go/device/v1;devicev1";
option java_multiple_files = true;
option java_package = "devicev1";
option (gnostic.openapi.v3.document) = {
  info: {
    title: "Device Management API"
    version: "v1.0.0"
    description: "The Device Management API provides comprehensive device management capabilities including device registration, session tracking, and unified key/token management. The API uses a unified KeyObject model for all key types including FCM tokens, encryption keys (Curve25519, Ed25519, Pickle), Matrix keys, and notification keys. This enables applications to register and track user devices across platforms (mobile, web, desktop), manage push notification tokens, handle encryption keys for secure communications, and maintain detailed logs of device activity for security and compliance purposes."
    contact: {
      name: "Ant Investor Ltd"
      url: "https://github.com/antinvestor/service-device"
      email: "info@antinvestor.com"
    }
    license: {
      name: "Apache License"
      url: "https://github.com/antinvestor/apis/blob/master/LICENSE"
    }
  }
  components: {
    security_schemes: {
      additional_properties: [
        {
          name: "BearerAuth"
          value: {
            security_scheme: {
              type: "http"
              scheme: "bearer"
              bearer_format: "JWT"
            }
          }
        }
      ]
    }
  }
};

// -----------------------------------------------------
// Enumerations
// -----------------------------------------------------

// KeyType defines the types of keys that can be stored for a device.
// Different key types serve different purposes in the security infrastructure.
// buf:lint:ignore ENUM_VALUE_PREFIX
enum KeyType {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
  MATRIX_KEY = 0; // Encryption key for Matrix protocol end-to-end encryption
  NOTIFICATION_KEY = 1; // Key for secure push notification delivery
  FCM_TOKEN = 2; // Firebase Cloud Messaging token for push notifications
  CURVE25519_KEY = 3; // Curve25519 key for ECDH
  ED25519_KEY = 4; // Ed25519 key for signing
  PICKLE_KEY = 5; // Pickled key for session storage
}

// PresenceStatus defines the online/offline status of a device.
// buf:lint:ignore ENUM_VALUE_PREFIX
enum PresenceStatus {
  // buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
  OFFLINE = 0; // Device is offline
  ONLINE = 1; // Device is online and active
  AWAY = 2; // Device is online but idle/away
  BUSY = 3; // Device is online but user is busy
  INVISIBLE = 4; // Device is online but appears offline to others
}

// -----------------------------------------------------
// Core Data Types
// -----------------------------------------------------

// Locale represents the localization settings for a device.
// Used to provide localized content and format data appropriately for the user.
message Locale {
  repeated string language = 1; // Preferred languages in priority order (e.g., ["en-US", "en"])
  string timezone = 5; // IANA timezone identifier (e.g., "America/New_York")
  string utc_offset = 6; // UTC offset in format "+HH:MM" or "-HH:MM"
  string currency = 8; // ISO 4217 currency code (e.g., "USD", "EUR")
  string currency_name = 9; // Human-readable currency name
  string code = 10; // ISO 3166-1 alpha-2 country code (e.g., "US", "GB")
}

// KeyObject represents a key or token associated with a device.
// Keys are used for secure communications, authentication, and push notifications.
message KeyObject {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Unique identifier for the key
  string device_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device this key belongs to
  KeyType key_type = 3; // Type of key (FCM token, encryption key, etc.)
  bytes key = 4; // The actual key material or token (encrypted at rest)
  string created_at = 5; // Timestamp when key was created (RFC3339)
  string expires_at = 6; // Optional expiration timestamp (RFC3339)
  bool is_active = 7; // Whether the key is currently active
  google.protobuf.Struct extra = 8 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional key metadata (algorithm, app_id, etc.)
}

// DeviceLog represents an activity log entry for a device.
// Logs track device sessions, locations, and activity for security auditing.
message DeviceLog {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Unique identifier for this log entry
  string device_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device this log entry belongs to
  string session_id = 3; // Session identifier for this activity
  string ip = 4; // IP address of the device during this session
  Locale locale = 5; // Locale settings during this session
  string user_agent = 6; // User agent string (browser/app info)
  string os = 7; // Operating system and version
  string last_seen = 8; // Last activity timestamp (RFC3339)
  google.protobuf.Struct location = 9 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Geographic location data (lat/long, city, country)
  google.protobuf.Struct extra = 10 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional log metadata
}

// DeviceObject represents a registered device in the system.
// Devices must be registered and linked to a profile before use.
message DeviceObject {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Unique identifier for the device
  string name = 2; // User-friendly device name (e.g., "John's iPhone")
  string session_id = 3; // Current active session identifier
  string ip = 4; // Last known IP address
  string user_agent = 5; // User agent string
  string os = 6; // Operating system and version
  string last_seen = 7; // Last activity timestamp (RFC3339)
  string profile_id = 8; // Profile this device is linked to
  Locale locale = 9; // Device locale settings
  PresenceStatus presence = 10; // Device presense status
  google.protobuf.Struct location = 11 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Last known geographic location
  google.protobuf.Struct properties = 15 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional device properties (model, manufacturer, etc.)
}

// PresenceObject represents the presence/availability status of a device.
// Tracks online/offline status and last activity for real-time communication features.
message PresenceObject {
  string device_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device this presence status belongs to
  string profile_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Profile this device belongs to
  PresenceStatus status = 3; // Current presence status
  string status_message = 4; // Optional custom status message
  string last_active = 5; // Timestamp of last activity (RFC3339)
  string updated_at = 6; // Timestamp when presence was last updated (RFC3339)
  google.protobuf.Struct extras = 7 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional presence metadata (activity type, etc.)
}

// -----------------------------------------------------
// Device Management Messages
// -----------------------------------------------------

// GetByIdRequest retrieves one or more devices by their unique identifiers.
message GetByIdRequest {
  repeated string id = 1 [(buf.validate.field).repeated.items = {
    string: {
      min_len: 3
      max_len: 40
      pattern: "[0-9a-z_-]{3,20}"
    }
  }]; // List of device IDs to retrieve
  bool extensive = 2; // If true, include additional details (logs, keys count, etc.)
}

// GetByIdResponse returns the requested devices.
message GetByIdResponse {
  repeated DeviceObject data = 1; // List of devices matching the request
}

// GetBySessionIdRequest retrieves a device by its active session identifier.
message GetBySessionIdRequest {
  string id = 1 [(buf.validate.field).string = {
    min_len: 3
    max_len: 40
    pattern: "[0-9a-z_-]{3,20}"
  }]; // Session ID to look up
}

// GetBySessionIdResponse returns the device associated with the session.
message GetBySessionIdResponse {
  DeviceObject data = 1; // Device object for the session
}

// SearchRequest searches for devices matching specified criteria.
message SearchRequest {
  string query = 1; // Search query (device name, OS, etc.)
  int32 page = 2; // Page number for pagination
  int32 count = 3; // Number of results per page
  string start_date = 4; // Filter devices created after this date (RFC3339)
  string end_date = 5; // Filter devices created before this date (RFC3339)
  repeated string properties = 6; // Specific properties to include in results
  google.protobuf.Struct extras = 7 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional search filters
}

// SearchResponse returns devices matching the search criteria.
message SearchResponse {
  repeated DeviceObject data = 1; // List of matching devices
}

// CreateRequest registers a new device in the system.
message CreateRequest {
  string name = 2; // User-friendly name for the device
  google.protobuf.Struct properties = 3 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Device properties (model, manufacturer, OS version, etc.)
}

// CreateResponse returns the newly created device.
message CreateResponse {
  DeviceObject data = 1; // The created device object
}

// UpdateRequest updates an existing device's information.
message UpdateRequest {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to update
  string name = 2; // New device name (if changing)
  google.protobuf.Struct properties = 3 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Updated device properties
}

// UpdateResponse returns the updated device.
message UpdateResponse {
  DeviceObject data = 1; // The updated device object
}

// LinkRequest links a device to a user profile.
// Devices must be linked before they can be used for authenticated operations.
message LinkRequest {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to link
  string profile_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Profile ID to link the device to
  google.protobuf.Struct properties = 3 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional linking properties
}

// LinkResponse returns the linked device.
message LinkResponse {
  DeviceObject data = 1; // The linked device object
}

// RemoveRequest removes a device from the system.
// This is typically used when a user logs out or removes a device from their account.
message RemoveRequest {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to remove
}

// RemoveResponse returns the removed device.
message RemoveResponse {
  DeviceObject data = 1; // The removed device object
}

// -----------------------------------------------------
// Device Logging Messages
// -----------------------------------------------------

// LogRequest creates a new activity log entry for a device.
// Used for tracking device sessions and security auditing.
message LogRequest {
  string device_id = 1 [
    (buf.validate.field).ignore = IGNORE_IF_ZERO_VALUE,
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID (optional if session_id is provided)

  string session_id = 3 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Session identifier for this activity

  string ip = 4; // IP address of the device
  string locale = 5; // Locale settings (JSON string)
  string user_agent = 6; // User agent string
  string os = 7; // Operating system and version
  string last_seen = 8; // Timestamp of this activity (RFC3339)
  google.protobuf.Struct extras = 9 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional log data (location, app version, etc.)
}

// LogResponse returns the created log entry.
message LogResponse {
  DeviceLog data = 1; // The created log entry
}

// ListLogsRequest retrieves activity logs for a device.
// Useful for security auditing and tracking device usage patterns.
message ListLogsRequest {
  string device_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to retrieve logs for
  int32 count = 2; // Maximum number of log entries to return
}

// ListLogsResponse returns device activity logs.
message ListLogsResponse {
  repeated DeviceLog data = 1; // List of log entries
}

// -----------------------------------------------------
// Key Management Messages
// -----------------------------------------------------

// AddKeyRequest adds a key or token to a device.
// Keys are used for secure communications (Matrix E2EE, push notifications, FCM tokens, etc.).
message AddKeyRequest {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Unique identifier for the key
  string device_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device this key belongs to
  KeyType key_type = 3; // Type of key (Matrix, FCM, Encryption, etc.)
  bytes data = 4; // The key material or token (will be encrypted at rest)
  string expires_at = 5; // Optional expiration timestamp (RFC3339)
  google.protobuf.Struct extras = 6 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional key metadata (algorithm, app_id, etc.)
}

// AddKeyResponse returns the created key.
message AddKeyResponse {
  KeyObject data = 1; // The created key object
}

// RemoveKeyRequest removes one or more keys or tokens from a device.
// Used when rotating keys, removing tokens, or removing a device.
message RemoveKeyRequest {
  repeated string id = 1 [(buf.validate.field).repeated.items = {
    string: {
      min_len: 3
      max_len: 40
      pattern: "[0-9a-z_-]{3,20}"
    }
  }]; // List of key IDs to remove
}

// RemoveKeyResponse returns the IDs of removed keys.
message RemoveKeyResponse {
  repeated string id = 1; // List of removed key IDs
}

// SearchKeyRequest searches for keys or tokens associated with a device.
message SearchKeyRequest {
  string query = 1; // Search query (key ID pattern, etc.)
  string device_id = 2 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to search keys for
  repeated KeyType key_types = 3; // Filter by key types (if empty, returns all)
  bool include_expired = 4; // If true, includes expired keys
  int32 page = 5; // Page number for pagination
  int32 count = 6; // Number of results per page
}

// SearchKeyResponse returns matching keys or tokens.
message SearchKeyResponse {
  repeated KeyObject data = 1; // List of matching keys
}

// -----------------------------------------------------
// Registration Messages (for third-party integration)
// -----------------------------------------------------

// RegisterKeyRequest registers a device with third-party services.
// Used when the key/token is generated by the third-party service (e.g., FCM token
// generated on device by FCM SDK). This links the device to the external service.
// For storing key material, use AddKeyRequest instead.
message RegisterKeyRequest {
  string device_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device to register with the service
  KeyType key_type = 2; // Type of service to register with (FCM_TOKEN, etc.)
  google.protobuf.Struct extras = 3 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Service-specific metadata (app_id, platform, etc.)
}

// RegisterKeyResponse returns confirmation of registration.
// The actual key/token data is managed by the third-party service.
message RegisterKeyResponse {
  KeyObject data = 1; // Registered key object with service metadata
}

// DeRegisterKeyRequest removes device registration from third-party services.
// This cleans up the connection with external services like FCM.
message DeRegisterKeyRequest {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Key ID to deregister from external service
}

// DeRegisterKeyResponse confirms service deregistration.
message DeRegisterKeyResponse {
  bool success = 1; // True if successfully deregistered from service
  string message = 2; // Status message from the external service
}

// -----------------------------------------------------
// Presence Management Messages
// -----------------------------------------------------

// UpdatePresenceRequest updates the presence status of a device.
message UpdatePresenceRequest {
  string device_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to update presence for
  PresenceStatus status = 2; // New presence status
  string status_message = 3; // Optional custom status message
  google.protobuf.Struct extras = 4 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional presence metadata
}

// UpdatePresenceResponse returns the updated presence.
message UpdatePresenceResponse {
  PresenceObject data = 1; // Updated presence object
}

// -----------------------------------------------------
// Device Notification Messages
// -----------------------------------------------------

// NotifyPayload represents the content and metadata of a single notification.
message NotifyMessage {
  string id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ];
  string title = 3; // Notification title
  string body = 4; // Notification body/message
  google.protobuf.Struct data = 5 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional notification data/payload (custom data, actions, etc.)
  google.protobuf.Struct extras = 6 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Extra notification options (priority, TTL, badge, sound, etc.)
}

// NotifyRequest sends one or more notifications to a device using its registered keys.
// The service will select an appropriate key based on key_type (e.g., FCM_TOKEN for push notifications).
message NotifyRequest {
  string device_id = 1 [
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Device ID to notify

  // The following fields remain for backward compatibility and represent a single notification payload.
  // New integrations should prefer the notifications field for bulk sending.
  string key_id = 2 [
    (buf.validate.field).ignore = IGNORE_IF_ZERO_VALUE,
    (buf.validate.field).string.min_len = 3,
    (buf.validate.field).string.max_len = 40,
    (buf.validate.field).string.pattern = "[0-9a-z_-]{3,40}"
  ]; // Specific key ID to use (optional - if not provided, uses key_type to select)
  KeyType key_type = 3; // Type of key to use for notification (e.g., FCM_TOKEN, NOTIFICATION_KEY)

  repeated NotifyMessage notifications = 8 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 500
  ]; // Collection of notifications to send in bulk.
}

// NotifyResult details the outcome of sending an individual notification payload.
message NotifyResult {
  bool success = 1; // True if notification was successfully sent
  string message = 2; // Status message or error details
  string notification_id = 3; // Unique identifier for the sent notification (if provided by service)
  google.protobuf.Struct extras = 4 [
    (buf.validate.field).cel = {
      id: "struct.size_limit"
      message: "Struct size exceeds maximum allowed limit of 1MB"
      expression: "size(this) <= 1048576"
    },
    (buf.validate.field).cel = {
      id: "struct.field_count_limit"
      message: "Struct contains too many fields (max 50)"
      expression: "this.fields.size() <= 50"
    }
  ]; // Additional response metadata from notification service
}

// NotifyResponse confirms the notifications were sent.
message NotifyResponse {
  repeated NotifyResult results = 5; // Per-notification send results when using bulk notifications
}

// -----------------------------------------------------
// Service Definitions
// -----------------------------------------------------

// DeviceService provides core device management and key/token management.
// All RPCs require authentication via Bearer token unless otherwise specified.
service DeviceService {
  // GetById retrieves one or more devices by their unique identifiers.
  // Supports batch retrieval for efficiency.
  rpc GetById(GetByIdRequest) returns (GetByIdResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "getDeviceById"
      summary: "Get devices by ID"
      description: "Retrieves one or more devices by their unique identifiers. Supports batch retrieval and optional extensive details including logs and key counts."
      tags: "Devices"
    };
  }

  // GetBySessionId retrieves a device by its active session identifier.
  // Useful for resolving devices from session tokens.
  rpc GetBySessionId(GetBySessionIdRequest) returns (GetBySessionIdResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "getDeviceBySessionId"
      summary: "Get device by session ID"
      description: "Retrieves a device by its active session identifier. Used to resolve device information from session tokens."
      tags: "Devices"
    };
  }

  // Search finds devices matching specified criteria.
  // Supports filtering by date range, properties, and full-text search.
  rpc Search(SearchRequest) returns (stream SearchResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "searchDevices"
      summary: "Search devices"
      description: "Searches for devices matching specified criteria including device name, OS, date range, and custom properties. Returns a stream of matching devices."
      tags: "Devices"
    };
  }

  // Create registers a new device in the system.
  // Returns a unique device ID that should be stored by the client.
  rpc Create(CreateRequest) returns (CreateResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "createDevice"
      summary: "Register a new device"
      description: "Registers a new device in the system. The device must be linked to a profile before it can be used for authenticated operations."
      tags: "Devices"
    };
  }

  // Update modifies an existing device's information.
  // Only the device owner or administrators can update device information.
  rpc Update(UpdateRequest) returns (UpdateResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updateDevice"
      summary: "Update device information"
      description: "Updates an existing device's name and properties. Only the device owner or administrators can perform this operation."
      tags: "Devices"
    };
  }

  // Link associates a device with a user profile.
  // Required before the device can be used for authenticated operations.
  rpc Link(LinkRequest) returns (LinkResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "linkDevice"
      summary: "Link device to profile"
      description: "Links a device to a user profile. This operation is required before the device can be used for authenticated operations."
      tags: "Devices"
    };
  }

  // Remove deletes a device from the system.
  // This operation cannot be undone.
  rpc Remove(RemoveRequest) returns (RemoveResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "removeDevice"
      summary: "Remove a device"
      description: "Removes a device from the system. This operation is typically used when a user logs out or removes a device from their account. This action cannot be undone."
      tags: "Devices"
    };
  }

  // Log creates a new activity log entry for a device.
  // Used for session tracking and security auditing.
  rpc Log(LogRequest) returns (LogResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "logDeviceActivity"
      summary: "Log device activity"
      description: "Creates a new activity log entry for a device. Used for tracking device sessions, locations, and activity for security auditing and compliance."
      tags: "Device Logs"
    };
  }

  // ListLogs retrieves activity logs for a device.
  // Returns a stream of log entries for the specified device.
  rpc ListLogs(ListLogsRequest) returns (stream ListLogsResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "listDeviceLogs"
      summary: "List device activity logs"
      description: "Retrieves activity logs for a device. Useful for security auditing, tracking device usage patterns, and compliance reporting."
      tags: "Device Logs"
    };
  }

  // AddKey stores a key or token and its material in the local storage for a device.
  // This is used for keys generated by the service or when the service needs to manage the key material directly.
  rpc AddKey(AddKeyRequest) returns (AddKeyResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "addDeviceKey"
      summary: "Add key or token"
      description: "Adds a key or token to a device. Supports FCM tokens, encryption keys (Curve25519, Ed25519), and other key types."
      tags: "Device Keys"
    };
  }

  // RemoveKey removes one or more keys or tokens from local storage.
  // This does not handle deregistration from third-party services. For that, use DeRegisterKey.
  rpc RemoveKey(RemoveKeyRequest) returns (RemoveKeyResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "removeDeviceKey"
      summary: "Remove keys or tokens"
      description: "Removes one or more keys or tokens from a device. Used for key rotation, token management, or when removing a device."
      tags: "Device Keys"
    };
  }

  // SearchKey searches for keys or tokens associated with a device.
  rpc SearchKey(SearchKeyRequest) returns (SearchKeyResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "searchDeviceKey"
      summary: "Search keys or tokens"
      description: "Searches for keys or tokens associated with a device. Supports filtering by key type and expiration."
      tags: "Device Keys"
    };
  }

  // RegisterKey registers a key with a third-party service using an externally-generated key or token.
  // This method handles the integration with the external service and stores metadata about the key,
  // but not the key material itself. Use AddKey to store key material.
  rpc RegisterKey(RegisterKeyRequest) returns (RegisterKeyResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "registerKey"
      summary: "Register key with third-party service"
      description: "Registers a key or token with third-party services (like FCM for push notifications) and stores it. This method handles both the external service integration and local storage."
      tags: "Key Registration"
    };
  }

  // DeRegisterKey deregisters a key from a third-party service.
  // This handles cleanup with the external service and removes the associated key metadata from local storage.
  rpc DeRegisterKey(DeRegisterKeyRequest) returns (DeRegisterKeyResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "deRegisterKey"
      summary: "DeRegister key from third-party service"
      description: "DeRegisters a key or token from third-party services (like FCM) and removes it from storage. This method handles both the external service cleanup and local deletion."
      tags: "Key Registration"
    };
  }

  // Notify sends a notification to a device using one of its registered keys.
  // The service selects an appropriate key based on key_type (e.g., FCM_TOKEN for push notifications).
  // If key_id is provided, that specific key will be used; otherwise the service selects the best available key.
  rpc Notify(NotifyRequest) returns (NotifyResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "notifyDevice"
      summary: "Notify device using registered key"
      description: "Sends a notification to a device using one of its registered keys (FCM token, notification key, etc.). The service automatically selects an appropriate active key based on the key_type, or uses a specific key if key_id is provided."
      tags: "Device Notifications"
    };
  }

  // UpdatePresence updates the presence status of a device.
  // Used to track online/offline status and availability for real-time features.
  rpc UpdatePresence(UpdatePresenceRequest) returns (UpdatePresenceResponse) {
    option (gnostic.openapi.v3.operation) = {
      operation_id: "updatePresence"
      summary: "Update device presence"
      description: "Updates the presence status of a device. Used to indicate online/offline/away/busy status and track last activity for real-time communication features."
      tags: "Device Presence"
    };
  }
}
