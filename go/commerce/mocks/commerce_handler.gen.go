// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/commerce/connectrpc/go/commerce/v1/commercev1connect.CommerceServiceClient -o commerce_handler.gen.go -n CommerceServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/commerce/protocolbuffers/go/commerce/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// CommerceServiceClientMock implements mm_commercev1connect.CommerceServiceClient
type CommerceServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCartLine          func(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest]) (pp2 *connect.Response[v1.AddCartLineResponse], err error)
	funcAddCartLineOrigin    string
	inspectFuncAddCartLine   func(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest])
	afterAddCartLineCounter  uint64
	beforeAddCartLineCounter uint64
	AddCartLineMock          mCommerceServiceClientMockAddCartLine

	funcCreateCart          func(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest]) (pp2 *connect.Response[v1.CreateCartResponse], err error)
	funcCreateCartOrigin    string
	inspectFuncCreateCart   func(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest])
	afterCreateCartCounter  uint64
	beforeCreateCartCounter uint64
	CreateCartMock          mCommerceServiceClientMockCreateCart

	funcCreateFulfilment          func(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest]) (pp2 *connect.Response[v1.CreateFulfilmentResponse], err error)
	funcCreateFulfilmentOrigin    string
	inspectFuncCreateFulfilment   func(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest])
	afterCreateFulfilmentCounter  uint64
	beforeCreateFulfilmentCounter uint64
	CreateFulfilmentMock          mCommerceServiceClientMockCreateFulfilment

	funcCreateOrder          func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest]) (pp2 *connect.Response[v1.CreateOrderResponse], err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest])
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mCommerceServiceClientMockCreateOrder

	funcCreateOrderFromCart          func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest]) (pp2 *connect.Response[v1.CreateOrderFromCartResponse], err error)
	funcCreateOrderFromCartOrigin    string
	inspectFuncCreateOrderFromCart   func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest])
	afterCreateOrderFromCartCounter  uint64
	beforeCreateOrderFromCartCounter uint64
	CreateOrderFromCartMock          mCommerceServiceClientMockCreateOrderFromCart

	funcCreateProduct          func(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest]) (pp2 *connect.Response[v1.CreateProductResponse], err error)
	funcCreateProductOrigin    string
	inspectFuncCreateProduct   func(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest])
	afterCreateProductCounter  uint64
	beforeCreateProductCounter uint64
	CreateProductMock          mCommerceServiceClientMockCreateProduct

	funcCreateProductVariant          func(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest]) (pp2 *connect.Response[v1.CreateProductVariantResponse], err error)
	funcCreateProductVariantOrigin    string
	inspectFuncCreateProductVariant   func(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest])
	afterCreateProductVariantCounter  uint64
	beforeCreateProductVariantCounter uint64
	CreateProductVariantMock          mCommerceServiceClientMockCreateProductVariant

	funcCreateShop          func(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest]) (pp2 *connect.Response[v1.CreateShopResponse], err error)
	funcCreateShopOrigin    string
	inspectFuncCreateShop   func(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest])
	afterCreateShopCounter  uint64
	beforeCreateShopCounter uint64
	CreateShopMock          mCommerceServiceClientMockCreateShop

	funcGetCart          func(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest]) (pp2 *connect.Response[v1.GetCartResponse], err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest])
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCommerceServiceClientMockGetCart

	funcGetFulfilment          func(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest]) (pp2 *connect.Response[v1.GetFulfilmentResponse], err error)
	funcGetFulfilmentOrigin    string
	inspectFuncGetFulfilment   func(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest])
	afterGetFulfilmentCounter  uint64
	beforeGetFulfilmentCounter uint64
	GetFulfilmentMock          mCommerceServiceClientMockGetFulfilment

	funcGetOrder          func(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest]) (pp2 *connect.Response[v1.GetOrderResponse], err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest])
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mCommerceServiceClientMockGetOrder

	funcGetProduct          func(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest]) (pp2 *connect.Response[v1.GetProductResponse], err error)
	funcGetProductOrigin    string
	inspectFuncGetProduct   func(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest])
	afterGetProductCounter  uint64
	beforeGetProductCounter uint64
	GetProductMock          mCommerceServiceClientMockGetProduct

	funcGetShop          func(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest]) (pp2 *connect.Response[v1.GetShopResponse], err error)
	funcGetShopOrigin    string
	inspectFuncGetShop   func(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest])
	afterGetShopCounter  uint64
	beforeGetShopCounter uint64
	GetShopMock          mCommerceServiceClientMockGetShop

	funcListOrders          func(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest]) (pp2 *connect.Response[v1.ListOrdersResponse], err error)
	funcListOrdersOrigin    string
	inspectFuncListOrders   func(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest])
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mCommerceServiceClientMockListOrders

	funcListProducts          func(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest]) (pp2 *connect.Response[v1.ListProductsResponse], err error)
	funcListProductsOrigin    string
	inspectFuncListProducts   func(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest])
	afterListProductsCounter  uint64
	beforeListProductsCounter uint64
	ListProductsMock          mCommerceServiceClientMockListProducts

	funcRemoveCartLine          func(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest]) (pp2 *connect.Response[v1.RemoveCartLineResponse], err error)
	funcRemoveCartLineOrigin    string
	inspectFuncRemoveCartLine   func(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest])
	afterRemoveCartLineCounter  uint64
	beforeRemoveCartLineCounter uint64
	RemoveCartLineMock          mCommerceServiceClientMockRemoveCartLine

	funcUpdateFulfilment          func(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest]) (pp2 *connect.Response[v1.UpdateFulfilmentResponse], err error)
	funcUpdateFulfilmentOrigin    string
	inspectFuncUpdateFulfilment   func(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest])
	afterUpdateFulfilmentCounter  uint64
	beforeUpdateFulfilmentCounter uint64
	UpdateFulfilmentMock          mCommerceServiceClientMockUpdateFulfilment

	funcUpdateProductVariant          func(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest]) (pp2 *connect.Response[v1.UpdateProductVariantResponse], err error)
	funcUpdateProductVariantOrigin    string
	inspectFuncUpdateProductVariant   func(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest])
	afterUpdateProductVariantCounter  uint64
	beforeUpdateProductVariantCounter uint64
	UpdateProductVariantMock          mCommerceServiceClientMockUpdateProductVariant

	funcUpdateShop          func(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest]) (pp2 *connect.Response[v1.UpdateShopResponse], err error)
	funcUpdateShopOrigin    string
	inspectFuncUpdateShop   func(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest])
	afterUpdateShopCounter  uint64
	beforeUpdateShopCounter uint64
	UpdateShopMock          mCommerceServiceClientMockUpdateShop
}

// NewCommerceServiceClientMock returns a mock for mm_commercev1connect.CommerceServiceClient
func NewCommerceServiceClientMock(t minimock.Tester) *CommerceServiceClientMock {
	m := &CommerceServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCartLineMock = mCommerceServiceClientMockAddCartLine{mock: m}
	m.AddCartLineMock.callArgs = []*CommerceServiceClientMockAddCartLineParams{}

	m.CreateCartMock = mCommerceServiceClientMockCreateCart{mock: m}
	m.CreateCartMock.callArgs = []*CommerceServiceClientMockCreateCartParams{}

	m.CreateFulfilmentMock = mCommerceServiceClientMockCreateFulfilment{mock: m}
	m.CreateFulfilmentMock.callArgs = []*CommerceServiceClientMockCreateFulfilmentParams{}

	m.CreateOrderMock = mCommerceServiceClientMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*CommerceServiceClientMockCreateOrderParams{}

	m.CreateOrderFromCartMock = mCommerceServiceClientMockCreateOrderFromCart{mock: m}
	m.CreateOrderFromCartMock.callArgs = []*CommerceServiceClientMockCreateOrderFromCartParams{}

	m.CreateProductMock = mCommerceServiceClientMockCreateProduct{mock: m}
	m.CreateProductMock.callArgs = []*CommerceServiceClientMockCreateProductParams{}

	m.CreateProductVariantMock = mCommerceServiceClientMockCreateProductVariant{mock: m}
	m.CreateProductVariantMock.callArgs = []*CommerceServiceClientMockCreateProductVariantParams{}

	m.CreateShopMock = mCommerceServiceClientMockCreateShop{mock: m}
	m.CreateShopMock.callArgs = []*CommerceServiceClientMockCreateShopParams{}

	m.GetCartMock = mCommerceServiceClientMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CommerceServiceClientMockGetCartParams{}

	m.GetFulfilmentMock = mCommerceServiceClientMockGetFulfilment{mock: m}
	m.GetFulfilmentMock.callArgs = []*CommerceServiceClientMockGetFulfilmentParams{}

	m.GetOrderMock = mCommerceServiceClientMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*CommerceServiceClientMockGetOrderParams{}

	m.GetProductMock = mCommerceServiceClientMockGetProduct{mock: m}
	m.GetProductMock.callArgs = []*CommerceServiceClientMockGetProductParams{}

	m.GetShopMock = mCommerceServiceClientMockGetShop{mock: m}
	m.GetShopMock.callArgs = []*CommerceServiceClientMockGetShopParams{}

	m.ListOrdersMock = mCommerceServiceClientMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*CommerceServiceClientMockListOrdersParams{}

	m.ListProductsMock = mCommerceServiceClientMockListProducts{mock: m}
	m.ListProductsMock.callArgs = []*CommerceServiceClientMockListProductsParams{}

	m.RemoveCartLineMock = mCommerceServiceClientMockRemoveCartLine{mock: m}
	m.RemoveCartLineMock.callArgs = []*CommerceServiceClientMockRemoveCartLineParams{}

	m.UpdateFulfilmentMock = mCommerceServiceClientMockUpdateFulfilment{mock: m}
	m.UpdateFulfilmentMock.callArgs = []*CommerceServiceClientMockUpdateFulfilmentParams{}

	m.UpdateProductVariantMock = mCommerceServiceClientMockUpdateProductVariant{mock: m}
	m.UpdateProductVariantMock.callArgs = []*CommerceServiceClientMockUpdateProductVariantParams{}

	m.UpdateShopMock = mCommerceServiceClientMockUpdateShop{mock: m}
	m.UpdateShopMock.callArgs = []*CommerceServiceClientMockUpdateShopParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCommerceServiceClientMockAddCartLine struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockAddCartLineExpectation
	expectations       []*CommerceServiceClientMockAddCartLineExpectation

	callArgs []*CommerceServiceClientMockAddCartLineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockAddCartLineExpectation specifies expectation struct of the CommerceServiceClient.AddCartLine
type CommerceServiceClientMockAddCartLineExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockAddCartLineParams
	paramPtrs          *CommerceServiceClientMockAddCartLineParamPtrs
	expectationOrigins CommerceServiceClientMockAddCartLineExpectationOrigins
	results            *CommerceServiceClientMockAddCartLineResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockAddCartLineParams contains parameters of the CommerceServiceClient.AddCartLine
type CommerceServiceClientMockAddCartLineParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddCartLineRequest]
}

// CommerceServiceClientMockAddCartLineParamPtrs contains pointers to parameters of the CommerceServiceClient.AddCartLine
type CommerceServiceClientMockAddCartLineParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddCartLineRequest]
}

// CommerceServiceClientMockAddCartLineResults contains results of the CommerceServiceClient.AddCartLine
type CommerceServiceClientMockAddCartLineResults struct {
	pp2 *connect.Response[v1.AddCartLineResponse]
	err error
}

// CommerceServiceClientMockAddCartLineOrigins contains origins of expectations of the CommerceServiceClient.AddCartLine
type CommerceServiceClientMockAddCartLineExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Optional() *mCommerceServiceClientMockAddCartLine {
	mmAddCartLine.optional = true
	return mmAddCartLine
}

// Expect sets up expected params for CommerceServiceClient.AddCartLine
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Expect(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest]) *mCommerceServiceClientMockAddCartLine {
	if mmAddCartLine.mock.funcAddCartLine != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Set")
	}

	if mmAddCartLine.defaultExpectation == nil {
		mmAddCartLine.defaultExpectation = &CommerceServiceClientMockAddCartLineExpectation{}
	}

	if mmAddCartLine.defaultExpectation.paramPtrs != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by ExpectParams functions")
	}

	mmAddCartLine.defaultExpectation.params = &CommerceServiceClientMockAddCartLineParams{ctx, pp1}
	mmAddCartLine.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCartLine.expectations {
		if minimock.Equal(e.params, mmAddCartLine.defaultExpectation.params) {
			mmAddCartLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCartLine.defaultExpectation.params)
		}
	}

	return mmAddCartLine
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.AddCartLine
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockAddCartLine {
	if mmAddCartLine.mock.funcAddCartLine != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Set")
	}

	if mmAddCartLine.defaultExpectation == nil {
		mmAddCartLine.defaultExpectation = &CommerceServiceClientMockAddCartLineExpectation{}
	}

	if mmAddCartLine.defaultExpectation.params != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Expect")
	}

	if mmAddCartLine.defaultExpectation.paramPtrs == nil {
		mmAddCartLine.defaultExpectation.paramPtrs = &CommerceServiceClientMockAddCartLineParamPtrs{}
	}
	mmAddCartLine.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddCartLine.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddCartLine
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.AddCartLine
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) ExpectPp1Param2(pp1 *connect.Request[v1.AddCartLineRequest]) *mCommerceServiceClientMockAddCartLine {
	if mmAddCartLine.mock.funcAddCartLine != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Set")
	}

	if mmAddCartLine.defaultExpectation == nil {
		mmAddCartLine.defaultExpectation = &CommerceServiceClientMockAddCartLineExpectation{}
	}

	if mmAddCartLine.defaultExpectation.params != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Expect")
	}

	if mmAddCartLine.defaultExpectation.paramPtrs == nil {
		mmAddCartLine.defaultExpectation.paramPtrs = &CommerceServiceClientMockAddCartLineParamPtrs{}
	}
	mmAddCartLine.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddCartLine.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddCartLine
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.AddCartLine
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest])) *mCommerceServiceClientMockAddCartLine {
	if mmAddCartLine.mock.inspectFuncAddCartLine != nil {
		mmAddCartLine.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.AddCartLine")
	}

	mmAddCartLine.mock.inspectFuncAddCartLine = f

	return mmAddCartLine
}

// Return sets up results that will be returned by CommerceServiceClient.AddCartLine
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Return(pp2 *connect.Response[v1.AddCartLineResponse], err error) *CommerceServiceClientMock {
	if mmAddCartLine.mock.funcAddCartLine != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Set")
	}

	if mmAddCartLine.defaultExpectation == nil {
		mmAddCartLine.defaultExpectation = &CommerceServiceClientMockAddCartLineExpectation{mock: mmAddCartLine.mock}
	}
	mmAddCartLine.defaultExpectation.results = &CommerceServiceClientMockAddCartLineResults{pp2, err}
	mmAddCartLine.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCartLine.mock
}

// Set uses given function f to mock the CommerceServiceClient.AddCartLine method
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest]) (pp2 *connect.Response[v1.AddCartLineResponse], err error)) *CommerceServiceClientMock {
	if mmAddCartLine.defaultExpectation != nil {
		mmAddCartLine.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.AddCartLine method")
	}

	if len(mmAddCartLine.expectations) > 0 {
		mmAddCartLine.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.AddCartLine method")
	}

	mmAddCartLine.mock.funcAddCartLine = f
	mmAddCartLine.mock.funcAddCartLineOrigin = minimock.CallerInfo(1)
	return mmAddCartLine.mock
}

// When sets expectation for the CommerceServiceClient.AddCartLine which will trigger the result defined by the following
// Then helper
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) When(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest]) *CommerceServiceClientMockAddCartLineExpectation {
	if mmAddCartLine.mock.funcAddCartLine != nil {
		mmAddCartLine.mock.t.Fatalf("CommerceServiceClientMock.AddCartLine mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockAddCartLineExpectation{
		mock:               mmAddCartLine.mock,
		params:             &CommerceServiceClientMockAddCartLineParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockAddCartLineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCartLine.expectations = append(mmAddCartLine.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.AddCartLine return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockAddCartLineExpectation) Then(pp2 *connect.Response[v1.AddCartLineResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockAddCartLineResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.AddCartLine should be invoked
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Times(n uint64) *mCommerceServiceClientMockAddCartLine {
	if n == 0 {
		mmAddCartLine.mock.t.Fatalf("Times of CommerceServiceClientMock.AddCartLine mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCartLine.expectedInvocations, n)
	mmAddCartLine.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCartLine
}

func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) invocationsDone() bool {
	if len(mmAddCartLine.expectations) == 0 && mmAddCartLine.defaultExpectation == nil && mmAddCartLine.mock.funcAddCartLine == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCartLine.mock.afterAddCartLineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCartLine.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCartLine implements mm_commercev1connect.CommerceServiceClient
func (mmAddCartLine *CommerceServiceClientMock) AddCartLine(ctx context.Context, pp1 *connect.Request[v1.AddCartLineRequest]) (pp2 *connect.Response[v1.AddCartLineResponse], err error) {
	mm_atomic.AddUint64(&mmAddCartLine.beforeAddCartLineCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCartLine.afterAddCartLineCounter, 1)

	mmAddCartLine.t.Helper()

	if mmAddCartLine.inspectFuncAddCartLine != nil {
		mmAddCartLine.inspectFuncAddCartLine(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockAddCartLineParams{ctx, pp1}

	// Record call args
	mmAddCartLine.AddCartLineMock.mutex.Lock()
	mmAddCartLine.AddCartLineMock.callArgs = append(mmAddCartLine.AddCartLineMock.callArgs, &mm_params)
	mmAddCartLine.AddCartLineMock.mutex.Unlock()

	for _, e := range mmAddCartLine.AddCartLineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddCartLine.AddCartLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCartLine.AddCartLineMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCartLine.AddCartLineMock.defaultExpectation.params
		mm_want_ptrs := mmAddCartLine.AddCartLineMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockAddCartLineParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddCartLine.t.Errorf("CommerceServiceClientMock.AddCartLine got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCartLine.AddCartLineMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddCartLine.t.Errorf("CommerceServiceClientMock.AddCartLine got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCartLine.AddCartLineMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCartLine.t.Errorf("CommerceServiceClientMock.AddCartLine got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCartLine.AddCartLineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCartLine.AddCartLineMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCartLine.t.Fatal("No results are set for the CommerceServiceClientMock.AddCartLine")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddCartLine.funcAddCartLine != nil {
		return mmAddCartLine.funcAddCartLine(ctx, pp1)
	}
	mmAddCartLine.t.Fatalf("Unexpected call to CommerceServiceClientMock.AddCartLine. %v %v", ctx, pp1)
	return
}

// AddCartLineAfterCounter returns a count of finished CommerceServiceClientMock.AddCartLine invocations
func (mmAddCartLine *CommerceServiceClientMock) AddCartLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCartLine.afterAddCartLineCounter)
}

// AddCartLineBeforeCounter returns a count of CommerceServiceClientMock.AddCartLine invocations
func (mmAddCartLine *CommerceServiceClientMock) AddCartLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCartLine.beforeAddCartLineCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.AddCartLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCartLine *mCommerceServiceClientMockAddCartLine) Calls() []*CommerceServiceClientMockAddCartLineParams {
	mmAddCartLine.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockAddCartLineParams, len(mmAddCartLine.callArgs))
	copy(argCopy, mmAddCartLine.callArgs)

	mmAddCartLine.mutex.RUnlock()

	return argCopy
}

// MinimockAddCartLineDone returns true if the count of the AddCartLine invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockAddCartLineDone() bool {
	if m.AddCartLineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCartLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCartLineMock.invocationsDone()
}

// MinimockAddCartLineInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockAddCartLineInspect() {
	for _, e := range m.AddCartLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.AddCartLine at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCartLineCounter := mm_atomic.LoadUint64(&m.afterAddCartLineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCartLineMock.defaultExpectation != nil && afterAddCartLineCounter < 1 {
		if m.AddCartLineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.AddCartLine at\n%s", m.AddCartLineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.AddCartLine at\n%s with params: %#v", m.AddCartLineMock.defaultExpectation.expectationOrigins.origin, *m.AddCartLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCartLine != nil && afterAddCartLineCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.AddCartLine at\n%s", m.funcAddCartLineOrigin)
	}

	if !m.AddCartLineMock.invocationsDone() && afterAddCartLineCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.AddCartLine at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCartLineMock.expectedInvocations), m.AddCartLineMock.expectedInvocationsOrigin, afterAddCartLineCounter)
	}
}

type mCommerceServiceClientMockCreateCart struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateCartExpectation
	expectations       []*CommerceServiceClientMockCreateCartExpectation

	callArgs []*CommerceServiceClientMockCreateCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateCartExpectation specifies expectation struct of the CommerceServiceClient.CreateCart
type CommerceServiceClientMockCreateCartExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateCartParams
	paramPtrs          *CommerceServiceClientMockCreateCartParamPtrs
	expectationOrigins CommerceServiceClientMockCreateCartExpectationOrigins
	results            *CommerceServiceClientMockCreateCartResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateCartParams contains parameters of the CommerceServiceClient.CreateCart
type CommerceServiceClientMockCreateCartParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateCartRequest]
}

// CommerceServiceClientMockCreateCartParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateCart
type CommerceServiceClientMockCreateCartParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateCartRequest]
}

// CommerceServiceClientMockCreateCartResults contains results of the CommerceServiceClient.CreateCart
type CommerceServiceClientMockCreateCartResults struct {
	pp2 *connect.Response[v1.CreateCartResponse]
	err error
}

// CommerceServiceClientMockCreateCartOrigins contains origins of expectations of the CommerceServiceClient.CreateCart
type CommerceServiceClientMockCreateCartExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Optional() *mCommerceServiceClientMockCreateCart {
	mmCreateCart.optional = true
	return mmCreateCart
}

// Expect sets up expected params for CommerceServiceClient.CreateCart
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest]) *mCommerceServiceClientMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CommerceServiceClientMockCreateCartExpectation{}
	}

	if mmCreateCart.defaultExpectation.paramPtrs != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by ExpectParams functions")
	}

	mmCreateCart.defaultExpectation.params = &CommerceServiceClientMockCreateCartParams{ctx, pp1}
	mmCreateCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCart.expectations {
		if minimock.Equal(e.params, mmCreateCart.defaultExpectation.params) {
			mmCreateCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCart.defaultExpectation.params)
		}
	}

	return mmCreateCart
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateCart
func (mmCreateCart *mCommerceServiceClientMockCreateCart) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CommerceServiceClientMockCreateCartExpectation{}
	}

	if mmCreateCart.defaultExpectation.params != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Expect")
	}

	if mmCreateCart.defaultExpectation.paramPtrs == nil {
		mmCreateCart.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateCartParamPtrs{}
	}
	mmCreateCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCart
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateCart
func (mmCreateCart *mCommerceServiceClientMockCreateCart) ExpectPp1Param2(pp1 *connect.Request[v1.CreateCartRequest]) *mCommerceServiceClientMockCreateCart {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CommerceServiceClientMockCreateCartExpectation{}
	}

	if mmCreateCart.defaultExpectation.params != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Expect")
	}

	if mmCreateCart.defaultExpectation.paramPtrs == nil {
		mmCreateCart.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateCartParamPtrs{}
	}
	mmCreateCart.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateCart.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateCart
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateCart
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest])) *mCommerceServiceClientMockCreateCart {
	if mmCreateCart.mock.inspectFuncCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateCart")
	}

	mmCreateCart.mock.inspectFuncCreateCart = f

	return mmCreateCart
}

// Return sets up results that will be returned by CommerceServiceClient.CreateCart
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Return(pp2 *connect.Response[v1.CreateCartResponse], err error) *CommerceServiceClientMock {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Set")
	}

	if mmCreateCart.defaultExpectation == nil {
		mmCreateCart.defaultExpectation = &CommerceServiceClientMockCreateCartExpectation{mock: mmCreateCart.mock}
	}
	mmCreateCart.defaultExpectation.results = &CommerceServiceClientMockCreateCartResults{pp2, err}
	mmCreateCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCart.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateCart method
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest]) (pp2 *connect.Response[v1.CreateCartResponse], err error)) *CommerceServiceClientMock {
	if mmCreateCart.defaultExpectation != nil {
		mmCreateCart.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateCart method")
	}

	if len(mmCreateCart.expectations) > 0 {
		mmCreateCart.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateCart method")
	}

	mmCreateCart.mock.funcCreateCart = f
	mmCreateCart.mock.funcCreateCartOrigin = minimock.CallerInfo(1)
	return mmCreateCart.mock
}

// When sets expectation for the CommerceServiceClient.CreateCart which will trigger the result defined by the following
// Then helper
func (mmCreateCart *mCommerceServiceClientMockCreateCart) When(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest]) *CommerceServiceClientMockCreateCartExpectation {
	if mmCreateCart.mock.funcCreateCart != nil {
		mmCreateCart.mock.t.Fatalf("CommerceServiceClientMock.CreateCart mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateCartExpectation{
		mock:               mmCreateCart.mock,
		params:             &CommerceServiceClientMockCreateCartParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCart.expectations = append(mmCreateCart.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateCart return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateCartExpectation) Then(pp2 *connect.Response[v1.CreateCartResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateCartResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateCart should be invoked
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Times(n uint64) *mCommerceServiceClientMockCreateCart {
	if n == 0 {
		mmCreateCart.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCart.expectedInvocations, n)
	mmCreateCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCart
}

func (mmCreateCart *mCommerceServiceClientMockCreateCart) invocationsDone() bool {
	if len(mmCreateCart.expectations) == 0 && mmCreateCart.defaultExpectation == nil && mmCreateCart.mock.funcCreateCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCart.mock.afterCreateCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCart implements mm_commercev1connect.CommerceServiceClient
func (mmCreateCart *CommerceServiceClientMock) CreateCart(ctx context.Context, pp1 *connect.Request[v1.CreateCartRequest]) (pp2 *connect.Response[v1.CreateCartResponse], err error) {
	mm_atomic.AddUint64(&mmCreateCart.beforeCreateCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCart.afterCreateCartCounter, 1)

	mmCreateCart.t.Helper()

	if mmCreateCart.inspectFuncCreateCart != nil {
		mmCreateCart.inspectFuncCreateCart(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateCartParams{ctx, pp1}

	// Record call args
	mmCreateCart.CreateCartMock.mutex.Lock()
	mmCreateCart.CreateCartMock.callArgs = append(mmCreateCart.CreateCartMock.callArgs, &mm_params)
	mmCreateCart.CreateCartMock.mutex.Unlock()

	for _, e := range mmCreateCart.CreateCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateCart.CreateCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCart.CreateCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCart.CreateCartMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCart.CreateCartMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateCartParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCart.t.Errorf("CommerceServiceClientMock.CreateCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCart.CreateCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateCart.t.Errorf("CommerceServiceClientMock.CreateCart got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCart.CreateCartMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCart.t.Errorf("CommerceServiceClientMock.CreateCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCart.CreateCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCart.CreateCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCart.t.Fatal("No results are set for the CommerceServiceClientMock.CreateCart")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateCart.funcCreateCart != nil {
		return mmCreateCart.funcCreateCart(ctx, pp1)
	}
	mmCreateCart.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateCart. %v %v", ctx, pp1)
	return
}

// CreateCartAfterCounter returns a count of finished CommerceServiceClientMock.CreateCart invocations
func (mmCreateCart *CommerceServiceClientMock) CreateCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCart.afterCreateCartCounter)
}

// CreateCartBeforeCounter returns a count of CommerceServiceClientMock.CreateCart invocations
func (mmCreateCart *CommerceServiceClientMock) CreateCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCart.beforeCreateCartCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCart *mCommerceServiceClientMockCreateCart) Calls() []*CommerceServiceClientMockCreateCartParams {
	mmCreateCart.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateCartParams, len(mmCreateCart.callArgs))
	copy(argCopy, mmCreateCart.callArgs)

	mmCreateCart.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartDone returns true if the count of the CreateCart invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateCartDone() bool {
	if m.CreateCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCartMock.invocationsDone()
}

// MinimockCreateCartInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateCartInspect() {
	for _, e := range m.CreateCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCartCounter := mm_atomic.LoadUint64(&m.afterCreateCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartMock.defaultExpectation != nil && afterCreateCartCounter < 1 {
		if m.CreateCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateCart at\n%s", m.CreateCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateCart at\n%s with params: %#v", m.CreateCartMock.defaultExpectation.expectationOrigins.origin, *m.CreateCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCart != nil && afterCreateCartCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateCart at\n%s", m.funcCreateCartOrigin)
	}

	if !m.CreateCartMock.invocationsDone() && afterCreateCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCartMock.expectedInvocations), m.CreateCartMock.expectedInvocationsOrigin, afterCreateCartCounter)
	}
}

type mCommerceServiceClientMockCreateFulfilment struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateFulfilmentExpectation
	expectations       []*CommerceServiceClientMockCreateFulfilmentExpectation

	callArgs []*CommerceServiceClientMockCreateFulfilmentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateFulfilmentExpectation specifies expectation struct of the CommerceServiceClient.CreateFulfilment
type CommerceServiceClientMockCreateFulfilmentExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateFulfilmentParams
	paramPtrs          *CommerceServiceClientMockCreateFulfilmentParamPtrs
	expectationOrigins CommerceServiceClientMockCreateFulfilmentExpectationOrigins
	results            *CommerceServiceClientMockCreateFulfilmentResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateFulfilmentParams contains parameters of the CommerceServiceClient.CreateFulfilment
type CommerceServiceClientMockCreateFulfilmentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateFulfilmentRequest]
}

// CommerceServiceClientMockCreateFulfilmentParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateFulfilment
type CommerceServiceClientMockCreateFulfilmentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateFulfilmentRequest]
}

// CommerceServiceClientMockCreateFulfilmentResults contains results of the CommerceServiceClient.CreateFulfilment
type CommerceServiceClientMockCreateFulfilmentResults struct {
	pp2 *connect.Response[v1.CreateFulfilmentResponse]
	err error
}

// CommerceServiceClientMockCreateFulfilmentOrigins contains origins of expectations of the CommerceServiceClient.CreateFulfilment
type CommerceServiceClientMockCreateFulfilmentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Optional() *mCommerceServiceClientMockCreateFulfilment {
	mmCreateFulfilment.optional = true
	return mmCreateFulfilment
}

// Expect sets up expected params for CommerceServiceClient.CreateFulfilment
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest]) *mCommerceServiceClientMockCreateFulfilment {
	if mmCreateFulfilment.mock.funcCreateFulfilment != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Set")
	}

	if mmCreateFulfilment.defaultExpectation == nil {
		mmCreateFulfilment.defaultExpectation = &CommerceServiceClientMockCreateFulfilmentExpectation{}
	}

	if mmCreateFulfilment.defaultExpectation.paramPtrs != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by ExpectParams functions")
	}

	mmCreateFulfilment.defaultExpectation.params = &CommerceServiceClientMockCreateFulfilmentParams{ctx, pp1}
	mmCreateFulfilment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateFulfilment.expectations {
		if minimock.Equal(e.params, mmCreateFulfilment.defaultExpectation.params) {
			mmCreateFulfilment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateFulfilment.defaultExpectation.params)
		}
	}

	return mmCreateFulfilment
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateFulfilment
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateFulfilment {
	if mmCreateFulfilment.mock.funcCreateFulfilment != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Set")
	}

	if mmCreateFulfilment.defaultExpectation == nil {
		mmCreateFulfilment.defaultExpectation = &CommerceServiceClientMockCreateFulfilmentExpectation{}
	}

	if mmCreateFulfilment.defaultExpectation.params != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Expect")
	}

	if mmCreateFulfilment.defaultExpectation.paramPtrs == nil {
		mmCreateFulfilment.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateFulfilmentParamPtrs{}
	}
	mmCreateFulfilment.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateFulfilment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateFulfilment
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateFulfilment
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) ExpectPp1Param2(pp1 *connect.Request[v1.CreateFulfilmentRequest]) *mCommerceServiceClientMockCreateFulfilment {
	if mmCreateFulfilment.mock.funcCreateFulfilment != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Set")
	}

	if mmCreateFulfilment.defaultExpectation == nil {
		mmCreateFulfilment.defaultExpectation = &CommerceServiceClientMockCreateFulfilmentExpectation{}
	}

	if mmCreateFulfilment.defaultExpectation.params != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Expect")
	}

	if mmCreateFulfilment.defaultExpectation.paramPtrs == nil {
		mmCreateFulfilment.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateFulfilmentParamPtrs{}
	}
	mmCreateFulfilment.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateFulfilment.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateFulfilment
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateFulfilment
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest])) *mCommerceServiceClientMockCreateFulfilment {
	if mmCreateFulfilment.mock.inspectFuncCreateFulfilment != nil {
		mmCreateFulfilment.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateFulfilment")
	}

	mmCreateFulfilment.mock.inspectFuncCreateFulfilment = f

	return mmCreateFulfilment
}

// Return sets up results that will be returned by CommerceServiceClient.CreateFulfilment
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Return(pp2 *connect.Response[v1.CreateFulfilmentResponse], err error) *CommerceServiceClientMock {
	if mmCreateFulfilment.mock.funcCreateFulfilment != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Set")
	}

	if mmCreateFulfilment.defaultExpectation == nil {
		mmCreateFulfilment.defaultExpectation = &CommerceServiceClientMockCreateFulfilmentExpectation{mock: mmCreateFulfilment.mock}
	}
	mmCreateFulfilment.defaultExpectation.results = &CommerceServiceClientMockCreateFulfilmentResults{pp2, err}
	mmCreateFulfilment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateFulfilment.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateFulfilment method
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest]) (pp2 *connect.Response[v1.CreateFulfilmentResponse], err error)) *CommerceServiceClientMock {
	if mmCreateFulfilment.defaultExpectation != nil {
		mmCreateFulfilment.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateFulfilment method")
	}

	if len(mmCreateFulfilment.expectations) > 0 {
		mmCreateFulfilment.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateFulfilment method")
	}

	mmCreateFulfilment.mock.funcCreateFulfilment = f
	mmCreateFulfilment.mock.funcCreateFulfilmentOrigin = minimock.CallerInfo(1)
	return mmCreateFulfilment.mock
}

// When sets expectation for the CommerceServiceClient.CreateFulfilment which will trigger the result defined by the following
// Then helper
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) When(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest]) *CommerceServiceClientMockCreateFulfilmentExpectation {
	if mmCreateFulfilment.mock.funcCreateFulfilment != nil {
		mmCreateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.CreateFulfilment mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateFulfilmentExpectation{
		mock:               mmCreateFulfilment.mock,
		params:             &CommerceServiceClientMockCreateFulfilmentParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateFulfilmentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateFulfilment.expectations = append(mmCreateFulfilment.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateFulfilment return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateFulfilmentExpectation) Then(pp2 *connect.Response[v1.CreateFulfilmentResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateFulfilmentResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateFulfilment should be invoked
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Times(n uint64) *mCommerceServiceClientMockCreateFulfilment {
	if n == 0 {
		mmCreateFulfilment.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateFulfilment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateFulfilment.expectedInvocations, n)
	mmCreateFulfilment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateFulfilment
}

func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) invocationsDone() bool {
	if len(mmCreateFulfilment.expectations) == 0 && mmCreateFulfilment.defaultExpectation == nil && mmCreateFulfilment.mock.funcCreateFulfilment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateFulfilment.mock.afterCreateFulfilmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateFulfilment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateFulfilment implements mm_commercev1connect.CommerceServiceClient
func (mmCreateFulfilment *CommerceServiceClientMock) CreateFulfilment(ctx context.Context, pp1 *connect.Request[v1.CreateFulfilmentRequest]) (pp2 *connect.Response[v1.CreateFulfilmentResponse], err error) {
	mm_atomic.AddUint64(&mmCreateFulfilment.beforeCreateFulfilmentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateFulfilment.afterCreateFulfilmentCounter, 1)

	mmCreateFulfilment.t.Helper()

	if mmCreateFulfilment.inspectFuncCreateFulfilment != nil {
		mmCreateFulfilment.inspectFuncCreateFulfilment(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateFulfilmentParams{ctx, pp1}

	// Record call args
	mmCreateFulfilment.CreateFulfilmentMock.mutex.Lock()
	mmCreateFulfilment.CreateFulfilmentMock.callArgs = append(mmCreateFulfilment.CreateFulfilmentMock.callArgs, &mm_params)
	mmCreateFulfilment.CreateFulfilmentMock.mutex.Unlock()

	for _, e := range mmCreateFulfilment.CreateFulfilmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateFulfilmentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateFulfilment.t.Errorf("CommerceServiceClientMock.CreateFulfilment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateFulfilment.t.Errorf("CommerceServiceClientMock.CreateFulfilment got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateFulfilment.t.Errorf("CommerceServiceClientMock.CreateFulfilment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateFulfilment.CreateFulfilmentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateFulfilment.t.Fatal("No results are set for the CommerceServiceClientMock.CreateFulfilment")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateFulfilment.funcCreateFulfilment != nil {
		return mmCreateFulfilment.funcCreateFulfilment(ctx, pp1)
	}
	mmCreateFulfilment.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateFulfilment. %v %v", ctx, pp1)
	return
}

// CreateFulfilmentAfterCounter returns a count of finished CommerceServiceClientMock.CreateFulfilment invocations
func (mmCreateFulfilment *CommerceServiceClientMock) CreateFulfilmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateFulfilment.afterCreateFulfilmentCounter)
}

// CreateFulfilmentBeforeCounter returns a count of CommerceServiceClientMock.CreateFulfilment invocations
func (mmCreateFulfilment *CommerceServiceClientMock) CreateFulfilmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateFulfilment.beforeCreateFulfilmentCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateFulfilment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateFulfilment *mCommerceServiceClientMockCreateFulfilment) Calls() []*CommerceServiceClientMockCreateFulfilmentParams {
	mmCreateFulfilment.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateFulfilmentParams, len(mmCreateFulfilment.callArgs))
	copy(argCopy, mmCreateFulfilment.callArgs)

	mmCreateFulfilment.mutex.RUnlock()

	return argCopy
}

// MinimockCreateFulfilmentDone returns true if the count of the CreateFulfilment invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateFulfilmentDone() bool {
	if m.CreateFulfilmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateFulfilmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateFulfilmentMock.invocationsDone()
}

// MinimockCreateFulfilmentInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateFulfilmentInspect() {
	for _, e := range m.CreateFulfilmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateFulfilment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateFulfilmentCounter := mm_atomic.LoadUint64(&m.afterCreateFulfilmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateFulfilmentMock.defaultExpectation != nil && afterCreateFulfilmentCounter < 1 {
		if m.CreateFulfilmentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateFulfilment at\n%s", m.CreateFulfilmentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateFulfilment at\n%s with params: %#v", m.CreateFulfilmentMock.defaultExpectation.expectationOrigins.origin, *m.CreateFulfilmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateFulfilment != nil && afterCreateFulfilmentCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateFulfilment at\n%s", m.funcCreateFulfilmentOrigin)
	}

	if !m.CreateFulfilmentMock.invocationsDone() && afterCreateFulfilmentCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateFulfilment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateFulfilmentMock.expectedInvocations), m.CreateFulfilmentMock.expectedInvocationsOrigin, afterCreateFulfilmentCounter)
	}
}

type mCommerceServiceClientMockCreateOrder struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateOrderExpectation
	expectations       []*CommerceServiceClientMockCreateOrderExpectation

	callArgs []*CommerceServiceClientMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateOrderExpectation specifies expectation struct of the CommerceServiceClient.CreateOrder
type CommerceServiceClientMockCreateOrderExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateOrderParams
	paramPtrs          *CommerceServiceClientMockCreateOrderParamPtrs
	expectationOrigins CommerceServiceClientMockCreateOrderExpectationOrigins
	results            *CommerceServiceClientMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateOrderParams contains parameters of the CommerceServiceClient.CreateOrder
type CommerceServiceClientMockCreateOrderParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateOrderRequest]
}

// CommerceServiceClientMockCreateOrderParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateOrder
type CommerceServiceClientMockCreateOrderParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateOrderRequest]
}

// CommerceServiceClientMockCreateOrderResults contains results of the CommerceServiceClient.CreateOrder
type CommerceServiceClientMockCreateOrderResults struct {
	pp2 *connect.Response[v1.CreateOrderResponse]
	err error
}

// CommerceServiceClientMockCreateOrderOrigins contains origins of expectations of the CommerceServiceClient.CreateOrder
type CommerceServiceClientMockCreateOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Optional() *mCommerceServiceClientMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for CommerceServiceClient.CreateOrder
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest]) *mCommerceServiceClientMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &CommerceServiceClientMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &CommerceServiceClientMockCreateOrderParams{ctx, pp1}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateOrder
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &CommerceServiceClientMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateOrder
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) ExpectPp1Param2(pp1 *connect.Request[v1.CreateOrderRequest]) *mCommerceServiceClientMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &CommerceServiceClientMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateOrder.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateOrder
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest])) *mCommerceServiceClientMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by CommerceServiceClient.CreateOrder
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Return(pp2 *connect.Response[v1.CreateOrderResponse], err error) *CommerceServiceClientMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &CommerceServiceClientMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &CommerceServiceClientMockCreateOrderResults{pp2, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateOrder method
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest]) (pp2 *connect.Response[v1.CreateOrderResponse], err error)) *CommerceServiceClientMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the CommerceServiceClient.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) When(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest]) *CommerceServiceClientMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("CommerceServiceClientMock.CreateOrder mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &CommerceServiceClientMockCreateOrderParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateOrder return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateOrderExpectation) Then(pp2 *connect.Response[v1.CreateOrderResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateOrderResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateOrder should be invoked
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Times(n uint64) *mCommerceServiceClientMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_commercev1connect.CommerceServiceClient
func (mmCreateOrder *CommerceServiceClientMock) CreateOrder(ctx context.Context, pp1 *connect.Request[v1.CreateOrderRequest]) (pp2 *connect.Response[v1.CreateOrderResponse], err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateOrderParams{ctx, pp1}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateOrderParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("CommerceServiceClientMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateOrder.t.Errorf("CommerceServiceClientMock.CreateOrder got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("CommerceServiceClientMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the CommerceServiceClientMock.CreateOrder")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, pp1)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateOrder. %v %v", ctx, pp1)
	return
}

// CreateOrderAfterCounter returns a count of finished CommerceServiceClientMock.CreateOrder invocations
func (mmCreateOrder *CommerceServiceClientMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of CommerceServiceClientMock.CreateOrder invocations
func (mmCreateOrder *CommerceServiceClientMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mCommerceServiceClientMockCreateOrder) Calls() []*CommerceServiceClientMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mCommerceServiceClientMockCreateOrderFromCart struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateOrderFromCartExpectation
	expectations       []*CommerceServiceClientMockCreateOrderFromCartExpectation

	callArgs []*CommerceServiceClientMockCreateOrderFromCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateOrderFromCartExpectation specifies expectation struct of the CommerceServiceClient.CreateOrderFromCart
type CommerceServiceClientMockCreateOrderFromCartExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateOrderFromCartParams
	paramPtrs          *CommerceServiceClientMockCreateOrderFromCartParamPtrs
	expectationOrigins CommerceServiceClientMockCreateOrderFromCartExpectationOrigins
	results            *CommerceServiceClientMockCreateOrderFromCartResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateOrderFromCartParams contains parameters of the CommerceServiceClient.CreateOrderFromCart
type CommerceServiceClientMockCreateOrderFromCartParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateOrderFromCartRequest]
}

// CommerceServiceClientMockCreateOrderFromCartParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateOrderFromCart
type CommerceServiceClientMockCreateOrderFromCartParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateOrderFromCartRequest]
}

// CommerceServiceClientMockCreateOrderFromCartResults contains results of the CommerceServiceClient.CreateOrderFromCart
type CommerceServiceClientMockCreateOrderFromCartResults struct {
	pp2 *connect.Response[v1.CreateOrderFromCartResponse]
	err error
}

// CommerceServiceClientMockCreateOrderFromCartOrigins contains origins of expectations of the CommerceServiceClient.CreateOrderFromCart
type CommerceServiceClientMockCreateOrderFromCartExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Optional() *mCommerceServiceClientMockCreateOrderFromCart {
	mmCreateOrderFromCart.optional = true
	return mmCreateOrderFromCart
}

// Expect sets up expected params for CommerceServiceClient.CreateOrderFromCart
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest]) *mCommerceServiceClientMockCreateOrderFromCart {
	if mmCreateOrderFromCart.mock.funcCreateOrderFromCart != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Set")
	}

	if mmCreateOrderFromCart.defaultExpectation == nil {
		mmCreateOrderFromCart.defaultExpectation = &CommerceServiceClientMockCreateOrderFromCartExpectation{}
	}

	if mmCreateOrderFromCart.defaultExpectation.paramPtrs != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by ExpectParams functions")
	}

	mmCreateOrderFromCart.defaultExpectation.params = &CommerceServiceClientMockCreateOrderFromCartParams{ctx, pp1}
	mmCreateOrderFromCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrderFromCart.expectations {
		if minimock.Equal(e.params, mmCreateOrderFromCart.defaultExpectation.params) {
			mmCreateOrderFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrderFromCart.defaultExpectation.params)
		}
	}

	return mmCreateOrderFromCart
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateOrderFromCart
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateOrderFromCart {
	if mmCreateOrderFromCart.mock.funcCreateOrderFromCart != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Set")
	}

	if mmCreateOrderFromCart.defaultExpectation == nil {
		mmCreateOrderFromCart.defaultExpectation = &CommerceServiceClientMockCreateOrderFromCartExpectation{}
	}

	if mmCreateOrderFromCart.defaultExpectation.params != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Expect")
	}

	if mmCreateOrderFromCart.defaultExpectation.paramPtrs == nil {
		mmCreateOrderFromCart.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateOrderFromCartParamPtrs{}
	}
	mmCreateOrderFromCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrderFromCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrderFromCart
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateOrderFromCart
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) ExpectPp1Param2(pp1 *connect.Request[v1.CreateOrderFromCartRequest]) *mCommerceServiceClientMockCreateOrderFromCart {
	if mmCreateOrderFromCart.mock.funcCreateOrderFromCart != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Set")
	}

	if mmCreateOrderFromCart.defaultExpectation == nil {
		mmCreateOrderFromCart.defaultExpectation = &CommerceServiceClientMockCreateOrderFromCartExpectation{}
	}

	if mmCreateOrderFromCart.defaultExpectation.params != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Expect")
	}

	if mmCreateOrderFromCart.defaultExpectation.paramPtrs == nil {
		mmCreateOrderFromCart.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateOrderFromCartParamPtrs{}
	}
	mmCreateOrderFromCart.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateOrderFromCart.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateOrderFromCart
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateOrderFromCart
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest])) *mCommerceServiceClientMockCreateOrderFromCart {
	if mmCreateOrderFromCart.mock.inspectFuncCreateOrderFromCart != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateOrderFromCart")
	}

	mmCreateOrderFromCart.mock.inspectFuncCreateOrderFromCart = f

	return mmCreateOrderFromCart
}

// Return sets up results that will be returned by CommerceServiceClient.CreateOrderFromCart
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Return(pp2 *connect.Response[v1.CreateOrderFromCartResponse], err error) *CommerceServiceClientMock {
	if mmCreateOrderFromCart.mock.funcCreateOrderFromCart != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Set")
	}

	if mmCreateOrderFromCart.defaultExpectation == nil {
		mmCreateOrderFromCart.defaultExpectation = &CommerceServiceClientMockCreateOrderFromCartExpectation{mock: mmCreateOrderFromCart.mock}
	}
	mmCreateOrderFromCart.defaultExpectation.results = &CommerceServiceClientMockCreateOrderFromCartResults{pp2, err}
	mmCreateOrderFromCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrderFromCart.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateOrderFromCart method
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest]) (pp2 *connect.Response[v1.CreateOrderFromCartResponse], err error)) *CommerceServiceClientMock {
	if mmCreateOrderFromCart.defaultExpectation != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateOrderFromCart method")
	}

	if len(mmCreateOrderFromCart.expectations) > 0 {
		mmCreateOrderFromCart.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateOrderFromCart method")
	}

	mmCreateOrderFromCart.mock.funcCreateOrderFromCart = f
	mmCreateOrderFromCart.mock.funcCreateOrderFromCartOrigin = minimock.CallerInfo(1)
	return mmCreateOrderFromCart.mock
}

// When sets expectation for the CommerceServiceClient.CreateOrderFromCart which will trigger the result defined by the following
// Then helper
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) When(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest]) *CommerceServiceClientMockCreateOrderFromCartExpectation {
	if mmCreateOrderFromCart.mock.funcCreateOrderFromCart != nil {
		mmCreateOrderFromCart.mock.t.Fatalf("CommerceServiceClientMock.CreateOrderFromCart mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateOrderFromCartExpectation{
		mock:               mmCreateOrderFromCart.mock,
		params:             &CommerceServiceClientMockCreateOrderFromCartParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateOrderFromCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrderFromCart.expectations = append(mmCreateOrderFromCart.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateOrderFromCart return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateOrderFromCartExpectation) Then(pp2 *connect.Response[v1.CreateOrderFromCartResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateOrderFromCartResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateOrderFromCart should be invoked
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Times(n uint64) *mCommerceServiceClientMockCreateOrderFromCart {
	if n == 0 {
		mmCreateOrderFromCart.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateOrderFromCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrderFromCart.expectedInvocations, n)
	mmCreateOrderFromCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrderFromCart
}

func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) invocationsDone() bool {
	if len(mmCreateOrderFromCart.expectations) == 0 && mmCreateOrderFromCart.defaultExpectation == nil && mmCreateOrderFromCart.mock.funcCreateOrderFromCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrderFromCart.mock.afterCreateOrderFromCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrderFromCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrderFromCart implements mm_commercev1connect.CommerceServiceClient
func (mmCreateOrderFromCart *CommerceServiceClientMock) CreateOrderFromCart(ctx context.Context, pp1 *connect.Request[v1.CreateOrderFromCartRequest]) (pp2 *connect.Response[v1.CreateOrderFromCartResponse], err error) {
	mm_atomic.AddUint64(&mmCreateOrderFromCart.beforeCreateOrderFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrderFromCart.afterCreateOrderFromCartCounter, 1)

	mmCreateOrderFromCart.t.Helper()

	if mmCreateOrderFromCart.inspectFuncCreateOrderFromCart != nil {
		mmCreateOrderFromCart.inspectFuncCreateOrderFromCart(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateOrderFromCartParams{ctx, pp1}

	// Record call args
	mmCreateOrderFromCart.CreateOrderFromCartMock.mutex.Lock()
	mmCreateOrderFromCart.CreateOrderFromCartMock.callArgs = append(mmCreateOrderFromCart.CreateOrderFromCartMock.callArgs, &mm_params)
	mmCreateOrderFromCart.CreateOrderFromCartMock.mutex.Unlock()

	for _, e := range mmCreateOrderFromCart.CreateOrderFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateOrderFromCartParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrderFromCart.t.Errorf("CommerceServiceClientMock.CreateOrderFromCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateOrderFromCart.t.Errorf("CommerceServiceClientMock.CreateOrderFromCart got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrderFromCart.t.Errorf("CommerceServiceClientMock.CreateOrderFromCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrderFromCart.CreateOrderFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrderFromCart.t.Fatal("No results are set for the CommerceServiceClientMock.CreateOrderFromCart")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateOrderFromCart.funcCreateOrderFromCart != nil {
		return mmCreateOrderFromCart.funcCreateOrderFromCart(ctx, pp1)
	}
	mmCreateOrderFromCart.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateOrderFromCart. %v %v", ctx, pp1)
	return
}

// CreateOrderFromCartAfterCounter returns a count of finished CommerceServiceClientMock.CreateOrderFromCart invocations
func (mmCreateOrderFromCart *CommerceServiceClientMock) CreateOrderFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderFromCart.afterCreateOrderFromCartCounter)
}

// CreateOrderFromCartBeforeCounter returns a count of CommerceServiceClientMock.CreateOrderFromCart invocations
func (mmCreateOrderFromCart *CommerceServiceClientMock) CreateOrderFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderFromCart.beforeCreateOrderFromCartCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateOrderFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrderFromCart *mCommerceServiceClientMockCreateOrderFromCart) Calls() []*CommerceServiceClientMockCreateOrderFromCartParams {
	mmCreateOrderFromCart.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateOrderFromCartParams, len(mmCreateOrderFromCart.callArgs))
	copy(argCopy, mmCreateOrderFromCart.callArgs)

	mmCreateOrderFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderFromCartDone returns true if the count of the CreateOrderFromCart invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateOrderFromCartDone() bool {
	if m.CreateOrderFromCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderFromCartMock.invocationsDone()
}

// MinimockCreateOrderFromCartInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateOrderFromCartInspect() {
	for _, e := range m.CreateOrderFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrderFromCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderFromCartCounter := mm_atomic.LoadUint64(&m.afterCreateOrderFromCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderFromCartMock.defaultExpectation != nil && afterCreateOrderFromCartCounter < 1 {
		if m.CreateOrderFromCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrderFromCart at\n%s", m.CreateOrderFromCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrderFromCart at\n%s with params: %#v", m.CreateOrderFromCartMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderFromCart != nil && afterCreateOrderFromCartCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateOrderFromCart at\n%s", m.funcCreateOrderFromCartOrigin)
	}

	if !m.CreateOrderFromCartMock.invocationsDone() && afterCreateOrderFromCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateOrderFromCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderFromCartMock.expectedInvocations), m.CreateOrderFromCartMock.expectedInvocationsOrigin, afterCreateOrderFromCartCounter)
	}
}

type mCommerceServiceClientMockCreateProduct struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateProductExpectation
	expectations       []*CommerceServiceClientMockCreateProductExpectation

	callArgs []*CommerceServiceClientMockCreateProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateProductExpectation specifies expectation struct of the CommerceServiceClient.CreateProduct
type CommerceServiceClientMockCreateProductExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateProductParams
	paramPtrs          *CommerceServiceClientMockCreateProductParamPtrs
	expectationOrigins CommerceServiceClientMockCreateProductExpectationOrigins
	results            *CommerceServiceClientMockCreateProductResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateProductParams contains parameters of the CommerceServiceClient.CreateProduct
type CommerceServiceClientMockCreateProductParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateProductRequest]
}

// CommerceServiceClientMockCreateProductParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateProduct
type CommerceServiceClientMockCreateProductParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateProductRequest]
}

// CommerceServiceClientMockCreateProductResults contains results of the CommerceServiceClient.CreateProduct
type CommerceServiceClientMockCreateProductResults struct {
	pp2 *connect.Response[v1.CreateProductResponse]
	err error
}

// CommerceServiceClientMockCreateProductOrigins contains origins of expectations of the CommerceServiceClient.CreateProduct
type CommerceServiceClientMockCreateProductExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Optional() *mCommerceServiceClientMockCreateProduct {
	mmCreateProduct.optional = true
	return mmCreateProduct
}

// Expect sets up expected params for CommerceServiceClient.CreateProduct
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest]) *mCommerceServiceClientMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &CommerceServiceClientMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.paramPtrs != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by ExpectParams functions")
	}

	mmCreateProduct.defaultExpectation.params = &CommerceServiceClientMockCreateProductParams{ctx, pp1}
	mmCreateProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProduct.expectations {
		if minimock.Equal(e.params, mmCreateProduct.defaultExpectation.params) {
			mmCreateProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProduct.defaultExpectation.params)
		}
	}

	return mmCreateProduct
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateProduct
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &CommerceServiceClientMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProduct
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateProduct
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) ExpectPp1Param2(pp1 *connect.Request[v1.CreateProductRequest]) *mCommerceServiceClientMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &CommerceServiceClientMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateProduct.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateProduct
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateProduct
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest])) *mCommerceServiceClientMockCreateProduct {
	if mmCreateProduct.mock.inspectFuncCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateProduct")
	}

	mmCreateProduct.mock.inspectFuncCreateProduct = f

	return mmCreateProduct
}

// Return sets up results that will be returned by CommerceServiceClient.CreateProduct
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Return(pp2 *connect.Response[v1.CreateProductResponse], err error) *CommerceServiceClientMock {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &CommerceServiceClientMockCreateProductExpectation{mock: mmCreateProduct.mock}
	}
	mmCreateProduct.defaultExpectation.results = &CommerceServiceClientMockCreateProductResults{pp2, err}
	mmCreateProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateProduct method
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest]) (pp2 *connect.Response[v1.CreateProductResponse], err error)) *CommerceServiceClientMock {
	if mmCreateProduct.defaultExpectation != nil {
		mmCreateProduct.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateProduct method")
	}

	if len(mmCreateProduct.expectations) > 0 {
		mmCreateProduct.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateProduct method")
	}

	mmCreateProduct.mock.funcCreateProduct = f
	mmCreateProduct.mock.funcCreateProductOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// When sets expectation for the CommerceServiceClient.CreateProduct which will trigger the result defined by the following
// Then helper
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) When(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest]) *CommerceServiceClientMockCreateProductExpectation {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("CommerceServiceClientMock.CreateProduct mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateProductExpectation{
		mock:               mmCreateProduct.mock,
		params:             &CommerceServiceClientMockCreateProductParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProduct.expectations = append(mmCreateProduct.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateProduct return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateProductExpectation) Then(pp2 *connect.Response[v1.CreateProductResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateProductResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateProduct should be invoked
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Times(n uint64) *mCommerceServiceClientMockCreateProduct {
	if n == 0 {
		mmCreateProduct.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProduct.expectedInvocations, n)
	mmCreateProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProduct
}

func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) invocationsDone() bool {
	if len(mmCreateProduct.expectations) == 0 && mmCreateProduct.defaultExpectation == nil && mmCreateProduct.mock.funcCreateProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProduct.mock.afterCreateProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProduct implements mm_commercev1connect.CommerceServiceClient
func (mmCreateProduct *CommerceServiceClientMock) CreateProduct(ctx context.Context, pp1 *connect.Request[v1.CreateProductRequest]) (pp2 *connect.Response[v1.CreateProductResponse], err error) {
	mm_atomic.AddUint64(&mmCreateProduct.beforeCreateProductCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProduct.afterCreateProductCounter, 1)

	mmCreateProduct.t.Helper()

	if mmCreateProduct.inspectFuncCreateProduct != nil {
		mmCreateProduct.inspectFuncCreateProduct(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateProductParams{ctx, pp1}

	// Record call args
	mmCreateProduct.CreateProductMock.mutex.Lock()
	mmCreateProduct.CreateProductMock.callArgs = append(mmCreateProduct.CreateProductMock.callArgs, &mm_params)
	mmCreateProduct.CreateProductMock.mutex.Unlock()

	for _, e := range mmCreateProduct.CreateProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateProduct.CreateProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProduct.CreateProductMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProduct.CreateProductMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProduct.CreateProductMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateProductParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProduct.t.Errorf("CommerceServiceClientMock.CreateProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateProduct.t.Errorf("CommerceServiceClientMock.CreateProduct got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProduct.t.Errorf("CommerceServiceClientMock.CreateProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProduct.CreateProductMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProduct.t.Fatal("No results are set for the CommerceServiceClientMock.CreateProduct")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateProduct.funcCreateProduct != nil {
		return mmCreateProduct.funcCreateProduct(ctx, pp1)
	}
	mmCreateProduct.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateProduct. %v %v", ctx, pp1)
	return
}

// CreateProductAfterCounter returns a count of finished CommerceServiceClientMock.CreateProduct invocations
func (mmCreateProduct *CommerceServiceClientMock) CreateProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.afterCreateProductCounter)
}

// CreateProductBeforeCounter returns a count of CommerceServiceClientMock.CreateProduct invocations
func (mmCreateProduct *CommerceServiceClientMock) CreateProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.beforeCreateProductCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProduct *mCommerceServiceClientMockCreateProduct) Calls() []*CommerceServiceClientMockCreateProductParams {
	mmCreateProduct.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateProductParams, len(mmCreateProduct.callArgs))
	copy(argCopy, mmCreateProduct.callArgs)

	mmCreateProduct.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProductDone returns true if the count of the CreateProduct invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateProductDone() bool {
	if m.CreateProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateProductMock.invocationsDone()
}

// MinimockCreateProductInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateProductInspect() {
	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateProductCounter := mm_atomic.LoadUint64(&m.afterCreateProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProductMock.defaultExpectation != nil && afterCreateProductCounter < 1 {
		if m.CreateProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProduct at\n%s", m.CreateProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProduct at\n%s with params: %#v", m.CreateProductMock.defaultExpectation.expectationOrigins.origin, *m.CreateProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProduct != nil && afterCreateProductCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProduct at\n%s", m.funcCreateProductOrigin)
	}

	if !m.CreateProductMock.invocationsDone() && afterCreateProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateProductMock.expectedInvocations), m.CreateProductMock.expectedInvocationsOrigin, afterCreateProductCounter)
	}
}

type mCommerceServiceClientMockCreateProductVariant struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateProductVariantExpectation
	expectations       []*CommerceServiceClientMockCreateProductVariantExpectation

	callArgs []*CommerceServiceClientMockCreateProductVariantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateProductVariantExpectation specifies expectation struct of the CommerceServiceClient.CreateProductVariant
type CommerceServiceClientMockCreateProductVariantExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateProductVariantParams
	paramPtrs          *CommerceServiceClientMockCreateProductVariantParamPtrs
	expectationOrigins CommerceServiceClientMockCreateProductVariantExpectationOrigins
	results            *CommerceServiceClientMockCreateProductVariantResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateProductVariantParams contains parameters of the CommerceServiceClient.CreateProductVariant
type CommerceServiceClientMockCreateProductVariantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateProductVariantRequest]
}

// CommerceServiceClientMockCreateProductVariantParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateProductVariant
type CommerceServiceClientMockCreateProductVariantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateProductVariantRequest]
}

// CommerceServiceClientMockCreateProductVariantResults contains results of the CommerceServiceClient.CreateProductVariant
type CommerceServiceClientMockCreateProductVariantResults struct {
	pp2 *connect.Response[v1.CreateProductVariantResponse]
	err error
}

// CommerceServiceClientMockCreateProductVariantOrigins contains origins of expectations of the CommerceServiceClient.CreateProductVariant
type CommerceServiceClientMockCreateProductVariantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Optional() *mCommerceServiceClientMockCreateProductVariant {
	mmCreateProductVariant.optional = true
	return mmCreateProductVariant
}

// Expect sets up expected params for CommerceServiceClient.CreateProductVariant
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest]) *mCommerceServiceClientMockCreateProductVariant {
	if mmCreateProductVariant.mock.funcCreateProductVariant != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Set")
	}

	if mmCreateProductVariant.defaultExpectation == nil {
		mmCreateProductVariant.defaultExpectation = &CommerceServiceClientMockCreateProductVariantExpectation{}
	}

	if mmCreateProductVariant.defaultExpectation.paramPtrs != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by ExpectParams functions")
	}

	mmCreateProductVariant.defaultExpectation.params = &CommerceServiceClientMockCreateProductVariantParams{ctx, pp1}
	mmCreateProductVariant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProductVariant.expectations {
		if minimock.Equal(e.params, mmCreateProductVariant.defaultExpectation.params) {
			mmCreateProductVariant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProductVariant.defaultExpectation.params)
		}
	}

	return mmCreateProductVariant
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateProductVariant
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateProductVariant {
	if mmCreateProductVariant.mock.funcCreateProductVariant != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Set")
	}

	if mmCreateProductVariant.defaultExpectation == nil {
		mmCreateProductVariant.defaultExpectation = &CommerceServiceClientMockCreateProductVariantExpectation{}
	}

	if mmCreateProductVariant.defaultExpectation.params != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Expect")
	}

	if mmCreateProductVariant.defaultExpectation.paramPtrs == nil {
		mmCreateProductVariant.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateProductVariantParamPtrs{}
	}
	mmCreateProductVariant.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProductVariant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProductVariant
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateProductVariant
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) ExpectPp1Param2(pp1 *connect.Request[v1.CreateProductVariantRequest]) *mCommerceServiceClientMockCreateProductVariant {
	if mmCreateProductVariant.mock.funcCreateProductVariant != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Set")
	}

	if mmCreateProductVariant.defaultExpectation == nil {
		mmCreateProductVariant.defaultExpectation = &CommerceServiceClientMockCreateProductVariantExpectation{}
	}

	if mmCreateProductVariant.defaultExpectation.params != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Expect")
	}

	if mmCreateProductVariant.defaultExpectation.paramPtrs == nil {
		mmCreateProductVariant.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateProductVariantParamPtrs{}
	}
	mmCreateProductVariant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateProductVariant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateProductVariant
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateProductVariant
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest])) *mCommerceServiceClientMockCreateProductVariant {
	if mmCreateProductVariant.mock.inspectFuncCreateProductVariant != nil {
		mmCreateProductVariant.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateProductVariant")
	}

	mmCreateProductVariant.mock.inspectFuncCreateProductVariant = f

	return mmCreateProductVariant
}

// Return sets up results that will be returned by CommerceServiceClient.CreateProductVariant
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Return(pp2 *connect.Response[v1.CreateProductVariantResponse], err error) *CommerceServiceClientMock {
	if mmCreateProductVariant.mock.funcCreateProductVariant != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Set")
	}

	if mmCreateProductVariant.defaultExpectation == nil {
		mmCreateProductVariant.defaultExpectation = &CommerceServiceClientMockCreateProductVariantExpectation{mock: mmCreateProductVariant.mock}
	}
	mmCreateProductVariant.defaultExpectation.results = &CommerceServiceClientMockCreateProductVariantResults{pp2, err}
	mmCreateProductVariant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProductVariant.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateProductVariant method
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest]) (pp2 *connect.Response[v1.CreateProductVariantResponse], err error)) *CommerceServiceClientMock {
	if mmCreateProductVariant.defaultExpectation != nil {
		mmCreateProductVariant.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateProductVariant method")
	}

	if len(mmCreateProductVariant.expectations) > 0 {
		mmCreateProductVariant.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateProductVariant method")
	}

	mmCreateProductVariant.mock.funcCreateProductVariant = f
	mmCreateProductVariant.mock.funcCreateProductVariantOrigin = minimock.CallerInfo(1)
	return mmCreateProductVariant.mock
}

// When sets expectation for the CommerceServiceClient.CreateProductVariant which will trigger the result defined by the following
// Then helper
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) When(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest]) *CommerceServiceClientMockCreateProductVariantExpectation {
	if mmCreateProductVariant.mock.funcCreateProductVariant != nil {
		mmCreateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.CreateProductVariant mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateProductVariantExpectation{
		mock:               mmCreateProductVariant.mock,
		params:             &CommerceServiceClientMockCreateProductVariantParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateProductVariantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProductVariant.expectations = append(mmCreateProductVariant.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateProductVariant return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateProductVariantExpectation) Then(pp2 *connect.Response[v1.CreateProductVariantResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateProductVariantResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateProductVariant should be invoked
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Times(n uint64) *mCommerceServiceClientMockCreateProductVariant {
	if n == 0 {
		mmCreateProductVariant.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateProductVariant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProductVariant.expectedInvocations, n)
	mmCreateProductVariant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProductVariant
}

func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) invocationsDone() bool {
	if len(mmCreateProductVariant.expectations) == 0 && mmCreateProductVariant.defaultExpectation == nil && mmCreateProductVariant.mock.funcCreateProductVariant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProductVariant.mock.afterCreateProductVariantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProductVariant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProductVariant implements mm_commercev1connect.CommerceServiceClient
func (mmCreateProductVariant *CommerceServiceClientMock) CreateProductVariant(ctx context.Context, pp1 *connect.Request[v1.CreateProductVariantRequest]) (pp2 *connect.Response[v1.CreateProductVariantResponse], err error) {
	mm_atomic.AddUint64(&mmCreateProductVariant.beforeCreateProductVariantCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProductVariant.afterCreateProductVariantCounter, 1)

	mmCreateProductVariant.t.Helper()

	if mmCreateProductVariant.inspectFuncCreateProductVariant != nil {
		mmCreateProductVariant.inspectFuncCreateProductVariant(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateProductVariantParams{ctx, pp1}

	// Record call args
	mmCreateProductVariant.CreateProductVariantMock.mutex.Lock()
	mmCreateProductVariant.CreateProductVariantMock.callArgs = append(mmCreateProductVariant.CreateProductVariantMock.callArgs, &mm_params)
	mmCreateProductVariant.CreateProductVariantMock.mutex.Unlock()

	for _, e := range mmCreateProductVariant.CreateProductVariantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateProductVariant.CreateProductVariantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateProductVariantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProductVariant.t.Errorf("CommerceServiceClientMock.CreateProductVariant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateProductVariant.t.Errorf("CommerceServiceClientMock.CreateProductVariant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProductVariant.t.Errorf("CommerceServiceClientMock.CreateProductVariant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProductVariant.CreateProductVariantMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProductVariant.t.Fatal("No results are set for the CommerceServiceClientMock.CreateProductVariant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateProductVariant.funcCreateProductVariant != nil {
		return mmCreateProductVariant.funcCreateProductVariant(ctx, pp1)
	}
	mmCreateProductVariant.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateProductVariant. %v %v", ctx, pp1)
	return
}

// CreateProductVariantAfterCounter returns a count of finished CommerceServiceClientMock.CreateProductVariant invocations
func (mmCreateProductVariant *CommerceServiceClientMock) CreateProductVariantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProductVariant.afterCreateProductVariantCounter)
}

// CreateProductVariantBeforeCounter returns a count of CommerceServiceClientMock.CreateProductVariant invocations
func (mmCreateProductVariant *CommerceServiceClientMock) CreateProductVariantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProductVariant.beforeCreateProductVariantCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateProductVariant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProductVariant *mCommerceServiceClientMockCreateProductVariant) Calls() []*CommerceServiceClientMockCreateProductVariantParams {
	mmCreateProductVariant.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateProductVariantParams, len(mmCreateProductVariant.callArgs))
	copy(argCopy, mmCreateProductVariant.callArgs)

	mmCreateProductVariant.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProductVariantDone returns true if the count of the CreateProductVariant invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateProductVariantDone() bool {
	if m.CreateProductVariantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateProductVariantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateProductVariantMock.invocationsDone()
}

// MinimockCreateProductVariantInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateProductVariantInspect() {
	for _, e := range m.CreateProductVariantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProductVariant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateProductVariantCounter := mm_atomic.LoadUint64(&m.afterCreateProductVariantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProductVariantMock.defaultExpectation != nil && afterCreateProductVariantCounter < 1 {
		if m.CreateProductVariantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProductVariant at\n%s", m.CreateProductVariantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProductVariant at\n%s with params: %#v", m.CreateProductVariantMock.defaultExpectation.expectationOrigins.origin, *m.CreateProductVariantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProductVariant != nil && afterCreateProductVariantCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateProductVariant at\n%s", m.funcCreateProductVariantOrigin)
	}

	if !m.CreateProductVariantMock.invocationsDone() && afterCreateProductVariantCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateProductVariant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateProductVariantMock.expectedInvocations), m.CreateProductVariantMock.expectedInvocationsOrigin, afterCreateProductVariantCounter)
	}
}

type mCommerceServiceClientMockCreateShop struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockCreateShopExpectation
	expectations       []*CommerceServiceClientMockCreateShopExpectation

	callArgs []*CommerceServiceClientMockCreateShopParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockCreateShopExpectation specifies expectation struct of the CommerceServiceClient.CreateShop
type CommerceServiceClientMockCreateShopExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockCreateShopParams
	paramPtrs          *CommerceServiceClientMockCreateShopParamPtrs
	expectationOrigins CommerceServiceClientMockCreateShopExpectationOrigins
	results            *CommerceServiceClientMockCreateShopResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockCreateShopParams contains parameters of the CommerceServiceClient.CreateShop
type CommerceServiceClientMockCreateShopParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateShopRequest]
}

// CommerceServiceClientMockCreateShopParamPtrs contains pointers to parameters of the CommerceServiceClient.CreateShop
type CommerceServiceClientMockCreateShopParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateShopRequest]
}

// CommerceServiceClientMockCreateShopResults contains results of the CommerceServiceClient.CreateShop
type CommerceServiceClientMockCreateShopResults struct {
	pp2 *connect.Response[v1.CreateShopResponse]
	err error
}

// CommerceServiceClientMockCreateShopOrigins contains origins of expectations of the CommerceServiceClient.CreateShop
type CommerceServiceClientMockCreateShopExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Optional() *mCommerceServiceClientMockCreateShop {
	mmCreateShop.optional = true
	return mmCreateShop
}

// Expect sets up expected params for CommerceServiceClient.CreateShop
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest]) *mCommerceServiceClientMockCreateShop {
	if mmCreateShop.mock.funcCreateShop != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Set")
	}

	if mmCreateShop.defaultExpectation == nil {
		mmCreateShop.defaultExpectation = &CommerceServiceClientMockCreateShopExpectation{}
	}

	if mmCreateShop.defaultExpectation.paramPtrs != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by ExpectParams functions")
	}

	mmCreateShop.defaultExpectation.params = &CommerceServiceClientMockCreateShopParams{ctx, pp1}
	mmCreateShop.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateShop.expectations {
		if minimock.Equal(e.params, mmCreateShop.defaultExpectation.params) {
			mmCreateShop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateShop.defaultExpectation.params)
		}
	}

	return mmCreateShop
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.CreateShop
func (mmCreateShop *mCommerceServiceClientMockCreateShop) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockCreateShop {
	if mmCreateShop.mock.funcCreateShop != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Set")
	}

	if mmCreateShop.defaultExpectation == nil {
		mmCreateShop.defaultExpectation = &CommerceServiceClientMockCreateShopExpectation{}
	}

	if mmCreateShop.defaultExpectation.params != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Expect")
	}

	if mmCreateShop.defaultExpectation.paramPtrs == nil {
		mmCreateShop.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateShopParamPtrs{}
	}
	mmCreateShop.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateShop.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateShop
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.CreateShop
func (mmCreateShop *mCommerceServiceClientMockCreateShop) ExpectPp1Param2(pp1 *connect.Request[v1.CreateShopRequest]) *mCommerceServiceClientMockCreateShop {
	if mmCreateShop.mock.funcCreateShop != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Set")
	}

	if mmCreateShop.defaultExpectation == nil {
		mmCreateShop.defaultExpectation = &CommerceServiceClientMockCreateShopExpectation{}
	}

	if mmCreateShop.defaultExpectation.params != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Expect")
	}

	if mmCreateShop.defaultExpectation.paramPtrs == nil {
		mmCreateShop.defaultExpectation.paramPtrs = &CommerceServiceClientMockCreateShopParamPtrs{}
	}
	mmCreateShop.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateShop.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateShop
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.CreateShop
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest])) *mCommerceServiceClientMockCreateShop {
	if mmCreateShop.mock.inspectFuncCreateShop != nil {
		mmCreateShop.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.CreateShop")
	}

	mmCreateShop.mock.inspectFuncCreateShop = f

	return mmCreateShop
}

// Return sets up results that will be returned by CommerceServiceClient.CreateShop
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Return(pp2 *connect.Response[v1.CreateShopResponse], err error) *CommerceServiceClientMock {
	if mmCreateShop.mock.funcCreateShop != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Set")
	}

	if mmCreateShop.defaultExpectation == nil {
		mmCreateShop.defaultExpectation = &CommerceServiceClientMockCreateShopExpectation{mock: mmCreateShop.mock}
	}
	mmCreateShop.defaultExpectation.results = &CommerceServiceClientMockCreateShopResults{pp2, err}
	mmCreateShop.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateShop.mock
}

// Set uses given function f to mock the CommerceServiceClient.CreateShop method
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest]) (pp2 *connect.Response[v1.CreateShopResponse], err error)) *CommerceServiceClientMock {
	if mmCreateShop.defaultExpectation != nil {
		mmCreateShop.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.CreateShop method")
	}

	if len(mmCreateShop.expectations) > 0 {
		mmCreateShop.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.CreateShop method")
	}

	mmCreateShop.mock.funcCreateShop = f
	mmCreateShop.mock.funcCreateShopOrigin = minimock.CallerInfo(1)
	return mmCreateShop.mock
}

// When sets expectation for the CommerceServiceClient.CreateShop which will trigger the result defined by the following
// Then helper
func (mmCreateShop *mCommerceServiceClientMockCreateShop) When(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest]) *CommerceServiceClientMockCreateShopExpectation {
	if mmCreateShop.mock.funcCreateShop != nil {
		mmCreateShop.mock.t.Fatalf("CommerceServiceClientMock.CreateShop mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockCreateShopExpectation{
		mock:               mmCreateShop.mock,
		params:             &CommerceServiceClientMockCreateShopParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockCreateShopExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateShop.expectations = append(mmCreateShop.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.CreateShop return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockCreateShopExpectation) Then(pp2 *connect.Response[v1.CreateShopResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockCreateShopResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.CreateShop should be invoked
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Times(n uint64) *mCommerceServiceClientMockCreateShop {
	if n == 0 {
		mmCreateShop.mock.t.Fatalf("Times of CommerceServiceClientMock.CreateShop mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateShop.expectedInvocations, n)
	mmCreateShop.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateShop
}

func (mmCreateShop *mCommerceServiceClientMockCreateShop) invocationsDone() bool {
	if len(mmCreateShop.expectations) == 0 && mmCreateShop.defaultExpectation == nil && mmCreateShop.mock.funcCreateShop == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateShop.mock.afterCreateShopCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateShop.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateShop implements mm_commercev1connect.CommerceServiceClient
func (mmCreateShop *CommerceServiceClientMock) CreateShop(ctx context.Context, pp1 *connect.Request[v1.CreateShopRequest]) (pp2 *connect.Response[v1.CreateShopResponse], err error) {
	mm_atomic.AddUint64(&mmCreateShop.beforeCreateShopCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateShop.afterCreateShopCounter, 1)

	mmCreateShop.t.Helper()

	if mmCreateShop.inspectFuncCreateShop != nil {
		mmCreateShop.inspectFuncCreateShop(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockCreateShopParams{ctx, pp1}

	// Record call args
	mmCreateShop.CreateShopMock.mutex.Lock()
	mmCreateShop.CreateShopMock.callArgs = append(mmCreateShop.CreateShopMock.callArgs, &mm_params)
	mmCreateShop.CreateShopMock.mutex.Unlock()

	for _, e := range mmCreateShop.CreateShopMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateShop.CreateShopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateShop.CreateShopMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateShop.CreateShopMock.defaultExpectation.params
		mm_want_ptrs := mmCreateShop.CreateShopMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockCreateShopParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateShop.t.Errorf("CommerceServiceClientMock.CreateShop got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateShop.CreateShopMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateShop.t.Errorf("CommerceServiceClientMock.CreateShop got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateShop.CreateShopMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateShop.t.Errorf("CommerceServiceClientMock.CreateShop got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateShop.CreateShopMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateShop.CreateShopMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateShop.t.Fatal("No results are set for the CommerceServiceClientMock.CreateShop")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateShop.funcCreateShop != nil {
		return mmCreateShop.funcCreateShop(ctx, pp1)
	}
	mmCreateShop.t.Fatalf("Unexpected call to CommerceServiceClientMock.CreateShop. %v %v", ctx, pp1)
	return
}

// CreateShopAfterCounter returns a count of finished CommerceServiceClientMock.CreateShop invocations
func (mmCreateShop *CommerceServiceClientMock) CreateShopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateShop.afterCreateShopCounter)
}

// CreateShopBeforeCounter returns a count of CommerceServiceClientMock.CreateShop invocations
func (mmCreateShop *CommerceServiceClientMock) CreateShopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateShop.beforeCreateShopCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.CreateShop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateShop *mCommerceServiceClientMockCreateShop) Calls() []*CommerceServiceClientMockCreateShopParams {
	mmCreateShop.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockCreateShopParams, len(mmCreateShop.callArgs))
	copy(argCopy, mmCreateShop.callArgs)

	mmCreateShop.mutex.RUnlock()

	return argCopy
}

// MinimockCreateShopDone returns true if the count of the CreateShop invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockCreateShopDone() bool {
	if m.CreateShopMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateShopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateShopMock.invocationsDone()
}

// MinimockCreateShopInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockCreateShopInspect() {
	for _, e := range m.CreateShopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateShop at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateShopCounter := mm_atomic.LoadUint64(&m.afterCreateShopCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateShopMock.defaultExpectation != nil && afterCreateShopCounter < 1 {
		if m.CreateShopMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateShop at\n%s", m.CreateShopMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.CreateShop at\n%s with params: %#v", m.CreateShopMock.defaultExpectation.expectationOrigins.origin, *m.CreateShopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateShop != nil && afterCreateShopCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.CreateShop at\n%s", m.funcCreateShopOrigin)
	}

	if !m.CreateShopMock.invocationsDone() && afterCreateShopCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.CreateShop at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateShopMock.expectedInvocations), m.CreateShopMock.expectedInvocationsOrigin, afterCreateShopCounter)
	}
}

type mCommerceServiceClientMockGetCart struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockGetCartExpectation
	expectations       []*CommerceServiceClientMockGetCartExpectation

	callArgs []*CommerceServiceClientMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockGetCartExpectation specifies expectation struct of the CommerceServiceClient.GetCart
type CommerceServiceClientMockGetCartExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockGetCartParams
	paramPtrs          *CommerceServiceClientMockGetCartParamPtrs
	expectationOrigins CommerceServiceClientMockGetCartExpectationOrigins
	results            *CommerceServiceClientMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockGetCartParams contains parameters of the CommerceServiceClient.GetCart
type CommerceServiceClientMockGetCartParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetCartRequest]
}

// CommerceServiceClientMockGetCartParamPtrs contains pointers to parameters of the CommerceServiceClient.GetCart
type CommerceServiceClientMockGetCartParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetCartRequest]
}

// CommerceServiceClientMockGetCartResults contains results of the CommerceServiceClient.GetCart
type CommerceServiceClientMockGetCartResults struct {
	pp2 *connect.Response[v1.GetCartResponse]
	err error
}

// CommerceServiceClientMockGetCartOrigins contains origins of expectations of the CommerceServiceClient.GetCart
type CommerceServiceClientMockGetCartExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCommerceServiceClientMockGetCart) Optional() *mCommerceServiceClientMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CommerceServiceClient.GetCart
func (mmGetCart *mCommerceServiceClientMockGetCart) Expect(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest]) *mCommerceServiceClientMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CommerceServiceClientMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CommerceServiceClientMockGetCartParams{ctx, pp1}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.GetCart
func (mmGetCart *mCommerceServiceClientMockGetCart) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CommerceServiceClientMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.GetCart
func (mmGetCart *mCommerceServiceClientMockGetCart) ExpectPp1Param2(pp1 *connect.Request[v1.GetCartRequest]) *mCommerceServiceClientMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CommerceServiceClientMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetCart.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.GetCart
func (mmGetCart *mCommerceServiceClientMockGetCart) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest])) *mCommerceServiceClientMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CommerceServiceClient.GetCart
func (mmGetCart *mCommerceServiceClientMockGetCart) Return(pp2 *connect.Response[v1.GetCartResponse], err error) *CommerceServiceClientMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CommerceServiceClientMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CommerceServiceClientMockGetCartResults{pp2, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CommerceServiceClient.GetCart method
func (mmGetCart *mCommerceServiceClientMockGetCart) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest]) (pp2 *connect.Response[v1.GetCartResponse], err error)) *CommerceServiceClientMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CommerceServiceClient.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCommerceServiceClientMockGetCart) When(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest]) *CommerceServiceClientMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CommerceServiceClientMock.GetCart mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CommerceServiceClientMockGetCartParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.GetCart return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockGetCartExpectation) Then(pp2 *connect.Response[v1.GetCartResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockGetCartResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.GetCart should be invoked
func (mmGetCart *mCommerceServiceClientMockGetCart) Times(n uint64) *mCommerceServiceClientMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CommerceServiceClientMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCommerceServiceClientMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_commercev1connect.CommerceServiceClient
func (mmGetCart *CommerceServiceClientMock) GetCart(ctx context.Context, pp1 *connect.Request[v1.GetCartRequest]) (pp2 *connect.Response[v1.GetCartResponse], err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockGetCartParams{ctx, pp1}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockGetCartParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CommerceServiceClientMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetCart.t.Errorf("CommerceServiceClientMock.GetCart got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CommerceServiceClientMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CommerceServiceClientMock.GetCart")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, pp1)
	}
	mmGetCart.t.Fatalf("Unexpected call to CommerceServiceClientMock.GetCart. %v %v", ctx, pp1)
	return
}

// GetCartAfterCounter returns a count of finished CommerceServiceClientMock.GetCart invocations
func (mmGetCart *CommerceServiceClientMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CommerceServiceClientMock.GetCart invocations
func (mmGetCart *CommerceServiceClientMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCommerceServiceClientMockGetCart) Calls() []*CommerceServiceClientMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

type mCommerceServiceClientMockGetFulfilment struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockGetFulfilmentExpectation
	expectations       []*CommerceServiceClientMockGetFulfilmentExpectation

	callArgs []*CommerceServiceClientMockGetFulfilmentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockGetFulfilmentExpectation specifies expectation struct of the CommerceServiceClient.GetFulfilment
type CommerceServiceClientMockGetFulfilmentExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockGetFulfilmentParams
	paramPtrs          *CommerceServiceClientMockGetFulfilmentParamPtrs
	expectationOrigins CommerceServiceClientMockGetFulfilmentExpectationOrigins
	results            *CommerceServiceClientMockGetFulfilmentResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockGetFulfilmentParams contains parameters of the CommerceServiceClient.GetFulfilment
type CommerceServiceClientMockGetFulfilmentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetFulfilmentRequest]
}

// CommerceServiceClientMockGetFulfilmentParamPtrs contains pointers to parameters of the CommerceServiceClient.GetFulfilment
type CommerceServiceClientMockGetFulfilmentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetFulfilmentRequest]
}

// CommerceServiceClientMockGetFulfilmentResults contains results of the CommerceServiceClient.GetFulfilment
type CommerceServiceClientMockGetFulfilmentResults struct {
	pp2 *connect.Response[v1.GetFulfilmentResponse]
	err error
}

// CommerceServiceClientMockGetFulfilmentOrigins contains origins of expectations of the CommerceServiceClient.GetFulfilment
type CommerceServiceClientMockGetFulfilmentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Optional() *mCommerceServiceClientMockGetFulfilment {
	mmGetFulfilment.optional = true
	return mmGetFulfilment
}

// Expect sets up expected params for CommerceServiceClient.GetFulfilment
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Expect(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest]) *mCommerceServiceClientMockGetFulfilment {
	if mmGetFulfilment.mock.funcGetFulfilment != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Set")
	}

	if mmGetFulfilment.defaultExpectation == nil {
		mmGetFulfilment.defaultExpectation = &CommerceServiceClientMockGetFulfilmentExpectation{}
	}

	if mmGetFulfilment.defaultExpectation.paramPtrs != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by ExpectParams functions")
	}

	mmGetFulfilment.defaultExpectation.params = &CommerceServiceClientMockGetFulfilmentParams{ctx, pp1}
	mmGetFulfilment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFulfilment.expectations {
		if minimock.Equal(e.params, mmGetFulfilment.defaultExpectation.params) {
			mmGetFulfilment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFulfilment.defaultExpectation.params)
		}
	}

	return mmGetFulfilment
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.GetFulfilment
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockGetFulfilment {
	if mmGetFulfilment.mock.funcGetFulfilment != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Set")
	}

	if mmGetFulfilment.defaultExpectation == nil {
		mmGetFulfilment.defaultExpectation = &CommerceServiceClientMockGetFulfilmentExpectation{}
	}

	if mmGetFulfilment.defaultExpectation.params != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Expect")
	}

	if mmGetFulfilment.defaultExpectation.paramPtrs == nil {
		mmGetFulfilment.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetFulfilmentParamPtrs{}
	}
	mmGetFulfilment.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFulfilment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFulfilment
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.GetFulfilment
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) ExpectPp1Param2(pp1 *connect.Request[v1.GetFulfilmentRequest]) *mCommerceServiceClientMockGetFulfilment {
	if mmGetFulfilment.mock.funcGetFulfilment != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Set")
	}

	if mmGetFulfilment.defaultExpectation == nil {
		mmGetFulfilment.defaultExpectation = &CommerceServiceClientMockGetFulfilmentExpectation{}
	}

	if mmGetFulfilment.defaultExpectation.params != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Expect")
	}

	if mmGetFulfilment.defaultExpectation.paramPtrs == nil {
		mmGetFulfilment.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetFulfilmentParamPtrs{}
	}
	mmGetFulfilment.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetFulfilment.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetFulfilment
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.GetFulfilment
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest])) *mCommerceServiceClientMockGetFulfilment {
	if mmGetFulfilment.mock.inspectFuncGetFulfilment != nil {
		mmGetFulfilment.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.GetFulfilment")
	}

	mmGetFulfilment.mock.inspectFuncGetFulfilment = f

	return mmGetFulfilment
}

// Return sets up results that will be returned by CommerceServiceClient.GetFulfilment
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Return(pp2 *connect.Response[v1.GetFulfilmentResponse], err error) *CommerceServiceClientMock {
	if mmGetFulfilment.mock.funcGetFulfilment != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Set")
	}

	if mmGetFulfilment.defaultExpectation == nil {
		mmGetFulfilment.defaultExpectation = &CommerceServiceClientMockGetFulfilmentExpectation{mock: mmGetFulfilment.mock}
	}
	mmGetFulfilment.defaultExpectation.results = &CommerceServiceClientMockGetFulfilmentResults{pp2, err}
	mmGetFulfilment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFulfilment.mock
}

// Set uses given function f to mock the CommerceServiceClient.GetFulfilment method
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest]) (pp2 *connect.Response[v1.GetFulfilmentResponse], err error)) *CommerceServiceClientMock {
	if mmGetFulfilment.defaultExpectation != nil {
		mmGetFulfilment.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.GetFulfilment method")
	}

	if len(mmGetFulfilment.expectations) > 0 {
		mmGetFulfilment.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.GetFulfilment method")
	}

	mmGetFulfilment.mock.funcGetFulfilment = f
	mmGetFulfilment.mock.funcGetFulfilmentOrigin = minimock.CallerInfo(1)
	return mmGetFulfilment.mock
}

// When sets expectation for the CommerceServiceClient.GetFulfilment which will trigger the result defined by the following
// Then helper
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) When(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest]) *CommerceServiceClientMockGetFulfilmentExpectation {
	if mmGetFulfilment.mock.funcGetFulfilment != nil {
		mmGetFulfilment.mock.t.Fatalf("CommerceServiceClientMock.GetFulfilment mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockGetFulfilmentExpectation{
		mock:               mmGetFulfilment.mock,
		params:             &CommerceServiceClientMockGetFulfilmentParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockGetFulfilmentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFulfilment.expectations = append(mmGetFulfilment.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.GetFulfilment return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockGetFulfilmentExpectation) Then(pp2 *connect.Response[v1.GetFulfilmentResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockGetFulfilmentResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.GetFulfilment should be invoked
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Times(n uint64) *mCommerceServiceClientMockGetFulfilment {
	if n == 0 {
		mmGetFulfilment.mock.t.Fatalf("Times of CommerceServiceClientMock.GetFulfilment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFulfilment.expectedInvocations, n)
	mmGetFulfilment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFulfilment
}

func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) invocationsDone() bool {
	if len(mmGetFulfilment.expectations) == 0 && mmGetFulfilment.defaultExpectation == nil && mmGetFulfilment.mock.funcGetFulfilment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFulfilment.mock.afterGetFulfilmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFulfilment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFulfilment implements mm_commercev1connect.CommerceServiceClient
func (mmGetFulfilment *CommerceServiceClientMock) GetFulfilment(ctx context.Context, pp1 *connect.Request[v1.GetFulfilmentRequest]) (pp2 *connect.Response[v1.GetFulfilmentResponse], err error) {
	mm_atomic.AddUint64(&mmGetFulfilment.beforeGetFulfilmentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFulfilment.afterGetFulfilmentCounter, 1)

	mmGetFulfilment.t.Helper()

	if mmGetFulfilment.inspectFuncGetFulfilment != nil {
		mmGetFulfilment.inspectFuncGetFulfilment(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockGetFulfilmentParams{ctx, pp1}

	// Record call args
	mmGetFulfilment.GetFulfilmentMock.mutex.Lock()
	mmGetFulfilment.GetFulfilmentMock.callArgs = append(mmGetFulfilment.GetFulfilmentMock.callArgs, &mm_params)
	mmGetFulfilment.GetFulfilmentMock.mutex.Unlock()

	for _, e := range mmGetFulfilment.GetFulfilmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetFulfilment.GetFulfilmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFulfilment.GetFulfilmentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFulfilment.GetFulfilmentMock.defaultExpectation.params
		mm_want_ptrs := mmGetFulfilment.GetFulfilmentMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockGetFulfilmentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFulfilment.t.Errorf("CommerceServiceClientMock.GetFulfilment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFulfilment.GetFulfilmentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetFulfilment.t.Errorf("CommerceServiceClientMock.GetFulfilment got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFulfilment.GetFulfilmentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFulfilment.t.Errorf("CommerceServiceClientMock.GetFulfilment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFulfilment.GetFulfilmentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFulfilment.GetFulfilmentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFulfilment.t.Fatal("No results are set for the CommerceServiceClientMock.GetFulfilment")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetFulfilment.funcGetFulfilment != nil {
		return mmGetFulfilment.funcGetFulfilment(ctx, pp1)
	}
	mmGetFulfilment.t.Fatalf("Unexpected call to CommerceServiceClientMock.GetFulfilment. %v %v", ctx, pp1)
	return
}

// GetFulfilmentAfterCounter returns a count of finished CommerceServiceClientMock.GetFulfilment invocations
func (mmGetFulfilment *CommerceServiceClientMock) GetFulfilmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFulfilment.afterGetFulfilmentCounter)
}

// GetFulfilmentBeforeCounter returns a count of CommerceServiceClientMock.GetFulfilment invocations
func (mmGetFulfilment *CommerceServiceClientMock) GetFulfilmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFulfilment.beforeGetFulfilmentCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.GetFulfilment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFulfilment *mCommerceServiceClientMockGetFulfilment) Calls() []*CommerceServiceClientMockGetFulfilmentParams {
	mmGetFulfilment.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockGetFulfilmentParams, len(mmGetFulfilment.callArgs))
	copy(argCopy, mmGetFulfilment.callArgs)

	mmGetFulfilment.mutex.RUnlock()

	return argCopy
}

// MinimockGetFulfilmentDone returns true if the count of the GetFulfilment invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockGetFulfilmentDone() bool {
	if m.GetFulfilmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFulfilmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFulfilmentMock.invocationsDone()
}

// MinimockGetFulfilmentInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockGetFulfilmentInspect() {
	for _, e := range m.GetFulfilmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetFulfilment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFulfilmentCounter := mm_atomic.LoadUint64(&m.afterGetFulfilmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFulfilmentMock.defaultExpectation != nil && afterGetFulfilmentCounter < 1 {
		if m.GetFulfilmentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetFulfilment at\n%s", m.GetFulfilmentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetFulfilment at\n%s with params: %#v", m.GetFulfilmentMock.defaultExpectation.expectationOrigins.origin, *m.GetFulfilmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFulfilment != nil && afterGetFulfilmentCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.GetFulfilment at\n%s", m.funcGetFulfilmentOrigin)
	}

	if !m.GetFulfilmentMock.invocationsDone() && afterGetFulfilmentCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.GetFulfilment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFulfilmentMock.expectedInvocations), m.GetFulfilmentMock.expectedInvocationsOrigin, afterGetFulfilmentCounter)
	}
}

type mCommerceServiceClientMockGetOrder struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockGetOrderExpectation
	expectations       []*CommerceServiceClientMockGetOrderExpectation

	callArgs []*CommerceServiceClientMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockGetOrderExpectation specifies expectation struct of the CommerceServiceClient.GetOrder
type CommerceServiceClientMockGetOrderExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockGetOrderParams
	paramPtrs          *CommerceServiceClientMockGetOrderParamPtrs
	expectationOrigins CommerceServiceClientMockGetOrderExpectationOrigins
	results            *CommerceServiceClientMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockGetOrderParams contains parameters of the CommerceServiceClient.GetOrder
type CommerceServiceClientMockGetOrderParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetOrderRequest]
}

// CommerceServiceClientMockGetOrderParamPtrs contains pointers to parameters of the CommerceServiceClient.GetOrder
type CommerceServiceClientMockGetOrderParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetOrderRequest]
}

// CommerceServiceClientMockGetOrderResults contains results of the CommerceServiceClient.GetOrder
type CommerceServiceClientMockGetOrderResults struct {
	pp2 *connect.Response[v1.GetOrderResponse]
	err error
}

// CommerceServiceClientMockGetOrderOrigins contains origins of expectations of the CommerceServiceClient.GetOrder
type CommerceServiceClientMockGetOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Optional() *mCommerceServiceClientMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for CommerceServiceClient.GetOrder
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Expect(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest]) *mCommerceServiceClientMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &CommerceServiceClientMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &CommerceServiceClientMockGetOrderParams{ctx, pp1}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.GetOrder
func (mmGetOrder *mCommerceServiceClientMockGetOrder) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &CommerceServiceClientMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrder
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.GetOrder
func (mmGetOrder *mCommerceServiceClientMockGetOrder) ExpectPp1Param2(pp1 *connect.Request[v1.GetOrderRequest]) *mCommerceServiceClientMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &CommerceServiceClientMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetOrder.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.GetOrder
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest])) *mCommerceServiceClientMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by CommerceServiceClient.GetOrder
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Return(pp2 *connect.Response[v1.GetOrderResponse], err error) *CommerceServiceClientMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &CommerceServiceClientMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &CommerceServiceClientMockGetOrderResults{pp2, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the CommerceServiceClient.GetOrder method
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest]) (pp2 *connect.Response[v1.GetOrderResponse], err error)) *CommerceServiceClientMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the CommerceServiceClient.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mCommerceServiceClientMockGetOrder) When(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest]) *CommerceServiceClientMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("CommerceServiceClientMock.GetOrder mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &CommerceServiceClientMockGetOrderParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.GetOrder return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockGetOrderExpectation) Then(pp2 *connect.Response[v1.GetOrderResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockGetOrderResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.GetOrder should be invoked
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Times(n uint64) *mCommerceServiceClientMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of CommerceServiceClientMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mCommerceServiceClientMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_commercev1connect.CommerceServiceClient
func (mmGetOrder *CommerceServiceClientMock) GetOrder(ctx context.Context, pp1 *connect.Request[v1.GetOrderRequest]) (pp2 *connect.Response[v1.GetOrderResponse], err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockGetOrderParams{ctx, pp1}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockGetOrderParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrder.t.Errorf("CommerceServiceClientMock.GetOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetOrder.t.Errorf("CommerceServiceClientMock.GetOrder got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("CommerceServiceClientMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the CommerceServiceClientMock.GetOrder")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, pp1)
	}
	mmGetOrder.t.Fatalf("Unexpected call to CommerceServiceClientMock.GetOrder. %v %v", ctx, pp1)
	return
}

// GetOrderAfterCounter returns a count of finished CommerceServiceClientMock.GetOrder invocations
func (mmGetOrder *CommerceServiceClientMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of CommerceServiceClientMock.GetOrder invocations
func (mmGetOrder *CommerceServiceClientMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mCommerceServiceClientMockGetOrder) Calls() []*CommerceServiceClientMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mCommerceServiceClientMockGetProduct struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockGetProductExpectation
	expectations       []*CommerceServiceClientMockGetProductExpectation

	callArgs []*CommerceServiceClientMockGetProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockGetProductExpectation specifies expectation struct of the CommerceServiceClient.GetProduct
type CommerceServiceClientMockGetProductExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockGetProductParams
	paramPtrs          *CommerceServiceClientMockGetProductParamPtrs
	expectationOrigins CommerceServiceClientMockGetProductExpectationOrigins
	results            *CommerceServiceClientMockGetProductResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockGetProductParams contains parameters of the CommerceServiceClient.GetProduct
type CommerceServiceClientMockGetProductParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetProductRequest]
}

// CommerceServiceClientMockGetProductParamPtrs contains pointers to parameters of the CommerceServiceClient.GetProduct
type CommerceServiceClientMockGetProductParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetProductRequest]
}

// CommerceServiceClientMockGetProductResults contains results of the CommerceServiceClient.GetProduct
type CommerceServiceClientMockGetProductResults struct {
	pp2 *connect.Response[v1.GetProductResponse]
	err error
}

// CommerceServiceClientMockGetProductOrigins contains origins of expectations of the CommerceServiceClient.GetProduct
type CommerceServiceClientMockGetProductExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Optional() *mCommerceServiceClientMockGetProduct {
	mmGetProduct.optional = true
	return mmGetProduct
}

// Expect sets up expected params for CommerceServiceClient.GetProduct
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Expect(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest]) *mCommerceServiceClientMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &CommerceServiceClientMockGetProductExpectation{}
	}

	if mmGetProduct.defaultExpectation.paramPtrs != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by ExpectParams functions")
	}

	mmGetProduct.defaultExpectation.params = &CommerceServiceClientMockGetProductParams{ctx, pp1}
	mmGetProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetProduct.expectations {
		if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) {
			mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
		}
	}

	return mmGetProduct
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.GetProduct
func (mmGetProduct *mCommerceServiceClientMockGetProduct) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &CommerceServiceClientMockGetProductExpectation{}
	}

	if mmGetProduct.defaultExpectation.params != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Expect")
	}

	if mmGetProduct.defaultExpectation.paramPtrs == nil {
		mmGetProduct.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetProductParamPtrs{}
	}
	mmGetProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetProduct
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.GetProduct
func (mmGetProduct *mCommerceServiceClientMockGetProduct) ExpectPp1Param2(pp1 *connect.Request[v1.GetProductRequest]) *mCommerceServiceClientMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &CommerceServiceClientMockGetProductExpectation{}
	}

	if mmGetProduct.defaultExpectation.params != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Expect")
	}

	if mmGetProduct.defaultExpectation.paramPtrs == nil {
		mmGetProduct.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetProductParamPtrs{}
	}
	mmGetProduct.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetProduct.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetProduct
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.GetProduct
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest])) *mCommerceServiceClientMockGetProduct {
	if mmGetProduct.mock.inspectFuncGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.GetProduct")
	}

	mmGetProduct.mock.inspectFuncGetProduct = f

	return mmGetProduct
}

// Return sets up results that will be returned by CommerceServiceClient.GetProduct
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Return(pp2 *connect.Response[v1.GetProductResponse], err error) *CommerceServiceClientMock {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &CommerceServiceClientMockGetProductExpectation{mock: mmGetProduct.mock}
	}
	mmGetProduct.defaultExpectation.results = &CommerceServiceClientMockGetProductResults{pp2, err}
	mmGetProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetProduct.mock
}

// Set uses given function f to mock the CommerceServiceClient.GetProduct method
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest]) (pp2 *connect.Response[v1.GetProductResponse], err error)) *CommerceServiceClientMock {
	if mmGetProduct.defaultExpectation != nil {
		mmGetProduct.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.GetProduct method")
	}

	if len(mmGetProduct.expectations) > 0 {
		mmGetProduct.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.GetProduct method")
	}

	mmGetProduct.mock.funcGetProduct = f
	mmGetProduct.mock.funcGetProductOrigin = minimock.CallerInfo(1)
	return mmGetProduct.mock
}

// When sets expectation for the CommerceServiceClient.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mCommerceServiceClientMockGetProduct) When(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest]) *CommerceServiceClientMockGetProductExpectation {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CommerceServiceClientMock.GetProduct mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockGetProductExpectation{
		mock:               mmGetProduct.mock,
		params:             &CommerceServiceClientMockGetProductParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockGetProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.GetProduct return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockGetProductExpectation) Then(pp2 *connect.Response[v1.GetProductResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockGetProductResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.GetProduct should be invoked
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Times(n uint64) *mCommerceServiceClientMockGetProduct {
	if n == 0 {
		mmGetProduct.mock.t.Fatalf("Times of CommerceServiceClientMock.GetProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetProduct.expectedInvocations, n)
	mmGetProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetProduct
}

func (mmGetProduct *mCommerceServiceClientMockGetProduct) invocationsDone() bool {
	if len(mmGetProduct.expectations) == 0 && mmGetProduct.defaultExpectation == nil && mmGetProduct.mock.funcGetProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetProduct.mock.afterGetProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetProduct implements mm_commercev1connect.CommerceServiceClient
func (mmGetProduct *CommerceServiceClientMock) GetProduct(ctx context.Context, pp1 *connect.Request[v1.GetProductRequest]) (pp2 *connect.Response[v1.GetProductResponse], err error) {
	mm_atomic.AddUint64(&mmGetProduct.beforeGetProductCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProduct.afterGetProductCounter, 1)

	mmGetProduct.t.Helper()

	if mmGetProduct.inspectFuncGetProduct != nil {
		mmGetProduct.inspectFuncGetProduct(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockGetProductParams{ctx, pp1}

	// Record call args
	mmGetProduct.GetProductMock.mutex.Lock()
	mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, &mm_params)
	mmGetProduct.GetProductMock.mutex.Unlock()

	for _, e := range mmGetProduct.GetProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetProduct.GetProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
		mm_want_ptrs := mmGetProduct.GetProductMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockGetProductParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetProduct.t.Errorf("CommerceServiceClientMock.GetProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProduct.GetProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetProduct.t.Errorf("CommerceServiceClientMock.GetProduct got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetProduct.GetProductMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProduct.t.Errorf("CommerceServiceClientMock.GetProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetProduct.GetProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProduct.t.Fatal("No results are set for the CommerceServiceClientMock.GetProduct")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetProduct.funcGetProduct != nil {
		return mmGetProduct.funcGetProduct(ctx, pp1)
	}
	mmGetProduct.t.Fatalf("Unexpected call to CommerceServiceClientMock.GetProduct. %v %v", ctx, pp1)
	return
}

// GetProductAfterCounter returns a count of finished CommerceServiceClientMock.GetProduct invocations
func (mmGetProduct *CommerceServiceClientMock) GetProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.afterGetProductCounter)
}

// GetProductBeforeCounter returns a count of CommerceServiceClientMock.GetProduct invocations
func (mmGetProduct *CommerceServiceClientMock) GetProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.beforeGetProductCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mCommerceServiceClientMockGetProduct) Calls() []*CommerceServiceClientMockGetProductParams {
	mmGetProduct.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockGetProductParams, len(mmGetProduct.callArgs))
	copy(argCopy, mmGetProduct.callArgs)

	mmGetProduct.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockGetProductDone() bool {
	if m.GetProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetProductMock.invocationsDone()
}

// MinimockGetProductInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockGetProductInspect() {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetProductCounter := mm_atomic.LoadUint64(&m.afterGetProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && afterGetProductCounter < 1 {
		if m.GetProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetProduct at\n%s", m.GetProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetProduct at\n%s with params: %#v", m.GetProductMock.defaultExpectation.expectationOrigins.origin, *m.GetProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && afterGetProductCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.GetProduct at\n%s", m.funcGetProductOrigin)
	}

	if !m.GetProductMock.invocationsDone() && afterGetProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.GetProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetProductMock.expectedInvocations), m.GetProductMock.expectedInvocationsOrigin, afterGetProductCounter)
	}
}

type mCommerceServiceClientMockGetShop struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockGetShopExpectation
	expectations       []*CommerceServiceClientMockGetShopExpectation

	callArgs []*CommerceServiceClientMockGetShopParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockGetShopExpectation specifies expectation struct of the CommerceServiceClient.GetShop
type CommerceServiceClientMockGetShopExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockGetShopParams
	paramPtrs          *CommerceServiceClientMockGetShopParamPtrs
	expectationOrigins CommerceServiceClientMockGetShopExpectationOrigins
	results            *CommerceServiceClientMockGetShopResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockGetShopParams contains parameters of the CommerceServiceClient.GetShop
type CommerceServiceClientMockGetShopParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetShopRequest]
}

// CommerceServiceClientMockGetShopParamPtrs contains pointers to parameters of the CommerceServiceClient.GetShop
type CommerceServiceClientMockGetShopParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetShopRequest]
}

// CommerceServiceClientMockGetShopResults contains results of the CommerceServiceClient.GetShop
type CommerceServiceClientMockGetShopResults struct {
	pp2 *connect.Response[v1.GetShopResponse]
	err error
}

// CommerceServiceClientMockGetShopOrigins contains origins of expectations of the CommerceServiceClient.GetShop
type CommerceServiceClientMockGetShopExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetShop *mCommerceServiceClientMockGetShop) Optional() *mCommerceServiceClientMockGetShop {
	mmGetShop.optional = true
	return mmGetShop
}

// Expect sets up expected params for CommerceServiceClient.GetShop
func (mmGetShop *mCommerceServiceClientMockGetShop) Expect(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest]) *mCommerceServiceClientMockGetShop {
	if mmGetShop.mock.funcGetShop != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Set")
	}

	if mmGetShop.defaultExpectation == nil {
		mmGetShop.defaultExpectation = &CommerceServiceClientMockGetShopExpectation{}
	}

	if mmGetShop.defaultExpectation.paramPtrs != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by ExpectParams functions")
	}

	mmGetShop.defaultExpectation.params = &CommerceServiceClientMockGetShopParams{ctx, pp1}
	mmGetShop.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetShop.expectations {
		if minimock.Equal(e.params, mmGetShop.defaultExpectation.params) {
			mmGetShop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetShop.defaultExpectation.params)
		}
	}

	return mmGetShop
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.GetShop
func (mmGetShop *mCommerceServiceClientMockGetShop) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockGetShop {
	if mmGetShop.mock.funcGetShop != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Set")
	}

	if mmGetShop.defaultExpectation == nil {
		mmGetShop.defaultExpectation = &CommerceServiceClientMockGetShopExpectation{}
	}

	if mmGetShop.defaultExpectation.params != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Expect")
	}

	if mmGetShop.defaultExpectation.paramPtrs == nil {
		mmGetShop.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetShopParamPtrs{}
	}
	mmGetShop.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetShop.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetShop
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.GetShop
func (mmGetShop *mCommerceServiceClientMockGetShop) ExpectPp1Param2(pp1 *connect.Request[v1.GetShopRequest]) *mCommerceServiceClientMockGetShop {
	if mmGetShop.mock.funcGetShop != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Set")
	}

	if mmGetShop.defaultExpectation == nil {
		mmGetShop.defaultExpectation = &CommerceServiceClientMockGetShopExpectation{}
	}

	if mmGetShop.defaultExpectation.params != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Expect")
	}

	if mmGetShop.defaultExpectation.paramPtrs == nil {
		mmGetShop.defaultExpectation.paramPtrs = &CommerceServiceClientMockGetShopParamPtrs{}
	}
	mmGetShop.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetShop.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetShop
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.GetShop
func (mmGetShop *mCommerceServiceClientMockGetShop) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest])) *mCommerceServiceClientMockGetShop {
	if mmGetShop.mock.inspectFuncGetShop != nil {
		mmGetShop.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.GetShop")
	}

	mmGetShop.mock.inspectFuncGetShop = f

	return mmGetShop
}

// Return sets up results that will be returned by CommerceServiceClient.GetShop
func (mmGetShop *mCommerceServiceClientMockGetShop) Return(pp2 *connect.Response[v1.GetShopResponse], err error) *CommerceServiceClientMock {
	if mmGetShop.mock.funcGetShop != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Set")
	}

	if mmGetShop.defaultExpectation == nil {
		mmGetShop.defaultExpectation = &CommerceServiceClientMockGetShopExpectation{mock: mmGetShop.mock}
	}
	mmGetShop.defaultExpectation.results = &CommerceServiceClientMockGetShopResults{pp2, err}
	mmGetShop.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetShop.mock
}

// Set uses given function f to mock the CommerceServiceClient.GetShop method
func (mmGetShop *mCommerceServiceClientMockGetShop) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest]) (pp2 *connect.Response[v1.GetShopResponse], err error)) *CommerceServiceClientMock {
	if mmGetShop.defaultExpectation != nil {
		mmGetShop.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.GetShop method")
	}

	if len(mmGetShop.expectations) > 0 {
		mmGetShop.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.GetShop method")
	}

	mmGetShop.mock.funcGetShop = f
	mmGetShop.mock.funcGetShopOrigin = minimock.CallerInfo(1)
	return mmGetShop.mock
}

// When sets expectation for the CommerceServiceClient.GetShop which will trigger the result defined by the following
// Then helper
func (mmGetShop *mCommerceServiceClientMockGetShop) When(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest]) *CommerceServiceClientMockGetShopExpectation {
	if mmGetShop.mock.funcGetShop != nil {
		mmGetShop.mock.t.Fatalf("CommerceServiceClientMock.GetShop mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockGetShopExpectation{
		mock:               mmGetShop.mock,
		params:             &CommerceServiceClientMockGetShopParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockGetShopExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetShop.expectations = append(mmGetShop.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.GetShop return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockGetShopExpectation) Then(pp2 *connect.Response[v1.GetShopResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockGetShopResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.GetShop should be invoked
func (mmGetShop *mCommerceServiceClientMockGetShop) Times(n uint64) *mCommerceServiceClientMockGetShop {
	if n == 0 {
		mmGetShop.mock.t.Fatalf("Times of CommerceServiceClientMock.GetShop mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetShop.expectedInvocations, n)
	mmGetShop.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetShop
}

func (mmGetShop *mCommerceServiceClientMockGetShop) invocationsDone() bool {
	if len(mmGetShop.expectations) == 0 && mmGetShop.defaultExpectation == nil && mmGetShop.mock.funcGetShop == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetShop.mock.afterGetShopCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetShop.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetShop implements mm_commercev1connect.CommerceServiceClient
func (mmGetShop *CommerceServiceClientMock) GetShop(ctx context.Context, pp1 *connect.Request[v1.GetShopRequest]) (pp2 *connect.Response[v1.GetShopResponse], err error) {
	mm_atomic.AddUint64(&mmGetShop.beforeGetShopCounter, 1)
	defer mm_atomic.AddUint64(&mmGetShop.afterGetShopCounter, 1)

	mmGetShop.t.Helper()

	if mmGetShop.inspectFuncGetShop != nil {
		mmGetShop.inspectFuncGetShop(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockGetShopParams{ctx, pp1}

	// Record call args
	mmGetShop.GetShopMock.mutex.Lock()
	mmGetShop.GetShopMock.callArgs = append(mmGetShop.GetShopMock.callArgs, &mm_params)
	mmGetShop.GetShopMock.mutex.Unlock()

	for _, e := range mmGetShop.GetShopMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetShop.GetShopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetShop.GetShopMock.defaultExpectation.Counter, 1)
		mm_want := mmGetShop.GetShopMock.defaultExpectation.params
		mm_want_ptrs := mmGetShop.GetShopMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockGetShopParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetShop.t.Errorf("CommerceServiceClientMock.GetShop got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetShop.GetShopMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetShop.t.Errorf("CommerceServiceClientMock.GetShop got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetShop.GetShopMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetShop.t.Errorf("CommerceServiceClientMock.GetShop got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetShop.GetShopMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetShop.GetShopMock.defaultExpectation.results
		if mm_results == nil {
			mmGetShop.t.Fatal("No results are set for the CommerceServiceClientMock.GetShop")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetShop.funcGetShop != nil {
		return mmGetShop.funcGetShop(ctx, pp1)
	}
	mmGetShop.t.Fatalf("Unexpected call to CommerceServiceClientMock.GetShop. %v %v", ctx, pp1)
	return
}

// GetShopAfterCounter returns a count of finished CommerceServiceClientMock.GetShop invocations
func (mmGetShop *CommerceServiceClientMock) GetShopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetShop.afterGetShopCounter)
}

// GetShopBeforeCounter returns a count of CommerceServiceClientMock.GetShop invocations
func (mmGetShop *CommerceServiceClientMock) GetShopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetShop.beforeGetShopCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.GetShop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetShop *mCommerceServiceClientMockGetShop) Calls() []*CommerceServiceClientMockGetShopParams {
	mmGetShop.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockGetShopParams, len(mmGetShop.callArgs))
	copy(argCopy, mmGetShop.callArgs)

	mmGetShop.mutex.RUnlock()

	return argCopy
}

// MinimockGetShopDone returns true if the count of the GetShop invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockGetShopDone() bool {
	if m.GetShopMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetShopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetShopMock.invocationsDone()
}

// MinimockGetShopInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockGetShopInspect() {
	for _, e := range m.GetShopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetShop at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetShopCounter := mm_atomic.LoadUint64(&m.afterGetShopCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetShopMock.defaultExpectation != nil && afterGetShopCounter < 1 {
		if m.GetShopMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetShop at\n%s", m.GetShopMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.GetShop at\n%s with params: %#v", m.GetShopMock.defaultExpectation.expectationOrigins.origin, *m.GetShopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetShop != nil && afterGetShopCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.GetShop at\n%s", m.funcGetShopOrigin)
	}

	if !m.GetShopMock.invocationsDone() && afterGetShopCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.GetShop at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetShopMock.expectedInvocations), m.GetShopMock.expectedInvocationsOrigin, afterGetShopCounter)
	}
}

type mCommerceServiceClientMockListOrders struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockListOrdersExpectation
	expectations       []*CommerceServiceClientMockListOrdersExpectation

	callArgs []*CommerceServiceClientMockListOrdersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockListOrdersExpectation specifies expectation struct of the CommerceServiceClient.ListOrders
type CommerceServiceClientMockListOrdersExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockListOrdersParams
	paramPtrs          *CommerceServiceClientMockListOrdersParamPtrs
	expectationOrigins CommerceServiceClientMockListOrdersExpectationOrigins
	results            *CommerceServiceClientMockListOrdersResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockListOrdersParams contains parameters of the CommerceServiceClient.ListOrders
type CommerceServiceClientMockListOrdersParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListOrdersRequest]
}

// CommerceServiceClientMockListOrdersParamPtrs contains pointers to parameters of the CommerceServiceClient.ListOrders
type CommerceServiceClientMockListOrdersParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListOrdersRequest]
}

// CommerceServiceClientMockListOrdersResults contains results of the CommerceServiceClient.ListOrders
type CommerceServiceClientMockListOrdersResults struct {
	pp2 *connect.Response[v1.ListOrdersResponse]
	err error
}

// CommerceServiceClientMockListOrdersOrigins contains origins of expectations of the CommerceServiceClient.ListOrders
type CommerceServiceClientMockListOrdersExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListOrders *mCommerceServiceClientMockListOrders) Optional() *mCommerceServiceClientMockListOrders {
	mmListOrders.optional = true
	return mmListOrders
}

// Expect sets up expected params for CommerceServiceClient.ListOrders
func (mmListOrders *mCommerceServiceClientMockListOrders) Expect(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest]) *mCommerceServiceClientMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &CommerceServiceClientMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.paramPtrs != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by ExpectParams functions")
	}

	mmListOrders.defaultExpectation.params = &CommerceServiceClientMockListOrdersParams{ctx, pp1}
	mmListOrders.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.ListOrders
func (mmListOrders *mCommerceServiceClientMockListOrders) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &CommerceServiceClientMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &CommerceServiceClientMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.ctx = &ctx
	mmListOrders.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListOrders
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.ListOrders
func (mmListOrders *mCommerceServiceClientMockListOrders) ExpectPp1Param2(pp1 *connect.Request[v1.ListOrdersRequest]) *mCommerceServiceClientMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &CommerceServiceClientMockListOrdersExpectation{}
	}

	if mmListOrders.defaultExpectation.params != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Expect")
	}

	if mmListOrders.defaultExpectation.paramPtrs == nil {
		mmListOrders.defaultExpectation.paramPtrs = &CommerceServiceClientMockListOrdersParamPtrs{}
	}
	mmListOrders.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListOrders.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.ListOrders
func (mmListOrders *mCommerceServiceClientMockListOrders) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest])) *mCommerceServiceClientMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by CommerceServiceClient.ListOrders
func (mmListOrders *mCommerceServiceClientMockListOrders) Return(pp2 *connect.Response[v1.ListOrdersResponse], err error) *CommerceServiceClientMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &CommerceServiceClientMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &CommerceServiceClientMockListOrdersResults{pp2, err}
	mmListOrders.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// Set uses given function f to mock the CommerceServiceClient.ListOrders method
func (mmListOrders *mCommerceServiceClientMockListOrders) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest]) (pp2 *connect.Response[v1.ListOrdersResponse], err error)) *CommerceServiceClientMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	mmListOrders.mock.funcListOrdersOrigin = minimock.CallerInfo(1)
	return mmListOrders.mock
}

// When sets expectation for the CommerceServiceClient.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mCommerceServiceClientMockListOrders) When(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest]) *CommerceServiceClientMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("CommerceServiceClientMock.ListOrders mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockListOrdersExpectation{
		mock:               mmListOrders.mock,
		params:             &CommerceServiceClientMockListOrdersParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockListOrdersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.ListOrders return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockListOrdersExpectation) Then(pp2 *connect.Response[v1.ListOrdersResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockListOrdersResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.ListOrders should be invoked
func (mmListOrders *mCommerceServiceClientMockListOrders) Times(n uint64) *mCommerceServiceClientMockListOrders {
	if n == 0 {
		mmListOrders.mock.t.Fatalf("Times of CommerceServiceClientMock.ListOrders mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListOrders.expectedInvocations, n)
	mmListOrders.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListOrders
}

func (mmListOrders *mCommerceServiceClientMockListOrders) invocationsDone() bool {
	if len(mmListOrders.expectations) == 0 && mmListOrders.defaultExpectation == nil && mmListOrders.mock.funcListOrders == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListOrders.mock.afterListOrdersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListOrders.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListOrders implements mm_commercev1connect.CommerceServiceClient
func (mmListOrders *CommerceServiceClientMock) ListOrders(ctx context.Context, pp1 *connect.Request[v1.ListOrdersRequest]) (pp2 *connect.Response[v1.ListOrdersResponse], err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	mmListOrders.t.Helper()

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockListOrdersParams{ctx, pp1}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_want_ptrs := mmListOrders.ListOrdersMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockListOrdersParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListOrders.t.Errorf("CommerceServiceClientMock.ListOrders got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListOrders.t.Errorf("CommerceServiceClientMock.ListOrders got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("CommerceServiceClientMock.ListOrders got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListOrders.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the CommerceServiceClientMock.ListOrders")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx, pp1)
	}
	mmListOrders.t.Fatalf("Unexpected call to CommerceServiceClientMock.ListOrders. %v %v", ctx, pp1)
	return
}

// ListOrdersAfterCounter returns a count of finished CommerceServiceClientMock.ListOrders invocations
func (mmListOrders *CommerceServiceClientMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of CommerceServiceClientMock.ListOrders invocations
func (mmListOrders *CommerceServiceClientMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mCommerceServiceClientMockListOrders) Calls() []*CommerceServiceClientMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockListOrdersDone() bool {
	if m.ListOrdersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListOrdersMock.invocationsDone()
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.ListOrders at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListOrdersCounter := mm_atomic.LoadUint64(&m.afterListOrdersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && afterListOrdersCounter < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.ListOrders at\n%s", m.ListOrdersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.ListOrders at\n%s with params: %#v", m.ListOrdersMock.defaultExpectation.expectationOrigins.origin, *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && afterListOrdersCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.ListOrders at\n%s", m.funcListOrdersOrigin)
	}

	if !m.ListOrdersMock.invocationsDone() && afterListOrdersCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.ListOrders at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListOrdersMock.expectedInvocations), m.ListOrdersMock.expectedInvocationsOrigin, afterListOrdersCounter)
	}
}

type mCommerceServiceClientMockListProducts struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockListProductsExpectation
	expectations       []*CommerceServiceClientMockListProductsExpectation

	callArgs []*CommerceServiceClientMockListProductsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockListProductsExpectation specifies expectation struct of the CommerceServiceClient.ListProducts
type CommerceServiceClientMockListProductsExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockListProductsParams
	paramPtrs          *CommerceServiceClientMockListProductsParamPtrs
	expectationOrigins CommerceServiceClientMockListProductsExpectationOrigins
	results            *CommerceServiceClientMockListProductsResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockListProductsParams contains parameters of the CommerceServiceClient.ListProducts
type CommerceServiceClientMockListProductsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListProductsRequest]
}

// CommerceServiceClientMockListProductsParamPtrs contains pointers to parameters of the CommerceServiceClient.ListProducts
type CommerceServiceClientMockListProductsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListProductsRequest]
}

// CommerceServiceClientMockListProductsResults contains results of the CommerceServiceClient.ListProducts
type CommerceServiceClientMockListProductsResults struct {
	pp2 *connect.Response[v1.ListProductsResponse]
	err error
}

// CommerceServiceClientMockListProductsOrigins contains origins of expectations of the CommerceServiceClient.ListProducts
type CommerceServiceClientMockListProductsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListProducts *mCommerceServiceClientMockListProducts) Optional() *mCommerceServiceClientMockListProducts {
	mmListProducts.optional = true
	return mmListProducts
}

// Expect sets up expected params for CommerceServiceClient.ListProducts
func (mmListProducts *mCommerceServiceClientMockListProducts) Expect(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest]) *mCommerceServiceClientMockListProducts {
	if mmListProducts.mock.funcListProducts != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Set")
	}

	if mmListProducts.defaultExpectation == nil {
		mmListProducts.defaultExpectation = &CommerceServiceClientMockListProductsExpectation{}
	}

	if mmListProducts.defaultExpectation.paramPtrs != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by ExpectParams functions")
	}

	mmListProducts.defaultExpectation.params = &CommerceServiceClientMockListProductsParams{ctx, pp1}
	mmListProducts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListProducts.expectations {
		if minimock.Equal(e.params, mmListProducts.defaultExpectation.params) {
			mmListProducts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListProducts.defaultExpectation.params)
		}
	}

	return mmListProducts
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.ListProducts
func (mmListProducts *mCommerceServiceClientMockListProducts) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockListProducts {
	if mmListProducts.mock.funcListProducts != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Set")
	}

	if mmListProducts.defaultExpectation == nil {
		mmListProducts.defaultExpectation = &CommerceServiceClientMockListProductsExpectation{}
	}

	if mmListProducts.defaultExpectation.params != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Expect")
	}

	if mmListProducts.defaultExpectation.paramPtrs == nil {
		mmListProducts.defaultExpectation.paramPtrs = &CommerceServiceClientMockListProductsParamPtrs{}
	}
	mmListProducts.defaultExpectation.paramPtrs.ctx = &ctx
	mmListProducts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListProducts
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.ListProducts
func (mmListProducts *mCommerceServiceClientMockListProducts) ExpectPp1Param2(pp1 *connect.Request[v1.ListProductsRequest]) *mCommerceServiceClientMockListProducts {
	if mmListProducts.mock.funcListProducts != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Set")
	}

	if mmListProducts.defaultExpectation == nil {
		mmListProducts.defaultExpectation = &CommerceServiceClientMockListProductsExpectation{}
	}

	if mmListProducts.defaultExpectation.params != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Expect")
	}

	if mmListProducts.defaultExpectation.paramPtrs == nil {
		mmListProducts.defaultExpectation.paramPtrs = &CommerceServiceClientMockListProductsParamPtrs{}
	}
	mmListProducts.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListProducts.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListProducts
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.ListProducts
func (mmListProducts *mCommerceServiceClientMockListProducts) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest])) *mCommerceServiceClientMockListProducts {
	if mmListProducts.mock.inspectFuncListProducts != nil {
		mmListProducts.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.ListProducts")
	}

	mmListProducts.mock.inspectFuncListProducts = f

	return mmListProducts
}

// Return sets up results that will be returned by CommerceServiceClient.ListProducts
func (mmListProducts *mCommerceServiceClientMockListProducts) Return(pp2 *connect.Response[v1.ListProductsResponse], err error) *CommerceServiceClientMock {
	if mmListProducts.mock.funcListProducts != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Set")
	}

	if mmListProducts.defaultExpectation == nil {
		mmListProducts.defaultExpectation = &CommerceServiceClientMockListProductsExpectation{mock: mmListProducts.mock}
	}
	mmListProducts.defaultExpectation.results = &CommerceServiceClientMockListProductsResults{pp2, err}
	mmListProducts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListProducts.mock
}

// Set uses given function f to mock the CommerceServiceClient.ListProducts method
func (mmListProducts *mCommerceServiceClientMockListProducts) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest]) (pp2 *connect.Response[v1.ListProductsResponse], err error)) *CommerceServiceClientMock {
	if mmListProducts.defaultExpectation != nil {
		mmListProducts.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.ListProducts method")
	}

	if len(mmListProducts.expectations) > 0 {
		mmListProducts.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.ListProducts method")
	}

	mmListProducts.mock.funcListProducts = f
	mmListProducts.mock.funcListProductsOrigin = minimock.CallerInfo(1)
	return mmListProducts.mock
}

// When sets expectation for the CommerceServiceClient.ListProducts which will trigger the result defined by the following
// Then helper
func (mmListProducts *mCommerceServiceClientMockListProducts) When(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest]) *CommerceServiceClientMockListProductsExpectation {
	if mmListProducts.mock.funcListProducts != nil {
		mmListProducts.mock.t.Fatalf("CommerceServiceClientMock.ListProducts mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockListProductsExpectation{
		mock:               mmListProducts.mock,
		params:             &CommerceServiceClientMockListProductsParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockListProductsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListProducts.expectations = append(mmListProducts.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.ListProducts return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockListProductsExpectation) Then(pp2 *connect.Response[v1.ListProductsResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockListProductsResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.ListProducts should be invoked
func (mmListProducts *mCommerceServiceClientMockListProducts) Times(n uint64) *mCommerceServiceClientMockListProducts {
	if n == 0 {
		mmListProducts.mock.t.Fatalf("Times of CommerceServiceClientMock.ListProducts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListProducts.expectedInvocations, n)
	mmListProducts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListProducts
}

func (mmListProducts *mCommerceServiceClientMockListProducts) invocationsDone() bool {
	if len(mmListProducts.expectations) == 0 && mmListProducts.defaultExpectation == nil && mmListProducts.mock.funcListProducts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListProducts.mock.afterListProductsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListProducts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListProducts implements mm_commercev1connect.CommerceServiceClient
func (mmListProducts *CommerceServiceClientMock) ListProducts(ctx context.Context, pp1 *connect.Request[v1.ListProductsRequest]) (pp2 *connect.Response[v1.ListProductsResponse], err error) {
	mm_atomic.AddUint64(&mmListProducts.beforeListProductsCounter, 1)
	defer mm_atomic.AddUint64(&mmListProducts.afterListProductsCounter, 1)

	mmListProducts.t.Helper()

	if mmListProducts.inspectFuncListProducts != nil {
		mmListProducts.inspectFuncListProducts(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockListProductsParams{ctx, pp1}

	// Record call args
	mmListProducts.ListProductsMock.mutex.Lock()
	mmListProducts.ListProductsMock.callArgs = append(mmListProducts.ListProductsMock.callArgs, &mm_params)
	mmListProducts.ListProductsMock.mutex.Unlock()

	for _, e := range mmListProducts.ListProductsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListProducts.ListProductsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListProducts.ListProductsMock.defaultExpectation.Counter, 1)
		mm_want := mmListProducts.ListProductsMock.defaultExpectation.params
		mm_want_ptrs := mmListProducts.ListProductsMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockListProductsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListProducts.t.Errorf("CommerceServiceClientMock.ListProducts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListProducts.ListProductsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListProducts.t.Errorf("CommerceServiceClientMock.ListProducts got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListProducts.ListProductsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListProducts.t.Errorf("CommerceServiceClientMock.ListProducts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListProducts.ListProductsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListProducts.ListProductsMock.defaultExpectation.results
		if mm_results == nil {
			mmListProducts.t.Fatal("No results are set for the CommerceServiceClientMock.ListProducts")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListProducts.funcListProducts != nil {
		return mmListProducts.funcListProducts(ctx, pp1)
	}
	mmListProducts.t.Fatalf("Unexpected call to CommerceServiceClientMock.ListProducts. %v %v", ctx, pp1)
	return
}

// ListProductsAfterCounter returns a count of finished CommerceServiceClientMock.ListProducts invocations
func (mmListProducts *CommerceServiceClientMock) ListProductsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListProducts.afterListProductsCounter)
}

// ListProductsBeforeCounter returns a count of CommerceServiceClientMock.ListProducts invocations
func (mmListProducts *CommerceServiceClientMock) ListProductsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListProducts.beforeListProductsCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.ListProducts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListProducts *mCommerceServiceClientMockListProducts) Calls() []*CommerceServiceClientMockListProductsParams {
	mmListProducts.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockListProductsParams, len(mmListProducts.callArgs))
	copy(argCopy, mmListProducts.callArgs)

	mmListProducts.mutex.RUnlock()

	return argCopy
}

// MinimockListProductsDone returns true if the count of the ListProducts invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockListProductsDone() bool {
	if m.ListProductsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListProductsMock.invocationsDone()
}

// MinimockListProductsInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockListProductsInspect() {
	for _, e := range m.ListProductsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.ListProducts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListProductsCounter := mm_atomic.LoadUint64(&m.afterListProductsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListProductsMock.defaultExpectation != nil && afterListProductsCounter < 1 {
		if m.ListProductsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.ListProducts at\n%s", m.ListProductsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.ListProducts at\n%s with params: %#v", m.ListProductsMock.defaultExpectation.expectationOrigins.origin, *m.ListProductsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListProducts != nil && afterListProductsCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.ListProducts at\n%s", m.funcListProductsOrigin)
	}

	if !m.ListProductsMock.invocationsDone() && afterListProductsCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.ListProducts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListProductsMock.expectedInvocations), m.ListProductsMock.expectedInvocationsOrigin, afterListProductsCounter)
	}
}

type mCommerceServiceClientMockRemoveCartLine struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockRemoveCartLineExpectation
	expectations       []*CommerceServiceClientMockRemoveCartLineExpectation

	callArgs []*CommerceServiceClientMockRemoveCartLineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockRemoveCartLineExpectation specifies expectation struct of the CommerceServiceClient.RemoveCartLine
type CommerceServiceClientMockRemoveCartLineExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockRemoveCartLineParams
	paramPtrs          *CommerceServiceClientMockRemoveCartLineParamPtrs
	expectationOrigins CommerceServiceClientMockRemoveCartLineExpectationOrigins
	results            *CommerceServiceClientMockRemoveCartLineResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockRemoveCartLineParams contains parameters of the CommerceServiceClient.RemoveCartLine
type CommerceServiceClientMockRemoveCartLineParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveCartLineRequest]
}

// CommerceServiceClientMockRemoveCartLineParamPtrs contains pointers to parameters of the CommerceServiceClient.RemoveCartLine
type CommerceServiceClientMockRemoveCartLineParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveCartLineRequest]
}

// CommerceServiceClientMockRemoveCartLineResults contains results of the CommerceServiceClient.RemoveCartLine
type CommerceServiceClientMockRemoveCartLineResults struct {
	pp2 *connect.Response[v1.RemoveCartLineResponse]
	err error
}

// CommerceServiceClientMockRemoveCartLineOrigins contains origins of expectations of the CommerceServiceClient.RemoveCartLine
type CommerceServiceClientMockRemoveCartLineExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Optional() *mCommerceServiceClientMockRemoveCartLine {
	mmRemoveCartLine.optional = true
	return mmRemoveCartLine
}

// Expect sets up expected params for CommerceServiceClient.RemoveCartLine
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest]) *mCommerceServiceClientMockRemoveCartLine {
	if mmRemoveCartLine.mock.funcRemoveCartLine != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Set")
	}

	if mmRemoveCartLine.defaultExpectation == nil {
		mmRemoveCartLine.defaultExpectation = &CommerceServiceClientMockRemoveCartLineExpectation{}
	}

	if mmRemoveCartLine.defaultExpectation.paramPtrs != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by ExpectParams functions")
	}

	mmRemoveCartLine.defaultExpectation.params = &CommerceServiceClientMockRemoveCartLineParams{ctx, pp1}
	mmRemoveCartLine.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveCartLine.expectations {
		if minimock.Equal(e.params, mmRemoveCartLine.defaultExpectation.params) {
			mmRemoveCartLine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveCartLine.defaultExpectation.params)
		}
	}

	return mmRemoveCartLine
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.RemoveCartLine
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockRemoveCartLine {
	if mmRemoveCartLine.mock.funcRemoveCartLine != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Set")
	}

	if mmRemoveCartLine.defaultExpectation == nil {
		mmRemoveCartLine.defaultExpectation = &CommerceServiceClientMockRemoveCartLineExpectation{}
	}

	if mmRemoveCartLine.defaultExpectation.params != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Expect")
	}

	if mmRemoveCartLine.defaultExpectation.paramPtrs == nil {
		mmRemoveCartLine.defaultExpectation.paramPtrs = &CommerceServiceClientMockRemoveCartLineParamPtrs{}
	}
	mmRemoveCartLine.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveCartLine.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveCartLine
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.RemoveCartLine
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveCartLineRequest]) *mCommerceServiceClientMockRemoveCartLine {
	if mmRemoveCartLine.mock.funcRemoveCartLine != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Set")
	}

	if mmRemoveCartLine.defaultExpectation == nil {
		mmRemoveCartLine.defaultExpectation = &CommerceServiceClientMockRemoveCartLineExpectation{}
	}

	if mmRemoveCartLine.defaultExpectation.params != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Expect")
	}

	if mmRemoveCartLine.defaultExpectation.paramPtrs == nil {
		mmRemoveCartLine.defaultExpectation.paramPtrs = &CommerceServiceClientMockRemoveCartLineParamPtrs{}
	}
	mmRemoveCartLine.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveCartLine.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveCartLine
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.RemoveCartLine
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest])) *mCommerceServiceClientMockRemoveCartLine {
	if mmRemoveCartLine.mock.inspectFuncRemoveCartLine != nil {
		mmRemoveCartLine.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.RemoveCartLine")
	}

	mmRemoveCartLine.mock.inspectFuncRemoveCartLine = f

	return mmRemoveCartLine
}

// Return sets up results that will be returned by CommerceServiceClient.RemoveCartLine
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Return(pp2 *connect.Response[v1.RemoveCartLineResponse], err error) *CommerceServiceClientMock {
	if mmRemoveCartLine.mock.funcRemoveCartLine != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Set")
	}

	if mmRemoveCartLine.defaultExpectation == nil {
		mmRemoveCartLine.defaultExpectation = &CommerceServiceClientMockRemoveCartLineExpectation{mock: mmRemoveCartLine.mock}
	}
	mmRemoveCartLine.defaultExpectation.results = &CommerceServiceClientMockRemoveCartLineResults{pp2, err}
	mmRemoveCartLine.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveCartLine.mock
}

// Set uses given function f to mock the CommerceServiceClient.RemoveCartLine method
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest]) (pp2 *connect.Response[v1.RemoveCartLineResponse], err error)) *CommerceServiceClientMock {
	if mmRemoveCartLine.defaultExpectation != nil {
		mmRemoveCartLine.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.RemoveCartLine method")
	}

	if len(mmRemoveCartLine.expectations) > 0 {
		mmRemoveCartLine.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.RemoveCartLine method")
	}

	mmRemoveCartLine.mock.funcRemoveCartLine = f
	mmRemoveCartLine.mock.funcRemoveCartLineOrigin = minimock.CallerInfo(1)
	return mmRemoveCartLine.mock
}

// When sets expectation for the CommerceServiceClient.RemoveCartLine which will trigger the result defined by the following
// Then helper
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) When(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest]) *CommerceServiceClientMockRemoveCartLineExpectation {
	if mmRemoveCartLine.mock.funcRemoveCartLine != nil {
		mmRemoveCartLine.mock.t.Fatalf("CommerceServiceClientMock.RemoveCartLine mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockRemoveCartLineExpectation{
		mock:               mmRemoveCartLine.mock,
		params:             &CommerceServiceClientMockRemoveCartLineParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockRemoveCartLineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveCartLine.expectations = append(mmRemoveCartLine.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.RemoveCartLine return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockRemoveCartLineExpectation) Then(pp2 *connect.Response[v1.RemoveCartLineResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockRemoveCartLineResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.RemoveCartLine should be invoked
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Times(n uint64) *mCommerceServiceClientMockRemoveCartLine {
	if n == 0 {
		mmRemoveCartLine.mock.t.Fatalf("Times of CommerceServiceClientMock.RemoveCartLine mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveCartLine.expectedInvocations, n)
	mmRemoveCartLine.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveCartLine
}

func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) invocationsDone() bool {
	if len(mmRemoveCartLine.expectations) == 0 && mmRemoveCartLine.defaultExpectation == nil && mmRemoveCartLine.mock.funcRemoveCartLine == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveCartLine.mock.afterRemoveCartLineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveCartLine.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveCartLine implements mm_commercev1connect.CommerceServiceClient
func (mmRemoveCartLine *CommerceServiceClientMock) RemoveCartLine(ctx context.Context, pp1 *connect.Request[v1.RemoveCartLineRequest]) (pp2 *connect.Response[v1.RemoveCartLineResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveCartLine.beforeRemoveCartLineCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveCartLine.afterRemoveCartLineCounter, 1)

	mmRemoveCartLine.t.Helper()

	if mmRemoveCartLine.inspectFuncRemoveCartLine != nil {
		mmRemoveCartLine.inspectFuncRemoveCartLine(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockRemoveCartLineParams{ctx, pp1}

	// Record call args
	mmRemoveCartLine.RemoveCartLineMock.mutex.Lock()
	mmRemoveCartLine.RemoveCartLineMock.callArgs = append(mmRemoveCartLine.RemoveCartLineMock.callArgs, &mm_params)
	mmRemoveCartLine.RemoveCartLineMock.mutex.Unlock()

	for _, e := range mmRemoveCartLine.RemoveCartLineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveCartLine.RemoveCartLineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockRemoveCartLineParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveCartLine.t.Errorf("CommerceServiceClientMock.RemoveCartLine got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveCartLine.t.Errorf("CommerceServiceClientMock.RemoveCartLine got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveCartLine.t.Errorf("CommerceServiceClientMock.RemoveCartLine got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveCartLine.RemoveCartLineMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveCartLine.t.Fatal("No results are set for the CommerceServiceClientMock.RemoveCartLine")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveCartLine.funcRemoveCartLine != nil {
		return mmRemoveCartLine.funcRemoveCartLine(ctx, pp1)
	}
	mmRemoveCartLine.t.Fatalf("Unexpected call to CommerceServiceClientMock.RemoveCartLine. %v %v", ctx, pp1)
	return
}

// RemoveCartLineAfterCounter returns a count of finished CommerceServiceClientMock.RemoveCartLine invocations
func (mmRemoveCartLine *CommerceServiceClientMock) RemoveCartLineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCartLine.afterRemoveCartLineCounter)
}

// RemoveCartLineBeforeCounter returns a count of CommerceServiceClientMock.RemoveCartLine invocations
func (mmRemoveCartLine *CommerceServiceClientMock) RemoveCartLineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveCartLine.beforeRemoveCartLineCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.RemoveCartLine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveCartLine *mCommerceServiceClientMockRemoveCartLine) Calls() []*CommerceServiceClientMockRemoveCartLineParams {
	mmRemoveCartLine.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockRemoveCartLineParams, len(mmRemoveCartLine.callArgs))
	copy(argCopy, mmRemoveCartLine.callArgs)

	mmRemoveCartLine.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveCartLineDone returns true if the count of the RemoveCartLine invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockRemoveCartLineDone() bool {
	if m.RemoveCartLineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveCartLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveCartLineMock.invocationsDone()
}

// MinimockRemoveCartLineInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockRemoveCartLineInspect() {
	for _, e := range m.RemoveCartLineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.RemoveCartLine at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCartLineCounter := mm_atomic.LoadUint64(&m.afterRemoveCartLineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveCartLineMock.defaultExpectation != nil && afterRemoveCartLineCounter < 1 {
		if m.RemoveCartLineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.RemoveCartLine at\n%s", m.RemoveCartLineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.RemoveCartLine at\n%s with params: %#v", m.RemoveCartLineMock.defaultExpectation.expectationOrigins.origin, *m.RemoveCartLineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveCartLine != nil && afterRemoveCartLineCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.RemoveCartLine at\n%s", m.funcRemoveCartLineOrigin)
	}

	if !m.RemoveCartLineMock.invocationsDone() && afterRemoveCartLineCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.RemoveCartLine at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveCartLineMock.expectedInvocations), m.RemoveCartLineMock.expectedInvocationsOrigin, afterRemoveCartLineCounter)
	}
}

type mCommerceServiceClientMockUpdateFulfilment struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockUpdateFulfilmentExpectation
	expectations       []*CommerceServiceClientMockUpdateFulfilmentExpectation

	callArgs []*CommerceServiceClientMockUpdateFulfilmentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockUpdateFulfilmentExpectation specifies expectation struct of the CommerceServiceClient.UpdateFulfilment
type CommerceServiceClientMockUpdateFulfilmentExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockUpdateFulfilmentParams
	paramPtrs          *CommerceServiceClientMockUpdateFulfilmentParamPtrs
	expectationOrigins CommerceServiceClientMockUpdateFulfilmentExpectationOrigins
	results            *CommerceServiceClientMockUpdateFulfilmentResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockUpdateFulfilmentParams contains parameters of the CommerceServiceClient.UpdateFulfilment
type CommerceServiceClientMockUpdateFulfilmentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateFulfilmentRequest]
}

// CommerceServiceClientMockUpdateFulfilmentParamPtrs contains pointers to parameters of the CommerceServiceClient.UpdateFulfilment
type CommerceServiceClientMockUpdateFulfilmentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateFulfilmentRequest]
}

// CommerceServiceClientMockUpdateFulfilmentResults contains results of the CommerceServiceClient.UpdateFulfilment
type CommerceServiceClientMockUpdateFulfilmentResults struct {
	pp2 *connect.Response[v1.UpdateFulfilmentResponse]
	err error
}

// CommerceServiceClientMockUpdateFulfilmentOrigins contains origins of expectations of the CommerceServiceClient.UpdateFulfilment
type CommerceServiceClientMockUpdateFulfilmentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Optional() *mCommerceServiceClientMockUpdateFulfilment {
	mmUpdateFulfilment.optional = true
	return mmUpdateFulfilment
}

// Expect sets up expected params for CommerceServiceClient.UpdateFulfilment
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest]) *mCommerceServiceClientMockUpdateFulfilment {
	if mmUpdateFulfilment.mock.funcUpdateFulfilment != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Set")
	}

	if mmUpdateFulfilment.defaultExpectation == nil {
		mmUpdateFulfilment.defaultExpectation = &CommerceServiceClientMockUpdateFulfilmentExpectation{}
	}

	if mmUpdateFulfilment.defaultExpectation.paramPtrs != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by ExpectParams functions")
	}

	mmUpdateFulfilment.defaultExpectation.params = &CommerceServiceClientMockUpdateFulfilmentParams{ctx, pp1}
	mmUpdateFulfilment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateFulfilment.expectations {
		if minimock.Equal(e.params, mmUpdateFulfilment.defaultExpectation.params) {
			mmUpdateFulfilment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateFulfilment.defaultExpectation.params)
		}
	}

	return mmUpdateFulfilment
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.UpdateFulfilment
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockUpdateFulfilment {
	if mmUpdateFulfilment.mock.funcUpdateFulfilment != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Set")
	}

	if mmUpdateFulfilment.defaultExpectation == nil {
		mmUpdateFulfilment.defaultExpectation = &CommerceServiceClientMockUpdateFulfilmentExpectation{}
	}

	if mmUpdateFulfilment.defaultExpectation.params != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Expect")
	}

	if mmUpdateFulfilment.defaultExpectation.paramPtrs == nil {
		mmUpdateFulfilment.defaultExpectation.paramPtrs = &CommerceServiceClientMockUpdateFulfilmentParamPtrs{}
	}
	mmUpdateFulfilment.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateFulfilment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateFulfilment
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.UpdateFulfilment
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateFulfilmentRequest]) *mCommerceServiceClientMockUpdateFulfilment {
	if mmUpdateFulfilment.mock.funcUpdateFulfilment != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Set")
	}

	if mmUpdateFulfilment.defaultExpectation == nil {
		mmUpdateFulfilment.defaultExpectation = &CommerceServiceClientMockUpdateFulfilmentExpectation{}
	}

	if mmUpdateFulfilment.defaultExpectation.params != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Expect")
	}

	if mmUpdateFulfilment.defaultExpectation.paramPtrs == nil {
		mmUpdateFulfilment.defaultExpectation.paramPtrs = &CommerceServiceClientMockUpdateFulfilmentParamPtrs{}
	}
	mmUpdateFulfilment.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateFulfilment.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateFulfilment
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.UpdateFulfilment
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest])) *mCommerceServiceClientMockUpdateFulfilment {
	if mmUpdateFulfilment.mock.inspectFuncUpdateFulfilment != nil {
		mmUpdateFulfilment.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.UpdateFulfilment")
	}

	mmUpdateFulfilment.mock.inspectFuncUpdateFulfilment = f

	return mmUpdateFulfilment
}

// Return sets up results that will be returned by CommerceServiceClient.UpdateFulfilment
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Return(pp2 *connect.Response[v1.UpdateFulfilmentResponse], err error) *CommerceServiceClientMock {
	if mmUpdateFulfilment.mock.funcUpdateFulfilment != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Set")
	}

	if mmUpdateFulfilment.defaultExpectation == nil {
		mmUpdateFulfilment.defaultExpectation = &CommerceServiceClientMockUpdateFulfilmentExpectation{mock: mmUpdateFulfilment.mock}
	}
	mmUpdateFulfilment.defaultExpectation.results = &CommerceServiceClientMockUpdateFulfilmentResults{pp2, err}
	mmUpdateFulfilment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateFulfilment.mock
}

// Set uses given function f to mock the CommerceServiceClient.UpdateFulfilment method
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest]) (pp2 *connect.Response[v1.UpdateFulfilmentResponse], err error)) *CommerceServiceClientMock {
	if mmUpdateFulfilment.defaultExpectation != nil {
		mmUpdateFulfilment.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.UpdateFulfilment method")
	}

	if len(mmUpdateFulfilment.expectations) > 0 {
		mmUpdateFulfilment.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.UpdateFulfilment method")
	}

	mmUpdateFulfilment.mock.funcUpdateFulfilment = f
	mmUpdateFulfilment.mock.funcUpdateFulfilmentOrigin = minimock.CallerInfo(1)
	return mmUpdateFulfilment.mock
}

// When sets expectation for the CommerceServiceClient.UpdateFulfilment which will trigger the result defined by the following
// Then helper
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) When(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest]) *CommerceServiceClientMockUpdateFulfilmentExpectation {
	if mmUpdateFulfilment.mock.funcUpdateFulfilment != nil {
		mmUpdateFulfilment.mock.t.Fatalf("CommerceServiceClientMock.UpdateFulfilment mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockUpdateFulfilmentExpectation{
		mock:               mmUpdateFulfilment.mock,
		params:             &CommerceServiceClientMockUpdateFulfilmentParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockUpdateFulfilmentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateFulfilment.expectations = append(mmUpdateFulfilment.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.UpdateFulfilment return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockUpdateFulfilmentExpectation) Then(pp2 *connect.Response[v1.UpdateFulfilmentResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockUpdateFulfilmentResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.UpdateFulfilment should be invoked
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Times(n uint64) *mCommerceServiceClientMockUpdateFulfilment {
	if n == 0 {
		mmUpdateFulfilment.mock.t.Fatalf("Times of CommerceServiceClientMock.UpdateFulfilment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateFulfilment.expectedInvocations, n)
	mmUpdateFulfilment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateFulfilment
}

func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) invocationsDone() bool {
	if len(mmUpdateFulfilment.expectations) == 0 && mmUpdateFulfilment.defaultExpectation == nil && mmUpdateFulfilment.mock.funcUpdateFulfilment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateFulfilment.mock.afterUpdateFulfilmentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateFulfilment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateFulfilment implements mm_commercev1connect.CommerceServiceClient
func (mmUpdateFulfilment *CommerceServiceClientMock) UpdateFulfilment(ctx context.Context, pp1 *connect.Request[v1.UpdateFulfilmentRequest]) (pp2 *connect.Response[v1.UpdateFulfilmentResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateFulfilment.beforeUpdateFulfilmentCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateFulfilment.afterUpdateFulfilmentCounter, 1)

	mmUpdateFulfilment.t.Helper()

	if mmUpdateFulfilment.inspectFuncUpdateFulfilment != nil {
		mmUpdateFulfilment.inspectFuncUpdateFulfilment(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockUpdateFulfilmentParams{ctx, pp1}

	// Record call args
	mmUpdateFulfilment.UpdateFulfilmentMock.mutex.Lock()
	mmUpdateFulfilment.UpdateFulfilmentMock.callArgs = append(mmUpdateFulfilment.UpdateFulfilmentMock.callArgs, &mm_params)
	mmUpdateFulfilment.UpdateFulfilmentMock.mutex.Unlock()

	for _, e := range mmUpdateFulfilment.UpdateFulfilmentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockUpdateFulfilmentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateFulfilment.t.Errorf("CommerceServiceClientMock.UpdateFulfilment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateFulfilment.t.Errorf("CommerceServiceClientMock.UpdateFulfilment got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateFulfilment.t.Errorf("CommerceServiceClientMock.UpdateFulfilment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateFulfilment.UpdateFulfilmentMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateFulfilment.t.Fatal("No results are set for the CommerceServiceClientMock.UpdateFulfilment")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateFulfilment.funcUpdateFulfilment != nil {
		return mmUpdateFulfilment.funcUpdateFulfilment(ctx, pp1)
	}
	mmUpdateFulfilment.t.Fatalf("Unexpected call to CommerceServiceClientMock.UpdateFulfilment. %v %v", ctx, pp1)
	return
}

// UpdateFulfilmentAfterCounter returns a count of finished CommerceServiceClientMock.UpdateFulfilment invocations
func (mmUpdateFulfilment *CommerceServiceClientMock) UpdateFulfilmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateFulfilment.afterUpdateFulfilmentCounter)
}

// UpdateFulfilmentBeforeCounter returns a count of CommerceServiceClientMock.UpdateFulfilment invocations
func (mmUpdateFulfilment *CommerceServiceClientMock) UpdateFulfilmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateFulfilment.beforeUpdateFulfilmentCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.UpdateFulfilment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateFulfilment *mCommerceServiceClientMockUpdateFulfilment) Calls() []*CommerceServiceClientMockUpdateFulfilmentParams {
	mmUpdateFulfilment.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockUpdateFulfilmentParams, len(mmUpdateFulfilment.callArgs))
	copy(argCopy, mmUpdateFulfilment.callArgs)

	mmUpdateFulfilment.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateFulfilmentDone returns true if the count of the UpdateFulfilment invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockUpdateFulfilmentDone() bool {
	if m.UpdateFulfilmentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateFulfilmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateFulfilmentMock.invocationsDone()
}

// MinimockUpdateFulfilmentInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockUpdateFulfilmentInspect() {
	for _, e := range m.UpdateFulfilmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateFulfilment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateFulfilmentCounter := mm_atomic.LoadUint64(&m.afterUpdateFulfilmentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateFulfilmentMock.defaultExpectation != nil && afterUpdateFulfilmentCounter < 1 {
		if m.UpdateFulfilmentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateFulfilment at\n%s", m.UpdateFulfilmentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateFulfilment at\n%s with params: %#v", m.UpdateFulfilmentMock.defaultExpectation.expectationOrigins.origin, *m.UpdateFulfilmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateFulfilment != nil && afterUpdateFulfilmentCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateFulfilment at\n%s", m.funcUpdateFulfilmentOrigin)
	}

	if !m.UpdateFulfilmentMock.invocationsDone() && afterUpdateFulfilmentCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.UpdateFulfilment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateFulfilmentMock.expectedInvocations), m.UpdateFulfilmentMock.expectedInvocationsOrigin, afterUpdateFulfilmentCounter)
	}
}

type mCommerceServiceClientMockUpdateProductVariant struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockUpdateProductVariantExpectation
	expectations       []*CommerceServiceClientMockUpdateProductVariantExpectation

	callArgs []*CommerceServiceClientMockUpdateProductVariantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockUpdateProductVariantExpectation specifies expectation struct of the CommerceServiceClient.UpdateProductVariant
type CommerceServiceClientMockUpdateProductVariantExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockUpdateProductVariantParams
	paramPtrs          *CommerceServiceClientMockUpdateProductVariantParamPtrs
	expectationOrigins CommerceServiceClientMockUpdateProductVariantExpectationOrigins
	results            *CommerceServiceClientMockUpdateProductVariantResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockUpdateProductVariantParams contains parameters of the CommerceServiceClient.UpdateProductVariant
type CommerceServiceClientMockUpdateProductVariantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateProductVariantRequest]
}

// CommerceServiceClientMockUpdateProductVariantParamPtrs contains pointers to parameters of the CommerceServiceClient.UpdateProductVariant
type CommerceServiceClientMockUpdateProductVariantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateProductVariantRequest]
}

// CommerceServiceClientMockUpdateProductVariantResults contains results of the CommerceServiceClient.UpdateProductVariant
type CommerceServiceClientMockUpdateProductVariantResults struct {
	pp2 *connect.Response[v1.UpdateProductVariantResponse]
	err error
}

// CommerceServiceClientMockUpdateProductVariantOrigins contains origins of expectations of the CommerceServiceClient.UpdateProductVariant
type CommerceServiceClientMockUpdateProductVariantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Optional() *mCommerceServiceClientMockUpdateProductVariant {
	mmUpdateProductVariant.optional = true
	return mmUpdateProductVariant
}

// Expect sets up expected params for CommerceServiceClient.UpdateProductVariant
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest]) *mCommerceServiceClientMockUpdateProductVariant {
	if mmUpdateProductVariant.mock.funcUpdateProductVariant != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Set")
	}

	if mmUpdateProductVariant.defaultExpectation == nil {
		mmUpdateProductVariant.defaultExpectation = &CommerceServiceClientMockUpdateProductVariantExpectation{}
	}

	if mmUpdateProductVariant.defaultExpectation.paramPtrs != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by ExpectParams functions")
	}

	mmUpdateProductVariant.defaultExpectation.params = &CommerceServiceClientMockUpdateProductVariantParams{ctx, pp1}
	mmUpdateProductVariant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateProductVariant.expectations {
		if minimock.Equal(e.params, mmUpdateProductVariant.defaultExpectation.params) {
			mmUpdateProductVariant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateProductVariant.defaultExpectation.params)
		}
	}

	return mmUpdateProductVariant
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.UpdateProductVariant
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockUpdateProductVariant {
	if mmUpdateProductVariant.mock.funcUpdateProductVariant != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Set")
	}

	if mmUpdateProductVariant.defaultExpectation == nil {
		mmUpdateProductVariant.defaultExpectation = &CommerceServiceClientMockUpdateProductVariantExpectation{}
	}

	if mmUpdateProductVariant.defaultExpectation.params != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Expect")
	}

	if mmUpdateProductVariant.defaultExpectation.paramPtrs == nil {
		mmUpdateProductVariant.defaultExpectation.paramPtrs = &CommerceServiceClientMockUpdateProductVariantParamPtrs{}
	}
	mmUpdateProductVariant.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateProductVariant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateProductVariant
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.UpdateProductVariant
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateProductVariantRequest]) *mCommerceServiceClientMockUpdateProductVariant {
	if mmUpdateProductVariant.mock.funcUpdateProductVariant != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Set")
	}

	if mmUpdateProductVariant.defaultExpectation == nil {
		mmUpdateProductVariant.defaultExpectation = &CommerceServiceClientMockUpdateProductVariantExpectation{}
	}

	if mmUpdateProductVariant.defaultExpectation.params != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Expect")
	}

	if mmUpdateProductVariant.defaultExpectation.paramPtrs == nil {
		mmUpdateProductVariant.defaultExpectation.paramPtrs = &CommerceServiceClientMockUpdateProductVariantParamPtrs{}
	}
	mmUpdateProductVariant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateProductVariant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateProductVariant
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.UpdateProductVariant
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest])) *mCommerceServiceClientMockUpdateProductVariant {
	if mmUpdateProductVariant.mock.inspectFuncUpdateProductVariant != nil {
		mmUpdateProductVariant.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.UpdateProductVariant")
	}

	mmUpdateProductVariant.mock.inspectFuncUpdateProductVariant = f

	return mmUpdateProductVariant
}

// Return sets up results that will be returned by CommerceServiceClient.UpdateProductVariant
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Return(pp2 *connect.Response[v1.UpdateProductVariantResponse], err error) *CommerceServiceClientMock {
	if mmUpdateProductVariant.mock.funcUpdateProductVariant != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Set")
	}

	if mmUpdateProductVariant.defaultExpectation == nil {
		mmUpdateProductVariant.defaultExpectation = &CommerceServiceClientMockUpdateProductVariantExpectation{mock: mmUpdateProductVariant.mock}
	}
	mmUpdateProductVariant.defaultExpectation.results = &CommerceServiceClientMockUpdateProductVariantResults{pp2, err}
	mmUpdateProductVariant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateProductVariant.mock
}

// Set uses given function f to mock the CommerceServiceClient.UpdateProductVariant method
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest]) (pp2 *connect.Response[v1.UpdateProductVariantResponse], err error)) *CommerceServiceClientMock {
	if mmUpdateProductVariant.defaultExpectation != nil {
		mmUpdateProductVariant.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.UpdateProductVariant method")
	}

	if len(mmUpdateProductVariant.expectations) > 0 {
		mmUpdateProductVariant.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.UpdateProductVariant method")
	}

	mmUpdateProductVariant.mock.funcUpdateProductVariant = f
	mmUpdateProductVariant.mock.funcUpdateProductVariantOrigin = minimock.CallerInfo(1)
	return mmUpdateProductVariant.mock
}

// When sets expectation for the CommerceServiceClient.UpdateProductVariant which will trigger the result defined by the following
// Then helper
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) When(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest]) *CommerceServiceClientMockUpdateProductVariantExpectation {
	if mmUpdateProductVariant.mock.funcUpdateProductVariant != nil {
		mmUpdateProductVariant.mock.t.Fatalf("CommerceServiceClientMock.UpdateProductVariant mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockUpdateProductVariantExpectation{
		mock:               mmUpdateProductVariant.mock,
		params:             &CommerceServiceClientMockUpdateProductVariantParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockUpdateProductVariantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateProductVariant.expectations = append(mmUpdateProductVariant.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.UpdateProductVariant return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockUpdateProductVariantExpectation) Then(pp2 *connect.Response[v1.UpdateProductVariantResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockUpdateProductVariantResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.UpdateProductVariant should be invoked
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Times(n uint64) *mCommerceServiceClientMockUpdateProductVariant {
	if n == 0 {
		mmUpdateProductVariant.mock.t.Fatalf("Times of CommerceServiceClientMock.UpdateProductVariant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateProductVariant.expectedInvocations, n)
	mmUpdateProductVariant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateProductVariant
}

func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) invocationsDone() bool {
	if len(mmUpdateProductVariant.expectations) == 0 && mmUpdateProductVariant.defaultExpectation == nil && mmUpdateProductVariant.mock.funcUpdateProductVariant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateProductVariant.mock.afterUpdateProductVariantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateProductVariant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateProductVariant implements mm_commercev1connect.CommerceServiceClient
func (mmUpdateProductVariant *CommerceServiceClientMock) UpdateProductVariant(ctx context.Context, pp1 *connect.Request[v1.UpdateProductVariantRequest]) (pp2 *connect.Response[v1.UpdateProductVariantResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateProductVariant.beforeUpdateProductVariantCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateProductVariant.afterUpdateProductVariantCounter, 1)

	mmUpdateProductVariant.t.Helper()

	if mmUpdateProductVariant.inspectFuncUpdateProductVariant != nil {
		mmUpdateProductVariant.inspectFuncUpdateProductVariant(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockUpdateProductVariantParams{ctx, pp1}

	// Record call args
	mmUpdateProductVariant.UpdateProductVariantMock.mutex.Lock()
	mmUpdateProductVariant.UpdateProductVariantMock.callArgs = append(mmUpdateProductVariant.UpdateProductVariantMock.callArgs, &mm_params)
	mmUpdateProductVariant.UpdateProductVariantMock.mutex.Unlock()

	for _, e := range mmUpdateProductVariant.UpdateProductVariantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockUpdateProductVariantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateProductVariant.t.Errorf("CommerceServiceClientMock.UpdateProductVariant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateProductVariant.t.Errorf("CommerceServiceClientMock.UpdateProductVariant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateProductVariant.t.Errorf("CommerceServiceClientMock.UpdateProductVariant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateProductVariant.UpdateProductVariantMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateProductVariant.t.Fatal("No results are set for the CommerceServiceClientMock.UpdateProductVariant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateProductVariant.funcUpdateProductVariant != nil {
		return mmUpdateProductVariant.funcUpdateProductVariant(ctx, pp1)
	}
	mmUpdateProductVariant.t.Fatalf("Unexpected call to CommerceServiceClientMock.UpdateProductVariant. %v %v", ctx, pp1)
	return
}

// UpdateProductVariantAfterCounter returns a count of finished CommerceServiceClientMock.UpdateProductVariant invocations
func (mmUpdateProductVariant *CommerceServiceClientMock) UpdateProductVariantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProductVariant.afterUpdateProductVariantCounter)
}

// UpdateProductVariantBeforeCounter returns a count of CommerceServiceClientMock.UpdateProductVariant invocations
func (mmUpdateProductVariant *CommerceServiceClientMock) UpdateProductVariantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProductVariant.beforeUpdateProductVariantCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.UpdateProductVariant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateProductVariant *mCommerceServiceClientMockUpdateProductVariant) Calls() []*CommerceServiceClientMockUpdateProductVariantParams {
	mmUpdateProductVariant.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockUpdateProductVariantParams, len(mmUpdateProductVariant.callArgs))
	copy(argCopy, mmUpdateProductVariant.callArgs)

	mmUpdateProductVariant.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateProductVariantDone returns true if the count of the UpdateProductVariant invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockUpdateProductVariantDone() bool {
	if m.UpdateProductVariantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateProductVariantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateProductVariantMock.invocationsDone()
}

// MinimockUpdateProductVariantInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockUpdateProductVariantInspect() {
	for _, e := range m.UpdateProductVariantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateProductVariant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateProductVariantCounter := mm_atomic.LoadUint64(&m.afterUpdateProductVariantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateProductVariantMock.defaultExpectation != nil && afterUpdateProductVariantCounter < 1 {
		if m.UpdateProductVariantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateProductVariant at\n%s", m.UpdateProductVariantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateProductVariant at\n%s with params: %#v", m.UpdateProductVariantMock.defaultExpectation.expectationOrigins.origin, *m.UpdateProductVariantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateProductVariant != nil && afterUpdateProductVariantCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateProductVariant at\n%s", m.funcUpdateProductVariantOrigin)
	}

	if !m.UpdateProductVariantMock.invocationsDone() && afterUpdateProductVariantCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.UpdateProductVariant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateProductVariantMock.expectedInvocations), m.UpdateProductVariantMock.expectedInvocationsOrigin, afterUpdateProductVariantCounter)
	}
}

type mCommerceServiceClientMockUpdateShop struct {
	optional           bool
	mock               *CommerceServiceClientMock
	defaultExpectation *CommerceServiceClientMockUpdateShopExpectation
	expectations       []*CommerceServiceClientMockUpdateShopExpectation

	callArgs []*CommerceServiceClientMockUpdateShopParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CommerceServiceClientMockUpdateShopExpectation specifies expectation struct of the CommerceServiceClient.UpdateShop
type CommerceServiceClientMockUpdateShopExpectation struct {
	mock               *CommerceServiceClientMock
	params             *CommerceServiceClientMockUpdateShopParams
	paramPtrs          *CommerceServiceClientMockUpdateShopParamPtrs
	expectationOrigins CommerceServiceClientMockUpdateShopExpectationOrigins
	results            *CommerceServiceClientMockUpdateShopResults
	returnOrigin       string
	Counter            uint64
}

// CommerceServiceClientMockUpdateShopParams contains parameters of the CommerceServiceClient.UpdateShop
type CommerceServiceClientMockUpdateShopParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateShopRequest]
}

// CommerceServiceClientMockUpdateShopParamPtrs contains pointers to parameters of the CommerceServiceClient.UpdateShop
type CommerceServiceClientMockUpdateShopParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateShopRequest]
}

// CommerceServiceClientMockUpdateShopResults contains results of the CommerceServiceClient.UpdateShop
type CommerceServiceClientMockUpdateShopResults struct {
	pp2 *connect.Response[v1.UpdateShopResponse]
	err error
}

// CommerceServiceClientMockUpdateShopOrigins contains origins of expectations of the CommerceServiceClient.UpdateShop
type CommerceServiceClientMockUpdateShopExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Optional() *mCommerceServiceClientMockUpdateShop {
	mmUpdateShop.optional = true
	return mmUpdateShop
}

// Expect sets up expected params for CommerceServiceClient.UpdateShop
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest]) *mCommerceServiceClientMockUpdateShop {
	if mmUpdateShop.mock.funcUpdateShop != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Set")
	}

	if mmUpdateShop.defaultExpectation == nil {
		mmUpdateShop.defaultExpectation = &CommerceServiceClientMockUpdateShopExpectation{}
	}

	if mmUpdateShop.defaultExpectation.paramPtrs != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by ExpectParams functions")
	}

	mmUpdateShop.defaultExpectation.params = &CommerceServiceClientMockUpdateShopParams{ctx, pp1}
	mmUpdateShop.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateShop.expectations {
		if minimock.Equal(e.params, mmUpdateShop.defaultExpectation.params) {
			mmUpdateShop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateShop.defaultExpectation.params)
		}
	}

	return mmUpdateShop
}

// ExpectCtxParam1 sets up expected param ctx for CommerceServiceClient.UpdateShop
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) ExpectCtxParam1(ctx context.Context) *mCommerceServiceClientMockUpdateShop {
	if mmUpdateShop.mock.funcUpdateShop != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Set")
	}

	if mmUpdateShop.defaultExpectation == nil {
		mmUpdateShop.defaultExpectation = &CommerceServiceClientMockUpdateShopExpectation{}
	}

	if mmUpdateShop.defaultExpectation.params != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Expect")
	}

	if mmUpdateShop.defaultExpectation.paramPtrs == nil {
		mmUpdateShop.defaultExpectation.paramPtrs = &CommerceServiceClientMockUpdateShopParamPtrs{}
	}
	mmUpdateShop.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateShop.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateShop
}

// ExpectPp1Param2 sets up expected param pp1 for CommerceServiceClient.UpdateShop
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateShopRequest]) *mCommerceServiceClientMockUpdateShop {
	if mmUpdateShop.mock.funcUpdateShop != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Set")
	}

	if mmUpdateShop.defaultExpectation == nil {
		mmUpdateShop.defaultExpectation = &CommerceServiceClientMockUpdateShopExpectation{}
	}

	if mmUpdateShop.defaultExpectation.params != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Expect")
	}

	if mmUpdateShop.defaultExpectation.paramPtrs == nil {
		mmUpdateShop.defaultExpectation.paramPtrs = &CommerceServiceClientMockUpdateShopParamPtrs{}
	}
	mmUpdateShop.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateShop.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateShop
}

// Inspect accepts an inspector function that has same arguments as the CommerceServiceClient.UpdateShop
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest])) *mCommerceServiceClientMockUpdateShop {
	if mmUpdateShop.mock.inspectFuncUpdateShop != nil {
		mmUpdateShop.mock.t.Fatalf("Inspect function is already set for CommerceServiceClientMock.UpdateShop")
	}

	mmUpdateShop.mock.inspectFuncUpdateShop = f

	return mmUpdateShop
}

// Return sets up results that will be returned by CommerceServiceClient.UpdateShop
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Return(pp2 *connect.Response[v1.UpdateShopResponse], err error) *CommerceServiceClientMock {
	if mmUpdateShop.mock.funcUpdateShop != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Set")
	}

	if mmUpdateShop.defaultExpectation == nil {
		mmUpdateShop.defaultExpectation = &CommerceServiceClientMockUpdateShopExpectation{mock: mmUpdateShop.mock}
	}
	mmUpdateShop.defaultExpectation.results = &CommerceServiceClientMockUpdateShopResults{pp2, err}
	mmUpdateShop.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateShop.mock
}

// Set uses given function f to mock the CommerceServiceClient.UpdateShop method
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest]) (pp2 *connect.Response[v1.UpdateShopResponse], err error)) *CommerceServiceClientMock {
	if mmUpdateShop.defaultExpectation != nil {
		mmUpdateShop.mock.t.Fatalf("Default expectation is already set for the CommerceServiceClient.UpdateShop method")
	}

	if len(mmUpdateShop.expectations) > 0 {
		mmUpdateShop.mock.t.Fatalf("Some expectations are already set for the CommerceServiceClient.UpdateShop method")
	}

	mmUpdateShop.mock.funcUpdateShop = f
	mmUpdateShop.mock.funcUpdateShopOrigin = minimock.CallerInfo(1)
	return mmUpdateShop.mock
}

// When sets expectation for the CommerceServiceClient.UpdateShop which will trigger the result defined by the following
// Then helper
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) When(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest]) *CommerceServiceClientMockUpdateShopExpectation {
	if mmUpdateShop.mock.funcUpdateShop != nil {
		mmUpdateShop.mock.t.Fatalf("CommerceServiceClientMock.UpdateShop mock is already set by Set")
	}

	expectation := &CommerceServiceClientMockUpdateShopExpectation{
		mock:               mmUpdateShop.mock,
		params:             &CommerceServiceClientMockUpdateShopParams{ctx, pp1},
		expectationOrigins: CommerceServiceClientMockUpdateShopExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateShop.expectations = append(mmUpdateShop.expectations, expectation)
	return expectation
}

// Then sets up CommerceServiceClient.UpdateShop return parameters for the expectation previously defined by the When method
func (e *CommerceServiceClientMockUpdateShopExpectation) Then(pp2 *connect.Response[v1.UpdateShopResponse], err error) *CommerceServiceClientMock {
	e.results = &CommerceServiceClientMockUpdateShopResults{pp2, err}
	return e.mock
}

// Times sets number of times CommerceServiceClient.UpdateShop should be invoked
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Times(n uint64) *mCommerceServiceClientMockUpdateShop {
	if n == 0 {
		mmUpdateShop.mock.t.Fatalf("Times of CommerceServiceClientMock.UpdateShop mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateShop.expectedInvocations, n)
	mmUpdateShop.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateShop
}

func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) invocationsDone() bool {
	if len(mmUpdateShop.expectations) == 0 && mmUpdateShop.defaultExpectation == nil && mmUpdateShop.mock.funcUpdateShop == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateShop.mock.afterUpdateShopCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateShop.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateShop implements mm_commercev1connect.CommerceServiceClient
func (mmUpdateShop *CommerceServiceClientMock) UpdateShop(ctx context.Context, pp1 *connect.Request[v1.UpdateShopRequest]) (pp2 *connect.Response[v1.UpdateShopResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateShop.beforeUpdateShopCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateShop.afterUpdateShopCounter, 1)

	mmUpdateShop.t.Helper()

	if mmUpdateShop.inspectFuncUpdateShop != nil {
		mmUpdateShop.inspectFuncUpdateShop(ctx, pp1)
	}

	mm_params := CommerceServiceClientMockUpdateShopParams{ctx, pp1}

	// Record call args
	mmUpdateShop.UpdateShopMock.mutex.Lock()
	mmUpdateShop.UpdateShopMock.callArgs = append(mmUpdateShop.UpdateShopMock.callArgs, &mm_params)
	mmUpdateShop.UpdateShopMock.mutex.Unlock()

	for _, e := range mmUpdateShop.UpdateShopMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateShop.UpdateShopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateShop.UpdateShopMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateShop.UpdateShopMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateShop.UpdateShopMock.defaultExpectation.paramPtrs

		mm_got := CommerceServiceClientMockUpdateShopParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateShop.t.Errorf("CommerceServiceClientMock.UpdateShop got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateShop.UpdateShopMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateShop.t.Errorf("CommerceServiceClientMock.UpdateShop got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateShop.UpdateShopMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateShop.t.Errorf("CommerceServiceClientMock.UpdateShop got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateShop.UpdateShopMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateShop.UpdateShopMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateShop.t.Fatal("No results are set for the CommerceServiceClientMock.UpdateShop")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateShop.funcUpdateShop != nil {
		return mmUpdateShop.funcUpdateShop(ctx, pp1)
	}
	mmUpdateShop.t.Fatalf("Unexpected call to CommerceServiceClientMock.UpdateShop. %v %v", ctx, pp1)
	return
}

// UpdateShopAfterCounter returns a count of finished CommerceServiceClientMock.UpdateShop invocations
func (mmUpdateShop *CommerceServiceClientMock) UpdateShopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateShop.afterUpdateShopCounter)
}

// UpdateShopBeforeCounter returns a count of CommerceServiceClientMock.UpdateShop invocations
func (mmUpdateShop *CommerceServiceClientMock) UpdateShopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateShop.beforeUpdateShopCounter)
}

// Calls returns a list of arguments used in each call to CommerceServiceClientMock.UpdateShop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateShop *mCommerceServiceClientMockUpdateShop) Calls() []*CommerceServiceClientMockUpdateShopParams {
	mmUpdateShop.mutex.RLock()

	argCopy := make([]*CommerceServiceClientMockUpdateShopParams, len(mmUpdateShop.callArgs))
	copy(argCopy, mmUpdateShop.callArgs)

	mmUpdateShop.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateShopDone returns true if the count of the UpdateShop invocations corresponds
// the number of defined expectations
func (m *CommerceServiceClientMock) MinimockUpdateShopDone() bool {
	if m.UpdateShopMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateShopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateShopMock.invocationsDone()
}

// MinimockUpdateShopInspect logs each unmet expectation
func (m *CommerceServiceClientMock) MinimockUpdateShopInspect() {
	for _, e := range m.UpdateShopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateShop at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateShopCounter := mm_atomic.LoadUint64(&m.afterUpdateShopCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateShopMock.defaultExpectation != nil && afterUpdateShopCounter < 1 {
		if m.UpdateShopMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateShop at\n%s", m.UpdateShopMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateShop at\n%s with params: %#v", m.UpdateShopMock.defaultExpectation.expectationOrigins.origin, *m.UpdateShopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateShop != nil && afterUpdateShopCounter < 1 {
		m.t.Errorf("Expected call to CommerceServiceClientMock.UpdateShop at\n%s", m.funcUpdateShopOrigin)
	}

	if !m.UpdateShopMock.invocationsDone() && afterUpdateShopCounter > 0 {
		m.t.Errorf("Expected %d calls to CommerceServiceClientMock.UpdateShop at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateShopMock.expectedInvocations), m.UpdateShopMock.expectedInvocationsOrigin, afterUpdateShopCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CommerceServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCartLineInspect()

			m.MinimockCreateCartInspect()

			m.MinimockCreateFulfilmentInspect()

			m.MinimockCreateOrderInspect()

			m.MinimockCreateOrderFromCartInspect()

			m.MinimockCreateProductInspect()

			m.MinimockCreateProductVariantInspect()

			m.MinimockCreateShopInspect()

			m.MinimockGetCartInspect()

			m.MinimockGetFulfilmentInspect()

			m.MinimockGetOrderInspect()

			m.MinimockGetProductInspect()

			m.MinimockGetShopInspect()

			m.MinimockListOrdersInspect()

			m.MinimockListProductsInspect()

			m.MinimockRemoveCartLineInspect()

			m.MinimockUpdateFulfilmentInspect()

			m.MinimockUpdateProductVariantInspect()

			m.MinimockUpdateShopInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CommerceServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CommerceServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCartLineDone() &&
		m.MinimockCreateCartDone() &&
		m.MinimockCreateFulfilmentDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockCreateOrderFromCartDone() &&
		m.MinimockCreateProductDone() &&
		m.MinimockCreateProductVariantDone() &&
		m.MinimockCreateShopDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockGetFulfilmentDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetProductDone() &&
		m.MinimockGetShopDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockListProductsDone() &&
		m.MinimockRemoveCartLineDone() &&
		m.MinimockUpdateFulfilmentDone() &&
		m.MinimockUpdateProductVariantDone() &&
		m.MinimockUpdateShopDone()
}
