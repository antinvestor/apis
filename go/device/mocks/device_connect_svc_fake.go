// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"buf.build/gen/go/antinvestor/device/connectrpc/go/device/v1/devicev1connect"
	devicev1 "buf.build/gen/go/antinvestor/device/protocolbuffers/go/device/v1"
	"connectrpc.com/connect"
)

type FakeDeviceServiceHandler struct {
	AddKeyStub        func(context.Context, *connect.Request[devicev1.AddKeyRequest]) (*connect.Response[devicev1.AddKeyResponse], error)
	addKeyMutex       sync.RWMutex
	addKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.AddKeyRequest]
	}
	addKeyReturns struct {
		result1 *connect.Response[devicev1.AddKeyResponse]
		result2 error
	}
	addKeyReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.AddKeyResponse]
		result2 error
	}
	CreateStub        func(context.Context, *connect.Request[devicev1.CreateRequest]) (*connect.Response[devicev1.CreateResponse], error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.CreateRequest]
	}
	createReturns struct {
		result1 *connect.Response[devicev1.CreateResponse]
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.CreateResponse]
		result2 error
	}
	DeRegisterKeyStub        func(context.Context, *connect.Request[devicev1.DeRegisterKeyRequest]) (*connect.Response[devicev1.DeRegisterKeyResponse], error)
	deRegisterKeyMutex       sync.RWMutex
	deRegisterKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.DeRegisterKeyRequest]
	}
	deRegisterKeyReturns struct {
		result1 *connect.Response[devicev1.DeRegisterKeyResponse]
		result2 error
	}
	deRegisterKeyReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.DeRegisterKeyResponse]
		result2 error
	}
	GetByIdStub        func(context.Context, *connect.Request[devicev1.GetByIdRequest]) (*connect.Response[devicev1.GetByIdResponse], error)
	getByIdMutex       sync.RWMutex
	getByIdArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.GetByIdRequest]
	}
	getByIdReturns struct {
		result1 *connect.Response[devicev1.GetByIdResponse]
		result2 error
	}
	getByIdReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.GetByIdResponse]
		result2 error
	}
	GetBySessionIdStub        func(context.Context, *connect.Request[devicev1.GetBySessionIdRequest]) (*connect.Response[devicev1.GetBySessionIdResponse], error)
	getBySessionIdMutex       sync.RWMutex
	getBySessionIdArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.GetBySessionIdRequest]
	}
	getBySessionIdReturns struct {
		result1 *connect.Response[devicev1.GetBySessionIdResponse]
		result2 error
	}
	getBySessionIdReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.GetBySessionIdResponse]
		result2 error
	}
	LinkStub        func(context.Context, *connect.Request[devicev1.LinkRequest]) (*connect.Response[devicev1.LinkResponse], error)
	linkMutex       sync.RWMutex
	linkArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.LinkRequest]
	}
	linkReturns struct {
		result1 *connect.Response[devicev1.LinkResponse]
		result2 error
	}
	linkReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.LinkResponse]
		result2 error
	}
	ListLogsStub        func(context.Context, *connect.Request[devicev1.ListLogsRequest], *connect.ServerStream[devicev1.ListLogsResponse]) error
	listLogsMutex       sync.RWMutex
	listLogsArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.ListLogsRequest]
		arg3 *connect.ServerStream[devicev1.ListLogsResponse]
	}
	listLogsReturns struct {
		result1 error
	}
	listLogsReturnsOnCall map[int]struct {
		result1 error
	}
	LogStub        func(context.Context, *connect.Request[devicev1.LogRequest]) (*connect.Response[devicev1.LogResponse], error)
	logMutex       sync.RWMutex
	logArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.LogRequest]
	}
	logReturns struct {
		result1 *connect.Response[devicev1.LogResponse]
		result2 error
	}
	logReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.LogResponse]
		result2 error
	}
	NotifyStub        func(context.Context, *connect.Request[devicev1.NotifyRequest]) (*connect.Response[devicev1.NotifyResponse], error)
	notifyMutex       sync.RWMutex
	notifyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.NotifyRequest]
	}
	notifyReturns struct {
		result1 *connect.Response[devicev1.NotifyResponse]
		result2 error
	}
	notifyReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.NotifyResponse]
		result2 error
	}
	RegisterKeyStub        func(context.Context, *connect.Request[devicev1.RegisterKeyRequest]) (*connect.Response[devicev1.RegisterKeyResponse], error)
	registerKeyMutex       sync.RWMutex
	registerKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.RegisterKeyRequest]
	}
	registerKeyReturns struct {
		result1 *connect.Response[devicev1.RegisterKeyResponse]
		result2 error
	}
	registerKeyReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.RegisterKeyResponse]
		result2 error
	}
	RemoveStub        func(context.Context, *connect.Request[devicev1.RemoveRequest]) (*connect.Response[devicev1.RemoveResponse], error)
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.RemoveRequest]
	}
	removeReturns struct {
		result1 *connect.Response[devicev1.RemoveResponse]
		result2 error
	}
	removeReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.RemoveResponse]
		result2 error
	}
	RemoveKeyStub        func(context.Context, *connect.Request[devicev1.RemoveKeyRequest]) (*connect.Response[devicev1.RemoveKeyResponse], error)
	removeKeyMutex       sync.RWMutex
	removeKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.RemoveKeyRequest]
	}
	removeKeyReturns struct {
		result1 *connect.Response[devicev1.RemoveKeyResponse]
		result2 error
	}
	removeKeyReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.RemoveKeyResponse]
		result2 error
	}
	SearchStub        func(context.Context, *connect.Request[devicev1.SearchRequest], *connect.ServerStream[devicev1.SearchResponse]) error
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.SearchRequest]
		arg3 *connect.ServerStream[devicev1.SearchResponse]
	}
	searchReturns struct {
		result1 error
	}
	searchReturnsOnCall map[int]struct {
		result1 error
	}
	SearchKeyStub        func(context.Context, *connect.Request[devicev1.SearchKeyRequest]) (*connect.Response[devicev1.SearchKeyResponse], error)
	searchKeyMutex       sync.RWMutex
	searchKeyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.SearchKeyRequest]
	}
	searchKeyReturns struct {
		result1 *connect.Response[devicev1.SearchKeyResponse]
		result2 error
	}
	searchKeyReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.SearchKeyResponse]
		result2 error
	}
	UpdateStub        func(context.Context, *connect.Request[devicev1.UpdateRequest]) (*connect.Response[devicev1.UpdateResponse], error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.UpdateRequest]
	}
	updateReturns struct {
		result1 *connect.Response[devicev1.UpdateResponse]
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.UpdateResponse]
		result2 error
	}
	UpdatePresenceStub        func(context.Context, *connect.Request[devicev1.UpdatePresenceRequest]) (*connect.Response[devicev1.UpdatePresenceResponse], error)
	updatePresenceMutex       sync.RWMutex
	updatePresenceArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.UpdatePresenceRequest]
	}
	updatePresenceReturns struct {
		result1 *connect.Response[devicev1.UpdatePresenceResponse]
		result2 error
	}
	updatePresenceReturnsOnCall map[int]struct {
		result1 *connect.Response[devicev1.UpdatePresenceResponse]
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDeviceServiceHandler) AddKey(arg1 context.Context, arg2 *connect.Request[devicev1.AddKeyRequest]) (*connect.Response[devicev1.AddKeyResponse], error) {
	fake.addKeyMutex.Lock()
	ret, specificReturn := fake.addKeyReturnsOnCall[len(fake.addKeyArgsForCall)]
	fake.addKeyArgsForCall = append(fake.addKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.AddKeyRequest]
	}{arg1, arg2})
	stub := fake.AddKeyStub
	fakeReturns := fake.addKeyReturns
	fake.recordInvocation("AddKey", []interface{}{arg1, arg2})
	fake.addKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) AddKeyCallCount() int {
	fake.addKeyMutex.RLock()
	defer fake.addKeyMutex.RUnlock()
	return len(fake.addKeyArgsForCall)
}

func (fake *FakeDeviceServiceHandler) AddKeyCalls(stub func(context.Context, *connect.Request[devicev1.AddKeyRequest]) (*connect.Response[devicev1.AddKeyResponse], error)) {
	fake.addKeyMutex.Lock()
	defer fake.addKeyMutex.Unlock()
	fake.AddKeyStub = stub
}

func (fake *FakeDeviceServiceHandler) AddKeyArgsForCall(i int) (context.Context, *connect.Request[devicev1.AddKeyRequest]) {
	fake.addKeyMutex.RLock()
	defer fake.addKeyMutex.RUnlock()
	argsForCall := fake.addKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) AddKeyReturns(result1 *connect.Response[devicev1.AddKeyResponse], result2 error) {
	fake.addKeyMutex.Lock()
	defer fake.addKeyMutex.Unlock()
	fake.AddKeyStub = nil
	fake.addKeyReturns = struct {
		result1 *connect.Response[devicev1.AddKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) AddKeyReturnsOnCall(i int, result1 *connect.Response[devicev1.AddKeyResponse], result2 error) {
	fake.addKeyMutex.Lock()
	defer fake.addKeyMutex.Unlock()
	fake.AddKeyStub = nil
	if fake.addKeyReturnsOnCall == nil {
		fake.addKeyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.AddKeyResponse]
			result2 error
		})
	}
	fake.addKeyReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.AddKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Create(arg1 context.Context, arg2 *connect.Request[devicev1.CreateRequest]) (*connect.Response[devicev1.CreateResponse], error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.CreateRequest]
	}{arg1, arg2})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeDeviceServiceHandler) CreateCalls(stub func(context.Context, *connect.Request[devicev1.CreateRequest]) (*connect.Response[devicev1.CreateResponse], error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeDeviceServiceHandler) CreateArgsForCall(i int) (context.Context, *connect.Request[devicev1.CreateRequest]) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) CreateReturns(result1 *connect.Response[devicev1.CreateResponse], result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *connect.Response[devicev1.CreateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) CreateReturnsOnCall(i int, result1 *connect.Response[devicev1.CreateResponse], result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.CreateResponse]
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.CreateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) DeRegisterKey(arg1 context.Context, arg2 *connect.Request[devicev1.DeRegisterKeyRequest]) (*connect.Response[devicev1.DeRegisterKeyResponse], error) {
	fake.deRegisterKeyMutex.Lock()
	ret, specificReturn := fake.deRegisterKeyReturnsOnCall[len(fake.deRegisterKeyArgsForCall)]
	fake.deRegisterKeyArgsForCall = append(fake.deRegisterKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.DeRegisterKeyRequest]
	}{arg1, arg2})
	stub := fake.DeRegisterKeyStub
	fakeReturns := fake.deRegisterKeyReturns
	fake.recordInvocation("DeRegisterKey", []interface{}{arg1, arg2})
	fake.deRegisterKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) DeRegisterKeyCallCount() int {
	fake.deRegisterKeyMutex.RLock()
	defer fake.deRegisterKeyMutex.RUnlock()
	return len(fake.deRegisterKeyArgsForCall)
}

func (fake *FakeDeviceServiceHandler) DeRegisterKeyCalls(stub func(context.Context, *connect.Request[devicev1.DeRegisterKeyRequest]) (*connect.Response[devicev1.DeRegisterKeyResponse], error)) {
	fake.deRegisterKeyMutex.Lock()
	defer fake.deRegisterKeyMutex.Unlock()
	fake.DeRegisterKeyStub = stub
}

func (fake *FakeDeviceServiceHandler) DeRegisterKeyArgsForCall(i int) (context.Context, *connect.Request[devicev1.DeRegisterKeyRequest]) {
	fake.deRegisterKeyMutex.RLock()
	defer fake.deRegisterKeyMutex.RUnlock()
	argsForCall := fake.deRegisterKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) DeRegisterKeyReturns(result1 *connect.Response[devicev1.DeRegisterKeyResponse], result2 error) {
	fake.deRegisterKeyMutex.Lock()
	defer fake.deRegisterKeyMutex.Unlock()
	fake.DeRegisterKeyStub = nil
	fake.deRegisterKeyReturns = struct {
		result1 *connect.Response[devicev1.DeRegisterKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) DeRegisterKeyReturnsOnCall(i int, result1 *connect.Response[devicev1.DeRegisterKeyResponse], result2 error) {
	fake.deRegisterKeyMutex.Lock()
	defer fake.deRegisterKeyMutex.Unlock()
	fake.DeRegisterKeyStub = nil
	if fake.deRegisterKeyReturnsOnCall == nil {
		fake.deRegisterKeyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.DeRegisterKeyResponse]
			result2 error
		})
	}
	fake.deRegisterKeyReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.DeRegisterKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) GetById(arg1 context.Context, arg2 *connect.Request[devicev1.GetByIdRequest]) (*connect.Response[devicev1.GetByIdResponse], error) {
	fake.getByIdMutex.Lock()
	ret, specificReturn := fake.getByIdReturnsOnCall[len(fake.getByIdArgsForCall)]
	fake.getByIdArgsForCall = append(fake.getByIdArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.GetByIdRequest]
	}{arg1, arg2})
	stub := fake.GetByIdStub
	fakeReturns := fake.getByIdReturns
	fake.recordInvocation("GetById", []interface{}{arg1, arg2})
	fake.getByIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) GetByIdCallCount() int {
	fake.getByIdMutex.RLock()
	defer fake.getByIdMutex.RUnlock()
	return len(fake.getByIdArgsForCall)
}

func (fake *FakeDeviceServiceHandler) GetByIdCalls(stub func(context.Context, *connect.Request[devicev1.GetByIdRequest]) (*connect.Response[devicev1.GetByIdResponse], error)) {
	fake.getByIdMutex.Lock()
	defer fake.getByIdMutex.Unlock()
	fake.GetByIdStub = stub
}

func (fake *FakeDeviceServiceHandler) GetByIdArgsForCall(i int) (context.Context, *connect.Request[devicev1.GetByIdRequest]) {
	fake.getByIdMutex.RLock()
	defer fake.getByIdMutex.RUnlock()
	argsForCall := fake.getByIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) GetByIdReturns(result1 *connect.Response[devicev1.GetByIdResponse], result2 error) {
	fake.getByIdMutex.Lock()
	defer fake.getByIdMutex.Unlock()
	fake.GetByIdStub = nil
	fake.getByIdReturns = struct {
		result1 *connect.Response[devicev1.GetByIdResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) GetByIdReturnsOnCall(i int, result1 *connect.Response[devicev1.GetByIdResponse], result2 error) {
	fake.getByIdMutex.Lock()
	defer fake.getByIdMutex.Unlock()
	fake.GetByIdStub = nil
	if fake.getByIdReturnsOnCall == nil {
		fake.getByIdReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.GetByIdResponse]
			result2 error
		})
	}
	fake.getByIdReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.GetByIdResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) GetBySessionId(arg1 context.Context, arg2 *connect.Request[devicev1.GetBySessionIdRequest]) (*connect.Response[devicev1.GetBySessionIdResponse], error) {
	fake.getBySessionIdMutex.Lock()
	ret, specificReturn := fake.getBySessionIdReturnsOnCall[len(fake.getBySessionIdArgsForCall)]
	fake.getBySessionIdArgsForCall = append(fake.getBySessionIdArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.GetBySessionIdRequest]
	}{arg1, arg2})
	stub := fake.GetBySessionIdStub
	fakeReturns := fake.getBySessionIdReturns
	fake.recordInvocation("GetBySessionId", []interface{}{arg1, arg2})
	fake.getBySessionIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) GetBySessionIdCallCount() int {
	fake.getBySessionIdMutex.RLock()
	defer fake.getBySessionIdMutex.RUnlock()
	return len(fake.getBySessionIdArgsForCall)
}

func (fake *FakeDeviceServiceHandler) GetBySessionIdCalls(stub func(context.Context, *connect.Request[devicev1.GetBySessionIdRequest]) (*connect.Response[devicev1.GetBySessionIdResponse], error)) {
	fake.getBySessionIdMutex.Lock()
	defer fake.getBySessionIdMutex.Unlock()
	fake.GetBySessionIdStub = stub
}

func (fake *FakeDeviceServiceHandler) GetBySessionIdArgsForCall(i int) (context.Context, *connect.Request[devicev1.GetBySessionIdRequest]) {
	fake.getBySessionIdMutex.RLock()
	defer fake.getBySessionIdMutex.RUnlock()
	argsForCall := fake.getBySessionIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) GetBySessionIdReturns(result1 *connect.Response[devicev1.GetBySessionIdResponse], result2 error) {
	fake.getBySessionIdMutex.Lock()
	defer fake.getBySessionIdMutex.Unlock()
	fake.GetBySessionIdStub = nil
	fake.getBySessionIdReturns = struct {
		result1 *connect.Response[devicev1.GetBySessionIdResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) GetBySessionIdReturnsOnCall(i int, result1 *connect.Response[devicev1.GetBySessionIdResponse], result2 error) {
	fake.getBySessionIdMutex.Lock()
	defer fake.getBySessionIdMutex.Unlock()
	fake.GetBySessionIdStub = nil
	if fake.getBySessionIdReturnsOnCall == nil {
		fake.getBySessionIdReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.GetBySessionIdResponse]
			result2 error
		})
	}
	fake.getBySessionIdReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.GetBySessionIdResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Link(arg1 context.Context, arg2 *connect.Request[devicev1.LinkRequest]) (*connect.Response[devicev1.LinkResponse], error) {
	fake.linkMutex.Lock()
	ret, specificReturn := fake.linkReturnsOnCall[len(fake.linkArgsForCall)]
	fake.linkArgsForCall = append(fake.linkArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.LinkRequest]
	}{arg1, arg2})
	stub := fake.LinkStub
	fakeReturns := fake.linkReturns
	fake.recordInvocation("Link", []interface{}{arg1, arg2})
	fake.linkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) LinkCallCount() int {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	return len(fake.linkArgsForCall)
}

func (fake *FakeDeviceServiceHandler) LinkCalls(stub func(context.Context, *connect.Request[devicev1.LinkRequest]) (*connect.Response[devicev1.LinkResponse], error)) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = stub
}

func (fake *FakeDeviceServiceHandler) LinkArgsForCall(i int) (context.Context, *connect.Request[devicev1.LinkRequest]) {
	fake.linkMutex.RLock()
	defer fake.linkMutex.RUnlock()
	argsForCall := fake.linkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) LinkReturns(result1 *connect.Response[devicev1.LinkResponse], result2 error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	fake.linkReturns = struct {
		result1 *connect.Response[devicev1.LinkResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) LinkReturnsOnCall(i int, result1 *connect.Response[devicev1.LinkResponse], result2 error) {
	fake.linkMutex.Lock()
	defer fake.linkMutex.Unlock()
	fake.LinkStub = nil
	if fake.linkReturnsOnCall == nil {
		fake.linkReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.LinkResponse]
			result2 error
		})
	}
	fake.linkReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.LinkResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) ListLogs(arg1 context.Context, arg2 *connect.Request[devicev1.ListLogsRequest], arg3 *connect.ServerStream[devicev1.ListLogsResponse]) error {
	fake.listLogsMutex.Lock()
	ret, specificReturn := fake.listLogsReturnsOnCall[len(fake.listLogsArgsForCall)]
	fake.listLogsArgsForCall = append(fake.listLogsArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.ListLogsRequest]
		arg3 *connect.ServerStream[devicev1.ListLogsResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListLogsStub
	fakeReturns := fake.listLogsReturns
	fake.recordInvocation("ListLogs", []interface{}{arg1, arg2, arg3})
	fake.listLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeviceServiceHandler) ListLogsCallCount() int {
	fake.listLogsMutex.RLock()
	defer fake.listLogsMutex.RUnlock()
	return len(fake.listLogsArgsForCall)
}

func (fake *FakeDeviceServiceHandler) ListLogsCalls(stub func(context.Context, *connect.Request[devicev1.ListLogsRequest], *connect.ServerStream[devicev1.ListLogsResponse]) error) {
	fake.listLogsMutex.Lock()
	defer fake.listLogsMutex.Unlock()
	fake.ListLogsStub = stub
}

func (fake *FakeDeviceServiceHandler) ListLogsArgsForCall(i int) (context.Context, *connect.Request[devicev1.ListLogsRequest], *connect.ServerStream[devicev1.ListLogsResponse]) {
	fake.listLogsMutex.RLock()
	defer fake.listLogsMutex.RUnlock()
	argsForCall := fake.listLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDeviceServiceHandler) ListLogsReturns(result1 error) {
	fake.listLogsMutex.Lock()
	defer fake.listLogsMutex.Unlock()
	fake.ListLogsStub = nil
	fake.listLogsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeviceServiceHandler) ListLogsReturnsOnCall(i int, result1 error) {
	fake.listLogsMutex.Lock()
	defer fake.listLogsMutex.Unlock()
	fake.ListLogsStub = nil
	if fake.listLogsReturnsOnCall == nil {
		fake.listLogsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listLogsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeviceServiceHandler) Log(arg1 context.Context, arg2 *connect.Request[devicev1.LogRequest]) (*connect.Response[devicev1.LogResponse], error) {
	fake.logMutex.Lock()
	ret, specificReturn := fake.logReturnsOnCall[len(fake.logArgsForCall)]
	fake.logArgsForCall = append(fake.logArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.LogRequest]
	}{arg1, arg2})
	stub := fake.LogStub
	fakeReturns := fake.logReturns
	fake.recordInvocation("Log", []interface{}{arg1, arg2})
	fake.logMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) LogCallCount() int {
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	return len(fake.logArgsForCall)
}

func (fake *FakeDeviceServiceHandler) LogCalls(stub func(context.Context, *connect.Request[devicev1.LogRequest]) (*connect.Response[devicev1.LogResponse], error)) {
	fake.logMutex.Lock()
	defer fake.logMutex.Unlock()
	fake.LogStub = stub
}

func (fake *FakeDeviceServiceHandler) LogArgsForCall(i int) (context.Context, *connect.Request[devicev1.LogRequest]) {
	fake.logMutex.RLock()
	defer fake.logMutex.RUnlock()
	argsForCall := fake.logArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) LogReturns(result1 *connect.Response[devicev1.LogResponse], result2 error) {
	fake.logMutex.Lock()
	defer fake.logMutex.Unlock()
	fake.LogStub = nil
	fake.logReturns = struct {
		result1 *connect.Response[devicev1.LogResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) LogReturnsOnCall(i int, result1 *connect.Response[devicev1.LogResponse], result2 error) {
	fake.logMutex.Lock()
	defer fake.logMutex.Unlock()
	fake.LogStub = nil
	if fake.logReturnsOnCall == nil {
		fake.logReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.LogResponse]
			result2 error
		})
	}
	fake.logReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.LogResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Notify(arg1 context.Context, arg2 *connect.Request[devicev1.NotifyRequest]) (*connect.Response[devicev1.NotifyResponse], error) {
	fake.notifyMutex.Lock()
	ret, specificReturn := fake.notifyReturnsOnCall[len(fake.notifyArgsForCall)]
	fake.notifyArgsForCall = append(fake.notifyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.NotifyRequest]
	}{arg1, arg2})
	stub := fake.NotifyStub
	fakeReturns := fake.notifyReturns
	fake.recordInvocation("Notify", []interface{}{arg1, arg2})
	fake.notifyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) NotifyCallCount() int {
	fake.notifyMutex.RLock()
	defer fake.notifyMutex.RUnlock()
	return len(fake.notifyArgsForCall)
}

func (fake *FakeDeviceServiceHandler) NotifyCalls(stub func(context.Context, *connect.Request[devicev1.NotifyRequest]) (*connect.Response[devicev1.NotifyResponse], error)) {
	fake.notifyMutex.Lock()
	defer fake.notifyMutex.Unlock()
	fake.NotifyStub = stub
}

func (fake *FakeDeviceServiceHandler) NotifyArgsForCall(i int) (context.Context, *connect.Request[devicev1.NotifyRequest]) {
	fake.notifyMutex.RLock()
	defer fake.notifyMutex.RUnlock()
	argsForCall := fake.notifyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) NotifyReturns(result1 *connect.Response[devicev1.NotifyResponse], result2 error) {
	fake.notifyMutex.Lock()
	defer fake.notifyMutex.Unlock()
	fake.NotifyStub = nil
	fake.notifyReturns = struct {
		result1 *connect.Response[devicev1.NotifyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) NotifyReturnsOnCall(i int, result1 *connect.Response[devicev1.NotifyResponse], result2 error) {
	fake.notifyMutex.Lock()
	defer fake.notifyMutex.Unlock()
	fake.NotifyStub = nil
	if fake.notifyReturnsOnCall == nil {
		fake.notifyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.NotifyResponse]
			result2 error
		})
	}
	fake.notifyReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.NotifyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) RegisterKey(arg1 context.Context, arg2 *connect.Request[devicev1.RegisterKeyRequest]) (*connect.Response[devicev1.RegisterKeyResponse], error) {
	fake.registerKeyMutex.Lock()
	ret, specificReturn := fake.registerKeyReturnsOnCall[len(fake.registerKeyArgsForCall)]
	fake.registerKeyArgsForCall = append(fake.registerKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.RegisterKeyRequest]
	}{arg1, arg2})
	stub := fake.RegisterKeyStub
	fakeReturns := fake.registerKeyReturns
	fake.recordInvocation("RegisterKey", []interface{}{arg1, arg2})
	fake.registerKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) RegisterKeyCallCount() int {
	fake.registerKeyMutex.RLock()
	defer fake.registerKeyMutex.RUnlock()
	return len(fake.registerKeyArgsForCall)
}

func (fake *FakeDeviceServiceHandler) RegisterKeyCalls(stub func(context.Context, *connect.Request[devicev1.RegisterKeyRequest]) (*connect.Response[devicev1.RegisterKeyResponse], error)) {
	fake.registerKeyMutex.Lock()
	defer fake.registerKeyMutex.Unlock()
	fake.RegisterKeyStub = stub
}

func (fake *FakeDeviceServiceHandler) RegisterKeyArgsForCall(i int) (context.Context, *connect.Request[devicev1.RegisterKeyRequest]) {
	fake.registerKeyMutex.RLock()
	defer fake.registerKeyMutex.RUnlock()
	argsForCall := fake.registerKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) RegisterKeyReturns(result1 *connect.Response[devicev1.RegisterKeyResponse], result2 error) {
	fake.registerKeyMutex.Lock()
	defer fake.registerKeyMutex.Unlock()
	fake.RegisterKeyStub = nil
	fake.registerKeyReturns = struct {
		result1 *connect.Response[devicev1.RegisterKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) RegisterKeyReturnsOnCall(i int, result1 *connect.Response[devicev1.RegisterKeyResponse], result2 error) {
	fake.registerKeyMutex.Lock()
	defer fake.registerKeyMutex.Unlock()
	fake.RegisterKeyStub = nil
	if fake.registerKeyReturnsOnCall == nil {
		fake.registerKeyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.RegisterKeyResponse]
			result2 error
		})
	}
	fake.registerKeyReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.RegisterKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Remove(arg1 context.Context, arg2 *connect.Request[devicev1.RemoveRequest]) (*connect.Response[devicev1.RemoveResponse], error) {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.RemoveRequest]
	}{arg1, arg2})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1, arg2})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeDeviceServiceHandler) RemoveCalls(stub func(context.Context, *connect.Request[devicev1.RemoveRequest]) (*connect.Response[devicev1.RemoveResponse], error)) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeDeviceServiceHandler) RemoveArgsForCall(i int) (context.Context, *connect.Request[devicev1.RemoveRequest]) {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) RemoveReturns(result1 *connect.Response[devicev1.RemoveResponse], result2 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 *connect.Response[devicev1.RemoveResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) RemoveReturnsOnCall(i int, result1 *connect.Response[devicev1.RemoveResponse], result2 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.RemoveResponse]
			result2 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.RemoveResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) RemoveKey(arg1 context.Context, arg2 *connect.Request[devicev1.RemoveKeyRequest]) (*connect.Response[devicev1.RemoveKeyResponse], error) {
	fake.removeKeyMutex.Lock()
	ret, specificReturn := fake.removeKeyReturnsOnCall[len(fake.removeKeyArgsForCall)]
	fake.removeKeyArgsForCall = append(fake.removeKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.RemoveKeyRequest]
	}{arg1, arg2})
	stub := fake.RemoveKeyStub
	fakeReturns := fake.removeKeyReturns
	fake.recordInvocation("RemoveKey", []interface{}{arg1, arg2})
	fake.removeKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) RemoveKeyCallCount() int {
	fake.removeKeyMutex.RLock()
	defer fake.removeKeyMutex.RUnlock()
	return len(fake.removeKeyArgsForCall)
}

func (fake *FakeDeviceServiceHandler) RemoveKeyCalls(stub func(context.Context, *connect.Request[devicev1.RemoveKeyRequest]) (*connect.Response[devicev1.RemoveKeyResponse], error)) {
	fake.removeKeyMutex.Lock()
	defer fake.removeKeyMutex.Unlock()
	fake.RemoveKeyStub = stub
}

func (fake *FakeDeviceServiceHandler) RemoveKeyArgsForCall(i int) (context.Context, *connect.Request[devicev1.RemoveKeyRequest]) {
	fake.removeKeyMutex.RLock()
	defer fake.removeKeyMutex.RUnlock()
	argsForCall := fake.removeKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) RemoveKeyReturns(result1 *connect.Response[devicev1.RemoveKeyResponse], result2 error) {
	fake.removeKeyMutex.Lock()
	defer fake.removeKeyMutex.Unlock()
	fake.RemoveKeyStub = nil
	fake.removeKeyReturns = struct {
		result1 *connect.Response[devicev1.RemoveKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) RemoveKeyReturnsOnCall(i int, result1 *connect.Response[devicev1.RemoveKeyResponse], result2 error) {
	fake.removeKeyMutex.Lock()
	defer fake.removeKeyMutex.Unlock()
	fake.RemoveKeyStub = nil
	if fake.removeKeyReturnsOnCall == nil {
		fake.removeKeyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.RemoveKeyResponse]
			result2 error
		})
	}
	fake.removeKeyReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.RemoveKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Search(arg1 context.Context, arg2 *connect.Request[devicev1.SearchRequest], arg3 *connect.ServerStream[devicev1.SearchResponse]) error {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.SearchRequest]
		arg3 *connect.ServerStream[devicev1.SearchResponse]
	}{arg1, arg2, arg3})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1, arg2, arg3})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDeviceServiceHandler) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *FakeDeviceServiceHandler) SearchCalls(stub func(context.Context, *connect.Request[devicev1.SearchRequest], *connect.ServerStream[devicev1.SearchResponse]) error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *FakeDeviceServiceHandler) SearchArgsForCall(i int) (context.Context, *connect.Request[devicev1.SearchRequest], *connect.ServerStream[devicev1.SearchResponse]) {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDeviceServiceHandler) SearchReturns(result1 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeviceServiceHandler) SearchReturnsOnCall(i int, result1 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDeviceServiceHandler) SearchKey(arg1 context.Context, arg2 *connect.Request[devicev1.SearchKeyRequest]) (*connect.Response[devicev1.SearchKeyResponse], error) {
	fake.searchKeyMutex.Lock()
	ret, specificReturn := fake.searchKeyReturnsOnCall[len(fake.searchKeyArgsForCall)]
	fake.searchKeyArgsForCall = append(fake.searchKeyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.SearchKeyRequest]
	}{arg1, arg2})
	stub := fake.SearchKeyStub
	fakeReturns := fake.searchKeyReturns
	fake.recordInvocation("SearchKey", []interface{}{arg1, arg2})
	fake.searchKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) SearchKeyCallCount() int {
	fake.searchKeyMutex.RLock()
	defer fake.searchKeyMutex.RUnlock()
	return len(fake.searchKeyArgsForCall)
}

func (fake *FakeDeviceServiceHandler) SearchKeyCalls(stub func(context.Context, *connect.Request[devicev1.SearchKeyRequest]) (*connect.Response[devicev1.SearchKeyResponse], error)) {
	fake.searchKeyMutex.Lock()
	defer fake.searchKeyMutex.Unlock()
	fake.SearchKeyStub = stub
}

func (fake *FakeDeviceServiceHandler) SearchKeyArgsForCall(i int) (context.Context, *connect.Request[devicev1.SearchKeyRequest]) {
	fake.searchKeyMutex.RLock()
	defer fake.searchKeyMutex.RUnlock()
	argsForCall := fake.searchKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) SearchKeyReturns(result1 *connect.Response[devicev1.SearchKeyResponse], result2 error) {
	fake.searchKeyMutex.Lock()
	defer fake.searchKeyMutex.Unlock()
	fake.SearchKeyStub = nil
	fake.searchKeyReturns = struct {
		result1 *connect.Response[devicev1.SearchKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) SearchKeyReturnsOnCall(i int, result1 *connect.Response[devicev1.SearchKeyResponse], result2 error) {
	fake.searchKeyMutex.Lock()
	defer fake.searchKeyMutex.Unlock()
	fake.SearchKeyStub = nil
	if fake.searchKeyReturnsOnCall == nil {
		fake.searchKeyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.SearchKeyResponse]
			result2 error
		})
	}
	fake.searchKeyReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.SearchKeyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Update(arg1 context.Context, arg2 *connect.Request[devicev1.UpdateRequest]) (*connect.Response[devicev1.UpdateResponse], error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.UpdateRequest]
	}{arg1, arg2})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeDeviceServiceHandler) UpdateCalls(stub func(context.Context, *connect.Request[devicev1.UpdateRequest]) (*connect.Response[devicev1.UpdateResponse], error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeDeviceServiceHandler) UpdateArgsForCall(i int) (context.Context, *connect.Request[devicev1.UpdateRequest]) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) UpdateReturns(result1 *connect.Response[devicev1.UpdateResponse], result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *connect.Response[devicev1.UpdateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) UpdateReturnsOnCall(i int, result1 *connect.Response[devicev1.UpdateResponse], result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.UpdateResponse]
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.UpdateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) UpdatePresence(arg1 context.Context, arg2 *connect.Request[devicev1.UpdatePresenceRequest]) (*connect.Response[devicev1.UpdatePresenceResponse], error) {
	fake.updatePresenceMutex.Lock()
	ret, specificReturn := fake.updatePresenceReturnsOnCall[len(fake.updatePresenceArgsForCall)]
	fake.updatePresenceArgsForCall = append(fake.updatePresenceArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[devicev1.UpdatePresenceRequest]
	}{arg1, arg2})
	stub := fake.UpdatePresenceStub
	fakeReturns := fake.updatePresenceReturns
	fake.recordInvocation("UpdatePresence", []interface{}{arg1, arg2})
	fake.updatePresenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDeviceServiceHandler) UpdatePresenceCallCount() int {
	fake.updatePresenceMutex.RLock()
	defer fake.updatePresenceMutex.RUnlock()
	return len(fake.updatePresenceArgsForCall)
}

func (fake *FakeDeviceServiceHandler) UpdatePresenceCalls(stub func(context.Context, *connect.Request[devicev1.UpdatePresenceRequest]) (*connect.Response[devicev1.UpdatePresenceResponse], error)) {
	fake.updatePresenceMutex.Lock()
	defer fake.updatePresenceMutex.Unlock()
	fake.UpdatePresenceStub = stub
}

func (fake *FakeDeviceServiceHandler) UpdatePresenceArgsForCall(i int) (context.Context, *connect.Request[devicev1.UpdatePresenceRequest]) {
	fake.updatePresenceMutex.RLock()
	defer fake.updatePresenceMutex.RUnlock()
	argsForCall := fake.updatePresenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDeviceServiceHandler) UpdatePresenceReturns(result1 *connect.Response[devicev1.UpdatePresenceResponse], result2 error) {
	fake.updatePresenceMutex.Lock()
	defer fake.updatePresenceMutex.Unlock()
	fake.UpdatePresenceStub = nil
	fake.updatePresenceReturns = struct {
		result1 *connect.Response[devicev1.UpdatePresenceResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) UpdatePresenceReturnsOnCall(i int, result1 *connect.Response[devicev1.UpdatePresenceResponse], result2 error) {
	fake.updatePresenceMutex.Lock()
	defer fake.updatePresenceMutex.Unlock()
	fake.UpdatePresenceStub = nil
	if fake.updatePresenceReturnsOnCall == nil {
		fake.updatePresenceReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[devicev1.UpdatePresenceResponse]
			result2 error
		})
	}
	fake.updatePresenceReturnsOnCall[i] = struct {
		result1 *connect.Response[devicev1.UpdatePresenceResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeDeviceServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDeviceServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ devicev1connect.DeviceServiceHandler = new(FakeDeviceServiceHandler)
