// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/device/connectrpc/go/device/v1/devicev1connect.DeviceServiceClient -o device_handler.gen.go -n DeviceServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/device/protocolbuffers/go/device/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// DeviceServiceClientMock implements mm_devicev1connect.DeviceServiceClient
type DeviceServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddKey          func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) (pp2 *connect.Response[v1.AddKeyResponse], err error)
	funcAddKeyOrigin    string
	inspectFuncAddKey   func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest])
	afterAddKeyCounter  uint64
	beforeAddKeyCounter uint64
	AddKeyMock          mDeviceServiceClientMockAddKey

	funcCreate          func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) (pp2 *connect.Response[v1.CreateResponse], err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest])
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mDeviceServiceClientMockCreate

	funcDeRegisterKey          func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) (pp2 *connect.Response[v1.DeRegisterKeyResponse], err error)
	funcDeRegisterKeyOrigin    string
	inspectFuncDeRegisterKey   func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest])
	afterDeRegisterKeyCounter  uint64
	beforeDeRegisterKeyCounter uint64
	DeRegisterKeyMock          mDeviceServiceClientMockDeRegisterKey

	funcGetById          func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) (pp2 *connect.Response[v1.GetByIdResponse], err error)
	funcGetByIdOrigin    string
	inspectFuncGetById   func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest])
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mDeviceServiceClientMockGetById

	funcGetBySessionId          func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) (pp2 *connect.Response[v1.GetBySessionIdResponse], err error)
	funcGetBySessionIdOrigin    string
	inspectFuncGetBySessionId   func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest])
	afterGetBySessionIdCounter  uint64
	beforeGetBySessionIdCounter uint64
	GetBySessionIdMock          mDeviceServiceClientMockGetBySessionId

	funcLink          func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) (pp2 *connect.Response[v1.LinkResponse], err error)
	funcLinkOrigin    string
	inspectFuncLink   func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest])
	afterLinkCounter  uint64
	beforeLinkCounter uint64
	LinkMock          mDeviceServiceClientMockLink

	funcListLogs          func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest]) (pp2 *connect.ServerStreamForClient[v1.ListLogsResponse], err error)
	funcListLogsOrigin    string
	inspectFuncListLogs   func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest])
	afterListLogsCounter  uint64
	beforeListLogsCounter uint64
	ListLogsMock          mDeviceServiceClientMockListLogs

	funcLog          func(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) (pp2 *connect.Response[v1.LogResponse], err error)
	funcLogOrigin    string
	inspectFuncLog   func(ctx context.Context, pp1 *connect.Request[v1.LogRequest])
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mDeviceServiceClientMockLog

	funcNotify          func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) (pp2 *connect.Response[v1.NotifyResponse], err error)
	funcNotifyOrigin    string
	inspectFuncNotify   func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest])
	afterNotifyCounter  uint64
	beforeNotifyCounter uint64
	NotifyMock          mDeviceServiceClientMockNotify

	funcRegisterKey          func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) (pp2 *connect.Response[v1.RegisterKeyResponse], err error)
	funcRegisterKeyOrigin    string
	inspectFuncRegisterKey   func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest])
	afterRegisterKeyCounter  uint64
	beforeRegisterKeyCounter uint64
	RegisterKeyMock          mDeviceServiceClientMockRegisterKey

	funcRemove          func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) (pp2 *connect.Response[v1.RemoveResponse], err error)
	funcRemoveOrigin    string
	inspectFuncRemove   func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest])
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mDeviceServiceClientMockRemove

	funcRemoveKey          func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) (pp2 *connect.Response[v1.RemoveKeyResponse], err error)
	funcRemoveKeyOrigin    string
	inspectFuncRemoveKey   func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest])
	afterRemoveKeyCounter  uint64
	beforeRemoveKeyCounter uint64
	RemoveKeyMock          mDeviceServiceClientMockRemoveKey

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mDeviceServiceClientMockSearch

	funcSearchKey          func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) (pp2 *connect.Response[v1.SearchKeyResponse], err error)
	funcSearchKeyOrigin    string
	inspectFuncSearchKey   func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest])
	afterSearchKeyCounter  uint64
	beforeSearchKeyCounter uint64
	SearchKeyMock          mDeviceServiceClientMockSearchKey

	funcUpdate          func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) (pp2 *connect.Response[v1.UpdateResponse], err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest])
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mDeviceServiceClientMockUpdate

	funcUpdatePresence          func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) (pp2 *connect.Response[v1.UpdatePresenceResponse], err error)
	funcUpdatePresenceOrigin    string
	inspectFuncUpdatePresence   func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest])
	afterUpdatePresenceCounter  uint64
	beforeUpdatePresenceCounter uint64
	UpdatePresenceMock          mDeviceServiceClientMockUpdatePresence
}

// NewDeviceServiceClientMock returns a mock for mm_devicev1connect.DeviceServiceClient
func NewDeviceServiceClientMock(t minimock.Tester) *DeviceServiceClientMock {
	m := &DeviceServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddKeyMock = mDeviceServiceClientMockAddKey{mock: m}
	m.AddKeyMock.callArgs = []*DeviceServiceClientMockAddKeyParams{}

	m.CreateMock = mDeviceServiceClientMockCreate{mock: m}
	m.CreateMock.callArgs = []*DeviceServiceClientMockCreateParams{}

	m.DeRegisterKeyMock = mDeviceServiceClientMockDeRegisterKey{mock: m}
	m.DeRegisterKeyMock.callArgs = []*DeviceServiceClientMockDeRegisterKeyParams{}

	m.GetByIdMock = mDeviceServiceClientMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*DeviceServiceClientMockGetByIdParams{}

	m.GetBySessionIdMock = mDeviceServiceClientMockGetBySessionId{mock: m}
	m.GetBySessionIdMock.callArgs = []*DeviceServiceClientMockGetBySessionIdParams{}

	m.LinkMock = mDeviceServiceClientMockLink{mock: m}
	m.LinkMock.callArgs = []*DeviceServiceClientMockLinkParams{}

	m.ListLogsMock = mDeviceServiceClientMockListLogs{mock: m}
	m.ListLogsMock.callArgs = []*DeviceServiceClientMockListLogsParams{}

	m.LogMock = mDeviceServiceClientMockLog{mock: m}
	m.LogMock.callArgs = []*DeviceServiceClientMockLogParams{}

	m.NotifyMock = mDeviceServiceClientMockNotify{mock: m}
	m.NotifyMock.callArgs = []*DeviceServiceClientMockNotifyParams{}

	m.RegisterKeyMock = mDeviceServiceClientMockRegisterKey{mock: m}
	m.RegisterKeyMock.callArgs = []*DeviceServiceClientMockRegisterKeyParams{}

	m.RemoveMock = mDeviceServiceClientMockRemove{mock: m}
	m.RemoveMock.callArgs = []*DeviceServiceClientMockRemoveParams{}

	m.RemoveKeyMock = mDeviceServiceClientMockRemoveKey{mock: m}
	m.RemoveKeyMock.callArgs = []*DeviceServiceClientMockRemoveKeyParams{}

	m.SearchMock = mDeviceServiceClientMockSearch{mock: m}
	m.SearchMock.callArgs = []*DeviceServiceClientMockSearchParams{}

	m.SearchKeyMock = mDeviceServiceClientMockSearchKey{mock: m}
	m.SearchKeyMock.callArgs = []*DeviceServiceClientMockSearchKeyParams{}

	m.UpdateMock = mDeviceServiceClientMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*DeviceServiceClientMockUpdateParams{}

	m.UpdatePresenceMock = mDeviceServiceClientMockUpdatePresence{mock: m}
	m.UpdatePresenceMock.callArgs = []*DeviceServiceClientMockUpdatePresenceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDeviceServiceClientMockAddKey struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockAddKeyExpectation
	expectations       []*DeviceServiceClientMockAddKeyExpectation

	callArgs []*DeviceServiceClientMockAddKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockAddKeyExpectation specifies expectation struct of the DeviceServiceClient.AddKey
type DeviceServiceClientMockAddKeyExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockAddKeyParams
	paramPtrs          *DeviceServiceClientMockAddKeyParamPtrs
	expectationOrigins DeviceServiceClientMockAddKeyExpectationOrigins
	results            *DeviceServiceClientMockAddKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockAddKeyParams contains parameters of the DeviceServiceClient.AddKey
type DeviceServiceClientMockAddKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddKeyRequest]
}

// DeviceServiceClientMockAddKeyParamPtrs contains pointers to parameters of the DeviceServiceClient.AddKey
type DeviceServiceClientMockAddKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddKeyRequest]
}

// DeviceServiceClientMockAddKeyResults contains results of the DeviceServiceClient.AddKey
type DeviceServiceClientMockAddKeyResults struct {
	pp2 *connect.Response[v1.AddKeyResponse]
	err error
}

// DeviceServiceClientMockAddKeyOrigins contains origins of expectations of the DeviceServiceClient.AddKey
type DeviceServiceClientMockAddKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddKey *mDeviceServiceClientMockAddKey) Optional() *mDeviceServiceClientMockAddKey {
	mmAddKey.optional = true
	return mmAddKey
}

// Expect sets up expected params for DeviceServiceClient.AddKey
func (mmAddKey *mDeviceServiceClientMockAddKey) Expect(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) *mDeviceServiceClientMockAddKey {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceClientMockAddKeyExpectation{}
	}

	if mmAddKey.defaultExpectation.paramPtrs != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by ExpectParams functions")
	}

	mmAddKey.defaultExpectation.params = &DeviceServiceClientMockAddKeyParams{ctx, pp1}
	mmAddKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddKey.expectations {
		if minimock.Equal(e.params, mmAddKey.defaultExpectation.params) {
			mmAddKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddKey.defaultExpectation.params)
		}
	}

	return mmAddKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.AddKey
func (mmAddKey *mDeviceServiceClientMockAddKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockAddKey {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceClientMockAddKeyExpectation{}
	}

	if mmAddKey.defaultExpectation.params != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Expect")
	}

	if mmAddKey.defaultExpectation.paramPtrs == nil {
		mmAddKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockAddKeyParamPtrs{}
	}
	mmAddKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.AddKey
func (mmAddKey *mDeviceServiceClientMockAddKey) ExpectPp1Param2(pp1 *connect.Request[v1.AddKeyRequest]) *mDeviceServiceClientMockAddKey {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceClientMockAddKeyExpectation{}
	}

	if mmAddKey.defaultExpectation.params != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Expect")
	}

	if mmAddKey.defaultExpectation.paramPtrs == nil {
		mmAddKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockAddKeyParamPtrs{}
	}
	mmAddKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.AddKey
func (mmAddKey *mDeviceServiceClientMockAddKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest])) *mDeviceServiceClientMockAddKey {
	if mmAddKey.mock.inspectFuncAddKey != nil {
		mmAddKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.AddKey")
	}

	mmAddKey.mock.inspectFuncAddKey = f

	return mmAddKey
}

// Return sets up results that will be returned by DeviceServiceClient.AddKey
func (mmAddKey *mDeviceServiceClientMockAddKey) Return(pp2 *connect.Response[v1.AddKeyResponse], err error) *DeviceServiceClientMock {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceClientMockAddKeyExpectation{mock: mmAddKey.mock}
	}
	mmAddKey.defaultExpectation.results = &DeviceServiceClientMockAddKeyResults{pp2, err}
	mmAddKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddKey.mock
}

// Set uses given function f to mock the DeviceServiceClient.AddKey method
func (mmAddKey *mDeviceServiceClientMockAddKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) (pp2 *connect.Response[v1.AddKeyResponse], err error)) *DeviceServiceClientMock {
	if mmAddKey.defaultExpectation != nil {
		mmAddKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.AddKey method")
	}

	if len(mmAddKey.expectations) > 0 {
		mmAddKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.AddKey method")
	}

	mmAddKey.mock.funcAddKey = f
	mmAddKey.mock.funcAddKeyOrigin = minimock.CallerInfo(1)
	return mmAddKey.mock
}

// When sets expectation for the DeviceServiceClient.AddKey which will trigger the result defined by the following
// Then helper
func (mmAddKey *mDeviceServiceClientMockAddKey) When(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) *DeviceServiceClientMockAddKeyExpectation {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceClientMock.AddKey mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockAddKeyExpectation{
		mock:               mmAddKey.mock,
		params:             &DeviceServiceClientMockAddKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockAddKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddKey.expectations = append(mmAddKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.AddKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockAddKeyExpectation) Then(pp2 *connect.Response[v1.AddKeyResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockAddKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.AddKey should be invoked
func (mmAddKey *mDeviceServiceClientMockAddKey) Times(n uint64) *mDeviceServiceClientMockAddKey {
	if n == 0 {
		mmAddKey.mock.t.Fatalf("Times of DeviceServiceClientMock.AddKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddKey.expectedInvocations, n)
	mmAddKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddKey
}

func (mmAddKey *mDeviceServiceClientMockAddKey) invocationsDone() bool {
	if len(mmAddKey.expectations) == 0 && mmAddKey.defaultExpectation == nil && mmAddKey.mock.funcAddKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddKey.mock.afterAddKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddKey implements mm_devicev1connect.DeviceServiceClient
func (mmAddKey *DeviceServiceClientMock) AddKey(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) (pp2 *connect.Response[v1.AddKeyResponse], err error) {
	mm_atomic.AddUint64(&mmAddKey.beforeAddKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddKey.afterAddKeyCounter, 1)

	mmAddKey.t.Helper()

	if mmAddKey.inspectFuncAddKey != nil {
		mmAddKey.inspectFuncAddKey(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockAddKeyParams{ctx, pp1}

	// Record call args
	mmAddKey.AddKeyMock.mutex.Lock()
	mmAddKey.AddKeyMock.callArgs = append(mmAddKey.AddKeyMock.callArgs, &mm_params)
	mmAddKey.AddKeyMock.mutex.Unlock()

	for _, e := range mmAddKey.AddKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddKey.AddKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddKey.AddKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddKey.AddKeyMock.defaultExpectation.params
		mm_want_ptrs := mmAddKey.AddKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockAddKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddKey.t.Errorf("DeviceServiceClientMock.AddKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddKey.AddKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddKey.t.Errorf("DeviceServiceClientMock.AddKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddKey.AddKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddKey.t.Errorf("DeviceServiceClientMock.AddKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddKey.AddKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddKey.AddKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddKey.t.Fatal("No results are set for the DeviceServiceClientMock.AddKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddKey.funcAddKey != nil {
		return mmAddKey.funcAddKey(ctx, pp1)
	}
	mmAddKey.t.Fatalf("Unexpected call to DeviceServiceClientMock.AddKey. %v %v", ctx, pp1)
	return
}

// AddKeyAfterCounter returns a count of finished DeviceServiceClientMock.AddKey invocations
func (mmAddKey *DeviceServiceClientMock) AddKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddKey.afterAddKeyCounter)
}

// AddKeyBeforeCounter returns a count of DeviceServiceClientMock.AddKey invocations
func (mmAddKey *DeviceServiceClientMock) AddKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddKey.beforeAddKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.AddKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddKey *mDeviceServiceClientMockAddKey) Calls() []*DeviceServiceClientMockAddKeyParams {
	mmAddKey.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockAddKeyParams, len(mmAddKey.callArgs))
	copy(argCopy, mmAddKey.callArgs)

	mmAddKey.mutex.RUnlock()

	return argCopy
}

// MinimockAddKeyDone returns true if the count of the AddKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockAddKeyDone() bool {
	if m.AddKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddKeyMock.invocationsDone()
}

// MinimockAddKeyInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockAddKeyInspect() {
	for _, e := range m.AddKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.AddKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddKeyCounter := mm_atomic.LoadUint64(&m.afterAddKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddKeyMock.defaultExpectation != nil && afterAddKeyCounter < 1 {
		if m.AddKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.AddKey at\n%s", m.AddKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.AddKey at\n%s with params: %#v", m.AddKeyMock.defaultExpectation.expectationOrigins.origin, *m.AddKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddKey != nil && afterAddKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.AddKey at\n%s", m.funcAddKeyOrigin)
	}

	if !m.AddKeyMock.invocationsDone() && afterAddKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.AddKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddKeyMock.expectedInvocations), m.AddKeyMock.expectedInvocationsOrigin, afterAddKeyCounter)
	}
}

type mDeviceServiceClientMockCreate struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockCreateExpectation
	expectations       []*DeviceServiceClientMockCreateExpectation

	callArgs []*DeviceServiceClientMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockCreateExpectation specifies expectation struct of the DeviceServiceClient.Create
type DeviceServiceClientMockCreateExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockCreateParams
	paramPtrs          *DeviceServiceClientMockCreateParamPtrs
	expectationOrigins DeviceServiceClientMockCreateExpectationOrigins
	results            *DeviceServiceClientMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockCreateParams contains parameters of the DeviceServiceClient.Create
type DeviceServiceClientMockCreateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateRequest]
}

// DeviceServiceClientMockCreateParamPtrs contains pointers to parameters of the DeviceServiceClient.Create
type DeviceServiceClientMockCreateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateRequest]
}

// DeviceServiceClientMockCreateResults contains results of the DeviceServiceClient.Create
type DeviceServiceClientMockCreateResults struct {
	pp2 *connect.Response[v1.CreateResponse]
	err error
}

// DeviceServiceClientMockCreateOrigins contains origins of expectations of the DeviceServiceClient.Create
type DeviceServiceClientMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mDeviceServiceClientMockCreate) Optional() *mDeviceServiceClientMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for DeviceServiceClient.Create
func (mmCreate *mDeviceServiceClientMockCreate) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) *mDeviceServiceClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &DeviceServiceClientMockCreateParams{ctx, pp1}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Create
func (mmCreate *mDeviceServiceClientMockCreate) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &DeviceServiceClientMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Create
func (mmCreate *mDeviceServiceClientMockCreate) ExpectPp1Param2(pp1 *connect.Request[v1.CreateRequest]) *mDeviceServiceClientMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceClientMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &DeviceServiceClientMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Create
func (mmCreate *mDeviceServiceClientMockCreate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest])) *mDeviceServiceClientMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by DeviceServiceClient.Create
func (mmCreate *mDeviceServiceClientMockCreate) Return(pp2 *connect.Response[v1.CreateResponse], err error) *DeviceServiceClientMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceClientMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &DeviceServiceClientMockCreateResults{pp2, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the DeviceServiceClient.Create method
func (mmCreate *mDeviceServiceClientMockCreate) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) (pp2 *connect.Response[v1.CreateResponse], err error)) *DeviceServiceClientMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the DeviceServiceClient.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mDeviceServiceClientMockCreate) When(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) *DeviceServiceClientMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceClientMock.Create mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &DeviceServiceClientMockCreateParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Create return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockCreateExpectation) Then(pp2 *connect.Response[v1.CreateResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockCreateResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Create should be invoked
func (mmCreate *mDeviceServiceClientMockCreate) Times(n uint64) *mDeviceServiceClientMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of DeviceServiceClientMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mDeviceServiceClientMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_devicev1connect.DeviceServiceClient
func (mmCreate *DeviceServiceClientMock) Create(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) (pp2 *connect.Response[v1.CreateResponse], err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockCreateParams{ctx, pp1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockCreateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("DeviceServiceClientMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreate.t.Errorf("DeviceServiceClientMock.Create got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("DeviceServiceClientMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the DeviceServiceClientMock.Create")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, pp1)
	}
	mmCreate.t.Fatalf("Unexpected call to DeviceServiceClientMock.Create. %v %v", ctx, pp1)
	return
}

// CreateAfterCounter returns a count of finished DeviceServiceClientMock.Create invocations
func (mmCreate *DeviceServiceClientMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of DeviceServiceClientMock.Create invocations
func (mmCreate *DeviceServiceClientMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mDeviceServiceClientMockCreate) Calls() []*DeviceServiceClientMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mDeviceServiceClientMockDeRegisterKey struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockDeRegisterKeyExpectation
	expectations       []*DeviceServiceClientMockDeRegisterKeyExpectation

	callArgs []*DeviceServiceClientMockDeRegisterKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockDeRegisterKeyExpectation specifies expectation struct of the DeviceServiceClient.DeRegisterKey
type DeviceServiceClientMockDeRegisterKeyExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockDeRegisterKeyParams
	paramPtrs          *DeviceServiceClientMockDeRegisterKeyParamPtrs
	expectationOrigins DeviceServiceClientMockDeRegisterKeyExpectationOrigins
	results            *DeviceServiceClientMockDeRegisterKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockDeRegisterKeyParams contains parameters of the DeviceServiceClient.DeRegisterKey
type DeviceServiceClientMockDeRegisterKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeRegisterKeyRequest]
}

// DeviceServiceClientMockDeRegisterKeyParamPtrs contains pointers to parameters of the DeviceServiceClient.DeRegisterKey
type DeviceServiceClientMockDeRegisterKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeRegisterKeyRequest]
}

// DeviceServiceClientMockDeRegisterKeyResults contains results of the DeviceServiceClient.DeRegisterKey
type DeviceServiceClientMockDeRegisterKeyResults struct {
	pp2 *connect.Response[v1.DeRegisterKeyResponse]
	err error
}

// DeviceServiceClientMockDeRegisterKeyOrigins contains origins of expectations of the DeviceServiceClient.DeRegisterKey
type DeviceServiceClientMockDeRegisterKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Optional() *mDeviceServiceClientMockDeRegisterKey {
	mmDeRegisterKey.optional = true
	return mmDeRegisterKey
}

// Expect sets up expected params for DeviceServiceClient.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Expect(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) *mDeviceServiceClientMockDeRegisterKey {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceClientMockDeRegisterKeyExpectation{}
	}

	if mmDeRegisterKey.defaultExpectation.paramPtrs != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by ExpectParams functions")
	}

	mmDeRegisterKey.defaultExpectation.params = &DeviceServiceClientMockDeRegisterKeyParams{ctx, pp1}
	mmDeRegisterKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeRegisterKey.expectations {
		if minimock.Equal(e.params, mmDeRegisterKey.defaultExpectation.params) {
			mmDeRegisterKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeRegisterKey.defaultExpectation.params)
		}
	}

	return mmDeRegisterKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockDeRegisterKey {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceClientMockDeRegisterKeyExpectation{}
	}

	if mmDeRegisterKey.defaultExpectation.params != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Expect")
	}

	if mmDeRegisterKey.defaultExpectation.paramPtrs == nil {
		mmDeRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockDeRegisterKeyParamPtrs{}
	}
	mmDeRegisterKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeRegisterKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeRegisterKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) ExpectPp1Param2(pp1 *connect.Request[v1.DeRegisterKeyRequest]) *mDeviceServiceClientMockDeRegisterKey {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceClientMockDeRegisterKeyExpectation{}
	}

	if mmDeRegisterKey.defaultExpectation.params != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Expect")
	}

	if mmDeRegisterKey.defaultExpectation.paramPtrs == nil {
		mmDeRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockDeRegisterKeyParamPtrs{}
	}
	mmDeRegisterKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeRegisterKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeRegisterKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest])) *mDeviceServiceClientMockDeRegisterKey {
	if mmDeRegisterKey.mock.inspectFuncDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.DeRegisterKey")
	}

	mmDeRegisterKey.mock.inspectFuncDeRegisterKey = f

	return mmDeRegisterKey
}

// Return sets up results that will be returned by DeviceServiceClient.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Return(pp2 *connect.Response[v1.DeRegisterKeyResponse], err error) *DeviceServiceClientMock {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceClientMockDeRegisterKeyExpectation{mock: mmDeRegisterKey.mock}
	}
	mmDeRegisterKey.defaultExpectation.results = &DeviceServiceClientMockDeRegisterKeyResults{pp2, err}
	mmDeRegisterKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeRegisterKey.mock
}

// Set uses given function f to mock the DeviceServiceClient.DeRegisterKey method
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) (pp2 *connect.Response[v1.DeRegisterKeyResponse], err error)) *DeviceServiceClientMock {
	if mmDeRegisterKey.defaultExpectation != nil {
		mmDeRegisterKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.DeRegisterKey method")
	}

	if len(mmDeRegisterKey.expectations) > 0 {
		mmDeRegisterKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.DeRegisterKey method")
	}

	mmDeRegisterKey.mock.funcDeRegisterKey = f
	mmDeRegisterKey.mock.funcDeRegisterKeyOrigin = minimock.CallerInfo(1)
	return mmDeRegisterKey.mock
}

// When sets expectation for the DeviceServiceClient.DeRegisterKey which will trigger the result defined by the following
// Then helper
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) When(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) *DeviceServiceClientMockDeRegisterKeyExpectation {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.DeRegisterKey mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockDeRegisterKeyExpectation{
		mock:               mmDeRegisterKey.mock,
		params:             &DeviceServiceClientMockDeRegisterKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockDeRegisterKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeRegisterKey.expectations = append(mmDeRegisterKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.DeRegisterKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockDeRegisterKeyExpectation) Then(pp2 *connect.Response[v1.DeRegisterKeyResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockDeRegisterKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.DeRegisterKey should be invoked
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Times(n uint64) *mDeviceServiceClientMockDeRegisterKey {
	if n == 0 {
		mmDeRegisterKey.mock.t.Fatalf("Times of DeviceServiceClientMock.DeRegisterKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeRegisterKey.expectedInvocations, n)
	mmDeRegisterKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeRegisterKey
}

func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) invocationsDone() bool {
	if len(mmDeRegisterKey.expectations) == 0 && mmDeRegisterKey.defaultExpectation == nil && mmDeRegisterKey.mock.funcDeRegisterKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeRegisterKey.mock.afterDeRegisterKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeRegisterKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeRegisterKey implements mm_devicev1connect.DeviceServiceClient
func (mmDeRegisterKey *DeviceServiceClientMock) DeRegisterKey(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) (pp2 *connect.Response[v1.DeRegisterKeyResponse], err error) {
	mm_atomic.AddUint64(&mmDeRegisterKey.beforeDeRegisterKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmDeRegisterKey.afterDeRegisterKeyCounter, 1)

	mmDeRegisterKey.t.Helper()

	if mmDeRegisterKey.inspectFuncDeRegisterKey != nil {
		mmDeRegisterKey.inspectFuncDeRegisterKey(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockDeRegisterKeyParams{ctx, pp1}

	// Record call args
	mmDeRegisterKey.DeRegisterKeyMock.mutex.Lock()
	mmDeRegisterKey.DeRegisterKeyMock.callArgs = append(mmDeRegisterKey.DeRegisterKeyMock.callArgs, &mm_params)
	mmDeRegisterKey.DeRegisterKeyMock.mutex.Unlock()

	for _, e := range mmDeRegisterKey.DeRegisterKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.params
		mm_want_ptrs := mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockDeRegisterKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeRegisterKey.t.Errorf("DeviceServiceClientMock.DeRegisterKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeRegisterKey.t.Errorf("DeviceServiceClientMock.DeRegisterKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeRegisterKey.t.Errorf("DeviceServiceClientMock.DeRegisterKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmDeRegisterKey.t.Fatal("No results are set for the DeviceServiceClientMock.DeRegisterKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeRegisterKey.funcDeRegisterKey != nil {
		return mmDeRegisterKey.funcDeRegisterKey(ctx, pp1)
	}
	mmDeRegisterKey.t.Fatalf("Unexpected call to DeviceServiceClientMock.DeRegisterKey. %v %v", ctx, pp1)
	return
}

// DeRegisterKeyAfterCounter returns a count of finished DeviceServiceClientMock.DeRegisterKey invocations
func (mmDeRegisterKey *DeviceServiceClientMock) DeRegisterKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeRegisterKey.afterDeRegisterKeyCounter)
}

// DeRegisterKeyBeforeCounter returns a count of DeviceServiceClientMock.DeRegisterKey invocations
func (mmDeRegisterKey *DeviceServiceClientMock) DeRegisterKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeRegisterKey.beforeDeRegisterKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.DeRegisterKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeRegisterKey *mDeviceServiceClientMockDeRegisterKey) Calls() []*DeviceServiceClientMockDeRegisterKeyParams {
	mmDeRegisterKey.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockDeRegisterKeyParams, len(mmDeRegisterKey.callArgs))
	copy(argCopy, mmDeRegisterKey.callArgs)

	mmDeRegisterKey.mutex.RUnlock()

	return argCopy
}

// MinimockDeRegisterKeyDone returns true if the count of the DeRegisterKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockDeRegisterKeyDone() bool {
	if m.DeRegisterKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeRegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeRegisterKeyMock.invocationsDone()
}

// MinimockDeRegisterKeyInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockDeRegisterKeyInspect() {
	for _, e := range m.DeRegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.DeRegisterKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeRegisterKeyCounter := mm_atomic.LoadUint64(&m.afterDeRegisterKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeRegisterKeyMock.defaultExpectation != nil && afterDeRegisterKeyCounter < 1 {
		if m.DeRegisterKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.DeRegisterKey at\n%s", m.DeRegisterKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.DeRegisterKey at\n%s with params: %#v", m.DeRegisterKeyMock.defaultExpectation.expectationOrigins.origin, *m.DeRegisterKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeRegisterKey != nil && afterDeRegisterKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.DeRegisterKey at\n%s", m.funcDeRegisterKeyOrigin)
	}

	if !m.DeRegisterKeyMock.invocationsDone() && afterDeRegisterKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.DeRegisterKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeRegisterKeyMock.expectedInvocations), m.DeRegisterKeyMock.expectedInvocationsOrigin, afterDeRegisterKeyCounter)
	}
}

type mDeviceServiceClientMockGetById struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockGetByIdExpectation
	expectations       []*DeviceServiceClientMockGetByIdExpectation

	callArgs []*DeviceServiceClientMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockGetByIdExpectation specifies expectation struct of the DeviceServiceClient.GetById
type DeviceServiceClientMockGetByIdExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockGetByIdParams
	paramPtrs          *DeviceServiceClientMockGetByIdParamPtrs
	expectationOrigins DeviceServiceClientMockGetByIdExpectationOrigins
	results            *DeviceServiceClientMockGetByIdResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockGetByIdParams contains parameters of the DeviceServiceClient.GetById
type DeviceServiceClientMockGetByIdParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetByIdRequest]
}

// DeviceServiceClientMockGetByIdParamPtrs contains pointers to parameters of the DeviceServiceClient.GetById
type DeviceServiceClientMockGetByIdParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetByIdRequest]
}

// DeviceServiceClientMockGetByIdResults contains results of the DeviceServiceClient.GetById
type DeviceServiceClientMockGetByIdResults struct {
	pp2 *connect.Response[v1.GetByIdResponse]
	err error
}

// DeviceServiceClientMockGetByIdOrigins contains origins of expectations of the DeviceServiceClient.GetById
type DeviceServiceClientMockGetByIdExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mDeviceServiceClientMockGetById) Optional() *mDeviceServiceClientMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for DeviceServiceClient.GetById
func (mmGetById *mDeviceServiceClientMockGetById) Expect(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) *mDeviceServiceClientMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceClientMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &DeviceServiceClientMockGetByIdParams{ctx, pp1}
	mmGetById.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.GetById
func (mmGetById *mDeviceServiceClientMockGetById) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceClientMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &DeviceServiceClientMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetById.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetById
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.GetById
func (mmGetById *mDeviceServiceClientMockGetById) ExpectPp1Param2(pp1 *connect.Request[v1.GetByIdRequest]) *mDeviceServiceClientMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceClientMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &DeviceServiceClientMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetById.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.GetById
func (mmGetById *mDeviceServiceClientMockGetById) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest])) *mDeviceServiceClientMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by DeviceServiceClient.GetById
func (mmGetById *mDeviceServiceClientMockGetById) Return(pp2 *connect.Response[v1.GetByIdResponse], err error) *DeviceServiceClientMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceClientMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &DeviceServiceClientMockGetByIdResults{pp2, err}
	mmGetById.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// Set uses given function f to mock the DeviceServiceClient.GetById method
func (mmGetById *mDeviceServiceClientMockGetById) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) (pp2 *connect.Response[v1.GetByIdResponse], err error)) *DeviceServiceClientMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.GetById method")
	}

	mmGetById.mock.funcGetById = f
	mmGetById.mock.funcGetByIdOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// When sets expectation for the DeviceServiceClient.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mDeviceServiceClientMockGetById) When(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) *DeviceServiceClientMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceClientMock.GetById mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockGetByIdExpectation{
		mock:               mmGetById.mock,
		params:             &DeviceServiceClientMockGetByIdParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockGetByIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.GetById return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockGetByIdExpectation) Then(pp2 *connect.Response[v1.GetByIdResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockGetByIdResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.GetById should be invoked
func (mmGetById *mDeviceServiceClientMockGetById) Times(n uint64) *mDeviceServiceClientMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of DeviceServiceClientMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	mmGetById.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetById
}

func (mmGetById *mDeviceServiceClientMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements mm_devicev1connect.DeviceServiceClient
func (mmGetById *DeviceServiceClientMock) GetById(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) (pp2 *connect.Response[v1.GetByIdResponse], err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	mmGetById.t.Helper()

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockGetByIdParams{ctx, pp1}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockGetByIdParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("DeviceServiceClientMock.GetById got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetById.t.Errorf("DeviceServiceClientMock.GetById got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("DeviceServiceClientMock.GetById got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the DeviceServiceClientMock.GetById")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, pp1)
	}
	mmGetById.t.Fatalf("Unexpected call to DeviceServiceClientMock.GetById. %v %v", ctx, pp1)
	return
}

// GetByIdAfterCounter returns a count of finished DeviceServiceClientMock.GetById invocations
func (mmGetById *DeviceServiceClientMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of DeviceServiceClientMock.GetById invocations
func (mmGetById *DeviceServiceClientMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mDeviceServiceClientMockGetById) Calls() []*DeviceServiceClientMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.GetById at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.GetById at\n%s", m.GetByIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.GetById at\n%s with params: %#v", m.GetByIdMock.defaultExpectation.expectationOrigins.origin, *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.GetById at\n%s", m.funcGetByIdOrigin)
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.GetById at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), m.GetByIdMock.expectedInvocationsOrigin, afterGetByIdCounter)
	}
}

type mDeviceServiceClientMockGetBySessionId struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockGetBySessionIdExpectation
	expectations       []*DeviceServiceClientMockGetBySessionIdExpectation

	callArgs []*DeviceServiceClientMockGetBySessionIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockGetBySessionIdExpectation specifies expectation struct of the DeviceServiceClient.GetBySessionId
type DeviceServiceClientMockGetBySessionIdExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockGetBySessionIdParams
	paramPtrs          *DeviceServiceClientMockGetBySessionIdParamPtrs
	expectationOrigins DeviceServiceClientMockGetBySessionIdExpectationOrigins
	results            *DeviceServiceClientMockGetBySessionIdResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockGetBySessionIdParams contains parameters of the DeviceServiceClient.GetBySessionId
type DeviceServiceClientMockGetBySessionIdParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetBySessionIdRequest]
}

// DeviceServiceClientMockGetBySessionIdParamPtrs contains pointers to parameters of the DeviceServiceClient.GetBySessionId
type DeviceServiceClientMockGetBySessionIdParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetBySessionIdRequest]
}

// DeviceServiceClientMockGetBySessionIdResults contains results of the DeviceServiceClient.GetBySessionId
type DeviceServiceClientMockGetBySessionIdResults struct {
	pp2 *connect.Response[v1.GetBySessionIdResponse]
	err error
}

// DeviceServiceClientMockGetBySessionIdOrigins contains origins of expectations of the DeviceServiceClient.GetBySessionId
type DeviceServiceClientMockGetBySessionIdExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Optional() *mDeviceServiceClientMockGetBySessionId {
	mmGetBySessionId.optional = true
	return mmGetBySessionId
}

// Expect sets up expected params for DeviceServiceClient.GetBySessionId
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Expect(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) *mDeviceServiceClientMockGetBySessionId {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceClientMockGetBySessionIdExpectation{}
	}

	if mmGetBySessionId.defaultExpectation.paramPtrs != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by ExpectParams functions")
	}

	mmGetBySessionId.defaultExpectation.params = &DeviceServiceClientMockGetBySessionIdParams{ctx, pp1}
	mmGetBySessionId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySessionId.expectations {
		if minimock.Equal(e.params, mmGetBySessionId.defaultExpectation.params) {
			mmGetBySessionId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySessionId.defaultExpectation.params)
		}
	}

	return mmGetBySessionId
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.GetBySessionId
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockGetBySessionId {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceClientMockGetBySessionIdExpectation{}
	}

	if mmGetBySessionId.defaultExpectation.params != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Expect")
	}

	if mmGetBySessionId.defaultExpectation.paramPtrs == nil {
		mmGetBySessionId.defaultExpectation.paramPtrs = &DeviceServiceClientMockGetBySessionIdParamPtrs{}
	}
	mmGetBySessionId.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySessionId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySessionId
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.GetBySessionId
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) ExpectPp1Param2(pp1 *connect.Request[v1.GetBySessionIdRequest]) *mDeviceServiceClientMockGetBySessionId {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceClientMockGetBySessionIdExpectation{}
	}

	if mmGetBySessionId.defaultExpectation.params != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Expect")
	}

	if mmGetBySessionId.defaultExpectation.paramPtrs == nil {
		mmGetBySessionId.defaultExpectation.paramPtrs = &DeviceServiceClientMockGetBySessionIdParamPtrs{}
	}
	mmGetBySessionId.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetBySessionId.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetBySessionId
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.GetBySessionId
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest])) *mDeviceServiceClientMockGetBySessionId {
	if mmGetBySessionId.mock.inspectFuncGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.GetBySessionId")
	}

	mmGetBySessionId.mock.inspectFuncGetBySessionId = f

	return mmGetBySessionId
}

// Return sets up results that will be returned by DeviceServiceClient.GetBySessionId
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Return(pp2 *connect.Response[v1.GetBySessionIdResponse], err error) *DeviceServiceClientMock {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceClientMockGetBySessionIdExpectation{mock: mmGetBySessionId.mock}
	}
	mmGetBySessionId.defaultExpectation.results = &DeviceServiceClientMockGetBySessionIdResults{pp2, err}
	mmGetBySessionId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySessionId.mock
}

// Set uses given function f to mock the DeviceServiceClient.GetBySessionId method
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) (pp2 *connect.Response[v1.GetBySessionIdResponse], err error)) *DeviceServiceClientMock {
	if mmGetBySessionId.defaultExpectation != nil {
		mmGetBySessionId.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.GetBySessionId method")
	}

	if len(mmGetBySessionId.expectations) > 0 {
		mmGetBySessionId.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.GetBySessionId method")
	}

	mmGetBySessionId.mock.funcGetBySessionId = f
	mmGetBySessionId.mock.funcGetBySessionIdOrigin = minimock.CallerInfo(1)
	return mmGetBySessionId.mock
}

// When sets expectation for the DeviceServiceClient.GetBySessionId which will trigger the result defined by the following
// Then helper
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) When(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) *DeviceServiceClientMockGetBySessionIdExpectation {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceClientMock.GetBySessionId mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockGetBySessionIdExpectation{
		mock:               mmGetBySessionId.mock,
		params:             &DeviceServiceClientMockGetBySessionIdParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockGetBySessionIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySessionId.expectations = append(mmGetBySessionId.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.GetBySessionId return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockGetBySessionIdExpectation) Then(pp2 *connect.Response[v1.GetBySessionIdResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockGetBySessionIdResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.GetBySessionId should be invoked
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Times(n uint64) *mDeviceServiceClientMockGetBySessionId {
	if n == 0 {
		mmGetBySessionId.mock.t.Fatalf("Times of DeviceServiceClientMock.GetBySessionId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySessionId.expectedInvocations, n)
	mmGetBySessionId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySessionId
}

func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) invocationsDone() bool {
	if len(mmGetBySessionId.expectations) == 0 && mmGetBySessionId.defaultExpectation == nil && mmGetBySessionId.mock.funcGetBySessionId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySessionId.mock.afterGetBySessionIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySessionId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySessionId implements mm_devicev1connect.DeviceServiceClient
func (mmGetBySessionId *DeviceServiceClientMock) GetBySessionId(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) (pp2 *connect.Response[v1.GetBySessionIdResponse], err error) {
	mm_atomic.AddUint64(&mmGetBySessionId.beforeGetBySessionIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySessionId.afterGetBySessionIdCounter, 1)

	mmGetBySessionId.t.Helper()

	if mmGetBySessionId.inspectFuncGetBySessionId != nil {
		mmGetBySessionId.inspectFuncGetBySessionId(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockGetBySessionIdParams{ctx, pp1}

	// Record call args
	mmGetBySessionId.GetBySessionIdMock.mutex.Lock()
	mmGetBySessionId.GetBySessionIdMock.callArgs = append(mmGetBySessionId.GetBySessionIdMock.callArgs, &mm_params)
	mmGetBySessionId.GetBySessionIdMock.mutex.Unlock()

	for _, e := range mmGetBySessionId.GetBySessionIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetBySessionId.GetBySessionIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySessionId.GetBySessionIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySessionId.GetBySessionIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySessionId.GetBySessionIdMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockGetBySessionIdParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySessionId.t.Errorf("DeviceServiceClientMock.GetBySessionId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySessionId.GetBySessionIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetBySessionId.t.Errorf("DeviceServiceClientMock.GetBySessionId got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySessionId.GetBySessionIdMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySessionId.t.Errorf("DeviceServiceClientMock.GetBySessionId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySessionId.GetBySessionIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySessionId.GetBySessionIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySessionId.t.Fatal("No results are set for the DeviceServiceClientMock.GetBySessionId")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetBySessionId.funcGetBySessionId != nil {
		return mmGetBySessionId.funcGetBySessionId(ctx, pp1)
	}
	mmGetBySessionId.t.Fatalf("Unexpected call to DeviceServiceClientMock.GetBySessionId. %v %v", ctx, pp1)
	return
}

// GetBySessionIdAfterCounter returns a count of finished DeviceServiceClientMock.GetBySessionId invocations
func (mmGetBySessionId *DeviceServiceClientMock) GetBySessionIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySessionId.afterGetBySessionIdCounter)
}

// GetBySessionIdBeforeCounter returns a count of DeviceServiceClientMock.GetBySessionId invocations
func (mmGetBySessionId *DeviceServiceClientMock) GetBySessionIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySessionId.beforeGetBySessionIdCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.GetBySessionId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySessionId *mDeviceServiceClientMockGetBySessionId) Calls() []*DeviceServiceClientMockGetBySessionIdParams {
	mmGetBySessionId.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockGetBySessionIdParams, len(mmGetBySessionId.callArgs))
	copy(argCopy, mmGetBySessionId.callArgs)

	mmGetBySessionId.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySessionIdDone returns true if the count of the GetBySessionId invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockGetBySessionIdDone() bool {
	if m.GetBySessionIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySessionIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySessionIdMock.invocationsDone()
}

// MinimockGetBySessionIdInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockGetBySessionIdInspect() {
	for _, e := range m.GetBySessionIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.GetBySessionId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySessionIdCounter := mm_atomic.LoadUint64(&m.afterGetBySessionIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySessionIdMock.defaultExpectation != nil && afterGetBySessionIdCounter < 1 {
		if m.GetBySessionIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.GetBySessionId at\n%s", m.GetBySessionIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.GetBySessionId at\n%s with params: %#v", m.GetBySessionIdMock.defaultExpectation.expectationOrigins.origin, *m.GetBySessionIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySessionId != nil && afterGetBySessionIdCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.GetBySessionId at\n%s", m.funcGetBySessionIdOrigin)
	}

	if !m.GetBySessionIdMock.invocationsDone() && afterGetBySessionIdCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.GetBySessionId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySessionIdMock.expectedInvocations), m.GetBySessionIdMock.expectedInvocationsOrigin, afterGetBySessionIdCounter)
	}
}

type mDeviceServiceClientMockLink struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockLinkExpectation
	expectations       []*DeviceServiceClientMockLinkExpectation

	callArgs []*DeviceServiceClientMockLinkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockLinkExpectation specifies expectation struct of the DeviceServiceClient.Link
type DeviceServiceClientMockLinkExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockLinkParams
	paramPtrs          *DeviceServiceClientMockLinkParamPtrs
	expectationOrigins DeviceServiceClientMockLinkExpectationOrigins
	results            *DeviceServiceClientMockLinkResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockLinkParams contains parameters of the DeviceServiceClient.Link
type DeviceServiceClientMockLinkParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.LinkRequest]
}

// DeviceServiceClientMockLinkParamPtrs contains pointers to parameters of the DeviceServiceClient.Link
type DeviceServiceClientMockLinkParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.LinkRequest]
}

// DeviceServiceClientMockLinkResults contains results of the DeviceServiceClient.Link
type DeviceServiceClientMockLinkResults struct {
	pp2 *connect.Response[v1.LinkResponse]
	err error
}

// DeviceServiceClientMockLinkOrigins contains origins of expectations of the DeviceServiceClient.Link
type DeviceServiceClientMockLinkExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLink *mDeviceServiceClientMockLink) Optional() *mDeviceServiceClientMockLink {
	mmLink.optional = true
	return mmLink
}

// Expect sets up expected params for DeviceServiceClient.Link
func (mmLink *mDeviceServiceClientMockLink) Expect(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) *mDeviceServiceClientMockLink {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceClientMockLinkExpectation{}
	}

	if mmLink.defaultExpectation.paramPtrs != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by ExpectParams functions")
	}

	mmLink.defaultExpectation.params = &DeviceServiceClientMockLinkParams{ctx, pp1}
	mmLink.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLink.expectations {
		if minimock.Equal(e.params, mmLink.defaultExpectation.params) {
			mmLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLink.defaultExpectation.params)
		}
	}

	return mmLink
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Link
func (mmLink *mDeviceServiceClientMockLink) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockLink {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceClientMockLinkExpectation{}
	}

	if mmLink.defaultExpectation.params != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Expect")
	}

	if mmLink.defaultExpectation.paramPtrs == nil {
		mmLink.defaultExpectation.paramPtrs = &DeviceServiceClientMockLinkParamPtrs{}
	}
	mmLink.defaultExpectation.paramPtrs.ctx = &ctx
	mmLink.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLink
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Link
func (mmLink *mDeviceServiceClientMockLink) ExpectPp1Param2(pp1 *connect.Request[v1.LinkRequest]) *mDeviceServiceClientMockLink {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceClientMockLinkExpectation{}
	}

	if mmLink.defaultExpectation.params != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Expect")
	}

	if mmLink.defaultExpectation.paramPtrs == nil {
		mmLink.defaultExpectation.paramPtrs = &DeviceServiceClientMockLinkParamPtrs{}
	}
	mmLink.defaultExpectation.paramPtrs.pp1 = &pp1
	mmLink.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmLink
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Link
func (mmLink *mDeviceServiceClientMockLink) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest])) *mDeviceServiceClientMockLink {
	if mmLink.mock.inspectFuncLink != nil {
		mmLink.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Link")
	}

	mmLink.mock.inspectFuncLink = f

	return mmLink
}

// Return sets up results that will be returned by DeviceServiceClient.Link
func (mmLink *mDeviceServiceClientMockLink) Return(pp2 *connect.Response[v1.LinkResponse], err error) *DeviceServiceClientMock {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceClientMockLinkExpectation{mock: mmLink.mock}
	}
	mmLink.defaultExpectation.results = &DeviceServiceClientMockLinkResults{pp2, err}
	mmLink.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLink.mock
}

// Set uses given function f to mock the DeviceServiceClient.Link method
func (mmLink *mDeviceServiceClientMockLink) Set(f func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) (pp2 *connect.Response[v1.LinkResponse], err error)) *DeviceServiceClientMock {
	if mmLink.defaultExpectation != nil {
		mmLink.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Link method")
	}

	if len(mmLink.expectations) > 0 {
		mmLink.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Link method")
	}

	mmLink.mock.funcLink = f
	mmLink.mock.funcLinkOrigin = minimock.CallerInfo(1)
	return mmLink.mock
}

// When sets expectation for the DeviceServiceClient.Link which will trigger the result defined by the following
// Then helper
func (mmLink *mDeviceServiceClientMockLink) When(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) *DeviceServiceClientMockLinkExpectation {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceClientMock.Link mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockLinkExpectation{
		mock:               mmLink.mock,
		params:             &DeviceServiceClientMockLinkParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockLinkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLink.expectations = append(mmLink.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Link return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockLinkExpectation) Then(pp2 *connect.Response[v1.LinkResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockLinkResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Link should be invoked
func (mmLink *mDeviceServiceClientMockLink) Times(n uint64) *mDeviceServiceClientMockLink {
	if n == 0 {
		mmLink.mock.t.Fatalf("Times of DeviceServiceClientMock.Link mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLink.expectedInvocations, n)
	mmLink.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLink
}

func (mmLink *mDeviceServiceClientMockLink) invocationsDone() bool {
	if len(mmLink.expectations) == 0 && mmLink.defaultExpectation == nil && mmLink.mock.funcLink == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLink.mock.afterLinkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLink.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Link implements mm_devicev1connect.DeviceServiceClient
func (mmLink *DeviceServiceClientMock) Link(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) (pp2 *connect.Response[v1.LinkResponse], err error) {
	mm_atomic.AddUint64(&mmLink.beforeLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmLink.afterLinkCounter, 1)

	mmLink.t.Helper()

	if mmLink.inspectFuncLink != nil {
		mmLink.inspectFuncLink(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockLinkParams{ctx, pp1}

	// Record call args
	mmLink.LinkMock.mutex.Lock()
	mmLink.LinkMock.callArgs = append(mmLink.LinkMock.callArgs, &mm_params)
	mmLink.LinkMock.mutex.Unlock()

	for _, e := range mmLink.LinkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmLink.LinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLink.LinkMock.defaultExpectation.Counter, 1)
		mm_want := mmLink.LinkMock.defaultExpectation.params
		mm_want_ptrs := mmLink.LinkMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockLinkParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLink.t.Errorf("DeviceServiceClientMock.Link got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLink.LinkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmLink.t.Errorf("DeviceServiceClientMock.Link got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLink.LinkMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLink.t.Errorf("DeviceServiceClientMock.Link got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLink.LinkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLink.LinkMock.defaultExpectation.results
		if mm_results == nil {
			mmLink.t.Fatal("No results are set for the DeviceServiceClientMock.Link")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmLink.funcLink != nil {
		return mmLink.funcLink(ctx, pp1)
	}
	mmLink.t.Fatalf("Unexpected call to DeviceServiceClientMock.Link. %v %v", ctx, pp1)
	return
}

// LinkAfterCounter returns a count of finished DeviceServiceClientMock.Link invocations
func (mmLink *DeviceServiceClientMock) LinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLink.afterLinkCounter)
}

// LinkBeforeCounter returns a count of DeviceServiceClientMock.Link invocations
func (mmLink *DeviceServiceClientMock) LinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLink.beforeLinkCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Link.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLink *mDeviceServiceClientMockLink) Calls() []*DeviceServiceClientMockLinkParams {
	mmLink.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockLinkParams, len(mmLink.callArgs))
	copy(argCopy, mmLink.callArgs)

	mmLink.mutex.RUnlock()

	return argCopy
}

// MinimockLinkDone returns true if the count of the Link invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockLinkDone() bool {
	if m.LinkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LinkMock.invocationsDone()
}

// MinimockLinkInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockLinkInspect() {
	for _, e := range m.LinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Link at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLinkCounter := mm_atomic.LoadUint64(&m.afterLinkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LinkMock.defaultExpectation != nil && afterLinkCounter < 1 {
		if m.LinkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Link at\n%s", m.LinkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Link at\n%s with params: %#v", m.LinkMock.defaultExpectation.expectationOrigins.origin, *m.LinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLink != nil && afterLinkCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Link at\n%s", m.funcLinkOrigin)
	}

	if !m.LinkMock.invocationsDone() && afterLinkCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Link at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LinkMock.expectedInvocations), m.LinkMock.expectedInvocationsOrigin, afterLinkCounter)
	}
}

type mDeviceServiceClientMockListLogs struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockListLogsExpectation
	expectations       []*DeviceServiceClientMockListLogsExpectation

	callArgs []*DeviceServiceClientMockListLogsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockListLogsExpectation specifies expectation struct of the DeviceServiceClient.ListLogs
type DeviceServiceClientMockListLogsExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockListLogsParams
	paramPtrs          *DeviceServiceClientMockListLogsParamPtrs
	expectationOrigins DeviceServiceClientMockListLogsExpectationOrigins
	results            *DeviceServiceClientMockListLogsResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockListLogsParams contains parameters of the DeviceServiceClient.ListLogs
type DeviceServiceClientMockListLogsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListLogsRequest]
}

// DeviceServiceClientMockListLogsParamPtrs contains pointers to parameters of the DeviceServiceClient.ListLogs
type DeviceServiceClientMockListLogsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListLogsRequest]
}

// DeviceServiceClientMockListLogsResults contains results of the DeviceServiceClient.ListLogs
type DeviceServiceClientMockListLogsResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListLogsResponse]
	err error
}

// DeviceServiceClientMockListLogsOrigins contains origins of expectations of the DeviceServiceClient.ListLogs
type DeviceServiceClientMockListLogsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListLogs *mDeviceServiceClientMockListLogs) Optional() *mDeviceServiceClientMockListLogs {
	mmListLogs.optional = true
	return mmListLogs
}

// Expect sets up expected params for DeviceServiceClient.ListLogs
func (mmListLogs *mDeviceServiceClientMockListLogs) Expect(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest]) *mDeviceServiceClientMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceClientMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.paramPtrs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by ExpectParams functions")
	}

	mmListLogs.defaultExpectation.params = &DeviceServiceClientMockListLogsParams{ctx, pp1}
	mmListLogs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListLogs.expectations {
		if minimock.Equal(e.params, mmListLogs.defaultExpectation.params) {
			mmListLogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListLogs.defaultExpectation.params)
		}
	}

	return mmListLogs
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.ListLogs
func (mmListLogs *mDeviceServiceClientMockListLogs) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceClientMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.params != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Expect")
	}

	if mmListLogs.defaultExpectation.paramPtrs == nil {
		mmListLogs.defaultExpectation.paramPtrs = &DeviceServiceClientMockListLogsParamPtrs{}
	}
	mmListLogs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListLogs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListLogs
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.ListLogs
func (mmListLogs *mDeviceServiceClientMockListLogs) ExpectPp1Param2(pp1 *connect.Request[v1.ListLogsRequest]) *mDeviceServiceClientMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceClientMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.params != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Expect")
	}

	if mmListLogs.defaultExpectation.paramPtrs == nil {
		mmListLogs.defaultExpectation.paramPtrs = &DeviceServiceClientMockListLogsParamPtrs{}
	}
	mmListLogs.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListLogs.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListLogs
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.ListLogs
func (mmListLogs *mDeviceServiceClientMockListLogs) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest])) *mDeviceServiceClientMockListLogs {
	if mmListLogs.mock.inspectFuncListLogs != nil {
		mmListLogs.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.ListLogs")
	}

	mmListLogs.mock.inspectFuncListLogs = f

	return mmListLogs
}

// Return sets up results that will be returned by DeviceServiceClient.ListLogs
func (mmListLogs *mDeviceServiceClientMockListLogs) Return(pp2 *connect.ServerStreamForClient[v1.ListLogsResponse], err error) *DeviceServiceClientMock {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceClientMockListLogsExpectation{mock: mmListLogs.mock}
	}
	mmListLogs.defaultExpectation.results = &DeviceServiceClientMockListLogsResults{pp2, err}
	mmListLogs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListLogs.mock
}

// Set uses given function f to mock the DeviceServiceClient.ListLogs method
func (mmListLogs *mDeviceServiceClientMockListLogs) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest]) (pp2 *connect.ServerStreamForClient[v1.ListLogsResponse], err error)) *DeviceServiceClientMock {
	if mmListLogs.defaultExpectation != nil {
		mmListLogs.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.ListLogs method")
	}

	if len(mmListLogs.expectations) > 0 {
		mmListLogs.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.ListLogs method")
	}

	mmListLogs.mock.funcListLogs = f
	mmListLogs.mock.funcListLogsOrigin = minimock.CallerInfo(1)
	return mmListLogs.mock
}

// When sets expectation for the DeviceServiceClient.ListLogs which will trigger the result defined by the following
// Then helper
func (mmListLogs *mDeviceServiceClientMockListLogs) When(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest]) *DeviceServiceClientMockListLogsExpectation {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceClientMock.ListLogs mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockListLogsExpectation{
		mock:               mmListLogs.mock,
		params:             &DeviceServiceClientMockListLogsParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockListLogsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListLogs.expectations = append(mmListLogs.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.ListLogs return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockListLogsExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListLogsResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockListLogsResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.ListLogs should be invoked
func (mmListLogs *mDeviceServiceClientMockListLogs) Times(n uint64) *mDeviceServiceClientMockListLogs {
	if n == 0 {
		mmListLogs.mock.t.Fatalf("Times of DeviceServiceClientMock.ListLogs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListLogs.expectedInvocations, n)
	mmListLogs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListLogs
}

func (mmListLogs *mDeviceServiceClientMockListLogs) invocationsDone() bool {
	if len(mmListLogs.expectations) == 0 && mmListLogs.defaultExpectation == nil && mmListLogs.mock.funcListLogs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListLogs.mock.afterListLogsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListLogs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListLogs implements mm_devicev1connect.DeviceServiceClient
func (mmListLogs *DeviceServiceClientMock) ListLogs(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest]) (pp2 *connect.ServerStreamForClient[v1.ListLogsResponse], err error) {
	mm_atomic.AddUint64(&mmListLogs.beforeListLogsCounter, 1)
	defer mm_atomic.AddUint64(&mmListLogs.afterListLogsCounter, 1)

	mmListLogs.t.Helper()

	if mmListLogs.inspectFuncListLogs != nil {
		mmListLogs.inspectFuncListLogs(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockListLogsParams{ctx, pp1}

	// Record call args
	mmListLogs.ListLogsMock.mutex.Lock()
	mmListLogs.ListLogsMock.callArgs = append(mmListLogs.ListLogsMock.callArgs, &mm_params)
	mmListLogs.ListLogsMock.mutex.Unlock()

	for _, e := range mmListLogs.ListLogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListLogs.ListLogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListLogs.ListLogsMock.defaultExpectation.Counter, 1)
		mm_want := mmListLogs.ListLogsMock.defaultExpectation.params
		mm_want_ptrs := mmListLogs.ListLogsMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockListLogsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListLogs.t.Errorf("DeviceServiceClientMock.ListLogs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListLogs.t.Errorf("DeviceServiceClientMock.ListLogs got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListLogs.t.Errorf("DeviceServiceClientMock.ListLogs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListLogs.ListLogsMock.defaultExpectation.results
		if mm_results == nil {
			mmListLogs.t.Fatal("No results are set for the DeviceServiceClientMock.ListLogs")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListLogs.funcListLogs != nil {
		return mmListLogs.funcListLogs(ctx, pp1)
	}
	mmListLogs.t.Fatalf("Unexpected call to DeviceServiceClientMock.ListLogs. %v %v", ctx, pp1)
	return
}

// ListLogsAfterCounter returns a count of finished DeviceServiceClientMock.ListLogs invocations
func (mmListLogs *DeviceServiceClientMock) ListLogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListLogs.afterListLogsCounter)
}

// ListLogsBeforeCounter returns a count of DeviceServiceClientMock.ListLogs invocations
func (mmListLogs *DeviceServiceClientMock) ListLogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListLogs.beforeListLogsCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.ListLogs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListLogs *mDeviceServiceClientMockListLogs) Calls() []*DeviceServiceClientMockListLogsParams {
	mmListLogs.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockListLogsParams, len(mmListLogs.callArgs))
	copy(argCopy, mmListLogs.callArgs)

	mmListLogs.mutex.RUnlock()

	return argCopy
}

// MinimockListLogsDone returns true if the count of the ListLogs invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockListLogsDone() bool {
	if m.ListLogsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListLogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListLogsMock.invocationsDone()
}

// MinimockListLogsInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockListLogsInspect() {
	for _, e := range m.ListLogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.ListLogs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListLogsCounter := mm_atomic.LoadUint64(&m.afterListLogsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListLogsMock.defaultExpectation != nil && afterListLogsCounter < 1 {
		if m.ListLogsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.ListLogs at\n%s", m.ListLogsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.ListLogs at\n%s with params: %#v", m.ListLogsMock.defaultExpectation.expectationOrigins.origin, *m.ListLogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListLogs != nil && afterListLogsCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.ListLogs at\n%s", m.funcListLogsOrigin)
	}

	if !m.ListLogsMock.invocationsDone() && afterListLogsCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.ListLogs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListLogsMock.expectedInvocations), m.ListLogsMock.expectedInvocationsOrigin, afterListLogsCounter)
	}
}

type mDeviceServiceClientMockLog struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockLogExpectation
	expectations       []*DeviceServiceClientMockLogExpectation

	callArgs []*DeviceServiceClientMockLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockLogExpectation specifies expectation struct of the DeviceServiceClient.Log
type DeviceServiceClientMockLogExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockLogParams
	paramPtrs          *DeviceServiceClientMockLogParamPtrs
	expectationOrigins DeviceServiceClientMockLogExpectationOrigins
	results            *DeviceServiceClientMockLogResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockLogParams contains parameters of the DeviceServiceClient.Log
type DeviceServiceClientMockLogParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.LogRequest]
}

// DeviceServiceClientMockLogParamPtrs contains pointers to parameters of the DeviceServiceClient.Log
type DeviceServiceClientMockLogParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.LogRequest]
}

// DeviceServiceClientMockLogResults contains results of the DeviceServiceClient.Log
type DeviceServiceClientMockLogResults struct {
	pp2 *connect.Response[v1.LogResponse]
	err error
}

// DeviceServiceClientMockLogOrigins contains origins of expectations of the DeviceServiceClient.Log
type DeviceServiceClientMockLogExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLog *mDeviceServiceClientMockLog) Optional() *mDeviceServiceClientMockLog {
	mmLog.optional = true
	return mmLog
}

// Expect sets up expected params for DeviceServiceClient.Log
func (mmLog *mDeviceServiceClientMockLog) Expect(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) *mDeviceServiceClientMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceClientMockLogExpectation{}
	}

	if mmLog.defaultExpectation.paramPtrs != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by ExpectParams functions")
	}

	mmLog.defaultExpectation.params = &DeviceServiceClientMockLogParams{ctx, pp1}
	mmLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLog.expectations {
		if minimock.Equal(e.params, mmLog.defaultExpectation.params) {
			mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
		}
	}

	return mmLog
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Log
func (mmLog *mDeviceServiceClientMockLog) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceClientMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &DeviceServiceClientMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLog
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Log
func (mmLog *mDeviceServiceClientMockLog) ExpectPp1Param2(pp1 *connect.Request[v1.LogRequest]) *mDeviceServiceClientMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceClientMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &DeviceServiceClientMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.pp1 = &pp1
	mmLog.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Log
func (mmLog *mDeviceServiceClientMockLog) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.LogRequest])) *mDeviceServiceClientMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by DeviceServiceClient.Log
func (mmLog *mDeviceServiceClientMockLog) Return(pp2 *connect.Response[v1.LogResponse], err error) *DeviceServiceClientMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceClientMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &DeviceServiceClientMockLogResults{pp2, err}
	mmLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// Set uses given function f to mock the DeviceServiceClient.Log method
func (mmLog *mDeviceServiceClientMockLog) Set(f func(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) (pp2 *connect.Response[v1.LogResponse], err error)) *DeviceServiceClientMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Log method")
	}

	mmLog.mock.funcLog = f
	mmLog.mock.funcLogOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// When sets expectation for the DeviceServiceClient.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mDeviceServiceClientMockLog) When(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) *DeviceServiceClientMockLogExpectation {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceClientMock.Log mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockLogExpectation{
		mock:               mmLog.mock,
		params:             &DeviceServiceClientMockLogParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLog.expectations = append(mmLog.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Log return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockLogExpectation) Then(pp2 *connect.Response[v1.LogResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockLogResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Log should be invoked
func (mmLog *mDeviceServiceClientMockLog) Times(n uint64) *mDeviceServiceClientMockLog {
	if n == 0 {
		mmLog.mock.t.Fatalf("Times of DeviceServiceClientMock.Log mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLog.expectedInvocations, n)
	mmLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLog
}

func (mmLog *mDeviceServiceClientMockLog) invocationsDone() bool {
	if len(mmLog.expectations) == 0 && mmLog.defaultExpectation == nil && mmLog.mock.funcLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLog.mock.afterLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Log implements mm_devicev1connect.DeviceServiceClient
func (mmLog *DeviceServiceClientMock) Log(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) (pp2 *connect.Response[v1.LogResponse], err error) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	mmLog.t.Helper()

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockLogParams{ctx, pp1}

	// Record call args
	mmLog.LogMock.mutex.Lock()
	mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, &mm_params)
	mmLog.LogMock.mutex.Unlock()

	for _, e := range mmLog.LogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)
		mm_want := mmLog.LogMock.defaultExpectation.params
		mm_want_ptrs := mmLog.LogMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockLogParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLog.t.Errorf("DeviceServiceClientMock.Log got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmLog.t.Errorf("DeviceServiceClientMock.Log got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLog.t.Errorf("DeviceServiceClientMock.Log got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLog.LogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the DeviceServiceClientMock.Log")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog(ctx, pp1)
	}
	mmLog.t.Fatalf("Unexpected call to DeviceServiceClientMock.Log. %v %v", ctx, pp1)
	return
}

// LogAfterCounter returns a count of finished DeviceServiceClientMock.Log invocations
func (mmLog *DeviceServiceClientMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of DeviceServiceClientMock.Log invocations
func (mmLog *DeviceServiceClientMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mDeviceServiceClientMockLog) Calls() []*DeviceServiceClientMockLogParams {
	mmLog.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockLogParams, len(mmLog.callArgs))
	copy(argCopy, mmLog.callArgs)

	mmLog.mutex.RUnlock()

	return argCopy
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockLogDone() bool {
	if m.LogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogMock.invocationsDone()
}

// MinimockLogInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Log at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogCounter := mm_atomic.LoadUint64(&m.afterLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && afterLogCounter < 1 {
		if m.LogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Log at\n%s", m.LogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Log at\n%s with params: %#v", m.LogMock.defaultExpectation.expectationOrigins.origin, *m.LogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && afterLogCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Log at\n%s", m.funcLogOrigin)
	}

	if !m.LogMock.invocationsDone() && afterLogCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Log at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogMock.expectedInvocations), m.LogMock.expectedInvocationsOrigin, afterLogCounter)
	}
}

type mDeviceServiceClientMockNotify struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockNotifyExpectation
	expectations       []*DeviceServiceClientMockNotifyExpectation

	callArgs []*DeviceServiceClientMockNotifyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockNotifyExpectation specifies expectation struct of the DeviceServiceClient.Notify
type DeviceServiceClientMockNotifyExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockNotifyParams
	paramPtrs          *DeviceServiceClientMockNotifyParamPtrs
	expectationOrigins DeviceServiceClientMockNotifyExpectationOrigins
	results            *DeviceServiceClientMockNotifyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockNotifyParams contains parameters of the DeviceServiceClient.Notify
type DeviceServiceClientMockNotifyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.NotifyRequest]
}

// DeviceServiceClientMockNotifyParamPtrs contains pointers to parameters of the DeviceServiceClient.Notify
type DeviceServiceClientMockNotifyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.NotifyRequest]
}

// DeviceServiceClientMockNotifyResults contains results of the DeviceServiceClient.Notify
type DeviceServiceClientMockNotifyResults struct {
	pp2 *connect.Response[v1.NotifyResponse]
	err error
}

// DeviceServiceClientMockNotifyOrigins contains origins of expectations of the DeviceServiceClient.Notify
type DeviceServiceClientMockNotifyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNotify *mDeviceServiceClientMockNotify) Optional() *mDeviceServiceClientMockNotify {
	mmNotify.optional = true
	return mmNotify
}

// Expect sets up expected params for DeviceServiceClient.Notify
func (mmNotify *mDeviceServiceClientMockNotify) Expect(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) *mDeviceServiceClientMockNotify {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceClientMockNotifyExpectation{}
	}

	if mmNotify.defaultExpectation.paramPtrs != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by ExpectParams functions")
	}

	mmNotify.defaultExpectation.params = &DeviceServiceClientMockNotifyParams{ctx, pp1}
	mmNotify.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNotify.expectations {
		if minimock.Equal(e.params, mmNotify.defaultExpectation.params) {
			mmNotify.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNotify.defaultExpectation.params)
		}
	}

	return mmNotify
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Notify
func (mmNotify *mDeviceServiceClientMockNotify) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockNotify {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceClientMockNotifyExpectation{}
	}

	if mmNotify.defaultExpectation.params != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Expect")
	}

	if mmNotify.defaultExpectation.paramPtrs == nil {
		mmNotify.defaultExpectation.paramPtrs = &DeviceServiceClientMockNotifyParamPtrs{}
	}
	mmNotify.defaultExpectation.paramPtrs.ctx = &ctx
	mmNotify.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmNotify
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Notify
func (mmNotify *mDeviceServiceClientMockNotify) ExpectPp1Param2(pp1 *connect.Request[v1.NotifyRequest]) *mDeviceServiceClientMockNotify {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceClientMockNotifyExpectation{}
	}

	if mmNotify.defaultExpectation.params != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Expect")
	}

	if mmNotify.defaultExpectation.paramPtrs == nil {
		mmNotify.defaultExpectation.paramPtrs = &DeviceServiceClientMockNotifyParamPtrs{}
	}
	mmNotify.defaultExpectation.paramPtrs.pp1 = &pp1
	mmNotify.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmNotify
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Notify
func (mmNotify *mDeviceServiceClientMockNotify) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest])) *mDeviceServiceClientMockNotify {
	if mmNotify.mock.inspectFuncNotify != nil {
		mmNotify.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Notify")
	}

	mmNotify.mock.inspectFuncNotify = f

	return mmNotify
}

// Return sets up results that will be returned by DeviceServiceClient.Notify
func (mmNotify *mDeviceServiceClientMockNotify) Return(pp2 *connect.Response[v1.NotifyResponse], err error) *DeviceServiceClientMock {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceClientMockNotifyExpectation{mock: mmNotify.mock}
	}
	mmNotify.defaultExpectation.results = &DeviceServiceClientMockNotifyResults{pp2, err}
	mmNotify.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNotify.mock
}

// Set uses given function f to mock the DeviceServiceClient.Notify method
func (mmNotify *mDeviceServiceClientMockNotify) Set(f func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) (pp2 *connect.Response[v1.NotifyResponse], err error)) *DeviceServiceClientMock {
	if mmNotify.defaultExpectation != nil {
		mmNotify.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Notify method")
	}

	if len(mmNotify.expectations) > 0 {
		mmNotify.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Notify method")
	}

	mmNotify.mock.funcNotify = f
	mmNotify.mock.funcNotifyOrigin = minimock.CallerInfo(1)
	return mmNotify.mock
}

// When sets expectation for the DeviceServiceClient.Notify which will trigger the result defined by the following
// Then helper
func (mmNotify *mDeviceServiceClientMockNotify) When(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) *DeviceServiceClientMockNotifyExpectation {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceClientMock.Notify mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockNotifyExpectation{
		mock:               mmNotify.mock,
		params:             &DeviceServiceClientMockNotifyParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockNotifyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNotify.expectations = append(mmNotify.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Notify return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockNotifyExpectation) Then(pp2 *connect.Response[v1.NotifyResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockNotifyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Notify should be invoked
func (mmNotify *mDeviceServiceClientMockNotify) Times(n uint64) *mDeviceServiceClientMockNotify {
	if n == 0 {
		mmNotify.mock.t.Fatalf("Times of DeviceServiceClientMock.Notify mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNotify.expectedInvocations, n)
	mmNotify.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNotify
}

func (mmNotify *mDeviceServiceClientMockNotify) invocationsDone() bool {
	if len(mmNotify.expectations) == 0 && mmNotify.defaultExpectation == nil && mmNotify.mock.funcNotify == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNotify.mock.afterNotifyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNotify.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Notify implements mm_devicev1connect.DeviceServiceClient
func (mmNotify *DeviceServiceClientMock) Notify(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) (pp2 *connect.Response[v1.NotifyResponse], err error) {
	mm_atomic.AddUint64(&mmNotify.beforeNotifyCounter, 1)
	defer mm_atomic.AddUint64(&mmNotify.afterNotifyCounter, 1)

	mmNotify.t.Helper()

	if mmNotify.inspectFuncNotify != nil {
		mmNotify.inspectFuncNotify(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockNotifyParams{ctx, pp1}

	// Record call args
	mmNotify.NotifyMock.mutex.Lock()
	mmNotify.NotifyMock.callArgs = append(mmNotify.NotifyMock.callArgs, &mm_params)
	mmNotify.NotifyMock.mutex.Unlock()

	for _, e := range mmNotify.NotifyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmNotify.NotifyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNotify.NotifyMock.defaultExpectation.Counter, 1)
		mm_want := mmNotify.NotifyMock.defaultExpectation.params
		mm_want_ptrs := mmNotify.NotifyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockNotifyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmNotify.t.Errorf("DeviceServiceClientMock.Notify got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNotify.NotifyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmNotify.t.Errorf("DeviceServiceClientMock.Notify got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNotify.NotifyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNotify.t.Errorf("DeviceServiceClientMock.Notify got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNotify.NotifyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNotify.NotifyMock.defaultExpectation.results
		if mm_results == nil {
			mmNotify.t.Fatal("No results are set for the DeviceServiceClientMock.Notify")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmNotify.funcNotify != nil {
		return mmNotify.funcNotify(ctx, pp1)
	}
	mmNotify.t.Fatalf("Unexpected call to DeviceServiceClientMock.Notify. %v %v", ctx, pp1)
	return
}

// NotifyAfterCounter returns a count of finished DeviceServiceClientMock.Notify invocations
func (mmNotify *DeviceServiceClientMock) NotifyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotify.afterNotifyCounter)
}

// NotifyBeforeCounter returns a count of DeviceServiceClientMock.Notify invocations
func (mmNotify *DeviceServiceClientMock) NotifyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotify.beforeNotifyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Notify.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNotify *mDeviceServiceClientMockNotify) Calls() []*DeviceServiceClientMockNotifyParams {
	mmNotify.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockNotifyParams, len(mmNotify.callArgs))
	copy(argCopy, mmNotify.callArgs)

	mmNotify.mutex.RUnlock()

	return argCopy
}

// MinimockNotifyDone returns true if the count of the Notify invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockNotifyDone() bool {
	if m.NotifyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NotifyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NotifyMock.invocationsDone()
}

// MinimockNotifyInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockNotifyInspect() {
	for _, e := range m.NotifyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Notify at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNotifyCounter := mm_atomic.LoadUint64(&m.afterNotifyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NotifyMock.defaultExpectation != nil && afterNotifyCounter < 1 {
		if m.NotifyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Notify at\n%s", m.NotifyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Notify at\n%s with params: %#v", m.NotifyMock.defaultExpectation.expectationOrigins.origin, *m.NotifyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNotify != nil && afterNotifyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Notify at\n%s", m.funcNotifyOrigin)
	}

	if !m.NotifyMock.invocationsDone() && afterNotifyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Notify at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NotifyMock.expectedInvocations), m.NotifyMock.expectedInvocationsOrigin, afterNotifyCounter)
	}
}

type mDeviceServiceClientMockRegisterKey struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockRegisterKeyExpectation
	expectations       []*DeviceServiceClientMockRegisterKeyExpectation

	callArgs []*DeviceServiceClientMockRegisterKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockRegisterKeyExpectation specifies expectation struct of the DeviceServiceClient.RegisterKey
type DeviceServiceClientMockRegisterKeyExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockRegisterKeyParams
	paramPtrs          *DeviceServiceClientMockRegisterKeyParamPtrs
	expectationOrigins DeviceServiceClientMockRegisterKeyExpectationOrigins
	results            *DeviceServiceClientMockRegisterKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockRegisterKeyParams contains parameters of the DeviceServiceClient.RegisterKey
type DeviceServiceClientMockRegisterKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RegisterKeyRequest]
}

// DeviceServiceClientMockRegisterKeyParamPtrs contains pointers to parameters of the DeviceServiceClient.RegisterKey
type DeviceServiceClientMockRegisterKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RegisterKeyRequest]
}

// DeviceServiceClientMockRegisterKeyResults contains results of the DeviceServiceClient.RegisterKey
type DeviceServiceClientMockRegisterKeyResults struct {
	pp2 *connect.Response[v1.RegisterKeyResponse]
	err error
}

// DeviceServiceClientMockRegisterKeyOrigins contains origins of expectations of the DeviceServiceClient.RegisterKey
type DeviceServiceClientMockRegisterKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Optional() *mDeviceServiceClientMockRegisterKey {
	mmRegisterKey.optional = true
	return mmRegisterKey
}

// Expect sets up expected params for DeviceServiceClient.RegisterKey
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Expect(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) *mDeviceServiceClientMockRegisterKey {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceClientMockRegisterKeyExpectation{}
	}

	if mmRegisterKey.defaultExpectation.paramPtrs != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by ExpectParams functions")
	}

	mmRegisterKey.defaultExpectation.params = &DeviceServiceClientMockRegisterKeyParams{ctx, pp1}
	mmRegisterKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterKey.expectations {
		if minimock.Equal(e.params, mmRegisterKey.defaultExpectation.params) {
			mmRegisterKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterKey.defaultExpectation.params)
		}
	}

	return mmRegisterKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.RegisterKey
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockRegisterKey {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceClientMockRegisterKeyExpectation{}
	}

	if mmRegisterKey.defaultExpectation.params != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Expect")
	}

	if mmRegisterKey.defaultExpectation.paramPtrs == nil {
		mmRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockRegisterKeyParamPtrs{}
	}
	mmRegisterKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegisterKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegisterKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.RegisterKey
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) ExpectPp1Param2(pp1 *connect.Request[v1.RegisterKeyRequest]) *mDeviceServiceClientMockRegisterKey {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceClientMockRegisterKeyExpectation{}
	}

	if mmRegisterKey.defaultExpectation.params != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Expect")
	}

	if mmRegisterKey.defaultExpectation.paramPtrs == nil {
		mmRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockRegisterKeyParamPtrs{}
	}
	mmRegisterKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRegisterKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRegisterKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.RegisterKey
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest])) *mDeviceServiceClientMockRegisterKey {
	if mmRegisterKey.mock.inspectFuncRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.RegisterKey")
	}

	mmRegisterKey.mock.inspectFuncRegisterKey = f

	return mmRegisterKey
}

// Return sets up results that will be returned by DeviceServiceClient.RegisterKey
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Return(pp2 *connect.Response[v1.RegisterKeyResponse], err error) *DeviceServiceClientMock {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceClientMockRegisterKeyExpectation{mock: mmRegisterKey.mock}
	}
	mmRegisterKey.defaultExpectation.results = &DeviceServiceClientMockRegisterKeyResults{pp2, err}
	mmRegisterKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterKey.mock
}

// Set uses given function f to mock the DeviceServiceClient.RegisterKey method
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) (pp2 *connect.Response[v1.RegisterKeyResponse], err error)) *DeviceServiceClientMock {
	if mmRegisterKey.defaultExpectation != nil {
		mmRegisterKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.RegisterKey method")
	}

	if len(mmRegisterKey.expectations) > 0 {
		mmRegisterKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.RegisterKey method")
	}

	mmRegisterKey.mock.funcRegisterKey = f
	mmRegisterKey.mock.funcRegisterKeyOrigin = minimock.CallerInfo(1)
	return mmRegisterKey.mock
}

// When sets expectation for the DeviceServiceClient.RegisterKey which will trigger the result defined by the following
// Then helper
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) When(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) *DeviceServiceClientMockRegisterKeyExpectation {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceClientMock.RegisterKey mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockRegisterKeyExpectation{
		mock:               mmRegisterKey.mock,
		params:             &DeviceServiceClientMockRegisterKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockRegisterKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterKey.expectations = append(mmRegisterKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.RegisterKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockRegisterKeyExpectation) Then(pp2 *connect.Response[v1.RegisterKeyResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockRegisterKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.RegisterKey should be invoked
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Times(n uint64) *mDeviceServiceClientMockRegisterKey {
	if n == 0 {
		mmRegisterKey.mock.t.Fatalf("Times of DeviceServiceClientMock.RegisterKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterKey.expectedInvocations, n)
	mmRegisterKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterKey
}

func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) invocationsDone() bool {
	if len(mmRegisterKey.expectations) == 0 && mmRegisterKey.defaultExpectation == nil && mmRegisterKey.mock.funcRegisterKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterKey.mock.afterRegisterKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterKey implements mm_devicev1connect.DeviceServiceClient
func (mmRegisterKey *DeviceServiceClientMock) RegisterKey(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) (pp2 *connect.Response[v1.RegisterKeyResponse], err error) {
	mm_atomic.AddUint64(&mmRegisterKey.beforeRegisterKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterKey.afterRegisterKeyCounter, 1)

	mmRegisterKey.t.Helper()

	if mmRegisterKey.inspectFuncRegisterKey != nil {
		mmRegisterKey.inspectFuncRegisterKey(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockRegisterKeyParams{ctx, pp1}

	// Record call args
	mmRegisterKey.RegisterKeyMock.mutex.Lock()
	mmRegisterKey.RegisterKeyMock.callArgs = append(mmRegisterKey.RegisterKeyMock.callArgs, &mm_params)
	mmRegisterKey.RegisterKeyMock.mutex.Unlock()

	for _, e := range mmRegisterKey.RegisterKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRegisterKey.RegisterKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterKey.RegisterKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterKey.RegisterKeyMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterKey.RegisterKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockRegisterKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegisterKey.t.Errorf("DeviceServiceClientMock.RegisterKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterKey.RegisterKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRegisterKey.t.Errorf("DeviceServiceClientMock.RegisterKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterKey.RegisterKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterKey.t.Errorf("DeviceServiceClientMock.RegisterKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterKey.RegisterKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterKey.RegisterKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterKey.t.Fatal("No results are set for the DeviceServiceClientMock.RegisterKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRegisterKey.funcRegisterKey != nil {
		return mmRegisterKey.funcRegisterKey(ctx, pp1)
	}
	mmRegisterKey.t.Fatalf("Unexpected call to DeviceServiceClientMock.RegisterKey. %v %v", ctx, pp1)
	return
}

// RegisterKeyAfterCounter returns a count of finished DeviceServiceClientMock.RegisterKey invocations
func (mmRegisterKey *DeviceServiceClientMock) RegisterKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterKey.afterRegisterKeyCounter)
}

// RegisterKeyBeforeCounter returns a count of DeviceServiceClientMock.RegisterKey invocations
func (mmRegisterKey *DeviceServiceClientMock) RegisterKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterKey.beforeRegisterKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.RegisterKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterKey *mDeviceServiceClientMockRegisterKey) Calls() []*DeviceServiceClientMockRegisterKeyParams {
	mmRegisterKey.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockRegisterKeyParams, len(mmRegisterKey.callArgs))
	copy(argCopy, mmRegisterKey.callArgs)

	mmRegisterKey.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterKeyDone returns true if the count of the RegisterKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockRegisterKeyDone() bool {
	if m.RegisterKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterKeyMock.invocationsDone()
}

// MinimockRegisterKeyInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockRegisterKeyInspect() {
	for _, e := range m.RegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.RegisterKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterKeyCounter := mm_atomic.LoadUint64(&m.afterRegisterKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterKeyMock.defaultExpectation != nil && afterRegisterKeyCounter < 1 {
		if m.RegisterKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.RegisterKey at\n%s", m.RegisterKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.RegisterKey at\n%s with params: %#v", m.RegisterKeyMock.defaultExpectation.expectationOrigins.origin, *m.RegisterKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterKey != nil && afterRegisterKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.RegisterKey at\n%s", m.funcRegisterKeyOrigin)
	}

	if !m.RegisterKeyMock.invocationsDone() && afterRegisterKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.RegisterKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterKeyMock.expectedInvocations), m.RegisterKeyMock.expectedInvocationsOrigin, afterRegisterKeyCounter)
	}
}

type mDeviceServiceClientMockRemove struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockRemoveExpectation
	expectations       []*DeviceServiceClientMockRemoveExpectation

	callArgs []*DeviceServiceClientMockRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockRemoveExpectation specifies expectation struct of the DeviceServiceClient.Remove
type DeviceServiceClientMockRemoveExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockRemoveParams
	paramPtrs          *DeviceServiceClientMockRemoveParamPtrs
	expectationOrigins DeviceServiceClientMockRemoveExpectationOrigins
	results            *DeviceServiceClientMockRemoveResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockRemoveParams contains parameters of the DeviceServiceClient.Remove
type DeviceServiceClientMockRemoveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveRequest]
}

// DeviceServiceClientMockRemoveParamPtrs contains pointers to parameters of the DeviceServiceClient.Remove
type DeviceServiceClientMockRemoveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveRequest]
}

// DeviceServiceClientMockRemoveResults contains results of the DeviceServiceClient.Remove
type DeviceServiceClientMockRemoveResults struct {
	pp2 *connect.Response[v1.RemoveResponse]
	err error
}

// DeviceServiceClientMockRemoveOrigins contains origins of expectations of the DeviceServiceClient.Remove
type DeviceServiceClientMockRemoveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemove *mDeviceServiceClientMockRemove) Optional() *mDeviceServiceClientMockRemove {
	mmRemove.optional = true
	return mmRemove
}

// Expect sets up expected params for DeviceServiceClient.Remove
func (mmRemove *mDeviceServiceClientMockRemove) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) *mDeviceServiceClientMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceClientMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.paramPtrs != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by ExpectParams functions")
	}

	mmRemove.defaultExpectation.params = &DeviceServiceClientMockRemoveParams{ctx, pp1}
	mmRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Remove
func (mmRemove *mDeviceServiceClientMockRemove) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceClientMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &DeviceServiceClientMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemove
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Remove
func (mmRemove *mDeviceServiceClientMockRemove) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveRequest]) *mDeviceServiceClientMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceClientMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &DeviceServiceClientMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemove.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Remove
func (mmRemove *mDeviceServiceClientMockRemove) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest])) *mDeviceServiceClientMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by DeviceServiceClient.Remove
func (mmRemove *mDeviceServiceClientMockRemove) Return(pp2 *connect.Response[v1.RemoveResponse], err error) *DeviceServiceClientMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceClientMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &DeviceServiceClientMockRemoveResults{pp2, err}
	mmRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// Set uses given function f to mock the DeviceServiceClient.Remove method
func (mmRemove *mDeviceServiceClientMockRemove) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) (pp2 *connect.Response[v1.RemoveResponse], err error)) *DeviceServiceClientMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Remove method")
	}

	mmRemove.mock.funcRemove = f
	mmRemove.mock.funcRemoveOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// When sets expectation for the DeviceServiceClient.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mDeviceServiceClientMockRemove) When(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) *DeviceServiceClientMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceClientMock.Remove mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockRemoveExpectation{
		mock:               mmRemove.mock,
		params:             &DeviceServiceClientMockRemoveParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Remove return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockRemoveExpectation) Then(pp2 *connect.Response[v1.RemoveResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockRemoveResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Remove should be invoked
func (mmRemove *mDeviceServiceClientMockRemove) Times(n uint64) *mDeviceServiceClientMockRemove {
	if n == 0 {
		mmRemove.mock.t.Fatalf("Times of DeviceServiceClientMock.Remove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemove.expectedInvocations, n)
	mmRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemove
}

func (mmRemove *mDeviceServiceClientMockRemove) invocationsDone() bool {
	if len(mmRemove.expectations) == 0 && mmRemove.defaultExpectation == nil && mmRemove.mock.funcRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemove.mock.afterRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Remove implements mm_devicev1connect.DeviceServiceClient
func (mmRemove *DeviceServiceClientMock) Remove(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) (pp2 *connect.Response[v1.RemoveResponse], err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	mmRemove.t.Helper()

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockRemoveParams{ctx, pp1}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, &mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_want_ptrs := mmRemove.RemoveMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockRemoveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemove.t.Errorf("DeviceServiceClientMock.Remove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemove.t.Errorf("DeviceServiceClientMock.Remove got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("DeviceServiceClientMock.Remove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemove.RemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemove.RemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemove.t.Fatal("No results are set for the DeviceServiceClientMock.Remove")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(ctx, pp1)
	}
	mmRemove.t.Fatalf("Unexpected call to DeviceServiceClientMock.Remove. %v %v", ctx, pp1)
	return
}

// RemoveAfterCounter returns a count of finished DeviceServiceClientMock.Remove invocations
func (mmRemove *DeviceServiceClientMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of DeviceServiceClientMock.Remove invocations
func (mmRemove *DeviceServiceClientMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mDeviceServiceClientMockRemove) Calls() []*DeviceServiceClientMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockRemoveDone() bool {
	if m.RemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveMock.invocationsDone()
}

// MinimockRemoveInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Remove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCounter := mm_atomic.LoadUint64(&m.afterRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && afterRemoveCounter < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Remove at\n%s", m.RemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Remove at\n%s with params: %#v", m.RemoveMock.defaultExpectation.expectationOrigins.origin, *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && afterRemoveCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Remove at\n%s", m.funcRemoveOrigin)
	}

	if !m.RemoveMock.invocationsDone() && afterRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Remove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveMock.expectedInvocations), m.RemoveMock.expectedInvocationsOrigin, afterRemoveCounter)
	}
}

type mDeviceServiceClientMockRemoveKey struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockRemoveKeyExpectation
	expectations       []*DeviceServiceClientMockRemoveKeyExpectation

	callArgs []*DeviceServiceClientMockRemoveKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockRemoveKeyExpectation specifies expectation struct of the DeviceServiceClient.RemoveKey
type DeviceServiceClientMockRemoveKeyExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockRemoveKeyParams
	paramPtrs          *DeviceServiceClientMockRemoveKeyParamPtrs
	expectationOrigins DeviceServiceClientMockRemoveKeyExpectationOrigins
	results            *DeviceServiceClientMockRemoveKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockRemoveKeyParams contains parameters of the DeviceServiceClient.RemoveKey
type DeviceServiceClientMockRemoveKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveKeyRequest]
}

// DeviceServiceClientMockRemoveKeyParamPtrs contains pointers to parameters of the DeviceServiceClient.RemoveKey
type DeviceServiceClientMockRemoveKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveKeyRequest]
}

// DeviceServiceClientMockRemoveKeyResults contains results of the DeviceServiceClient.RemoveKey
type DeviceServiceClientMockRemoveKeyResults struct {
	pp2 *connect.Response[v1.RemoveKeyResponse]
	err error
}

// DeviceServiceClientMockRemoveKeyOrigins contains origins of expectations of the DeviceServiceClient.RemoveKey
type DeviceServiceClientMockRemoveKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Optional() *mDeviceServiceClientMockRemoveKey {
	mmRemoveKey.optional = true
	return mmRemoveKey
}

// Expect sets up expected params for DeviceServiceClient.RemoveKey
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) *mDeviceServiceClientMockRemoveKey {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceClientMockRemoveKeyExpectation{}
	}

	if mmRemoveKey.defaultExpectation.paramPtrs != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by ExpectParams functions")
	}

	mmRemoveKey.defaultExpectation.params = &DeviceServiceClientMockRemoveKeyParams{ctx, pp1}
	mmRemoveKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveKey.expectations {
		if minimock.Equal(e.params, mmRemoveKey.defaultExpectation.params) {
			mmRemoveKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveKey.defaultExpectation.params)
		}
	}

	return mmRemoveKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.RemoveKey
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockRemoveKey {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceClientMockRemoveKeyExpectation{}
	}

	if mmRemoveKey.defaultExpectation.params != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Expect")
	}

	if mmRemoveKey.defaultExpectation.paramPtrs == nil {
		mmRemoveKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockRemoveKeyParamPtrs{}
	}
	mmRemoveKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.RemoveKey
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveKeyRequest]) *mDeviceServiceClientMockRemoveKey {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceClientMockRemoveKeyExpectation{}
	}

	if mmRemoveKey.defaultExpectation.params != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Expect")
	}

	if mmRemoveKey.defaultExpectation.paramPtrs == nil {
		mmRemoveKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockRemoveKeyParamPtrs{}
	}
	mmRemoveKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.RemoveKey
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest])) *mDeviceServiceClientMockRemoveKey {
	if mmRemoveKey.mock.inspectFuncRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.RemoveKey")
	}

	mmRemoveKey.mock.inspectFuncRemoveKey = f

	return mmRemoveKey
}

// Return sets up results that will be returned by DeviceServiceClient.RemoveKey
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Return(pp2 *connect.Response[v1.RemoveKeyResponse], err error) *DeviceServiceClientMock {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceClientMockRemoveKeyExpectation{mock: mmRemoveKey.mock}
	}
	mmRemoveKey.defaultExpectation.results = &DeviceServiceClientMockRemoveKeyResults{pp2, err}
	mmRemoveKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveKey.mock
}

// Set uses given function f to mock the DeviceServiceClient.RemoveKey method
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) (pp2 *connect.Response[v1.RemoveKeyResponse], err error)) *DeviceServiceClientMock {
	if mmRemoveKey.defaultExpectation != nil {
		mmRemoveKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.RemoveKey method")
	}

	if len(mmRemoveKey.expectations) > 0 {
		mmRemoveKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.RemoveKey method")
	}

	mmRemoveKey.mock.funcRemoveKey = f
	mmRemoveKey.mock.funcRemoveKeyOrigin = minimock.CallerInfo(1)
	return mmRemoveKey.mock
}

// When sets expectation for the DeviceServiceClient.RemoveKey which will trigger the result defined by the following
// Then helper
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) When(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) *DeviceServiceClientMockRemoveKeyExpectation {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceClientMock.RemoveKey mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockRemoveKeyExpectation{
		mock:               mmRemoveKey.mock,
		params:             &DeviceServiceClientMockRemoveKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockRemoveKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveKey.expectations = append(mmRemoveKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.RemoveKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockRemoveKeyExpectation) Then(pp2 *connect.Response[v1.RemoveKeyResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockRemoveKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.RemoveKey should be invoked
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Times(n uint64) *mDeviceServiceClientMockRemoveKey {
	if n == 0 {
		mmRemoveKey.mock.t.Fatalf("Times of DeviceServiceClientMock.RemoveKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveKey.expectedInvocations, n)
	mmRemoveKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveKey
}

func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) invocationsDone() bool {
	if len(mmRemoveKey.expectations) == 0 && mmRemoveKey.defaultExpectation == nil && mmRemoveKey.mock.funcRemoveKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveKey.mock.afterRemoveKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveKey implements mm_devicev1connect.DeviceServiceClient
func (mmRemoveKey *DeviceServiceClientMock) RemoveKey(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) (pp2 *connect.Response[v1.RemoveKeyResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveKey.beforeRemoveKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveKey.afterRemoveKeyCounter, 1)

	mmRemoveKey.t.Helper()

	if mmRemoveKey.inspectFuncRemoveKey != nil {
		mmRemoveKey.inspectFuncRemoveKey(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockRemoveKeyParams{ctx, pp1}

	// Record call args
	mmRemoveKey.RemoveKeyMock.mutex.Lock()
	mmRemoveKey.RemoveKeyMock.callArgs = append(mmRemoveKey.RemoveKeyMock.callArgs, &mm_params)
	mmRemoveKey.RemoveKeyMock.mutex.Unlock()

	for _, e := range mmRemoveKey.RemoveKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveKey.RemoveKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveKey.RemoveKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveKey.RemoveKeyMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveKey.RemoveKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockRemoveKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveKey.t.Errorf("DeviceServiceClientMock.RemoveKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveKey.RemoveKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveKey.t.Errorf("DeviceServiceClientMock.RemoveKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveKey.RemoveKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveKey.t.Errorf("DeviceServiceClientMock.RemoveKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveKey.RemoveKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveKey.RemoveKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveKey.t.Fatal("No results are set for the DeviceServiceClientMock.RemoveKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveKey.funcRemoveKey != nil {
		return mmRemoveKey.funcRemoveKey(ctx, pp1)
	}
	mmRemoveKey.t.Fatalf("Unexpected call to DeviceServiceClientMock.RemoveKey. %v %v", ctx, pp1)
	return
}

// RemoveKeyAfterCounter returns a count of finished DeviceServiceClientMock.RemoveKey invocations
func (mmRemoveKey *DeviceServiceClientMock) RemoveKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveKey.afterRemoveKeyCounter)
}

// RemoveKeyBeforeCounter returns a count of DeviceServiceClientMock.RemoveKey invocations
func (mmRemoveKey *DeviceServiceClientMock) RemoveKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveKey.beforeRemoveKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.RemoveKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveKey *mDeviceServiceClientMockRemoveKey) Calls() []*DeviceServiceClientMockRemoveKeyParams {
	mmRemoveKey.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockRemoveKeyParams, len(mmRemoveKey.callArgs))
	copy(argCopy, mmRemoveKey.callArgs)

	mmRemoveKey.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveKeyDone returns true if the count of the RemoveKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockRemoveKeyDone() bool {
	if m.RemoveKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveKeyMock.invocationsDone()
}

// MinimockRemoveKeyInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockRemoveKeyInspect() {
	for _, e := range m.RemoveKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.RemoveKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveKeyCounter := mm_atomic.LoadUint64(&m.afterRemoveKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveKeyMock.defaultExpectation != nil && afterRemoveKeyCounter < 1 {
		if m.RemoveKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.RemoveKey at\n%s", m.RemoveKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.RemoveKey at\n%s with params: %#v", m.RemoveKeyMock.defaultExpectation.expectationOrigins.origin, *m.RemoveKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveKey != nil && afterRemoveKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.RemoveKey at\n%s", m.funcRemoveKeyOrigin)
	}

	if !m.RemoveKeyMock.invocationsDone() && afterRemoveKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.RemoveKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveKeyMock.expectedInvocations), m.RemoveKeyMock.expectedInvocationsOrigin, afterRemoveKeyCounter)
	}
}

type mDeviceServiceClientMockSearch struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockSearchExpectation
	expectations       []*DeviceServiceClientMockSearchExpectation

	callArgs []*DeviceServiceClientMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockSearchExpectation specifies expectation struct of the DeviceServiceClient.Search
type DeviceServiceClientMockSearchExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockSearchParams
	paramPtrs          *DeviceServiceClientMockSearchParamPtrs
	expectationOrigins DeviceServiceClientMockSearchExpectationOrigins
	results            *DeviceServiceClientMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockSearchParams contains parameters of the DeviceServiceClient.Search
type DeviceServiceClientMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
}

// DeviceServiceClientMockSearchParamPtrs contains pointers to parameters of the DeviceServiceClient.Search
type DeviceServiceClientMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
}

// DeviceServiceClientMockSearchResults contains results of the DeviceServiceClient.Search
type DeviceServiceClientMockSearchResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchResponse]
	err error
}

// DeviceServiceClientMockSearchOrigins contains origins of expectations of the DeviceServiceClient.Search
type DeviceServiceClientMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mDeviceServiceClientMockSearch) Optional() *mDeviceServiceClientMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for DeviceServiceClient.Search
func (mmSearch *mDeviceServiceClientMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *mDeviceServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &DeviceServiceClientMockSearchParams{ctx, pp1}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Search
func (mmSearch *mDeviceServiceClientMockSearch) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &DeviceServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Search
func (mmSearch *mDeviceServiceClientMockSearch) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mDeviceServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &DeviceServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Search
func (mmSearch *mDeviceServiceClientMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])) *mDeviceServiceClientMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by DeviceServiceClient.Search
func (mmSearch *mDeviceServiceClientMockSearch) Return(pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) *DeviceServiceClientMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceClientMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &DeviceServiceClientMockSearchResults{pp2, err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the DeviceServiceClient.Search method
func (mmSearch *mDeviceServiceClientMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error)) *DeviceServiceClientMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the DeviceServiceClient.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mDeviceServiceClientMockSearch) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *DeviceServiceClientMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceClientMock.Search mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &DeviceServiceClientMockSearchParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Search return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockSearchExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Search should be invoked
func (mmSearch *mDeviceServiceClientMockSearch) Times(n uint64) *mDeviceServiceClientMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of DeviceServiceClientMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mDeviceServiceClientMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_devicev1connect.DeviceServiceClient
func (mmSearch *DeviceServiceClientMock) Search(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockSearchParams{ctx, pp1}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("DeviceServiceClientMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("DeviceServiceClientMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("DeviceServiceClientMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the DeviceServiceClientMock.Search")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1)
	}
	mmSearch.t.Fatalf("Unexpected call to DeviceServiceClientMock.Search. %v %v", ctx, pp1)
	return
}

// SearchAfterCounter returns a count of finished DeviceServiceClientMock.Search invocations
func (mmSearch *DeviceServiceClientMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of DeviceServiceClientMock.Search invocations
func (mmSearch *DeviceServiceClientMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mDeviceServiceClientMockSearch) Calls() []*DeviceServiceClientMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

type mDeviceServiceClientMockSearchKey struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockSearchKeyExpectation
	expectations       []*DeviceServiceClientMockSearchKeyExpectation

	callArgs []*DeviceServiceClientMockSearchKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockSearchKeyExpectation specifies expectation struct of the DeviceServiceClient.SearchKey
type DeviceServiceClientMockSearchKeyExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockSearchKeyParams
	paramPtrs          *DeviceServiceClientMockSearchKeyParamPtrs
	expectationOrigins DeviceServiceClientMockSearchKeyExpectationOrigins
	results            *DeviceServiceClientMockSearchKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockSearchKeyParams contains parameters of the DeviceServiceClient.SearchKey
type DeviceServiceClientMockSearchKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchKeyRequest]
}

// DeviceServiceClientMockSearchKeyParamPtrs contains pointers to parameters of the DeviceServiceClient.SearchKey
type DeviceServiceClientMockSearchKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchKeyRequest]
}

// DeviceServiceClientMockSearchKeyResults contains results of the DeviceServiceClient.SearchKey
type DeviceServiceClientMockSearchKeyResults struct {
	pp2 *connect.Response[v1.SearchKeyResponse]
	err error
}

// DeviceServiceClientMockSearchKeyOrigins contains origins of expectations of the DeviceServiceClient.SearchKey
type DeviceServiceClientMockSearchKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Optional() *mDeviceServiceClientMockSearchKey {
	mmSearchKey.optional = true
	return mmSearchKey
}

// Expect sets up expected params for DeviceServiceClient.SearchKey
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) *mDeviceServiceClientMockSearchKey {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceClientMockSearchKeyExpectation{}
	}

	if mmSearchKey.defaultExpectation.paramPtrs != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by ExpectParams functions")
	}

	mmSearchKey.defaultExpectation.params = &DeviceServiceClientMockSearchKeyParams{ctx, pp1}
	mmSearchKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchKey.expectations {
		if minimock.Equal(e.params, mmSearchKey.defaultExpectation.params) {
			mmSearchKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchKey.defaultExpectation.params)
		}
	}

	return mmSearchKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.SearchKey
func (mmSearchKey *mDeviceServiceClientMockSearchKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockSearchKey {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceClientMockSearchKeyExpectation{}
	}

	if mmSearchKey.defaultExpectation.params != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Expect")
	}

	if mmSearchKey.defaultExpectation.paramPtrs == nil {
		mmSearchKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockSearchKeyParamPtrs{}
	}
	mmSearchKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.SearchKey
func (mmSearchKey *mDeviceServiceClientMockSearchKey) ExpectPp1Param2(pp1 *connect.Request[v1.SearchKeyRequest]) *mDeviceServiceClientMockSearchKey {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceClientMockSearchKeyExpectation{}
	}

	if mmSearchKey.defaultExpectation.params != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Expect")
	}

	if mmSearchKey.defaultExpectation.paramPtrs == nil {
		mmSearchKey.defaultExpectation.paramPtrs = &DeviceServiceClientMockSearchKeyParamPtrs{}
	}
	mmSearchKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.SearchKey
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest])) *mDeviceServiceClientMockSearchKey {
	if mmSearchKey.mock.inspectFuncSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.SearchKey")
	}

	mmSearchKey.mock.inspectFuncSearchKey = f

	return mmSearchKey
}

// Return sets up results that will be returned by DeviceServiceClient.SearchKey
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Return(pp2 *connect.Response[v1.SearchKeyResponse], err error) *DeviceServiceClientMock {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceClientMockSearchKeyExpectation{mock: mmSearchKey.mock}
	}
	mmSearchKey.defaultExpectation.results = &DeviceServiceClientMockSearchKeyResults{pp2, err}
	mmSearchKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchKey.mock
}

// Set uses given function f to mock the DeviceServiceClient.SearchKey method
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) (pp2 *connect.Response[v1.SearchKeyResponse], err error)) *DeviceServiceClientMock {
	if mmSearchKey.defaultExpectation != nil {
		mmSearchKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.SearchKey method")
	}

	if len(mmSearchKey.expectations) > 0 {
		mmSearchKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.SearchKey method")
	}

	mmSearchKey.mock.funcSearchKey = f
	mmSearchKey.mock.funcSearchKeyOrigin = minimock.CallerInfo(1)
	return mmSearchKey.mock
}

// When sets expectation for the DeviceServiceClient.SearchKey which will trigger the result defined by the following
// Then helper
func (mmSearchKey *mDeviceServiceClientMockSearchKey) When(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) *DeviceServiceClientMockSearchKeyExpectation {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceClientMock.SearchKey mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockSearchKeyExpectation{
		mock:               mmSearchKey.mock,
		params:             &DeviceServiceClientMockSearchKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockSearchKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchKey.expectations = append(mmSearchKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.SearchKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockSearchKeyExpectation) Then(pp2 *connect.Response[v1.SearchKeyResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockSearchKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.SearchKey should be invoked
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Times(n uint64) *mDeviceServiceClientMockSearchKey {
	if n == 0 {
		mmSearchKey.mock.t.Fatalf("Times of DeviceServiceClientMock.SearchKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchKey.expectedInvocations, n)
	mmSearchKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchKey
}

func (mmSearchKey *mDeviceServiceClientMockSearchKey) invocationsDone() bool {
	if len(mmSearchKey.expectations) == 0 && mmSearchKey.defaultExpectation == nil && mmSearchKey.mock.funcSearchKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchKey.mock.afterSearchKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchKey implements mm_devicev1connect.DeviceServiceClient
func (mmSearchKey *DeviceServiceClientMock) SearchKey(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) (pp2 *connect.Response[v1.SearchKeyResponse], err error) {
	mm_atomic.AddUint64(&mmSearchKey.beforeSearchKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchKey.afterSearchKeyCounter, 1)

	mmSearchKey.t.Helper()

	if mmSearchKey.inspectFuncSearchKey != nil {
		mmSearchKey.inspectFuncSearchKey(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockSearchKeyParams{ctx, pp1}

	// Record call args
	mmSearchKey.SearchKeyMock.mutex.Lock()
	mmSearchKey.SearchKeyMock.callArgs = append(mmSearchKey.SearchKeyMock.callArgs, &mm_params)
	mmSearchKey.SearchKeyMock.mutex.Unlock()

	for _, e := range mmSearchKey.SearchKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchKey.SearchKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchKey.SearchKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchKey.SearchKeyMock.defaultExpectation.params
		mm_want_ptrs := mmSearchKey.SearchKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockSearchKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchKey.t.Errorf("DeviceServiceClientMock.SearchKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchKey.SearchKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchKey.t.Errorf("DeviceServiceClientMock.SearchKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchKey.SearchKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchKey.t.Errorf("DeviceServiceClientMock.SearchKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchKey.SearchKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchKey.SearchKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchKey.t.Fatal("No results are set for the DeviceServiceClientMock.SearchKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchKey.funcSearchKey != nil {
		return mmSearchKey.funcSearchKey(ctx, pp1)
	}
	mmSearchKey.t.Fatalf("Unexpected call to DeviceServiceClientMock.SearchKey. %v %v", ctx, pp1)
	return
}

// SearchKeyAfterCounter returns a count of finished DeviceServiceClientMock.SearchKey invocations
func (mmSearchKey *DeviceServiceClientMock) SearchKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchKey.afterSearchKeyCounter)
}

// SearchKeyBeforeCounter returns a count of DeviceServiceClientMock.SearchKey invocations
func (mmSearchKey *DeviceServiceClientMock) SearchKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchKey.beforeSearchKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.SearchKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchKey *mDeviceServiceClientMockSearchKey) Calls() []*DeviceServiceClientMockSearchKeyParams {
	mmSearchKey.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockSearchKeyParams, len(mmSearchKey.callArgs))
	copy(argCopy, mmSearchKey.callArgs)

	mmSearchKey.mutex.RUnlock()

	return argCopy
}

// MinimockSearchKeyDone returns true if the count of the SearchKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockSearchKeyDone() bool {
	if m.SearchKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchKeyMock.invocationsDone()
}

// MinimockSearchKeyInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockSearchKeyInspect() {
	for _, e := range m.SearchKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.SearchKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchKeyCounter := mm_atomic.LoadUint64(&m.afterSearchKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchKeyMock.defaultExpectation != nil && afterSearchKeyCounter < 1 {
		if m.SearchKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.SearchKey at\n%s", m.SearchKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.SearchKey at\n%s with params: %#v", m.SearchKeyMock.defaultExpectation.expectationOrigins.origin, *m.SearchKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchKey != nil && afterSearchKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.SearchKey at\n%s", m.funcSearchKeyOrigin)
	}

	if !m.SearchKeyMock.invocationsDone() && afterSearchKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.SearchKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchKeyMock.expectedInvocations), m.SearchKeyMock.expectedInvocationsOrigin, afterSearchKeyCounter)
	}
}

type mDeviceServiceClientMockUpdate struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockUpdateExpectation
	expectations       []*DeviceServiceClientMockUpdateExpectation

	callArgs []*DeviceServiceClientMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockUpdateExpectation specifies expectation struct of the DeviceServiceClient.Update
type DeviceServiceClientMockUpdateExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockUpdateParams
	paramPtrs          *DeviceServiceClientMockUpdateParamPtrs
	expectationOrigins DeviceServiceClientMockUpdateExpectationOrigins
	results            *DeviceServiceClientMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockUpdateParams contains parameters of the DeviceServiceClient.Update
type DeviceServiceClientMockUpdateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateRequest]
}

// DeviceServiceClientMockUpdateParamPtrs contains pointers to parameters of the DeviceServiceClient.Update
type DeviceServiceClientMockUpdateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateRequest]
}

// DeviceServiceClientMockUpdateResults contains results of the DeviceServiceClient.Update
type DeviceServiceClientMockUpdateResults struct {
	pp2 *connect.Response[v1.UpdateResponse]
	err error
}

// DeviceServiceClientMockUpdateOrigins contains origins of expectations of the DeviceServiceClient.Update
type DeviceServiceClientMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mDeviceServiceClientMockUpdate) Optional() *mDeviceServiceClientMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for DeviceServiceClient.Update
func (mmUpdate *mDeviceServiceClientMockUpdate) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) *mDeviceServiceClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &DeviceServiceClientMockUpdateParams{ctx, pp1}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.Update
func (mmUpdate *mDeviceServiceClientMockUpdate) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DeviceServiceClientMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.Update
func (mmUpdate *mDeviceServiceClientMockUpdate) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateRequest]) *mDeviceServiceClientMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceClientMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DeviceServiceClientMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.Update
func (mmUpdate *mDeviceServiceClientMockUpdate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest])) *mDeviceServiceClientMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by DeviceServiceClient.Update
func (mmUpdate *mDeviceServiceClientMockUpdate) Return(pp2 *connect.Response[v1.UpdateResponse], err error) *DeviceServiceClientMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceClientMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &DeviceServiceClientMockUpdateResults{pp2, err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the DeviceServiceClient.Update method
func (mmUpdate *mDeviceServiceClientMockUpdate) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) (pp2 *connect.Response[v1.UpdateResponse], err error)) *DeviceServiceClientMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the DeviceServiceClient.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mDeviceServiceClientMockUpdate) When(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) *DeviceServiceClientMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceClientMock.Update mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &DeviceServiceClientMockUpdateParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.Update return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockUpdateExpectation) Then(pp2 *connect.Response[v1.UpdateResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockUpdateResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.Update should be invoked
func (mmUpdate *mDeviceServiceClientMockUpdate) Times(n uint64) *mDeviceServiceClientMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of DeviceServiceClientMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mDeviceServiceClientMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_devicev1connect.DeviceServiceClient
func (mmUpdate *DeviceServiceClientMock) Update(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) (pp2 *connect.Response[v1.UpdateResponse], err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockUpdateParams{ctx, pp1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockUpdateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("DeviceServiceClientMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdate.t.Errorf("DeviceServiceClientMock.Update got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("DeviceServiceClientMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the DeviceServiceClientMock.Update")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, pp1)
	}
	mmUpdate.t.Fatalf("Unexpected call to DeviceServiceClientMock.Update. %v %v", ctx, pp1)
	return
}

// UpdateAfterCounter returns a count of finished DeviceServiceClientMock.Update invocations
func (mmUpdate *DeviceServiceClientMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of DeviceServiceClientMock.Update invocations
func (mmUpdate *DeviceServiceClientMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mDeviceServiceClientMockUpdate) Calls() []*DeviceServiceClientMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

type mDeviceServiceClientMockUpdatePresence struct {
	optional           bool
	mock               *DeviceServiceClientMock
	defaultExpectation *DeviceServiceClientMockUpdatePresenceExpectation
	expectations       []*DeviceServiceClientMockUpdatePresenceExpectation

	callArgs []*DeviceServiceClientMockUpdatePresenceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceClientMockUpdatePresenceExpectation specifies expectation struct of the DeviceServiceClient.UpdatePresence
type DeviceServiceClientMockUpdatePresenceExpectation struct {
	mock               *DeviceServiceClientMock
	params             *DeviceServiceClientMockUpdatePresenceParams
	paramPtrs          *DeviceServiceClientMockUpdatePresenceParamPtrs
	expectationOrigins DeviceServiceClientMockUpdatePresenceExpectationOrigins
	results            *DeviceServiceClientMockUpdatePresenceResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceClientMockUpdatePresenceParams contains parameters of the DeviceServiceClient.UpdatePresence
type DeviceServiceClientMockUpdatePresenceParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdatePresenceRequest]
}

// DeviceServiceClientMockUpdatePresenceParamPtrs contains pointers to parameters of the DeviceServiceClient.UpdatePresence
type DeviceServiceClientMockUpdatePresenceParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdatePresenceRequest]
}

// DeviceServiceClientMockUpdatePresenceResults contains results of the DeviceServiceClient.UpdatePresence
type DeviceServiceClientMockUpdatePresenceResults struct {
	pp2 *connect.Response[v1.UpdatePresenceResponse]
	err error
}

// DeviceServiceClientMockUpdatePresenceOrigins contains origins of expectations of the DeviceServiceClient.UpdatePresence
type DeviceServiceClientMockUpdatePresenceExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Optional() *mDeviceServiceClientMockUpdatePresence {
	mmUpdatePresence.optional = true
	return mmUpdatePresence
}

// Expect sets up expected params for DeviceServiceClient.UpdatePresence
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) *mDeviceServiceClientMockUpdatePresence {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceClientMockUpdatePresenceExpectation{}
	}

	if mmUpdatePresence.defaultExpectation.paramPtrs != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by ExpectParams functions")
	}

	mmUpdatePresence.defaultExpectation.params = &DeviceServiceClientMockUpdatePresenceParams{ctx, pp1}
	mmUpdatePresence.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePresence.expectations {
		if minimock.Equal(e.params, mmUpdatePresence.defaultExpectation.params) {
			mmUpdatePresence.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePresence.defaultExpectation.params)
		}
	}

	return mmUpdatePresence
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceClient.UpdatePresence
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) ExpectCtxParam1(ctx context.Context) *mDeviceServiceClientMockUpdatePresence {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceClientMockUpdatePresenceExpectation{}
	}

	if mmUpdatePresence.defaultExpectation.params != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Expect")
	}

	if mmUpdatePresence.defaultExpectation.paramPtrs == nil {
		mmUpdatePresence.defaultExpectation.paramPtrs = &DeviceServiceClientMockUpdatePresenceParamPtrs{}
	}
	mmUpdatePresence.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePresence.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePresence
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceClient.UpdatePresence
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) ExpectPp1Param2(pp1 *connect.Request[v1.UpdatePresenceRequest]) *mDeviceServiceClientMockUpdatePresence {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceClientMockUpdatePresenceExpectation{}
	}

	if mmUpdatePresence.defaultExpectation.params != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Expect")
	}

	if mmUpdatePresence.defaultExpectation.paramPtrs == nil {
		mmUpdatePresence.defaultExpectation.paramPtrs = &DeviceServiceClientMockUpdatePresenceParamPtrs{}
	}
	mmUpdatePresence.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdatePresence.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdatePresence
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceClient.UpdatePresence
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest])) *mDeviceServiceClientMockUpdatePresence {
	if mmUpdatePresence.mock.inspectFuncUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("Inspect function is already set for DeviceServiceClientMock.UpdatePresence")
	}

	mmUpdatePresence.mock.inspectFuncUpdatePresence = f

	return mmUpdatePresence
}

// Return sets up results that will be returned by DeviceServiceClient.UpdatePresence
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Return(pp2 *connect.Response[v1.UpdatePresenceResponse], err error) *DeviceServiceClientMock {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceClientMockUpdatePresenceExpectation{mock: mmUpdatePresence.mock}
	}
	mmUpdatePresence.defaultExpectation.results = &DeviceServiceClientMockUpdatePresenceResults{pp2, err}
	mmUpdatePresence.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePresence.mock
}

// Set uses given function f to mock the DeviceServiceClient.UpdatePresence method
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) (pp2 *connect.Response[v1.UpdatePresenceResponse], err error)) *DeviceServiceClientMock {
	if mmUpdatePresence.defaultExpectation != nil {
		mmUpdatePresence.mock.t.Fatalf("Default expectation is already set for the DeviceServiceClient.UpdatePresence method")
	}

	if len(mmUpdatePresence.expectations) > 0 {
		mmUpdatePresence.mock.t.Fatalf("Some expectations are already set for the DeviceServiceClient.UpdatePresence method")
	}

	mmUpdatePresence.mock.funcUpdatePresence = f
	mmUpdatePresence.mock.funcUpdatePresenceOrigin = minimock.CallerInfo(1)
	return mmUpdatePresence.mock
}

// When sets expectation for the DeviceServiceClient.UpdatePresence which will trigger the result defined by the following
// Then helper
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) When(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) *DeviceServiceClientMockUpdatePresenceExpectation {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceClientMock.UpdatePresence mock is already set by Set")
	}

	expectation := &DeviceServiceClientMockUpdatePresenceExpectation{
		mock:               mmUpdatePresence.mock,
		params:             &DeviceServiceClientMockUpdatePresenceParams{ctx, pp1},
		expectationOrigins: DeviceServiceClientMockUpdatePresenceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePresence.expectations = append(mmUpdatePresence.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceClient.UpdatePresence return parameters for the expectation previously defined by the When method
func (e *DeviceServiceClientMockUpdatePresenceExpectation) Then(pp2 *connect.Response[v1.UpdatePresenceResponse], err error) *DeviceServiceClientMock {
	e.results = &DeviceServiceClientMockUpdatePresenceResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceClient.UpdatePresence should be invoked
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Times(n uint64) *mDeviceServiceClientMockUpdatePresence {
	if n == 0 {
		mmUpdatePresence.mock.t.Fatalf("Times of DeviceServiceClientMock.UpdatePresence mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePresence.expectedInvocations, n)
	mmUpdatePresence.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePresence
}

func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) invocationsDone() bool {
	if len(mmUpdatePresence.expectations) == 0 && mmUpdatePresence.defaultExpectation == nil && mmUpdatePresence.mock.funcUpdatePresence == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePresence.mock.afterUpdatePresenceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePresence.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePresence implements mm_devicev1connect.DeviceServiceClient
func (mmUpdatePresence *DeviceServiceClientMock) UpdatePresence(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) (pp2 *connect.Response[v1.UpdatePresenceResponse], err error) {
	mm_atomic.AddUint64(&mmUpdatePresence.beforeUpdatePresenceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePresence.afterUpdatePresenceCounter, 1)

	mmUpdatePresence.t.Helper()

	if mmUpdatePresence.inspectFuncUpdatePresence != nil {
		mmUpdatePresence.inspectFuncUpdatePresence(ctx, pp1)
	}

	mm_params := DeviceServiceClientMockUpdatePresenceParams{ctx, pp1}

	// Record call args
	mmUpdatePresence.UpdatePresenceMock.mutex.Lock()
	mmUpdatePresence.UpdatePresenceMock.callArgs = append(mmUpdatePresence.UpdatePresenceMock.callArgs, &mm_params)
	mmUpdatePresence.UpdatePresenceMock.mutex.Unlock()

	for _, e := range mmUpdatePresence.UpdatePresenceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdatePresence.UpdatePresenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePresence.UpdatePresenceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePresence.UpdatePresenceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePresence.UpdatePresenceMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceClientMockUpdatePresenceParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePresence.t.Errorf("DeviceServiceClientMock.UpdatePresence got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePresence.UpdatePresenceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdatePresence.t.Errorf("DeviceServiceClientMock.UpdatePresence got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePresence.UpdatePresenceMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePresence.t.Errorf("DeviceServiceClientMock.UpdatePresence got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePresence.UpdatePresenceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePresence.UpdatePresenceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePresence.t.Fatal("No results are set for the DeviceServiceClientMock.UpdatePresence")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdatePresence.funcUpdatePresence != nil {
		return mmUpdatePresence.funcUpdatePresence(ctx, pp1)
	}
	mmUpdatePresence.t.Fatalf("Unexpected call to DeviceServiceClientMock.UpdatePresence. %v %v", ctx, pp1)
	return
}

// UpdatePresenceAfterCounter returns a count of finished DeviceServiceClientMock.UpdatePresence invocations
func (mmUpdatePresence *DeviceServiceClientMock) UpdatePresenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePresence.afterUpdatePresenceCounter)
}

// UpdatePresenceBeforeCounter returns a count of DeviceServiceClientMock.UpdatePresence invocations
func (mmUpdatePresence *DeviceServiceClientMock) UpdatePresenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePresence.beforeUpdatePresenceCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceClientMock.UpdatePresence.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePresence *mDeviceServiceClientMockUpdatePresence) Calls() []*DeviceServiceClientMockUpdatePresenceParams {
	mmUpdatePresence.mutex.RLock()

	argCopy := make([]*DeviceServiceClientMockUpdatePresenceParams, len(mmUpdatePresence.callArgs))
	copy(argCopy, mmUpdatePresence.callArgs)

	mmUpdatePresence.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePresenceDone returns true if the count of the UpdatePresence invocations corresponds
// the number of defined expectations
func (m *DeviceServiceClientMock) MinimockUpdatePresenceDone() bool {
	if m.UpdatePresenceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePresenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePresenceMock.invocationsDone()
}

// MinimockUpdatePresenceInspect logs each unmet expectation
func (m *DeviceServiceClientMock) MinimockUpdatePresenceInspect() {
	for _, e := range m.UpdatePresenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceClientMock.UpdatePresence at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePresenceCounter := mm_atomic.LoadUint64(&m.afterUpdatePresenceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePresenceMock.defaultExpectation != nil && afterUpdatePresenceCounter < 1 {
		if m.UpdatePresenceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceClientMock.UpdatePresence at\n%s", m.UpdatePresenceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceClientMock.UpdatePresence at\n%s with params: %#v", m.UpdatePresenceMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePresenceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePresence != nil && afterUpdatePresenceCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceClientMock.UpdatePresence at\n%s", m.funcUpdatePresenceOrigin)
	}

	if !m.UpdatePresenceMock.invocationsDone() && afterUpdatePresenceCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceClientMock.UpdatePresence at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePresenceMock.expectedInvocations), m.UpdatePresenceMock.expectedInvocationsOrigin, afterUpdatePresenceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DeviceServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddKeyInspect()

			m.MinimockCreateInspect()

			m.MinimockDeRegisterKeyInspect()

			m.MinimockGetByIdInspect()

			m.MinimockGetBySessionIdInspect()

			m.MinimockLinkInspect()

			m.MinimockListLogsInspect()

			m.MinimockLogInspect()

			m.MinimockNotifyInspect()

			m.MinimockRegisterKeyInspect()

			m.MinimockRemoveInspect()

			m.MinimockRemoveKeyInspect()

			m.MinimockSearchInspect()

			m.MinimockSearchKeyInspect()

			m.MinimockUpdateInspect()

			m.MinimockUpdatePresenceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DeviceServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DeviceServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddKeyDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeRegisterKeyDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockGetBySessionIdDone() &&
		m.MinimockLinkDone() &&
		m.MinimockListLogsDone() &&
		m.MinimockLogDone() &&
		m.MinimockNotifyDone() &&
		m.MinimockRegisterKeyDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockRemoveKeyDone() &&
		m.MinimockSearchDone() &&
		m.MinimockSearchKeyDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdatePresenceDone()
}
