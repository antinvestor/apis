// Copyright 2023-2024 Ant Investor Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/device/connectrpc/go/device/v1/devicev1connect.DeviceServiceHandler -o device_handler.gen.go -n DeviceServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/device/protocolbuffers/go/device/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// DeviceServiceHandlerMock implements mm_devicev1connect.DeviceServiceHandler
type DeviceServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddKey          func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) (pp2 *connect.Response[v1.AddKeyResponse], err error)
	funcAddKeyOrigin    string
	inspectFuncAddKey   func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest])
	afterAddKeyCounter  uint64
	beforeAddKeyCounter uint64
	AddKeyMock          mDeviceServiceHandlerMockAddKey

	funcCreate          func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) (pp2 *connect.Response[v1.CreateResponse], err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest])
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mDeviceServiceHandlerMockCreate

	funcDeRegisterKey          func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) (pp2 *connect.Response[v1.DeRegisterKeyResponse], err error)
	funcDeRegisterKeyOrigin    string
	inspectFuncDeRegisterKey   func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest])
	afterDeRegisterKeyCounter  uint64
	beforeDeRegisterKeyCounter uint64
	DeRegisterKeyMock          mDeviceServiceHandlerMockDeRegisterKey

	funcGetById          func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) (pp2 *connect.Response[v1.GetByIdResponse], err error)
	funcGetByIdOrigin    string
	inspectFuncGetById   func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest])
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mDeviceServiceHandlerMockGetById

	funcGetBySessionId          func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) (pp2 *connect.Response[v1.GetBySessionIdResponse], err error)
	funcGetBySessionIdOrigin    string
	inspectFuncGetBySessionId   func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest])
	afterGetBySessionIdCounter  uint64
	beforeGetBySessionIdCounter uint64
	GetBySessionIdMock          mDeviceServiceHandlerMockGetBySessionId

	funcLink          func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) (pp2 *connect.Response[v1.LinkResponse], err error)
	funcLinkOrigin    string
	inspectFuncLink   func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest])
	afterLinkCounter  uint64
	beforeLinkCounter uint64
	LinkMock          mDeviceServiceHandlerMockLink

	funcListLogs          func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse]) (err error)
	funcListLogsOrigin    string
	inspectFuncListLogs   func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse])
	afterListLogsCounter  uint64
	beforeListLogsCounter uint64
	ListLogsMock          mDeviceServiceHandlerMockListLogs

	funcLog          func(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) (pp2 *connect.Response[v1.LogResponse], err error)
	funcLogOrigin    string
	inspectFuncLog   func(ctx context.Context, pp1 *connect.Request[v1.LogRequest])
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mDeviceServiceHandlerMockLog

	funcNotify          func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) (pp2 *connect.Response[v1.NotifyResponse], err error)
	funcNotifyOrigin    string
	inspectFuncNotify   func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest])
	afterNotifyCounter  uint64
	beforeNotifyCounter uint64
	NotifyMock          mDeviceServiceHandlerMockNotify

	funcRegisterKey          func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) (pp2 *connect.Response[v1.RegisterKeyResponse], err error)
	funcRegisterKeyOrigin    string
	inspectFuncRegisterKey   func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest])
	afterRegisterKeyCounter  uint64
	beforeRegisterKeyCounter uint64
	RegisterKeyMock          mDeviceServiceHandlerMockRegisterKey

	funcRemove          func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) (pp2 *connect.Response[v1.RemoveResponse], err error)
	funcRemoveOrigin    string
	inspectFuncRemove   func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest])
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mDeviceServiceHandlerMockRemove

	funcRemoveKey          func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) (pp2 *connect.Response[v1.RemoveKeyResponse], err error)
	funcRemoveKeyOrigin    string
	inspectFuncRemoveKey   func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest])
	afterRemoveKeyCounter  uint64
	beforeRemoveKeyCounter uint64
	RemoveKeyMock          mDeviceServiceHandlerMockRemoveKey

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mDeviceServiceHandlerMockSearch

	funcSearchKey          func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) (pp2 *connect.Response[v1.SearchKeyResponse], err error)
	funcSearchKeyOrigin    string
	inspectFuncSearchKey   func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest])
	afterSearchKeyCounter  uint64
	beforeSearchKeyCounter uint64
	SearchKeyMock          mDeviceServiceHandlerMockSearchKey

	funcUpdate          func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) (pp2 *connect.Response[v1.UpdateResponse], err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest])
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mDeviceServiceHandlerMockUpdate

	funcUpdatePresence          func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) (pp2 *connect.Response[v1.UpdatePresenceResponse], err error)
	funcUpdatePresenceOrigin    string
	inspectFuncUpdatePresence   func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest])
	afterUpdatePresenceCounter  uint64
	beforeUpdatePresenceCounter uint64
	UpdatePresenceMock          mDeviceServiceHandlerMockUpdatePresence
}

// NewDeviceServiceHandlerMock returns a mock for mm_devicev1connect.DeviceServiceHandler
func NewDeviceServiceHandlerMock(t minimock.Tester) *DeviceServiceHandlerMock {
	m := &DeviceServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddKeyMock = mDeviceServiceHandlerMockAddKey{mock: m}
	m.AddKeyMock.callArgs = []*DeviceServiceHandlerMockAddKeyParams{}

	m.CreateMock = mDeviceServiceHandlerMockCreate{mock: m}
	m.CreateMock.callArgs = []*DeviceServiceHandlerMockCreateParams{}

	m.DeRegisterKeyMock = mDeviceServiceHandlerMockDeRegisterKey{mock: m}
	m.DeRegisterKeyMock.callArgs = []*DeviceServiceHandlerMockDeRegisterKeyParams{}

	m.GetByIdMock = mDeviceServiceHandlerMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*DeviceServiceHandlerMockGetByIdParams{}

	m.GetBySessionIdMock = mDeviceServiceHandlerMockGetBySessionId{mock: m}
	m.GetBySessionIdMock.callArgs = []*DeviceServiceHandlerMockGetBySessionIdParams{}

	m.LinkMock = mDeviceServiceHandlerMockLink{mock: m}
	m.LinkMock.callArgs = []*DeviceServiceHandlerMockLinkParams{}

	m.ListLogsMock = mDeviceServiceHandlerMockListLogs{mock: m}
	m.ListLogsMock.callArgs = []*DeviceServiceHandlerMockListLogsParams{}

	m.LogMock = mDeviceServiceHandlerMockLog{mock: m}
	m.LogMock.callArgs = []*DeviceServiceHandlerMockLogParams{}

	m.NotifyMock = mDeviceServiceHandlerMockNotify{mock: m}
	m.NotifyMock.callArgs = []*DeviceServiceHandlerMockNotifyParams{}

	m.RegisterKeyMock = mDeviceServiceHandlerMockRegisterKey{mock: m}
	m.RegisterKeyMock.callArgs = []*DeviceServiceHandlerMockRegisterKeyParams{}

	m.RemoveMock = mDeviceServiceHandlerMockRemove{mock: m}
	m.RemoveMock.callArgs = []*DeviceServiceHandlerMockRemoveParams{}

	m.RemoveKeyMock = mDeviceServiceHandlerMockRemoveKey{mock: m}
	m.RemoveKeyMock.callArgs = []*DeviceServiceHandlerMockRemoveKeyParams{}

	m.SearchMock = mDeviceServiceHandlerMockSearch{mock: m}
	m.SearchMock.callArgs = []*DeviceServiceHandlerMockSearchParams{}

	m.SearchKeyMock = mDeviceServiceHandlerMockSearchKey{mock: m}
	m.SearchKeyMock.callArgs = []*DeviceServiceHandlerMockSearchKeyParams{}

	m.UpdateMock = mDeviceServiceHandlerMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*DeviceServiceHandlerMockUpdateParams{}

	m.UpdatePresenceMock = mDeviceServiceHandlerMockUpdatePresence{mock: m}
	m.UpdatePresenceMock.callArgs = []*DeviceServiceHandlerMockUpdatePresenceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDeviceServiceHandlerMockAddKey struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockAddKeyExpectation
	expectations       []*DeviceServiceHandlerMockAddKeyExpectation

	callArgs []*DeviceServiceHandlerMockAddKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockAddKeyExpectation specifies expectation struct of the DeviceServiceHandler.AddKey
type DeviceServiceHandlerMockAddKeyExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockAddKeyParams
	paramPtrs          *DeviceServiceHandlerMockAddKeyParamPtrs
	expectationOrigins DeviceServiceHandlerMockAddKeyExpectationOrigins
	results            *DeviceServiceHandlerMockAddKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockAddKeyParams contains parameters of the DeviceServiceHandler.AddKey
type DeviceServiceHandlerMockAddKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddKeyRequest]
}

// DeviceServiceHandlerMockAddKeyParamPtrs contains pointers to parameters of the DeviceServiceHandler.AddKey
type DeviceServiceHandlerMockAddKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddKeyRequest]
}

// DeviceServiceHandlerMockAddKeyResults contains results of the DeviceServiceHandler.AddKey
type DeviceServiceHandlerMockAddKeyResults struct {
	pp2 *connect.Response[v1.AddKeyResponse]
	err error
}

// DeviceServiceHandlerMockAddKeyOrigins contains origins of expectations of the DeviceServiceHandler.AddKey
type DeviceServiceHandlerMockAddKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Optional() *mDeviceServiceHandlerMockAddKey {
	mmAddKey.optional = true
	return mmAddKey
}

// Expect sets up expected params for DeviceServiceHandler.AddKey
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Expect(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) *mDeviceServiceHandlerMockAddKey {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceHandlerMockAddKeyExpectation{}
	}

	if mmAddKey.defaultExpectation.paramPtrs != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by ExpectParams functions")
	}

	mmAddKey.defaultExpectation.params = &DeviceServiceHandlerMockAddKeyParams{ctx, pp1}
	mmAddKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddKey.expectations {
		if minimock.Equal(e.params, mmAddKey.defaultExpectation.params) {
			mmAddKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddKey.defaultExpectation.params)
		}
	}

	return mmAddKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.AddKey
func (mmAddKey *mDeviceServiceHandlerMockAddKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockAddKey {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceHandlerMockAddKeyExpectation{}
	}

	if mmAddKey.defaultExpectation.params != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Expect")
	}

	if mmAddKey.defaultExpectation.paramPtrs == nil {
		mmAddKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockAddKeyParamPtrs{}
	}
	mmAddKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.AddKey
func (mmAddKey *mDeviceServiceHandlerMockAddKey) ExpectPp1Param2(pp1 *connect.Request[v1.AddKeyRequest]) *mDeviceServiceHandlerMockAddKey {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceHandlerMockAddKeyExpectation{}
	}

	if mmAddKey.defaultExpectation.params != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Expect")
	}

	if mmAddKey.defaultExpectation.paramPtrs == nil {
		mmAddKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockAddKeyParamPtrs{}
	}
	mmAddKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.AddKey
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest])) *mDeviceServiceHandlerMockAddKey {
	if mmAddKey.mock.inspectFuncAddKey != nil {
		mmAddKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.AddKey")
	}

	mmAddKey.mock.inspectFuncAddKey = f

	return mmAddKey
}

// Return sets up results that will be returned by DeviceServiceHandler.AddKey
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Return(pp2 *connect.Response[v1.AddKeyResponse], err error) *DeviceServiceHandlerMock {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Set")
	}

	if mmAddKey.defaultExpectation == nil {
		mmAddKey.defaultExpectation = &DeviceServiceHandlerMockAddKeyExpectation{mock: mmAddKey.mock}
	}
	mmAddKey.defaultExpectation.results = &DeviceServiceHandlerMockAddKeyResults{pp2, err}
	mmAddKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddKey.mock
}

// Set uses given function f to mock the DeviceServiceHandler.AddKey method
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) (pp2 *connect.Response[v1.AddKeyResponse], err error)) *DeviceServiceHandlerMock {
	if mmAddKey.defaultExpectation != nil {
		mmAddKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.AddKey method")
	}

	if len(mmAddKey.expectations) > 0 {
		mmAddKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.AddKey method")
	}

	mmAddKey.mock.funcAddKey = f
	mmAddKey.mock.funcAddKeyOrigin = minimock.CallerInfo(1)
	return mmAddKey.mock
}

// When sets expectation for the DeviceServiceHandler.AddKey which will trigger the result defined by the following
// Then helper
func (mmAddKey *mDeviceServiceHandlerMockAddKey) When(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) *DeviceServiceHandlerMockAddKeyExpectation {
	if mmAddKey.mock.funcAddKey != nil {
		mmAddKey.mock.t.Fatalf("DeviceServiceHandlerMock.AddKey mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockAddKeyExpectation{
		mock:               mmAddKey.mock,
		params:             &DeviceServiceHandlerMockAddKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockAddKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddKey.expectations = append(mmAddKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.AddKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockAddKeyExpectation) Then(pp2 *connect.Response[v1.AddKeyResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockAddKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.AddKey should be invoked
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Times(n uint64) *mDeviceServiceHandlerMockAddKey {
	if n == 0 {
		mmAddKey.mock.t.Fatalf("Times of DeviceServiceHandlerMock.AddKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddKey.expectedInvocations, n)
	mmAddKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddKey
}

func (mmAddKey *mDeviceServiceHandlerMockAddKey) invocationsDone() bool {
	if len(mmAddKey.expectations) == 0 && mmAddKey.defaultExpectation == nil && mmAddKey.mock.funcAddKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddKey.mock.afterAddKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddKey implements mm_devicev1connect.DeviceServiceHandler
func (mmAddKey *DeviceServiceHandlerMock) AddKey(ctx context.Context, pp1 *connect.Request[v1.AddKeyRequest]) (pp2 *connect.Response[v1.AddKeyResponse], err error) {
	mm_atomic.AddUint64(&mmAddKey.beforeAddKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmAddKey.afterAddKeyCounter, 1)

	mmAddKey.t.Helper()

	if mmAddKey.inspectFuncAddKey != nil {
		mmAddKey.inspectFuncAddKey(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockAddKeyParams{ctx, pp1}

	// Record call args
	mmAddKey.AddKeyMock.mutex.Lock()
	mmAddKey.AddKeyMock.callArgs = append(mmAddKey.AddKeyMock.callArgs, &mm_params)
	mmAddKey.AddKeyMock.mutex.Unlock()

	for _, e := range mmAddKey.AddKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddKey.AddKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddKey.AddKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmAddKey.AddKeyMock.defaultExpectation.params
		mm_want_ptrs := mmAddKey.AddKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockAddKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddKey.t.Errorf("DeviceServiceHandlerMock.AddKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddKey.AddKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddKey.t.Errorf("DeviceServiceHandlerMock.AddKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddKey.AddKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddKey.t.Errorf("DeviceServiceHandlerMock.AddKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddKey.AddKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddKey.AddKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmAddKey.t.Fatal("No results are set for the DeviceServiceHandlerMock.AddKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddKey.funcAddKey != nil {
		return mmAddKey.funcAddKey(ctx, pp1)
	}
	mmAddKey.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.AddKey. %v %v", ctx, pp1)
	return
}

// AddKeyAfterCounter returns a count of finished DeviceServiceHandlerMock.AddKey invocations
func (mmAddKey *DeviceServiceHandlerMock) AddKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddKey.afterAddKeyCounter)
}

// AddKeyBeforeCounter returns a count of DeviceServiceHandlerMock.AddKey invocations
func (mmAddKey *DeviceServiceHandlerMock) AddKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddKey.beforeAddKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.AddKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddKey *mDeviceServiceHandlerMockAddKey) Calls() []*DeviceServiceHandlerMockAddKeyParams {
	mmAddKey.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockAddKeyParams, len(mmAddKey.callArgs))
	copy(argCopy, mmAddKey.callArgs)

	mmAddKey.mutex.RUnlock()

	return argCopy
}

// MinimockAddKeyDone returns true if the count of the AddKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockAddKeyDone() bool {
	if m.AddKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddKeyMock.invocationsDone()
}

// MinimockAddKeyInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockAddKeyInspect() {
	for _, e := range m.AddKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.AddKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddKeyCounter := mm_atomic.LoadUint64(&m.afterAddKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddKeyMock.defaultExpectation != nil && afterAddKeyCounter < 1 {
		if m.AddKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.AddKey at\n%s", m.AddKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.AddKey at\n%s with params: %#v", m.AddKeyMock.defaultExpectation.expectationOrigins.origin, *m.AddKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddKey != nil && afterAddKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.AddKey at\n%s", m.funcAddKeyOrigin)
	}

	if !m.AddKeyMock.invocationsDone() && afterAddKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.AddKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddKeyMock.expectedInvocations), m.AddKeyMock.expectedInvocationsOrigin, afterAddKeyCounter)
	}
}

type mDeviceServiceHandlerMockCreate struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockCreateExpectation
	expectations       []*DeviceServiceHandlerMockCreateExpectation

	callArgs []*DeviceServiceHandlerMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockCreateExpectation specifies expectation struct of the DeviceServiceHandler.Create
type DeviceServiceHandlerMockCreateExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockCreateParams
	paramPtrs          *DeviceServiceHandlerMockCreateParamPtrs
	expectationOrigins DeviceServiceHandlerMockCreateExpectationOrigins
	results            *DeviceServiceHandlerMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockCreateParams contains parameters of the DeviceServiceHandler.Create
type DeviceServiceHandlerMockCreateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateRequest]
}

// DeviceServiceHandlerMockCreateParamPtrs contains pointers to parameters of the DeviceServiceHandler.Create
type DeviceServiceHandlerMockCreateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateRequest]
}

// DeviceServiceHandlerMockCreateResults contains results of the DeviceServiceHandler.Create
type DeviceServiceHandlerMockCreateResults struct {
	pp2 *connect.Response[v1.CreateResponse]
	err error
}

// DeviceServiceHandlerMockCreateOrigins contains origins of expectations of the DeviceServiceHandler.Create
type DeviceServiceHandlerMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mDeviceServiceHandlerMockCreate) Optional() *mDeviceServiceHandlerMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for DeviceServiceHandler.Create
func (mmCreate *mDeviceServiceHandlerMockCreate) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) *mDeviceServiceHandlerMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceHandlerMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &DeviceServiceHandlerMockCreateParams{ctx, pp1}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Create
func (mmCreate *mDeviceServiceHandlerMockCreate) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceHandlerMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Create
func (mmCreate *mDeviceServiceHandlerMockCreate) ExpectPp1Param2(pp1 *connect.Request[v1.CreateRequest]) *mDeviceServiceHandlerMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceHandlerMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Create
func (mmCreate *mDeviceServiceHandlerMockCreate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest])) *mDeviceServiceHandlerMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by DeviceServiceHandler.Create
func (mmCreate *mDeviceServiceHandlerMockCreate) Return(pp2 *connect.Response[v1.CreateResponse], err error) *DeviceServiceHandlerMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &DeviceServiceHandlerMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &DeviceServiceHandlerMockCreateResults{pp2, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Create method
func (mmCreate *mDeviceServiceHandlerMockCreate) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) (pp2 *connect.Response[v1.CreateResponse], err error)) *DeviceServiceHandlerMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the DeviceServiceHandler.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mDeviceServiceHandlerMockCreate) When(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) *DeviceServiceHandlerMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("DeviceServiceHandlerMock.Create mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &DeviceServiceHandlerMockCreateParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Create return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockCreateExpectation) Then(pp2 *connect.Response[v1.CreateResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockCreateResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Create should be invoked
func (mmCreate *mDeviceServiceHandlerMockCreate) Times(n uint64) *mDeviceServiceHandlerMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mDeviceServiceHandlerMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_devicev1connect.DeviceServiceHandler
func (mmCreate *DeviceServiceHandlerMock) Create(ctx context.Context, pp1 *connect.Request[v1.CreateRequest]) (pp2 *connect.Response[v1.CreateResponse], err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockCreateParams{ctx, pp1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockCreateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("DeviceServiceHandlerMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreate.t.Errorf("DeviceServiceHandlerMock.Create got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("DeviceServiceHandlerMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the DeviceServiceHandlerMock.Create")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, pp1)
	}
	mmCreate.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Create. %v %v", ctx, pp1)
	return
}

// CreateAfterCounter returns a count of finished DeviceServiceHandlerMock.Create invocations
func (mmCreate *DeviceServiceHandlerMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of DeviceServiceHandlerMock.Create invocations
func (mmCreate *DeviceServiceHandlerMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mDeviceServiceHandlerMockCreate) Calls() []*DeviceServiceHandlerMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mDeviceServiceHandlerMockDeRegisterKey struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockDeRegisterKeyExpectation
	expectations       []*DeviceServiceHandlerMockDeRegisterKeyExpectation

	callArgs []*DeviceServiceHandlerMockDeRegisterKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockDeRegisterKeyExpectation specifies expectation struct of the DeviceServiceHandler.DeRegisterKey
type DeviceServiceHandlerMockDeRegisterKeyExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockDeRegisterKeyParams
	paramPtrs          *DeviceServiceHandlerMockDeRegisterKeyParamPtrs
	expectationOrigins DeviceServiceHandlerMockDeRegisterKeyExpectationOrigins
	results            *DeviceServiceHandlerMockDeRegisterKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockDeRegisterKeyParams contains parameters of the DeviceServiceHandler.DeRegisterKey
type DeviceServiceHandlerMockDeRegisterKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeRegisterKeyRequest]
}

// DeviceServiceHandlerMockDeRegisterKeyParamPtrs contains pointers to parameters of the DeviceServiceHandler.DeRegisterKey
type DeviceServiceHandlerMockDeRegisterKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeRegisterKeyRequest]
}

// DeviceServiceHandlerMockDeRegisterKeyResults contains results of the DeviceServiceHandler.DeRegisterKey
type DeviceServiceHandlerMockDeRegisterKeyResults struct {
	pp2 *connect.Response[v1.DeRegisterKeyResponse]
	err error
}

// DeviceServiceHandlerMockDeRegisterKeyOrigins contains origins of expectations of the DeviceServiceHandler.DeRegisterKey
type DeviceServiceHandlerMockDeRegisterKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Optional() *mDeviceServiceHandlerMockDeRegisterKey {
	mmDeRegisterKey.optional = true
	return mmDeRegisterKey
}

// Expect sets up expected params for DeviceServiceHandler.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Expect(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) *mDeviceServiceHandlerMockDeRegisterKey {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceHandlerMockDeRegisterKeyExpectation{}
	}

	if mmDeRegisterKey.defaultExpectation.paramPtrs != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by ExpectParams functions")
	}

	mmDeRegisterKey.defaultExpectation.params = &DeviceServiceHandlerMockDeRegisterKeyParams{ctx, pp1}
	mmDeRegisterKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeRegisterKey.expectations {
		if minimock.Equal(e.params, mmDeRegisterKey.defaultExpectation.params) {
			mmDeRegisterKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeRegisterKey.defaultExpectation.params)
		}
	}

	return mmDeRegisterKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockDeRegisterKey {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceHandlerMockDeRegisterKeyExpectation{}
	}

	if mmDeRegisterKey.defaultExpectation.params != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Expect")
	}

	if mmDeRegisterKey.defaultExpectation.paramPtrs == nil {
		mmDeRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockDeRegisterKeyParamPtrs{}
	}
	mmDeRegisterKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeRegisterKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeRegisterKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) ExpectPp1Param2(pp1 *connect.Request[v1.DeRegisterKeyRequest]) *mDeviceServiceHandlerMockDeRegisterKey {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceHandlerMockDeRegisterKeyExpectation{}
	}

	if mmDeRegisterKey.defaultExpectation.params != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Expect")
	}

	if mmDeRegisterKey.defaultExpectation.paramPtrs == nil {
		mmDeRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockDeRegisterKeyParamPtrs{}
	}
	mmDeRegisterKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeRegisterKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeRegisterKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest])) *mDeviceServiceHandlerMockDeRegisterKey {
	if mmDeRegisterKey.mock.inspectFuncDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.DeRegisterKey")
	}

	mmDeRegisterKey.mock.inspectFuncDeRegisterKey = f

	return mmDeRegisterKey
}

// Return sets up results that will be returned by DeviceServiceHandler.DeRegisterKey
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Return(pp2 *connect.Response[v1.DeRegisterKeyResponse], err error) *DeviceServiceHandlerMock {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Set")
	}

	if mmDeRegisterKey.defaultExpectation == nil {
		mmDeRegisterKey.defaultExpectation = &DeviceServiceHandlerMockDeRegisterKeyExpectation{mock: mmDeRegisterKey.mock}
	}
	mmDeRegisterKey.defaultExpectation.results = &DeviceServiceHandlerMockDeRegisterKeyResults{pp2, err}
	mmDeRegisterKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeRegisterKey.mock
}

// Set uses given function f to mock the DeviceServiceHandler.DeRegisterKey method
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) (pp2 *connect.Response[v1.DeRegisterKeyResponse], err error)) *DeviceServiceHandlerMock {
	if mmDeRegisterKey.defaultExpectation != nil {
		mmDeRegisterKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.DeRegisterKey method")
	}

	if len(mmDeRegisterKey.expectations) > 0 {
		mmDeRegisterKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.DeRegisterKey method")
	}

	mmDeRegisterKey.mock.funcDeRegisterKey = f
	mmDeRegisterKey.mock.funcDeRegisterKeyOrigin = minimock.CallerInfo(1)
	return mmDeRegisterKey.mock
}

// When sets expectation for the DeviceServiceHandler.DeRegisterKey which will trigger the result defined by the following
// Then helper
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) When(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) *DeviceServiceHandlerMockDeRegisterKeyExpectation {
	if mmDeRegisterKey.mock.funcDeRegisterKey != nil {
		mmDeRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.DeRegisterKey mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockDeRegisterKeyExpectation{
		mock:               mmDeRegisterKey.mock,
		params:             &DeviceServiceHandlerMockDeRegisterKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockDeRegisterKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeRegisterKey.expectations = append(mmDeRegisterKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.DeRegisterKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockDeRegisterKeyExpectation) Then(pp2 *connect.Response[v1.DeRegisterKeyResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockDeRegisterKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.DeRegisterKey should be invoked
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Times(n uint64) *mDeviceServiceHandlerMockDeRegisterKey {
	if n == 0 {
		mmDeRegisterKey.mock.t.Fatalf("Times of DeviceServiceHandlerMock.DeRegisterKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeRegisterKey.expectedInvocations, n)
	mmDeRegisterKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeRegisterKey
}

func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) invocationsDone() bool {
	if len(mmDeRegisterKey.expectations) == 0 && mmDeRegisterKey.defaultExpectation == nil && mmDeRegisterKey.mock.funcDeRegisterKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeRegisterKey.mock.afterDeRegisterKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeRegisterKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeRegisterKey implements mm_devicev1connect.DeviceServiceHandler
func (mmDeRegisterKey *DeviceServiceHandlerMock) DeRegisterKey(ctx context.Context, pp1 *connect.Request[v1.DeRegisterKeyRequest]) (pp2 *connect.Response[v1.DeRegisterKeyResponse], err error) {
	mm_atomic.AddUint64(&mmDeRegisterKey.beforeDeRegisterKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmDeRegisterKey.afterDeRegisterKeyCounter, 1)

	mmDeRegisterKey.t.Helper()

	if mmDeRegisterKey.inspectFuncDeRegisterKey != nil {
		mmDeRegisterKey.inspectFuncDeRegisterKey(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockDeRegisterKeyParams{ctx, pp1}

	// Record call args
	mmDeRegisterKey.DeRegisterKeyMock.mutex.Lock()
	mmDeRegisterKey.DeRegisterKeyMock.callArgs = append(mmDeRegisterKey.DeRegisterKeyMock.callArgs, &mm_params)
	mmDeRegisterKey.DeRegisterKeyMock.mutex.Unlock()

	for _, e := range mmDeRegisterKey.DeRegisterKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.params
		mm_want_ptrs := mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockDeRegisterKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeRegisterKey.t.Errorf("DeviceServiceHandlerMock.DeRegisterKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeRegisterKey.t.Errorf("DeviceServiceHandlerMock.DeRegisterKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeRegisterKey.t.Errorf("DeviceServiceHandlerMock.DeRegisterKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeRegisterKey.DeRegisterKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmDeRegisterKey.t.Fatal("No results are set for the DeviceServiceHandlerMock.DeRegisterKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeRegisterKey.funcDeRegisterKey != nil {
		return mmDeRegisterKey.funcDeRegisterKey(ctx, pp1)
	}
	mmDeRegisterKey.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.DeRegisterKey. %v %v", ctx, pp1)
	return
}

// DeRegisterKeyAfterCounter returns a count of finished DeviceServiceHandlerMock.DeRegisterKey invocations
func (mmDeRegisterKey *DeviceServiceHandlerMock) DeRegisterKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeRegisterKey.afterDeRegisterKeyCounter)
}

// DeRegisterKeyBeforeCounter returns a count of DeviceServiceHandlerMock.DeRegisterKey invocations
func (mmDeRegisterKey *DeviceServiceHandlerMock) DeRegisterKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeRegisterKey.beforeDeRegisterKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.DeRegisterKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeRegisterKey *mDeviceServiceHandlerMockDeRegisterKey) Calls() []*DeviceServiceHandlerMockDeRegisterKeyParams {
	mmDeRegisterKey.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockDeRegisterKeyParams, len(mmDeRegisterKey.callArgs))
	copy(argCopy, mmDeRegisterKey.callArgs)

	mmDeRegisterKey.mutex.RUnlock()

	return argCopy
}

// MinimockDeRegisterKeyDone returns true if the count of the DeRegisterKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockDeRegisterKeyDone() bool {
	if m.DeRegisterKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeRegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeRegisterKeyMock.invocationsDone()
}

// MinimockDeRegisterKeyInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockDeRegisterKeyInspect() {
	for _, e := range m.DeRegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.DeRegisterKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeRegisterKeyCounter := mm_atomic.LoadUint64(&m.afterDeRegisterKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeRegisterKeyMock.defaultExpectation != nil && afterDeRegisterKeyCounter < 1 {
		if m.DeRegisterKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.DeRegisterKey at\n%s", m.DeRegisterKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.DeRegisterKey at\n%s with params: %#v", m.DeRegisterKeyMock.defaultExpectation.expectationOrigins.origin, *m.DeRegisterKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeRegisterKey != nil && afterDeRegisterKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.DeRegisterKey at\n%s", m.funcDeRegisterKeyOrigin)
	}

	if !m.DeRegisterKeyMock.invocationsDone() && afterDeRegisterKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.DeRegisterKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeRegisterKeyMock.expectedInvocations), m.DeRegisterKeyMock.expectedInvocationsOrigin, afterDeRegisterKeyCounter)
	}
}

type mDeviceServiceHandlerMockGetById struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockGetByIdExpectation
	expectations       []*DeviceServiceHandlerMockGetByIdExpectation

	callArgs []*DeviceServiceHandlerMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockGetByIdExpectation specifies expectation struct of the DeviceServiceHandler.GetById
type DeviceServiceHandlerMockGetByIdExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockGetByIdParams
	paramPtrs          *DeviceServiceHandlerMockGetByIdParamPtrs
	expectationOrigins DeviceServiceHandlerMockGetByIdExpectationOrigins
	results            *DeviceServiceHandlerMockGetByIdResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockGetByIdParams contains parameters of the DeviceServiceHandler.GetById
type DeviceServiceHandlerMockGetByIdParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetByIdRequest]
}

// DeviceServiceHandlerMockGetByIdParamPtrs contains pointers to parameters of the DeviceServiceHandler.GetById
type DeviceServiceHandlerMockGetByIdParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetByIdRequest]
}

// DeviceServiceHandlerMockGetByIdResults contains results of the DeviceServiceHandler.GetById
type DeviceServiceHandlerMockGetByIdResults struct {
	pp2 *connect.Response[v1.GetByIdResponse]
	err error
}

// DeviceServiceHandlerMockGetByIdOrigins contains origins of expectations of the DeviceServiceHandler.GetById
type DeviceServiceHandlerMockGetByIdExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mDeviceServiceHandlerMockGetById) Optional() *mDeviceServiceHandlerMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for DeviceServiceHandler.GetById
func (mmGetById *mDeviceServiceHandlerMockGetById) Expect(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) *mDeviceServiceHandlerMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceHandlerMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &DeviceServiceHandlerMockGetByIdParams{ctx, pp1}
	mmGetById.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.GetById
func (mmGetById *mDeviceServiceHandlerMockGetById) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceHandlerMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetById.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetById
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.GetById
func (mmGetById *mDeviceServiceHandlerMockGetById) ExpectPp1Param2(pp1 *connect.Request[v1.GetByIdRequest]) *mDeviceServiceHandlerMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceHandlerMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetById.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.GetById
func (mmGetById *mDeviceServiceHandlerMockGetById) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest])) *mDeviceServiceHandlerMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by DeviceServiceHandler.GetById
func (mmGetById *mDeviceServiceHandlerMockGetById) Return(pp2 *connect.Response[v1.GetByIdResponse], err error) *DeviceServiceHandlerMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &DeviceServiceHandlerMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &DeviceServiceHandlerMockGetByIdResults{pp2, err}
	mmGetById.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// Set uses given function f to mock the DeviceServiceHandler.GetById method
func (mmGetById *mDeviceServiceHandlerMockGetById) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) (pp2 *connect.Response[v1.GetByIdResponse], err error)) *DeviceServiceHandlerMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.GetById method")
	}

	mmGetById.mock.funcGetById = f
	mmGetById.mock.funcGetByIdOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// When sets expectation for the DeviceServiceHandler.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mDeviceServiceHandlerMockGetById) When(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) *DeviceServiceHandlerMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("DeviceServiceHandlerMock.GetById mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockGetByIdExpectation{
		mock:               mmGetById.mock,
		params:             &DeviceServiceHandlerMockGetByIdParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockGetByIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.GetById return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockGetByIdExpectation) Then(pp2 *connect.Response[v1.GetByIdResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockGetByIdResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.GetById should be invoked
func (mmGetById *mDeviceServiceHandlerMockGetById) Times(n uint64) *mDeviceServiceHandlerMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of DeviceServiceHandlerMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	mmGetById.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetById
}

func (mmGetById *mDeviceServiceHandlerMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements mm_devicev1connect.DeviceServiceHandler
func (mmGetById *DeviceServiceHandlerMock) GetById(ctx context.Context, pp1 *connect.Request[v1.GetByIdRequest]) (pp2 *connect.Response[v1.GetByIdResponse], err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	mmGetById.t.Helper()

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockGetByIdParams{ctx, pp1}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockGetByIdParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("DeviceServiceHandlerMock.GetById got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetById.t.Errorf("DeviceServiceHandlerMock.GetById got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("DeviceServiceHandlerMock.GetById got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the DeviceServiceHandlerMock.GetById")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, pp1)
	}
	mmGetById.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.GetById. %v %v", ctx, pp1)
	return
}

// GetByIdAfterCounter returns a count of finished DeviceServiceHandlerMock.GetById invocations
func (mmGetById *DeviceServiceHandlerMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of DeviceServiceHandlerMock.GetById invocations
func (mmGetById *DeviceServiceHandlerMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mDeviceServiceHandlerMockGetById) Calls() []*DeviceServiceHandlerMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetById at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetById at\n%s", m.GetByIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetById at\n%s with params: %#v", m.GetByIdMock.defaultExpectation.expectationOrigins.origin, *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetById at\n%s", m.funcGetByIdOrigin)
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.GetById at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), m.GetByIdMock.expectedInvocationsOrigin, afterGetByIdCounter)
	}
}

type mDeviceServiceHandlerMockGetBySessionId struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockGetBySessionIdExpectation
	expectations       []*DeviceServiceHandlerMockGetBySessionIdExpectation

	callArgs []*DeviceServiceHandlerMockGetBySessionIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockGetBySessionIdExpectation specifies expectation struct of the DeviceServiceHandler.GetBySessionId
type DeviceServiceHandlerMockGetBySessionIdExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockGetBySessionIdParams
	paramPtrs          *DeviceServiceHandlerMockGetBySessionIdParamPtrs
	expectationOrigins DeviceServiceHandlerMockGetBySessionIdExpectationOrigins
	results            *DeviceServiceHandlerMockGetBySessionIdResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockGetBySessionIdParams contains parameters of the DeviceServiceHandler.GetBySessionId
type DeviceServiceHandlerMockGetBySessionIdParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetBySessionIdRequest]
}

// DeviceServiceHandlerMockGetBySessionIdParamPtrs contains pointers to parameters of the DeviceServiceHandler.GetBySessionId
type DeviceServiceHandlerMockGetBySessionIdParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetBySessionIdRequest]
}

// DeviceServiceHandlerMockGetBySessionIdResults contains results of the DeviceServiceHandler.GetBySessionId
type DeviceServiceHandlerMockGetBySessionIdResults struct {
	pp2 *connect.Response[v1.GetBySessionIdResponse]
	err error
}

// DeviceServiceHandlerMockGetBySessionIdOrigins contains origins of expectations of the DeviceServiceHandler.GetBySessionId
type DeviceServiceHandlerMockGetBySessionIdExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Optional() *mDeviceServiceHandlerMockGetBySessionId {
	mmGetBySessionId.optional = true
	return mmGetBySessionId
}

// Expect sets up expected params for DeviceServiceHandler.GetBySessionId
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Expect(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) *mDeviceServiceHandlerMockGetBySessionId {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceHandlerMockGetBySessionIdExpectation{}
	}

	if mmGetBySessionId.defaultExpectation.paramPtrs != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by ExpectParams functions")
	}

	mmGetBySessionId.defaultExpectation.params = &DeviceServiceHandlerMockGetBySessionIdParams{ctx, pp1}
	mmGetBySessionId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySessionId.expectations {
		if minimock.Equal(e.params, mmGetBySessionId.defaultExpectation.params) {
			mmGetBySessionId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySessionId.defaultExpectation.params)
		}
	}

	return mmGetBySessionId
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.GetBySessionId
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockGetBySessionId {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceHandlerMockGetBySessionIdExpectation{}
	}

	if mmGetBySessionId.defaultExpectation.params != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Expect")
	}

	if mmGetBySessionId.defaultExpectation.paramPtrs == nil {
		mmGetBySessionId.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockGetBySessionIdParamPtrs{}
	}
	mmGetBySessionId.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySessionId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySessionId
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.GetBySessionId
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) ExpectPp1Param2(pp1 *connect.Request[v1.GetBySessionIdRequest]) *mDeviceServiceHandlerMockGetBySessionId {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceHandlerMockGetBySessionIdExpectation{}
	}

	if mmGetBySessionId.defaultExpectation.params != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Expect")
	}

	if mmGetBySessionId.defaultExpectation.paramPtrs == nil {
		mmGetBySessionId.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockGetBySessionIdParamPtrs{}
	}
	mmGetBySessionId.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetBySessionId.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetBySessionId
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.GetBySessionId
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest])) *mDeviceServiceHandlerMockGetBySessionId {
	if mmGetBySessionId.mock.inspectFuncGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.GetBySessionId")
	}

	mmGetBySessionId.mock.inspectFuncGetBySessionId = f

	return mmGetBySessionId
}

// Return sets up results that will be returned by DeviceServiceHandler.GetBySessionId
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Return(pp2 *connect.Response[v1.GetBySessionIdResponse], err error) *DeviceServiceHandlerMock {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Set")
	}

	if mmGetBySessionId.defaultExpectation == nil {
		mmGetBySessionId.defaultExpectation = &DeviceServiceHandlerMockGetBySessionIdExpectation{mock: mmGetBySessionId.mock}
	}
	mmGetBySessionId.defaultExpectation.results = &DeviceServiceHandlerMockGetBySessionIdResults{pp2, err}
	mmGetBySessionId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySessionId.mock
}

// Set uses given function f to mock the DeviceServiceHandler.GetBySessionId method
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) (pp2 *connect.Response[v1.GetBySessionIdResponse], err error)) *DeviceServiceHandlerMock {
	if mmGetBySessionId.defaultExpectation != nil {
		mmGetBySessionId.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.GetBySessionId method")
	}

	if len(mmGetBySessionId.expectations) > 0 {
		mmGetBySessionId.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.GetBySessionId method")
	}

	mmGetBySessionId.mock.funcGetBySessionId = f
	mmGetBySessionId.mock.funcGetBySessionIdOrigin = minimock.CallerInfo(1)
	return mmGetBySessionId.mock
}

// When sets expectation for the DeviceServiceHandler.GetBySessionId which will trigger the result defined by the following
// Then helper
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) When(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) *DeviceServiceHandlerMockGetBySessionIdExpectation {
	if mmGetBySessionId.mock.funcGetBySessionId != nil {
		mmGetBySessionId.mock.t.Fatalf("DeviceServiceHandlerMock.GetBySessionId mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockGetBySessionIdExpectation{
		mock:               mmGetBySessionId.mock,
		params:             &DeviceServiceHandlerMockGetBySessionIdParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockGetBySessionIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySessionId.expectations = append(mmGetBySessionId.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.GetBySessionId return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockGetBySessionIdExpectation) Then(pp2 *connect.Response[v1.GetBySessionIdResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockGetBySessionIdResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.GetBySessionId should be invoked
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Times(n uint64) *mDeviceServiceHandlerMockGetBySessionId {
	if n == 0 {
		mmGetBySessionId.mock.t.Fatalf("Times of DeviceServiceHandlerMock.GetBySessionId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySessionId.expectedInvocations, n)
	mmGetBySessionId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySessionId
}

func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) invocationsDone() bool {
	if len(mmGetBySessionId.expectations) == 0 && mmGetBySessionId.defaultExpectation == nil && mmGetBySessionId.mock.funcGetBySessionId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySessionId.mock.afterGetBySessionIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySessionId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySessionId implements mm_devicev1connect.DeviceServiceHandler
func (mmGetBySessionId *DeviceServiceHandlerMock) GetBySessionId(ctx context.Context, pp1 *connect.Request[v1.GetBySessionIdRequest]) (pp2 *connect.Response[v1.GetBySessionIdResponse], err error) {
	mm_atomic.AddUint64(&mmGetBySessionId.beforeGetBySessionIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySessionId.afterGetBySessionIdCounter, 1)

	mmGetBySessionId.t.Helper()

	if mmGetBySessionId.inspectFuncGetBySessionId != nil {
		mmGetBySessionId.inspectFuncGetBySessionId(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockGetBySessionIdParams{ctx, pp1}

	// Record call args
	mmGetBySessionId.GetBySessionIdMock.mutex.Lock()
	mmGetBySessionId.GetBySessionIdMock.callArgs = append(mmGetBySessionId.GetBySessionIdMock.callArgs, &mm_params)
	mmGetBySessionId.GetBySessionIdMock.mutex.Unlock()

	for _, e := range mmGetBySessionId.GetBySessionIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetBySessionId.GetBySessionIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySessionId.GetBySessionIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySessionId.GetBySessionIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySessionId.GetBySessionIdMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockGetBySessionIdParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySessionId.t.Errorf("DeviceServiceHandlerMock.GetBySessionId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySessionId.GetBySessionIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetBySessionId.t.Errorf("DeviceServiceHandlerMock.GetBySessionId got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySessionId.GetBySessionIdMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySessionId.t.Errorf("DeviceServiceHandlerMock.GetBySessionId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySessionId.GetBySessionIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySessionId.GetBySessionIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySessionId.t.Fatal("No results are set for the DeviceServiceHandlerMock.GetBySessionId")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetBySessionId.funcGetBySessionId != nil {
		return mmGetBySessionId.funcGetBySessionId(ctx, pp1)
	}
	mmGetBySessionId.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.GetBySessionId. %v %v", ctx, pp1)
	return
}

// GetBySessionIdAfterCounter returns a count of finished DeviceServiceHandlerMock.GetBySessionId invocations
func (mmGetBySessionId *DeviceServiceHandlerMock) GetBySessionIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySessionId.afterGetBySessionIdCounter)
}

// GetBySessionIdBeforeCounter returns a count of DeviceServiceHandlerMock.GetBySessionId invocations
func (mmGetBySessionId *DeviceServiceHandlerMock) GetBySessionIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySessionId.beforeGetBySessionIdCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.GetBySessionId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySessionId *mDeviceServiceHandlerMockGetBySessionId) Calls() []*DeviceServiceHandlerMockGetBySessionIdParams {
	mmGetBySessionId.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockGetBySessionIdParams, len(mmGetBySessionId.callArgs))
	copy(argCopy, mmGetBySessionId.callArgs)

	mmGetBySessionId.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySessionIdDone returns true if the count of the GetBySessionId invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockGetBySessionIdDone() bool {
	if m.GetBySessionIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySessionIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySessionIdMock.invocationsDone()
}

// MinimockGetBySessionIdInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockGetBySessionIdInspect() {
	for _, e := range m.GetBySessionIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetBySessionId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySessionIdCounter := mm_atomic.LoadUint64(&m.afterGetBySessionIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySessionIdMock.defaultExpectation != nil && afterGetBySessionIdCounter < 1 {
		if m.GetBySessionIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetBySessionId at\n%s", m.GetBySessionIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetBySessionId at\n%s with params: %#v", m.GetBySessionIdMock.defaultExpectation.expectationOrigins.origin, *m.GetBySessionIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySessionId != nil && afterGetBySessionIdCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.GetBySessionId at\n%s", m.funcGetBySessionIdOrigin)
	}

	if !m.GetBySessionIdMock.invocationsDone() && afterGetBySessionIdCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.GetBySessionId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySessionIdMock.expectedInvocations), m.GetBySessionIdMock.expectedInvocationsOrigin, afterGetBySessionIdCounter)
	}
}

type mDeviceServiceHandlerMockLink struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockLinkExpectation
	expectations       []*DeviceServiceHandlerMockLinkExpectation

	callArgs []*DeviceServiceHandlerMockLinkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockLinkExpectation specifies expectation struct of the DeviceServiceHandler.Link
type DeviceServiceHandlerMockLinkExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockLinkParams
	paramPtrs          *DeviceServiceHandlerMockLinkParamPtrs
	expectationOrigins DeviceServiceHandlerMockLinkExpectationOrigins
	results            *DeviceServiceHandlerMockLinkResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockLinkParams contains parameters of the DeviceServiceHandler.Link
type DeviceServiceHandlerMockLinkParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.LinkRequest]
}

// DeviceServiceHandlerMockLinkParamPtrs contains pointers to parameters of the DeviceServiceHandler.Link
type DeviceServiceHandlerMockLinkParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.LinkRequest]
}

// DeviceServiceHandlerMockLinkResults contains results of the DeviceServiceHandler.Link
type DeviceServiceHandlerMockLinkResults struct {
	pp2 *connect.Response[v1.LinkResponse]
	err error
}

// DeviceServiceHandlerMockLinkOrigins contains origins of expectations of the DeviceServiceHandler.Link
type DeviceServiceHandlerMockLinkExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLink *mDeviceServiceHandlerMockLink) Optional() *mDeviceServiceHandlerMockLink {
	mmLink.optional = true
	return mmLink
}

// Expect sets up expected params for DeviceServiceHandler.Link
func (mmLink *mDeviceServiceHandlerMockLink) Expect(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) *mDeviceServiceHandlerMockLink {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceHandlerMockLinkExpectation{}
	}

	if mmLink.defaultExpectation.paramPtrs != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by ExpectParams functions")
	}

	mmLink.defaultExpectation.params = &DeviceServiceHandlerMockLinkParams{ctx, pp1}
	mmLink.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLink.expectations {
		if minimock.Equal(e.params, mmLink.defaultExpectation.params) {
			mmLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLink.defaultExpectation.params)
		}
	}

	return mmLink
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Link
func (mmLink *mDeviceServiceHandlerMockLink) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockLink {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceHandlerMockLinkExpectation{}
	}

	if mmLink.defaultExpectation.params != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Expect")
	}

	if mmLink.defaultExpectation.paramPtrs == nil {
		mmLink.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockLinkParamPtrs{}
	}
	mmLink.defaultExpectation.paramPtrs.ctx = &ctx
	mmLink.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLink
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Link
func (mmLink *mDeviceServiceHandlerMockLink) ExpectPp1Param2(pp1 *connect.Request[v1.LinkRequest]) *mDeviceServiceHandlerMockLink {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceHandlerMockLinkExpectation{}
	}

	if mmLink.defaultExpectation.params != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Expect")
	}

	if mmLink.defaultExpectation.paramPtrs == nil {
		mmLink.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockLinkParamPtrs{}
	}
	mmLink.defaultExpectation.paramPtrs.pp1 = &pp1
	mmLink.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmLink
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Link
func (mmLink *mDeviceServiceHandlerMockLink) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest])) *mDeviceServiceHandlerMockLink {
	if mmLink.mock.inspectFuncLink != nil {
		mmLink.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Link")
	}

	mmLink.mock.inspectFuncLink = f

	return mmLink
}

// Return sets up results that will be returned by DeviceServiceHandler.Link
func (mmLink *mDeviceServiceHandlerMockLink) Return(pp2 *connect.Response[v1.LinkResponse], err error) *DeviceServiceHandlerMock {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Set")
	}

	if mmLink.defaultExpectation == nil {
		mmLink.defaultExpectation = &DeviceServiceHandlerMockLinkExpectation{mock: mmLink.mock}
	}
	mmLink.defaultExpectation.results = &DeviceServiceHandlerMockLinkResults{pp2, err}
	mmLink.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLink.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Link method
func (mmLink *mDeviceServiceHandlerMockLink) Set(f func(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) (pp2 *connect.Response[v1.LinkResponse], err error)) *DeviceServiceHandlerMock {
	if mmLink.defaultExpectation != nil {
		mmLink.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Link method")
	}

	if len(mmLink.expectations) > 0 {
		mmLink.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Link method")
	}

	mmLink.mock.funcLink = f
	mmLink.mock.funcLinkOrigin = minimock.CallerInfo(1)
	return mmLink.mock
}

// When sets expectation for the DeviceServiceHandler.Link which will trigger the result defined by the following
// Then helper
func (mmLink *mDeviceServiceHandlerMockLink) When(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) *DeviceServiceHandlerMockLinkExpectation {
	if mmLink.mock.funcLink != nil {
		mmLink.mock.t.Fatalf("DeviceServiceHandlerMock.Link mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockLinkExpectation{
		mock:               mmLink.mock,
		params:             &DeviceServiceHandlerMockLinkParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockLinkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLink.expectations = append(mmLink.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Link return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockLinkExpectation) Then(pp2 *connect.Response[v1.LinkResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockLinkResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Link should be invoked
func (mmLink *mDeviceServiceHandlerMockLink) Times(n uint64) *mDeviceServiceHandlerMockLink {
	if n == 0 {
		mmLink.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Link mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLink.expectedInvocations, n)
	mmLink.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLink
}

func (mmLink *mDeviceServiceHandlerMockLink) invocationsDone() bool {
	if len(mmLink.expectations) == 0 && mmLink.defaultExpectation == nil && mmLink.mock.funcLink == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLink.mock.afterLinkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLink.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Link implements mm_devicev1connect.DeviceServiceHandler
func (mmLink *DeviceServiceHandlerMock) Link(ctx context.Context, pp1 *connect.Request[v1.LinkRequest]) (pp2 *connect.Response[v1.LinkResponse], err error) {
	mm_atomic.AddUint64(&mmLink.beforeLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmLink.afterLinkCounter, 1)

	mmLink.t.Helper()

	if mmLink.inspectFuncLink != nil {
		mmLink.inspectFuncLink(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockLinkParams{ctx, pp1}

	// Record call args
	mmLink.LinkMock.mutex.Lock()
	mmLink.LinkMock.callArgs = append(mmLink.LinkMock.callArgs, &mm_params)
	mmLink.LinkMock.mutex.Unlock()

	for _, e := range mmLink.LinkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmLink.LinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLink.LinkMock.defaultExpectation.Counter, 1)
		mm_want := mmLink.LinkMock.defaultExpectation.params
		mm_want_ptrs := mmLink.LinkMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockLinkParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLink.t.Errorf("DeviceServiceHandlerMock.Link got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLink.LinkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmLink.t.Errorf("DeviceServiceHandlerMock.Link got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLink.LinkMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLink.t.Errorf("DeviceServiceHandlerMock.Link got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLink.LinkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLink.LinkMock.defaultExpectation.results
		if mm_results == nil {
			mmLink.t.Fatal("No results are set for the DeviceServiceHandlerMock.Link")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmLink.funcLink != nil {
		return mmLink.funcLink(ctx, pp1)
	}
	mmLink.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Link. %v %v", ctx, pp1)
	return
}

// LinkAfterCounter returns a count of finished DeviceServiceHandlerMock.Link invocations
func (mmLink *DeviceServiceHandlerMock) LinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLink.afterLinkCounter)
}

// LinkBeforeCounter returns a count of DeviceServiceHandlerMock.Link invocations
func (mmLink *DeviceServiceHandlerMock) LinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLink.beforeLinkCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Link.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLink *mDeviceServiceHandlerMockLink) Calls() []*DeviceServiceHandlerMockLinkParams {
	mmLink.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockLinkParams, len(mmLink.callArgs))
	copy(argCopy, mmLink.callArgs)

	mmLink.mutex.RUnlock()

	return argCopy
}

// MinimockLinkDone returns true if the count of the Link invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockLinkDone() bool {
	if m.LinkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LinkMock.invocationsDone()
}

// MinimockLinkInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockLinkInspect() {
	for _, e := range m.LinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Link at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLinkCounter := mm_atomic.LoadUint64(&m.afterLinkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LinkMock.defaultExpectation != nil && afterLinkCounter < 1 {
		if m.LinkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Link at\n%s", m.LinkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Link at\n%s with params: %#v", m.LinkMock.defaultExpectation.expectationOrigins.origin, *m.LinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLink != nil && afterLinkCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Link at\n%s", m.funcLinkOrigin)
	}

	if !m.LinkMock.invocationsDone() && afterLinkCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Link at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LinkMock.expectedInvocations), m.LinkMock.expectedInvocationsOrigin, afterLinkCounter)
	}
}

type mDeviceServiceHandlerMockListLogs struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockListLogsExpectation
	expectations       []*DeviceServiceHandlerMockListLogsExpectation

	callArgs []*DeviceServiceHandlerMockListLogsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockListLogsExpectation specifies expectation struct of the DeviceServiceHandler.ListLogs
type DeviceServiceHandlerMockListLogsExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockListLogsParams
	paramPtrs          *DeviceServiceHandlerMockListLogsParamPtrs
	expectationOrigins DeviceServiceHandlerMockListLogsExpectationOrigins
	results            *DeviceServiceHandlerMockListLogsResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockListLogsParams contains parameters of the DeviceServiceHandler.ListLogs
type DeviceServiceHandlerMockListLogsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListLogsRequest]
	pp2 *connect.ServerStream[v1.ListLogsResponse]
}

// DeviceServiceHandlerMockListLogsParamPtrs contains pointers to parameters of the DeviceServiceHandler.ListLogs
type DeviceServiceHandlerMockListLogsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListLogsRequest]
	pp2 **connect.ServerStream[v1.ListLogsResponse]
}

// DeviceServiceHandlerMockListLogsResults contains results of the DeviceServiceHandler.ListLogs
type DeviceServiceHandlerMockListLogsResults struct {
	err error
}

// DeviceServiceHandlerMockListLogsOrigins contains origins of expectations of the DeviceServiceHandler.ListLogs
type DeviceServiceHandlerMockListLogsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Optional() *mDeviceServiceHandlerMockListLogs {
	mmListLogs.optional = true
	return mmListLogs
}

// Expect sets up expected params for DeviceServiceHandler.ListLogs
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Expect(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse]) *mDeviceServiceHandlerMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceHandlerMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.paramPtrs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by ExpectParams functions")
	}

	mmListLogs.defaultExpectation.params = &DeviceServiceHandlerMockListLogsParams{ctx, pp1, pp2}
	mmListLogs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListLogs.expectations {
		if minimock.Equal(e.params, mmListLogs.defaultExpectation.params) {
			mmListLogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListLogs.defaultExpectation.params)
		}
	}

	return mmListLogs
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.ListLogs
func (mmListLogs *mDeviceServiceHandlerMockListLogs) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceHandlerMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.params != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Expect")
	}

	if mmListLogs.defaultExpectation.paramPtrs == nil {
		mmListLogs.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockListLogsParamPtrs{}
	}
	mmListLogs.defaultExpectation.paramPtrs.ctx = &ctx
	mmListLogs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListLogs
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.ListLogs
func (mmListLogs *mDeviceServiceHandlerMockListLogs) ExpectPp1Param2(pp1 *connect.Request[v1.ListLogsRequest]) *mDeviceServiceHandlerMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceHandlerMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.params != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Expect")
	}

	if mmListLogs.defaultExpectation.paramPtrs == nil {
		mmListLogs.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockListLogsParamPtrs{}
	}
	mmListLogs.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListLogs.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListLogs
}

// ExpectPp2Param3 sets up expected param pp2 for DeviceServiceHandler.ListLogs
func (mmListLogs *mDeviceServiceHandlerMockListLogs) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListLogsResponse]) *mDeviceServiceHandlerMockListLogs {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceHandlerMockListLogsExpectation{}
	}

	if mmListLogs.defaultExpectation.params != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Expect")
	}

	if mmListLogs.defaultExpectation.paramPtrs == nil {
		mmListLogs.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockListLogsParamPtrs{}
	}
	mmListLogs.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListLogs.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListLogs
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.ListLogs
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse])) *mDeviceServiceHandlerMockListLogs {
	if mmListLogs.mock.inspectFuncListLogs != nil {
		mmListLogs.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.ListLogs")
	}

	mmListLogs.mock.inspectFuncListLogs = f

	return mmListLogs
}

// Return sets up results that will be returned by DeviceServiceHandler.ListLogs
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Return(err error) *DeviceServiceHandlerMock {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Set")
	}

	if mmListLogs.defaultExpectation == nil {
		mmListLogs.defaultExpectation = &DeviceServiceHandlerMockListLogsExpectation{mock: mmListLogs.mock}
	}
	mmListLogs.defaultExpectation.results = &DeviceServiceHandlerMockListLogsResults{err}
	mmListLogs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListLogs.mock
}

// Set uses given function f to mock the DeviceServiceHandler.ListLogs method
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse]) (err error)) *DeviceServiceHandlerMock {
	if mmListLogs.defaultExpectation != nil {
		mmListLogs.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.ListLogs method")
	}

	if len(mmListLogs.expectations) > 0 {
		mmListLogs.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.ListLogs method")
	}

	mmListLogs.mock.funcListLogs = f
	mmListLogs.mock.funcListLogsOrigin = minimock.CallerInfo(1)
	return mmListLogs.mock
}

// When sets expectation for the DeviceServiceHandler.ListLogs which will trigger the result defined by the following
// Then helper
func (mmListLogs *mDeviceServiceHandlerMockListLogs) When(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse]) *DeviceServiceHandlerMockListLogsExpectation {
	if mmListLogs.mock.funcListLogs != nil {
		mmListLogs.mock.t.Fatalf("DeviceServiceHandlerMock.ListLogs mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockListLogsExpectation{
		mock:               mmListLogs.mock,
		params:             &DeviceServiceHandlerMockListLogsParams{ctx, pp1, pp2},
		expectationOrigins: DeviceServiceHandlerMockListLogsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListLogs.expectations = append(mmListLogs.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.ListLogs return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockListLogsExpectation) Then(err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockListLogsResults{err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.ListLogs should be invoked
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Times(n uint64) *mDeviceServiceHandlerMockListLogs {
	if n == 0 {
		mmListLogs.mock.t.Fatalf("Times of DeviceServiceHandlerMock.ListLogs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListLogs.expectedInvocations, n)
	mmListLogs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListLogs
}

func (mmListLogs *mDeviceServiceHandlerMockListLogs) invocationsDone() bool {
	if len(mmListLogs.expectations) == 0 && mmListLogs.defaultExpectation == nil && mmListLogs.mock.funcListLogs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListLogs.mock.afterListLogsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListLogs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListLogs implements mm_devicev1connect.DeviceServiceHandler
func (mmListLogs *DeviceServiceHandlerMock) ListLogs(ctx context.Context, pp1 *connect.Request[v1.ListLogsRequest], pp2 *connect.ServerStream[v1.ListLogsResponse]) (err error) {
	mm_atomic.AddUint64(&mmListLogs.beforeListLogsCounter, 1)
	defer mm_atomic.AddUint64(&mmListLogs.afterListLogsCounter, 1)

	mmListLogs.t.Helper()

	if mmListLogs.inspectFuncListLogs != nil {
		mmListLogs.inspectFuncListLogs(ctx, pp1, pp2)
	}

	mm_params := DeviceServiceHandlerMockListLogsParams{ctx, pp1, pp2}

	// Record call args
	mmListLogs.ListLogsMock.mutex.Lock()
	mmListLogs.ListLogsMock.callArgs = append(mmListLogs.ListLogsMock.callArgs, &mm_params)
	mmListLogs.ListLogsMock.mutex.Unlock()

	for _, e := range mmListLogs.ListLogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListLogs.ListLogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListLogs.ListLogsMock.defaultExpectation.Counter, 1)
		mm_want := mmListLogs.ListLogsMock.defaultExpectation.params
		mm_want_ptrs := mmListLogs.ListLogsMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockListLogsParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListLogs.t.Errorf("DeviceServiceHandlerMock.ListLogs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListLogs.t.Errorf("DeviceServiceHandlerMock.ListLogs got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListLogs.t.Errorf("DeviceServiceHandlerMock.ListLogs got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListLogs.t.Errorf("DeviceServiceHandlerMock.ListLogs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListLogs.ListLogsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListLogs.ListLogsMock.defaultExpectation.results
		if mm_results == nil {
			mmListLogs.t.Fatal("No results are set for the DeviceServiceHandlerMock.ListLogs")
		}
		return (*mm_results).err
	}
	if mmListLogs.funcListLogs != nil {
		return mmListLogs.funcListLogs(ctx, pp1, pp2)
	}
	mmListLogs.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.ListLogs. %v %v %v", ctx, pp1, pp2)
	return
}

// ListLogsAfterCounter returns a count of finished DeviceServiceHandlerMock.ListLogs invocations
func (mmListLogs *DeviceServiceHandlerMock) ListLogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListLogs.afterListLogsCounter)
}

// ListLogsBeforeCounter returns a count of DeviceServiceHandlerMock.ListLogs invocations
func (mmListLogs *DeviceServiceHandlerMock) ListLogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListLogs.beforeListLogsCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.ListLogs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListLogs *mDeviceServiceHandlerMockListLogs) Calls() []*DeviceServiceHandlerMockListLogsParams {
	mmListLogs.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockListLogsParams, len(mmListLogs.callArgs))
	copy(argCopy, mmListLogs.callArgs)

	mmListLogs.mutex.RUnlock()

	return argCopy
}

// MinimockListLogsDone returns true if the count of the ListLogs invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockListLogsDone() bool {
	if m.ListLogsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListLogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListLogsMock.invocationsDone()
}

// MinimockListLogsInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockListLogsInspect() {
	for _, e := range m.ListLogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.ListLogs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListLogsCounter := mm_atomic.LoadUint64(&m.afterListLogsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListLogsMock.defaultExpectation != nil && afterListLogsCounter < 1 {
		if m.ListLogsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.ListLogs at\n%s", m.ListLogsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.ListLogs at\n%s with params: %#v", m.ListLogsMock.defaultExpectation.expectationOrigins.origin, *m.ListLogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListLogs != nil && afterListLogsCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.ListLogs at\n%s", m.funcListLogsOrigin)
	}

	if !m.ListLogsMock.invocationsDone() && afterListLogsCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.ListLogs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListLogsMock.expectedInvocations), m.ListLogsMock.expectedInvocationsOrigin, afterListLogsCounter)
	}
}

type mDeviceServiceHandlerMockLog struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockLogExpectation
	expectations       []*DeviceServiceHandlerMockLogExpectation

	callArgs []*DeviceServiceHandlerMockLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockLogExpectation specifies expectation struct of the DeviceServiceHandler.Log
type DeviceServiceHandlerMockLogExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockLogParams
	paramPtrs          *DeviceServiceHandlerMockLogParamPtrs
	expectationOrigins DeviceServiceHandlerMockLogExpectationOrigins
	results            *DeviceServiceHandlerMockLogResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockLogParams contains parameters of the DeviceServiceHandler.Log
type DeviceServiceHandlerMockLogParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.LogRequest]
}

// DeviceServiceHandlerMockLogParamPtrs contains pointers to parameters of the DeviceServiceHandler.Log
type DeviceServiceHandlerMockLogParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.LogRequest]
}

// DeviceServiceHandlerMockLogResults contains results of the DeviceServiceHandler.Log
type DeviceServiceHandlerMockLogResults struct {
	pp2 *connect.Response[v1.LogResponse]
	err error
}

// DeviceServiceHandlerMockLogOrigins contains origins of expectations of the DeviceServiceHandler.Log
type DeviceServiceHandlerMockLogExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLog *mDeviceServiceHandlerMockLog) Optional() *mDeviceServiceHandlerMockLog {
	mmLog.optional = true
	return mmLog
}

// Expect sets up expected params for DeviceServiceHandler.Log
func (mmLog *mDeviceServiceHandlerMockLog) Expect(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) *mDeviceServiceHandlerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceHandlerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.paramPtrs != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by ExpectParams functions")
	}

	mmLog.defaultExpectation.params = &DeviceServiceHandlerMockLogParams{ctx, pp1}
	mmLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLog.expectations {
		if minimock.Equal(e.params, mmLog.defaultExpectation.params) {
			mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
		}
	}

	return mmLog
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Log
func (mmLog *mDeviceServiceHandlerMockLog) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceHandlerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLog
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Log
func (mmLog *mDeviceServiceHandlerMockLog) ExpectPp1Param2(pp1 *connect.Request[v1.LogRequest]) *mDeviceServiceHandlerMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceHandlerMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.pp1 = &pp1
	mmLog.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Log
func (mmLog *mDeviceServiceHandlerMockLog) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.LogRequest])) *mDeviceServiceHandlerMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by DeviceServiceHandler.Log
func (mmLog *mDeviceServiceHandlerMockLog) Return(pp2 *connect.Response[v1.LogResponse], err error) *DeviceServiceHandlerMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &DeviceServiceHandlerMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &DeviceServiceHandlerMockLogResults{pp2, err}
	mmLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Log method
func (mmLog *mDeviceServiceHandlerMockLog) Set(f func(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) (pp2 *connect.Response[v1.LogResponse], err error)) *DeviceServiceHandlerMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Log method")
	}

	mmLog.mock.funcLog = f
	mmLog.mock.funcLogOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// When sets expectation for the DeviceServiceHandler.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mDeviceServiceHandlerMockLog) When(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) *DeviceServiceHandlerMockLogExpectation {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("DeviceServiceHandlerMock.Log mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockLogExpectation{
		mock:               mmLog.mock,
		params:             &DeviceServiceHandlerMockLogParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLog.expectations = append(mmLog.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Log return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockLogExpectation) Then(pp2 *connect.Response[v1.LogResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockLogResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Log should be invoked
func (mmLog *mDeviceServiceHandlerMockLog) Times(n uint64) *mDeviceServiceHandlerMockLog {
	if n == 0 {
		mmLog.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Log mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLog.expectedInvocations, n)
	mmLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLog
}

func (mmLog *mDeviceServiceHandlerMockLog) invocationsDone() bool {
	if len(mmLog.expectations) == 0 && mmLog.defaultExpectation == nil && mmLog.mock.funcLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLog.mock.afterLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Log implements mm_devicev1connect.DeviceServiceHandler
func (mmLog *DeviceServiceHandlerMock) Log(ctx context.Context, pp1 *connect.Request[v1.LogRequest]) (pp2 *connect.Response[v1.LogResponse], err error) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	mmLog.t.Helper()

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockLogParams{ctx, pp1}

	// Record call args
	mmLog.LogMock.mutex.Lock()
	mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, &mm_params)
	mmLog.LogMock.mutex.Unlock()

	for _, e := range mmLog.LogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)
		mm_want := mmLog.LogMock.defaultExpectation.params
		mm_want_ptrs := mmLog.LogMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockLogParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLog.t.Errorf("DeviceServiceHandlerMock.Log got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmLog.t.Errorf("DeviceServiceHandlerMock.Log got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLog.t.Errorf("DeviceServiceHandlerMock.Log got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLog.LogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the DeviceServiceHandlerMock.Log")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog(ctx, pp1)
	}
	mmLog.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Log. %v %v", ctx, pp1)
	return
}

// LogAfterCounter returns a count of finished DeviceServiceHandlerMock.Log invocations
func (mmLog *DeviceServiceHandlerMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of DeviceServiceHandlerMock.Log invocations
func (mmLog *DeviceServiceHandlerMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mDeviceServiceHandlerMockLog) Calls() []*DeviceServiceHandlerMockLogParams {
	mmLog.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockLogParams, len(mmLog.callArgs))
	copy(argCopy, mmLog.callArgs)

	mmLog.mutex.RUnlock()

	return argCopy
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockLogDone() bool {
	if m.LogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogMock.invocationsDone()
}

// MinimockLogInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Log at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogCounter := mm_atomic.LoadUint64(&m.afterLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && afterLogCounter < 1 {
		if m.LogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Log at\n%s", m.LogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Log at\n%s with params: %#v", m.LogMock.defaultExpectation.expectationOrigins.origin, *m.LogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && afterLogCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Log at\n%s", m.funcLogOrigin)
	}

	if !m.LogMock.invocationsDone() && afterLogCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Log at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogMock.expectedInvocations), m.LogMock.expectedInvocationsOrigin, afterLogCounter)
	}
}

type mDeviceServiceHandlerMockNotify struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockNotifyExpectation
	expectations       []*DeviceServiceHandlerMockNotifyExpectation

	callArgs []*DeviceServiceHandlerMockNotifyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockNotifyExpectation specifies expectation struct of the DeviceServiceHandler.Notify
type DeviceServiceHandlerMockNotifyExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockNotifyParams
	paramPtrs          *DeviceServiceHandlerMockNotifyParamPtrs
	expectationOrigins DeviceServiceHandlerMockNotifyExpectationOrigins
	results            *DeviceServiceHandlerMockNotifyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockNotifyParams contains parameters of the DeviceServiceHandler.Notify
type DeviceServiceHandlerMockNotifyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.NotifyRequest]
}

// DeviceServiceHandlerMockNotifyParamPtrs contains pointers to parameters of the DeviceServiceHandler.Notify
type DeviceServiceHandlerMockNotifyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.NotifyRequest]
}

// DeviceServiceHandlerMockNotifyResults contains results of the DeviceServiceHandler.Notify
type DeviceServiceHandlerMockNotifyResults struct {
	pp2 *connect.Response[v1.NotifyResponse]
	err error
}

// DeviceServiceHandlerMockNotifyOrigins contains origins of expectations of the DeviceServiceHandler.Notify
type DeviceServiceHandlerMockNotifyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNotify *mDeviceServiceHandlerMockNotify) Optional() *mDeviceServiceHandlerMockNotify {
	mmNotify.optional = true
	return mmNotify
}

// Expect sets up expected params for DeviceServiceHandler.Notify
func (mmNotify *mDeviceServiceHandlerMockNotify) Expect(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) *mDeviceServiceHandlerMockNotify {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceHandlerMockNotifyExpectation{}
	}

	if mmNotify.defaultExpectation.paramPtrs != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by ExpectParams functions")
	}

	mmNotify.defaultExpectation.params = &DeviceServiceHandlerMockNotifyParams{ctx, pp1}
	mmNotify.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNotify.expectations {
		if minimock.Equal(e.params, mmNotify.defaultExpectation.params) {
			mmNotify.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNotify.defaultExpectation.params)
		}
	}

	return mmNotify
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Notify
func (mmNotify *mDeviceServiceHandlerMockNotify) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockNotify {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceHandlerMockNotifyExpectation{}
	}

	if mmNotify.defaultExpectation.params != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Expect")
	}

	if mmNotify.defaultExpectation.paramPtrs == nil {
		mmNotify.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockNotifyParamPtrs{}
	}
	mmNotify.defaultExpectation.paramPtrs.ctx = &ctx
	mmNotify.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmNotify
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Notify
func (mmNotify *mDeviceServiceHandlerMockNotify) ExpectPp1Param2(pp1 *connect.Request[v1.NotifyRequest]) *mDeviceServiceHandlerMockNotify {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceHandlerMockNotifyExpectation{}
	}

	if mmNotify.defaultExpectation.params != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Expect")
	}

	if mmNotify.defaultExpectation.paramPtrs == nil {
		mmNotify.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockNotifyParamPtrs{}
	}
	mmNotify.defaultExpectation.paramPtrs.pp1 = &pp1
	mmNotify.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmNotify
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Notify
func (mmNotify *mDeviceServiceHandlerMockNotify) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest])) *mDeviceServiceHandlerMockNotify {
	if mmNotify.mock.inspectFuncNotify != nil {
		mmNotify.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Notify")
	}

	mmNotify.mock.inspectFuncNotify = f

	return mmNotify
}

// Return sets up results that will be returned by DeviceServiceHandler.Notify
func (mmNotify *mDeviceServiceHandlerMockNotify) Return(pp2 *connect.Response[v1.NotifyResponse], err error) *DeviceServiceHandlerMock {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Set")
	}

	if mmNotify.defaultExpectation == nil {
		mmNotify.defaultExpectation = &DeviceServiceHandlerMockNotifyExpectation{mock: mmNotify.mock}
	}
	mmNotify.defaultExpectation.results = &DeviceServiceHandlerMockNotifyResults{pp2, err}
	mmNotify.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNotify.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Notify method
func (mmNotify *mDeviceServiceHandlerMockNotify) Set(f func(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) (pp2 *connect.Response[v1.NotifyResponse], err error)) *DeviceServiceHandlerMock {
	if mmNotify.defaultExpectation != nil {
		mmNotify.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Notify method")
	}

	if len(mmNotify.expectations) > 0 {
		mmNotify.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Notify method")
	}

	mmNotify.mock.funcNotify = f
	mmNotify.mock.funcNotifyOrigin = minimock.CallerInfo(1)
	return mmNotify.mock
}

// When sets expectation for the DeviceServiceHandler.Notify which will trigger the result defined by the following
// Then helper
func (mmNotify *mDeviceServiceHandlerMockNotify) When(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) *DeviceServiceHandlerMockNotifyExpectation {
	if mmNotify.mock.funcNotify != nil {
		mmNotify.mock.t.Fatalf("DeviceServiceHandlerMock.Notify mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockNotifyExpectation{
		mock:               mmNotify.mock,
		params:             &DeviceServiceHandlerMockNotifyParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockNotifyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmNotify.expectations = append(mmNotify.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Notify return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockNotifyExpectation) Then(pp2 *connect.Response[v1.NotifyResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockNotifyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Notify should be invoked
func (mmNotify *mDeviceServiceHandlerMockNotify) Times(n uint64) *mDeviceServiceHandlerMockNotify {
	if n == 0 {
		mmNotify.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Notify mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNotify.expectedInvocations, n)
	mmNotify.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNotify
}

func (mmNotify *mDeviceServiceHandlerMockNotify) invocationsDone() bool {
	if len(mmNotify.expectations) == 0 && mmNotify.defaultExpectation == nil && mmNotify.mock.funcNotify == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNotify.mock.afterNotifyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNotify.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Notify implements mm_devicev1connect.DeviceServiceHandler
func (mmNotify *DeviceServiceHandlerMock) Notify(ctx context.Context, pp1 *connect.Request[v1.NotifyRequest]) (pp2 *connect.Response[v1.NotifyResponse], err error) {
	mm_atomic.AddUint64(&mmNotify.beforeNotifyCounter, 1)
	defer mm_atomic.AddUint64(&mmNotify.afterNotifyCounter, 1)

	mmNotify.t.Helper()

	if mmNotify.inspectFuncNotify != nil {
		mmNotify.inspectFuncNotify(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockNotifyParams{ctx, pp1}

	// Record call args
	mmNotify.NotifyMock.mutex.Lock()
	mmNotify.NotifyMock.callArgs = append(mmNotify.NotifyMock.callArgs, &mm_params)
	mmNotify.NotifyMock.mutex.Unlock()

	for _, e := range mmNotify.NotifyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmNotify.NotifyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNotify.NotifyMock.defaultExpectation.Counter, 1)
		mm_want := mmNotify.NotifyMock.defaultExpectation.params
		mm_want_ptrs := mmNotify.NotifyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockNotifyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmNotify.t.Errorf("DeviceServiceHandlerMock.Notify got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNotify.NotifyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmNotify.t.Errorf("DeviceServiceHandlerMock.Notify got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNotify.NotifyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNotify.t.Errorf("DeviceServiceHandlerMock.Notify got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNotify.NotifyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmNotify.NotifyMock.defaultExpectation.results
		if mm_results == nil {
			mmNotify.t.Fatal("No results are set for the DeviceServiceHandlerMock.Notify")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmNotify.funcNotify != nil {
		return mmNotify.funcNotify(ctx, pp1)
	}
	mmNotify.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Notify. %v %v", ctx, pp1)
	return
}

// NotifyAfterCounter returns a count of finished DeviceServiceHandlerMock.Notify invocations
func (mmNotify *DeviceServiceHandlerMock) NotifyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotify.afterNotifyCounter)
}

// NotifyBeforeCounter returns a count of DeviceServiceHandlerMock.Notify invocations
func (mmNotify *DeviceServiceHandlerMock) NotifyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotify.beforeNotifyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Notify.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNotify *mDeviceServiceHandlerMockNotify) Calls() []*DeviceServiceHandlerMockNotifyParams {
	mmNotify.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockNotifyParams, len(mmNotify.callArgs))
	copy(argCopy, mmNotify.callArgs)

	mmNotify.mutex.RUnlock()

	return argCopy
}

// MinimockNotifyDone returns true if the count of the Notify invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockNotifyDone() bool {
	if m.NotifyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NotifyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NotifyMock.invocationsDone()
}

// MinimockNotifyInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockNotifyInspect() {
	for _, e := range m.NotifyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Notify at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNotifyCounter := mm_atomic.LoadUint64(&m.afterNotifyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NotifyMock.defaultExpectation != nil && afterNotifyCounter < 1 {
		if m.NotifyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Notify at\n%s", m.NotifyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Notify at\n%s with params: %#v", m.NotifyMock.defaultExpectation.expectationOrigins.origin, *m.NotifyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNotify != nil && afterNotifyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Notify at\n%s", m.funcNotifyOrigin)
	}

	if !m.NotifyMock.invocationsDone() && afterNotifyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Notify at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NotifyMock.expectedInvocations), m.NotifyMock.expectedInvocationsOrigin, afterNotifyCounter)
	}
}

type mDeviceServiceHandlerMockRegisterKey struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockRegisterKeyExpectation
	expectations       []*DeviceServiceHandlerMockRegisterKeyExpectation

	callArgs []*DeviceServiceHandlerMockRegisterKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockRegisterKeyExpectation specifies expectation struct of the DeviceServiceHandler.RegisterKey
type DeviceServiceHandlerMockRegisterKeyExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockRegisterKeyParams
	paramPtrs          *DeviceServiceHandlerMockRegisterKeyParamPtrs
	expectationOrigins DeviceServiceHandlerMockRegisterKeyExpectationOrigins
	results            *DeviceServiceHandlerMockRegisterKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockRegisterKeyParams contains parameters of the DeviceServiceHandler.RegisterKey
type DeviceServiceHandlerMockRegisterKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RegisterKeyRequest]
}

// DeviceServiceHandlerMockRegisterKeyParamPtrs contains pointers to parameters of the DeviceServiceHandler.RegisterKey
type DeviceServiceHandlerMockRegisterKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RegisterKeyRequest]
}

// DeviceServiceHandlerMockRegisterKeyResults contains results of the DeviceServiceHandler.RegisterKey
type DeviceServiceHandlerMockRegisterKeyResults struct {
	pp2 *connect.Response[v1.RegisterKeyResponse]
	err error
}

// DeviceServiceHandlerMockRegisterKeyOrigins contains origins of expectations of the DeviceServiceHandler.RegisterKey
type DeviceServiceHandlerMockRegisterKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Optional() *mDeviceServiceHandlerMockRegisterKey {
	mmRegisterKey.optional = true
	return mmRegisterKey
}

// Expect sets up expected params for DeviceServiceHandler.RegisterKey
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Expect(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) *mDeviceServiceHandlerMockRegisterKey {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceHandlerMockRegisterKeyExpectation{}
	}

	if mmRegisterKey.defaultExpectation.paramPtrs != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by ExpectParams functions")
	}

	mmRegisterKey.defaultExpectation.params = &DeviceServiceHandlerMockRegisterKeyParams{ctx, pp1}
	mmRegisterKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterKey.expectations {
		if minimock.Equal(e.params, mmRegisterKey.defaultExpectation.params) {
			mmRegisterKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterKey.defaultExpectation.params)
		}
	}

	return mmRegisterKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.RegisterKey
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockRegisterKey {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceHandlerMockRegisterKeyExpectation{}
	}

	if mmRegisterKey.defaultExpectation.params != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Expect")
	}

	if mmRegisterKey.defaultExpectation.paramPtrs == nil {
		mmRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockRegisterKeyParamPtrs{}
	}
	mmRegisterKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegisterKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegisterKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.RegisterKey
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) ExpectPp1Param2(pp1 *connect.Request[v1.RegisterKeyRequest]) *mDeviceServiceHandlerMockRegisterKey {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceHandlerMockRegisterKeyExpectation{}
	}

	if mmRegisterKey.defaultExpectation.params != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Expect")
	}

	if mmRegisterKey.defaultExpectation.paramPtrs == nil {
		mmRegisterKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockRegisterKeyParamPtrs{}
	}
	mmRegisterKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRegisterKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRegisterKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.RegisterKey
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest])) *mDeviceServiceHandlerMockRegisterKey {
	if mmRegisterKey.mock.inspectFuncRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.RegisterKey")
	}

	mmRegisterKey.mock.inspectFuncRegisterKey = f

	return mmRegisterKey
}

// Return sets up results that will be returned by DeviceServiceHandler.RegisterKey
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Return(pp2 *connect.Response[v1.RegisterKeyResponse], err error) *DeviceServiceHandlerMock {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Set")
	}

	if mmRegisterKey.defaultExpectation == nil {
		mmRegisterKey.defaultExpectation = &DeviceServiceHandlerMockRegisterKeyExpectation{mock: mmRegisterKey.mock}
	}
	mmRegisterKey.defaultExpectation.results = &DeviceServiceHandlerMockRegisterKeyResults{pp2, err}
	mmRegisterKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterKey.mock
}

// Set uses given function f to mock the DeviceServiceHandler.RegisterKey method
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) (pp2 *connect.Response[v1.RegisterKeyResponse], err error)) *DeviceServiceHandlerMock {
	if mmRegisterKey.defaultExpectation != nil {
		mmRegisterKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.RegisterKey method")
	}

	if len(mmRegisterKey.expectations) > 0 {
		mmRegisterKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.RegisterKey method")
	}

	mmRegisterKey.mock.funcRegisterKey = f
	mmRegisterKey.mock.funcRegisterKeyOrigin = minimock.CallerInfo(1)
	return mmRegisterKey.mock
}

// When sets expectation for the DeviceServiceHandler.RegisterKey which will trigger the result defined by the following
// Then helper
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) When(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) *DeviceServiceHandlerMockRegisterKeyExpectation {
	if mmRegisterKey.mock.funcRegisterKey != nil {
		mmRegisterKey.mock.t.Fatalf("DeviceServiceHandlerMock.RegisterKey mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockRegisterKeyExpectation{
		mock:               mmRegisterKey.mock,
		params:             &DeviceServiceHandlerMockRegisterKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockRegisterKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterKey.expectations = append(mmRegisterKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.RegisterKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockRegisterKeyExpectation) Then(pp2 *connect.Response[v1.RegisterKeyResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockRegisterKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.RegisterKey should be invoked
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Times(n uint64) *mDeviceServiceHandlerMockRegisterKey {
	if n == 0 {
		mmRegisterKey.mock.t.Fatalf("Times of DeviceServiceHandlerMock.RegisterKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterKey.expectedInvocations, n)
	mmRegisterKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterKey
}

func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) invocationsDone() bool {
	if len(mmRegisterKey.expectations) == 0 && mmRegisterKey.defaultExpectation == nil && mmRegisterKey.mock.funcRegisterKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterKey.mock.afterRegisterKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterKey implements mm_devicev1connect.DeviceServiceHandler
func (mmRegisterKey *DeviceServiceHandlerMock) RegisterKey(ctx context.Context, pp1 *connect.Request[v1.RegisterKeyRequest]) (pp2 *connect.Response[v1.RegisterKeyResponse], err error) {
	mm_atomic.AddUint64(&mmRegisterKey.beforeRegisterKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterKey.afterRegisterKeyCounter, 1)

	mmRegisterKey.t.Helper()

	if mmRegisterKey.inspectFuncRegisterKey != nil {
		mmRegisterKey.inspectFuncRegisterKey(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockRegisterKeyParams{ctx, pp1}

	// Record call args
	mmRegisterKey.RegisterKeyMock.mutex.Lock()
	mmRegisterKey.RegisterKeyMock.callArgs = append(mmRegisterKey.RegisterKeyMock.callArgs, &mm_params)
	mmRegisterKey.RegisterKeyMock.mutex.Unlock()

	for _, e := range mmRegisterKey.RegisterKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRegisterKey.RegisterKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterKey.RegisterKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterKey.RegisterKeyMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterKey.RegisterKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockRegisterKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegisterKey.t.Errorf("DeviceServiceHandlerMock.RegisterKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterKey.RegisterKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRegisterKey.t.Errorf("DeviceServiceHandlerMock.RegisterKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterKey.RegisterKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterKey.t.Errorf("DeviceServiceHandlerMock.RegisterKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterKey.RegisterKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterKey.RegisterKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterKey.t.Fatal("No results are set for the DeviceServiceHandlerMock.RegisterKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRegisterKey.funcRegisterKey != nil {
		return mmRegisterKey.funcRegisterKey(ctx, pp1)
	}
	mmRegisterKey.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.RegisterKey. %v %v", ctx, pp1)
	return
}

// RegisterKeyAfterCounter returns a count of finished DeviceServiceHandlerMock.RegisterKey invocations
func (mmRegisterKey *DeviceServiceHandlerMock) RegisterKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterKey.afterRegisterKeyCounter)
}

// RegisterKeyBeforeCounter returns a count of DeviceServiceHandlerMock.RegisterKey invocations
func (mmRegisterKey *DeviceServiceHandlerMock) RegisterKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterKey.beforeRegisterKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.RegisterKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterKey *mDeviceServiceHandlerMockRegisterKey) Calls() []*DeviceServiceHandlerMockRegisterKeyParams {
	mmRegisterKey.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockRegisterKeyParams, len(mmRegisterKey.callArgs))
	copy(argCopy, mmRegisterKey.callArgs)

	mmRegisterKey.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterKeyDone returns true if the count of the RegisterKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockRegisterKeyDone() bool {
	if m.RegisterKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterKeyMock.invocationsDone()
}

// MinimockRegisterKeyInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockRegisterKeyInspect() {
	for _, e := range m.RegisterKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.RegisterKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterKeyCounter := mm_atomic.LoadUint64(&m.afterRegisterKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterKeyMock.defaultExpectation != nil && afterRegisterKeyCounter < 1 {
		if m.RegisterKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.RegisterKey at\n%s", m.RegisterKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.RegisterKey at\n%s with params: %#v", m.RegisterKeyMock.defaultExpectation.expectationOrigins.origin, *m.RegisterKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterKey != nil && afterRegisterKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.RegisterKey at\n%s", m.funcRegisterKeyOrigin)
	}

	if !m.RegisterKeyMock.invocationsDone() && afterRegisterKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.RegisterKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterKeyMock.expectedInvocations), m.RegisterKeyMock.expectedInvocationsOrigin, afterRegisterKeyCounter)
	}
}

type mDeviceServiceHandlerMockRemove struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockRemoveExpectation
	expectations       []*DeviceServiceHandlerMockRemoveExpectation

	callArgs []*DeviceServiceHandlerMockRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockRemoveExpectation specifies expectation struct of the DeviceServiceHandler.Remove
type DeviceServiceHandlerMockRemoveExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockRemoveParams
	paramPtrs          *DeviceServiceHandlerMockRemoveParamPtrs
	expectationOrigins DeviceServiceHandlerMockRemoveExpectationOrigins
	results            *DeviceServiceHandlerMockRemoveResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockRemoveParams contains parameters of the DeviceServiceHandler.Remove
type DeviceServiceHandlerMockRemoveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveRequest]
}

// DeviceServiceHandlerMockRemoveParamPtrs contains pointers to parameters of the DeviceServiceHandler.Remove
type DeviceServiceHandlerMockRemoveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveRequest]
}

// DeviceServiceHandlerMockRemoveResults contains results of the DeviceServiceHandler.Remove
type DeviceServiceHandlerMockRemoveResults struct {
	pp2 *connect.Response[v1.RemoveResponse]
	err error
}

// DeviceServiceHandlerMockRemoveOrigins contains origins of expectations of the DeviceServiceHandler.Remove
type DeviceServiceHandlerMockRemoveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemove *mDeviceServiceHandlerMockRemove) Optional() *mDeviceServiceHandlerMockRemove {
	mmRemove.optional = true
	return mmRemove
}

// Expect sets up expected params for DeviceServiceHandler.Remove
func (mmRemove *mDeviceServiceHandlerMockRemove) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) *mDeviceServiceHandlerMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceHandlerMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.paramPtrs != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by ExpectParams functions")
	}

	mmRemove.defaultExpectation.params = &DeviceServiceHandlerMockRemoveParams{ctx, pp1}
	mmRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Remove
func (mmRemove *mDeviceServiceHandlerMockRemove) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceHandlerMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemove
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Remove
func (mmRemove *mDeviceServiceHandlerMockRemove) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveRequest]) *mDeviceServiceHandlerMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceHandlerMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemove.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Remove
func (mmRemove *mDeviceServiceHandlerMockRemove) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest])) *mDeviceServiceHandlerMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by DeviceServiceHandler.Remove
func (mmRemove *mDeviceServiceHandlerMockRemove) Return(pp2 *connect.Response[v1.RemoveResponse], err error) *DeviceServiceHandlerMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &DeviceServiceHandlerMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &DeviceServiceHandlerMockRemoveResults{pp2, err}
	mmRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Remove method
func (mmRemove *mDeviceServiceHandlerMockRemove) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) (pp2 *connect.Response[v1.RemoveResponse], err error)) *DeviceServiceHandlerMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Remove method")
	}

	mmRemove.mock.funcRemove = f
	mmRemove.mock.funcRemoveOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// When sets expectation for the DeviceServiceHandler.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mDeviceServiceHandlerMockRemove) When(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) *DeviceServiceHandlerMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("DeviceServiceHandlerMock.Remove mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockRemoveExpectation{
		mock:               mmRemove.mock,
		params:             &DeviceServiceHandlerMockRemoveParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Remove return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockRemoveExpectation) Then(pp2 *connect.Response[v1.RemoveResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockRemoveResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Remove should be invoked
func (mmRemove *mDeviceServiceHandlerMockRemove) Times(n uint64) *mDeviceServiceHandlerMockRemove {
	if n == 0 {
		mmRemove.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Remove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemove.expectedInvocations, n)
	mmRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemove
}

func (mmRemove *mDeviceServiceHandlerMockRemove) invocationsDone() bool {
	if len(mmRemove.expectations) == 0 && mmRemove.defaultExpectation == nil && mmRemove.mock.funcRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemove.mock.afterRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Remove implements mm_devicev1connect.DeviceServiceHandler
func (mmRemove *DeviceServiceHandlerMock) Remove(ctx context.Context, pp1 *connect.Request[v1.RemoveRequest]) (pp2 *connect.Response[v1.RemoveResponse], err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	mmRemove.t.Helper()

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockRemoveParams{ctx, pp1}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, &mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_want_ptrs := mmRemove.RemoveMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockRemoveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemove.t.Errorf("DeviceServiceHandlerMock.Remove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemove.t.Errorf("DeviceServiceHandlerMock.Remove got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("DeviceServiceHandlerMock.Remove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemove.RemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemove.RemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemove.t.Fatal("No results are set for the DeviceServiceHandlerMock.Remove")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(ctx, pp1)
	}
	mmRemove.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Remove. %v %v", ctx, pp1)
	return
}

// RemoveAfterCounter returns a count of finished DeviceServiceHandlerMock.Remove invocations
func (mmRemove *DeviceServiceHandlerMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of DeviceServiceHandlerMock.Remove invocations
func (mmRemove *DeviceServiceHandlerMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mDeviceServiceHandlerMockRemove) Calls() []*DeviceServiceHandlerMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockRemoveDone() bool {
	if m.RemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveMock.invocationsDone()
}

// MinimockRemoveInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Remove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCounter := mm_atomic.LoadUint64(&m.afterRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && afterRemoveCounter < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Remove at\n%s", m.RemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Remove at\n%s with params: %#v", m.RemoveMock.defaultExpectation.expectationOrigins.origin, *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && afterRemoveCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Remove at\n%s", m.funcRemoveOrigin)
	}

	if !m.RemoveMock.invocationsDone() && afterRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Remove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveMock.expectedInvocations), m.RemoveMock.expectedInvocationsOrigin, afterRemoveCounter)
	}
}

type mDeviceServiceHandlerMockRemoveKey struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockRemoveKeyExpectation
	expectations       []*DeviceServiceHandlerMockRemoveKeyExpectation

	callArgs []*DeviceServiceHandlerMockRemoveKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockRemoveKeyExpectation specifies expectation struct of the DeviceServiceHandler.RemoveKey
type DeviceServiceHandlerMockRemoveKeyExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockRemoveKeyParams
	paramPtrs          *DeviceServiceHandlerMockRemoveKeyParamPtrs
	expectationOrigins DeviceServiceHandlerMockRemoveKeyExpectationOrigins
	results            *DeviceServiceHandlerMockRemoveKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockRemoveKeyParams contains parameters of the DeviceServiceHandler.RemoveKey
type DeviceServiceHandlerMockRemoveKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveKeyRequest]
}

// DeviceServiceHandlerMockRemoveKeyParamPtrs contains pointers to parameters of the DeviceServiceHandler.RemoveKey
type DeviceServiceHandlerMockRemoveKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveKeyRequest]
}

// DeviceServiceHandlerMockRemoveKeyResults contains results of the DeviceServiceHandler.RemoveKey
type DeviceServiceHandlerMockRemoveKeyResults struct {
	pp2 *connect.Response[v1.RemoveKeyResponse]
	err error
}

// DeviceServiceHandlerMockRemoveKeyOrigins contains origins of expectations of the DeviceServiceHandler.RemoveKey
type DeviceServiceHandlerMockRemoveKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Optional() *mDeviceServiceHandlerMockRemoveKey {
	mmRemoveKey.optional = true
	return mmRemoveKey
}

// Expect sets up expected params for DeviceServiceHandler.RemoveKey
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) *mDeviceServiceHandlerMockRemoveKey {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceHandlerMockRemoveKeyExpectation{}
	}

	if mmRemoveKey.defaultExpectation.paramPtrs != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by ExpectParams functions")
	}

	mmRemoveKey.defaultExpectation.params = &DeviceServiceHandlerMockRemoveKeyParams{ctx, pp1}
	mmRemoveKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveKey.expectations {
		if minimock.Equal(e.params, mmRemoveKey.defaultExpectation.params) {
			mmRemoveKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveKey.defaultExpectation.params)
		}
	}

	return mmRemoveKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.RemoveKey
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockRemoveKey {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceHandlerMockRemoveKeyExpectation{}
	}

	if mmRemoveKey.defaultExpectation.params != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Expect")
	}

	if mmRemoveKey.defaultExpectation.paramPtrs == nil {
		mmRemoveKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockRemoveKeyParamPtrs{}
	}
	mmRemoveKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.RemoveKey
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveKeyRequest]) *mDeviceServiceHandlerMockRemoveKey {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceHandlerMockRemoveKeyExpectation{}
	}

	if mmRemoveKey.defaultExpectation.params != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Expect")
	}

	if mmRemoveKey.defaultExpectation.paramPtrs == nil {
		mmRemoveKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockRemoveKeyParamPtrs{}
	}
	mmRemoveKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.RemoveKey
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest])) *mDeviceServiceHandlerMockRemoveKey {
	if mmRemoveKey.mock.inspectFuncRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.RemoveKey")
	}

	mmRemoveKey.mock.inspectFuncRemoveKey = f

	return mmRemoveKey
}

// Return sets up results that will be returned by DeviceServiceHandler.RemoveKey
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Return(pp2 *connect.Response[v1.RemoveKeyResponse], err error) *DeviceServiceHandlerMock {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Set")
	}

	if mmRemoveKey.defaultExpectation == nil {
		mmRemoveKey.defaultExpectation = &DeviceServiceHandlerMockRemoveKeyExpectation{mock: mmRemoveKey.mock}
	}
	mmRemoveKey.defaultExpectation.results = &DeviceServiceHandlerMockRemoveKeyResults{pp2, err}
	mmRemoveKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveKey.mock
}

// Set uses given function f to mock the DeviceServiceHandler.RemoveKey method
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) (pp2 *connect.Response[v1.RemoveKeyResponse], err error)) *DeviceServiceHandlerMock {
	if mmRemoveKey.defaultExpectation != nil {
		mmRemoveKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.RemoveKey method")
	}

	if len(mmRemoveKey.expectations) > 0 {
		mmRemoveKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.RemoveKey method")
	}

	mmRemoveKey.mock.funcRemoveKey = f
	mmRemoveKey.mock.funcRemoveKeyOrigin = minimock.CallerInfo(1)
	return mmRemoveKey.mock
}

// When sets expectation for the DeviceServiceHandler.RemoveKey which will trigger the result defined by the following
// Then helper
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) When(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) *DeviceServiceHandlerMockRemoveKeyExpectation {
	if mmRemoveKey.mock.funcRemoveKey != nil {
		mmRemoveKey.mock.t.Fatalf("DeviceServiceHandlerMock.RemoveKey mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockRemoveKeyExpectation{
		mock:               mmRemoveKey.mock,
		params:             &DeviceServiceHandlerMockRemoveKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockRemoveKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveKey.expectations = append(mmRemoveKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.RemoveKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockRemoveKeyExpectation) Then(pp2 *connect.Response[v1.RemoveKeyResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockRemoveKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.RemoveKey should be invoked
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Times(n uint64) *mDeviceServiceHandlerMockRemoveKey {
	if n == 0 {
		mmRemoveKey.mock.t.Fatalf("Times of DeviceServiceHandlerMock.RemoveKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveKey.expectedInvocations, n)
	mmRemoveKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveKey
}

func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) invocationsDone() bool {
	if len(mmRemoveKey.expectations) == 0 && mmRemoveKey.defaultExpectation == nil && mmRemoveKey.mock.funcRemoveKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveKey.mock.afterRemoveKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveKey implements mm_devicev1connect.DeviceServiceHandler
func (mmRemoveKey *DeviceServiceHandlerMock) RemoveKey(ctx context.Context, pp1 *connect.Request[v1.RemoveKeyRequest]) (pp2 *connect.Response[v1.RemoveKeyResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveKey.beforeRemoveKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveKey.afterRemoveKeyCounter, 1)

	mmRemoveKey.t.Helper()

	if mmRemoveKey.inspectFuncRemoveKey != nil {
		mmRemoveKey.inspectFuncRemoveKey(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockRemoveKeyParams{ctx, pp1}

	// Record call args
	mmRemoveKey.RemoveKeyMock.mutex.Lock()
	mmRemoveKey.RemoveKeyMock.callArgs = append(mmRemoveKey.RemoveKeyMock.callArgs, &mm_params)
	mmRemoveKey.RemoveKeyMock.mutex.Unlock()

	for _, e := range mmRemoveKey.RemoveKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveKey.RemoveKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveKey.RemoveKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveKey.RemoveKeyMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveKey.RemoveKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockRemoveKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveKey.t.Errorf("DeviceServiceHandlerMock.RemoveKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveKey.RemoveKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveKey.t.Errorf("DeviceServiceHandlerMock.RemoveKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveKey.RemoveKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveKey.t.Errorf("DeviceServiceHandlerMock.RemoveKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveKey.RemoveKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveKey.RemoveKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveKey.t.Fatal("No results are set for the DeviceServiceHandlerMock.RemoveKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveKey.funcRemoveKey != nil {
		return mmRemoveKey.funcRemoveKey(ctx, pp1)
	}
	mmRemoveKey.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.RemoveKey. %v %v", ctx, pp1)
	return
}

// RemoveKeyAfterCounter returns a count of finished DeviceServiceHandlerMock.RemoveKey invocations
func (mmRemoveKey *DeviceServiceHandlerMock) RemoveKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveKey.afterRemoveKeyCounter)
}

// RemoveKeyBeforeCounter returns a count of DeviceServiceHandlerMock.RemoveKey invocations
func (mmRemoveKey *DeviceServiceHandlerMock) RemoveKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveKey.beforeRemoveKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.RemoveKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveKey *mDeviceServiceHandlerMockRemoveKey) Calls() []*DeviceServiceHandlerMockRemoveKeyParams {
	mmRemoveKey.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockRemoveKeyParams, len(mmRemoveKey.callArgs))
	copy(argCopy, mmRemoveKey.callArgs)

	mmRemoveKey.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveKeyDone returns true if the count of the RemoveKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockRemoveKeyDone() bool {
	if m.RemoveKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveKeyMock.invocationsDone()
}

// MinimockRemoveKeyInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockRemoveKeyInspect() {
	for _, e := range m.RemoveKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.RemoveKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveKeyCounter := mm_atomic.LoadUint64(&m.afterRemoveKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveKeyMock.defaultExpectation != nil && afterRemoveKeyCounter < 1 {
		if m.RemoveKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.RemoveKey at\n%s", m.RemoveKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.RemoveKey at\n%s with params: %#v", m.RemoveKeyMock.defaultExpectation.expectationOrigins.origin, *m.RemoveKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveKey != nil && afterRemoveKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.RemoveKey at\n%s", m.funcRemoveKeyOrigin)
	}

	if !m.RemoveKeyMock.invocationsDone() && afterRemoveKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.RemoveKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveKeyMock.expectedInvocations), m.RemoveKeyMock.expectedInvocationsOrigin, afterRemoveKeyCounter)
	}
}

type mDeviceServiceHandlerMockSearch struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockSearchExpectation
	expectations       []*DeviceServiceHandlerMockSearchExpectation

	callArgs []*DeviceServiceHandlerMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockSearchExpectation specifies expectation struct of the DeviceServiceHandler.Search
type DeviceServiceHandlerMockSearchExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockSearchParams
	paramPtrs          *DeviceServiceHandlerMockSearchParamPtrs
	expectationOrigins DeviceServiceHandlerMockSearchExpectationOrigins
	results            *DeviceServiceHandlerMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockSearchParams contains parameters of the DeviceServiceHandler.Search
type DeviceServiceHandlerMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
	pp2 *connect.ServerStream[v1.SearchResponse]
}

// DeviceServiceHandlerMockSearchParamPtrs contains pointers to parameters of the DeviceServiceHandler.Search
type DeviceServiceHandlerMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
	pp2 **connect.ServerStream[v1.SearchResponse]
}

// DeviceServiceHandlerMockSearchResults contains results of the DeviceServiceHandler.Search
type DeviceServiceHandlerMockSearchResults struct {
	err error
}

// DeviceServiceHandlerMockSearchOrigins contains origins of expectations of the DeviceServiceHandler.Search
type DeviceServiceHandlerMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mDeviceServiceHandlerMockSearch) Optional() *mDeviceServiceHandlerMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for DeviceServiceHandler.Search
func (mmSearch *mDeviceServiceHandlerMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) *mDeviceServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &DeviceServiceHandlerMockSearchParams{ctx, pp1, pp2}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Search
func (mmSearch *mDeviceServiceHandlerMockSearch) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Search
func (mmSearch *mDeviceServiceHandlerMockSearch) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mDeviceServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp2Param3 sets up expected param pp2 for DeviceServiceHandler.Search
func (mmSearch *mDeviceServiceHandlerMockSearch) ExpectPp2Param3(pp2 *connect.ServerStream[v1.SearchResponse]) *mDeviceServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearch.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Search
func (mmSearch *mDeviceServiceHandlerMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse])) *mDeviceServiceHandlerMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by DeviceServiceHandler.Search
func (mmSearch *mDeviceServiceHandlerMockSearch) Return(err error) *DeviceServiceHandlerMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &DeviceServiceHandlerMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &DeviceServiceHandlerMockSearchResults{err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Search method
func (mmSearch *mDeviceServiceHandlerMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error)) *DeviceServiceHandlerMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the DeviceServiceHandler.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mDeviceServiceHandlerMockSearch) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) *DeviceServiceHandlerMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("DeviceServiceHandlerMock.Search mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &DeviceServiceHandlerMockSearchParams{ctx, pp1, pp2},
		expectationOrigins: DeviceServiceHandlerMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Search return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockSearchExpectation) Then(err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockSearchResults{err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Search should be invoked
func (mmSearch *mDeviceServiceHandlerMockSearch) Times(n uint64) *mDeviceServiceHandlerMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mDeviceServiceHandlerMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_devicev1connect.DeviceServiceHandler
func (mmSearch *DeviceServiceHandlerMock) Search(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1, pp2)
	}

	mm_params := DeviceServiceHandlerMockSearchParams{ctx, pp1, pp2}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockSearchParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("DeviceServiceHandlerMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("DeviceServiceHandlerMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearch.t.Errorf("DeviceServiceHandlerMock.Search got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("DeviceServiceHandlerMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the DeviceServiceHandlerMock.Search")
		}
		return (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1, pp2)
	}
	mmSearch.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Search. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchAfterCounter returns a count of finished DeviceServiceHandlerMock.Search invocations
func (mmSearch *DeviceServiceHandlerMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of DeviceServiceHandlerMock.Search invocations
func (mmSearch *DeviceServiceHandlerMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mDeviceServiceHandlerMockSearch) Calls() []*DeviceServiceHandlerMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

type mDeviceServiceHandlerMockSearchKey struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockSearchKeyExpectation
	expectations       []*DeviceServiceHandlerMockSearchKeyExpectation

	callArgs []*DeviceServiceHandlerMockSearchKeyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockSearchKeyExpectation specifies expectation struct of the DeviceServiceHandler.SearchKey
type DeviceServiceHandlerMockSearchKeyExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockSearchKeyParams
	paramPtrs          *DeviceServiceHandlerMockSearchKeyParamPtrs
	expectationOrigins DeviceServiceHandlerMockSearchKeyExpectationOrigins
	results            *DeviceServiceHandlerMockSearchKeyResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockSearchKeyParams contains parameters of the DeviceServiceHandler.SearchKey
type DeviceServiceHandlerMockSearchKeyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchKeyRequest]
}

// DeviceServiceHandlerMockSearchKeyParamPtrs contains pointers to parameters of the DeviceServiceHandler.SearchKey
type DeviceServiceHandlerMockSearchKeyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchKeyRequest]
}

// DeviceServiceHandlerMockSearchKeyResults contains results of the DeviceServiceHandler.SearchKey
type DeviceServiceHandlerMockSearchKeyResults struct {
	pp2 *connect.Response[v1.SearchKeyResponse]
	err error
}

// DeviceServiceHandlerMockSearchKeyOrigins contains origins of expectations of the DeviceServiceHandler.SearchKey
type DeviceServiceHandlerMockSearchKeyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Optional() *mDeviceServiceHandlerMockSearchKey {
	mmSearchKey.optional = true
	return mmSearchKey
}

// Expect sets up expected params for DeviceServiceHandler.SearchKey
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) *mDeviceServiceHandlerMockSearchKey {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceHandlerMockSearchKeyExpectation{}
	}

	if mmSearchKey.defaultExpectation.paramPtrs != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by ExpectParams functions")
	}

	mmSearchKey.defaultExpectation.params = &DeviceServiceHandlerMockSearchKeyParams{ctx, pp1}
	mmSearchKey.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchKey.expectations {
		if minimock.Equal(e.params, mmSearchKey.defaultExpectation.params) {
			mmSearchKey.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchKey.defaultExpectation.params)
		}
	}

	return mmSearchKey
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.SearchKey
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockSearchKey {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceHandlerMockSearchKeyExpectation{}
	}

	if mmSearchKey.defaultExpectation.params != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Expect")
	}

	if mmSearchKey.defaultExpectation.paramPtrs == nil {
		mmSearchKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockSearchKeyParamPtrs{}
	}
	mmSearchKey.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchKey.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchKey
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.SearchKey
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) ExpectPp1Param2(pp1 *connect.Request[v1.SearchKeyRequest]) *mDeviceServiceHandlerMockSearchKey {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceHandlerMockSearchKeyExpectation{}
	}

	if mmSearchKey.defaultExpectation.params != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Expect")
	}

	if mmSearchKey.defaultExpectation.paramPtrs == nil {
		mmSearchKey.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockSearchKeyParamPtrs{}
	}
	mmSearchKey.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchKey.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchKey
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.SearchKey
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest])) *mDeviceServiceHandlerMockSearchKey {
	if mmSearchKey.mock.inspectFuncSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.SearchKey")
	}

	mmSearchKey.mock.inspectFuncSearchKey = f

	return mmSearchKey
}

// Return sets up results that will be returned by DeviceServiceHandler.SearchKey
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Return(pp2 *connect.Response[v1.SearchKeyResponse], err error) *DeviceServiceHandlerMock {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Set")
	}

	if mmSearchKey.defaultExpectation == nil {
		mmSearchKey.defaultExpectation = &DeviceServiceHandlerMockSearchKeyExpectation{mock: mmSearchKey.mock}
	}
	mmSearchKey.defaultExpectation.results = &DeviceServiceHandlerMockSearchKeyResults{pp2, err}
	mmSearchKey.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchKey.mock
}

// Set uses given function f to mock the DeviceServiceHandler.SearchKey method
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) (pp2 *connect.Response[v1.SearchKeyResponse], err error)) *DeviceServiceHandlerMock {
	if mmSearchKey.defaultExpectation != nil {
		mmSearchKey.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.SearchKey method")
	}

	if len(mmSearchKey.expectations) > 0 {
		mmSearchKey.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.SearchKey method")
	}

	mmSearchKey.mock.funcSearchKey = f
	mmSearchKey.mock.funcSearchKeyOrigin = minimock.CallerInfo(1)
	return mmSearchKey.mock
}

// When sets expectation for the DeviceServiceHandler.SearchKey which will trigger the result defined by the following
// Then helper
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) When(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) *DeviceServiceHandlerMockSearchKeyExpectation {
	if mmSearchKey.mock.funcSearchKey != nil {
		mmSearchKey.mock.t.Fatalf("DeviceServiceHandlerMock.SearchKey mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockSearchKeyExpectation{
		mock:               mmSearchKey.mock,
		params:             &DeviceServiceHandlerMockSearchKeyParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockSearchKeyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchKey.expectations = append(mmSearchKey.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.SearchKey return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockSearchKeyExpectation) Then(pp2 *connect.Response[v1.SearchKeyResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockSearchKeyResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.SearchKey should be invoked
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Times(n uint64) *mDeviceServiceHandlerMockSearchKey {
	if n == 0 {
		mmSearchKey.mock.t.Fatalf("Times of DeviceServiceHandlerMock.SearchKey mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchKey.expectedInvocations, n)
	mmSearchKey.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchKey
}

func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) invocationsDone() bool {
	if len(mmSearchKey.expectations) == 0 && mmSearchKey.defaultExpectation == nil && mmSearchKey.mock.funcSearchKey == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchKey.mock.afterSearchKeyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchKey.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchKey implements mm_devicev1connect.DeviceServiceHandler
func (mmSearchKey *DeviceServiceHandlerMock) SearchKey(ctx context.Context, pp1 *connect.Request[v1.SearchKeyRequest]) (pp2 *connect.Response[v1.SearchKeyResponse], err error) {
	mm_atomic.AddUint64(&mmSearchKey.beforeSearchKeyCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchKey.afterSearchKeyCounter, 1)

	mmSearchKey.t.Helper()

	if mmSearchKey.inspectFuncSearchKey != nil {
		mmSearchKey.inspectFuncSearchKey(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockSearchKeyParams{ctx, pp1}

	// Record call args
	mmSearchKey.SearchKeyMock.mutex.Lock()
	mmSearchKey.SearchKeyMock.callArgs = append(mmSearchKey.SearchKeyMock.callArgs, &mm_params)
	mmSearchKey.SearchKeyMock.mutex.Unlock()

	for _, e := range mmSearchKey.SearchKeyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchKey.SearchKeyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchKey.SearchKeyMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchKey.SearchKeyMock.defaultExpectation.params
		mm_want_ptrs := mmSearchKey.SearchKeyMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockSearchKeyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchKey.t.Errorf("DeviceServiceHandlerMock.SearchKey got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchKey.SearchKeyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchKey.t.Errorf("DeviceServiceHandlerMock.SearchKey got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchKey.SearchKeyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchKey.t.Errorf("DeviceServiceHandlerMock.SearchKey got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchKey.SearchKeyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchKey.SearchKeyMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchKey.t.Fatal("No results are set for the DeviceServiceHandlerMock.SearchKey")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchKey.funcSearchKey != nil {
		return mmSearchKey.funcSearchKey(ctx, pp1)
	}
	mmSearchKey.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.SearchKey. %v %v", ctx, pp1)
	return
}

// SearchKeyAfterCounter returns a count of finished DeviceServiceHandlerMock.SearchKey invocations
func (mmSearchKey *DeviceServiceHandlerMock) SearchKeyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchKey.afterSearchKeyCounter)
}

// SearchKeyBeforeCounter returns a count of DeviceServiceHandlerMock.SearchKey invocations
func (mmSearchKey *DeviceServiceHandlerMock) SearchKeyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchKey.beforeSearchKeyCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.SearchKey.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchKey *mDeviceServiceHandlerMockSearchKey) Calls() []*DeviceServiceHandlerMockSearchKeyParams {
	mmSearchKey.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockSearchKeyParams, len(mmSearchKey.callArgs))
	copy(argCopy, mmSearchKey.callArgs)

	mmSearchKey.mutex.RUnlock()

	return argCopy
}

// MinimockSearchKeyDone returns true if the count of the SearchKey invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockSearchKeyDone() bool {
	if m.SearchKeyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchKeyMock.invocationsDone()
}

// MinimockSearchKeyInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockSearchKeyInspect() {
	for _, e := range m.SearchKeyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.SearchKey at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchKeyCounter := mm_atomic.LoadUint64(&m.afterSearchKeyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchKeyMock.defaultExpectation != nil && afterSearchKeyCounter < 1 {
		if m.SearchKeyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.SearchKey at\n%s", m.SearchKeyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.SearchKey at\n%s with params: %#v", m.SearchKeyMock.defaultExpectation.expectationOrigins.origin, *m.SearchKeyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchKey != nil && afterSearchKeyCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.SearchKey at\n%s", m.funcSearchKeyOrigin)
	}

	if !m.SearchKeyMock.invocationsDone() && afterSearchKeyCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.SearchKey at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchKeyMock.expectedInvocations), m.SearchKeyMock.expectedInvocationsOrigin, afterSearchKeyCounter)
	}
}

type mDeviceServiceHandlerMockUpdate struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockUpdateExpectation
	expectations       []*DeviceServiceHandlerMockUpdateExpectation

	callArgs []*DeviceServiceHandlerMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockUpdateExpectation specifies expectation struct of the DeviceServiceHandler.Update
type DeviceServiceHandlerMockUpdateExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockUpdateParams
	paramPtrs          *DeviceServiceHandlerMockUpdateParamPtrs
	expectationOrigins DeviceServiceHandlerMockUpdateExpectationOrigins
	results            *DeviceServiceHandlerMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockUpdateParams contains parameters of the DeviceServiceHandler.Update
type DeviceServiceHandlerMockUpdateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateRequest]
}

// DeviceServiceHandlerMockUpdateParamPtrs contains pointers to parameters of the DeviceServiceHandler.Update
type DeviceServiceHandlerMockUpdateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateRequest]
}

// DeviceServiceHandlerMockUpdateResults contains results of the DeviceServiceHandler.Update
type DeviceServiceHandlerMockUpdateResults struct {
	pp2 *connect.Response[v1.UpdateResponse]
	err error
}

// DeviceServiceHandlerMockUpdateOrigins contains origins of expectations of the DeviceServiceHandler.Update
type DeviceServiceHandlerMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Optional() *mDeviceServiceHandlerMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for DeviceServiceHandler.Update
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) *mDeviceServiceHandlerMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceHandlerMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &DeviceServiceHandlerMockUpdateParams{ctx, pp1}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.Update
func (mmUpdate *mDeviceServiceHandlerMockUpdate) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceHandlerMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.Update
func (mmUpdate *mDeviceServiceHandlerMockUpdate) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateRequest]) *mDeviceServiceHandlerMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceHandlerMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.Update
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest])) *mDeviceServiceHandlerMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by DeviceServiceHandler.Update
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Return(pp2 *connect.Response[v1.UpdateResponse], err error) *DeviceServiceHandlerMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &DeviceServiceHandlerMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &DeviceServiceHandlerMockUpdateResults{pp2, err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the DeviceServiceHandler.Update method
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) (pp2 *connect.Response[v1.UpdateResponse], err error)) *DeviceServiceHandlerMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the DeviceServiceHandler.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mDeviceServiceHandlerMockUpdate) When(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) *DeviceServiceHandlerMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("DeviceServiceHandlerMock.Update mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &DeviceServiceHandlerMockUpdateParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.Update return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockUpdateExpectation) Then(pp2 *connect.Response[v1.UpdateResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockUpdateResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.Update should be invoked
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Times(n uint64) *mDeviceServiceHandlerMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of DeviceServiceHandlerMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mDeviceServiceHandlerMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_devicev1connect.DeviceServiceHandler
func (mmUpdate *DeviceServiceHandlerMock) Update(ctx context.Context, pp1 *connect.Request[v1.UpdateRequest]) (pp2 *connect.Response[v1.UpdateResponse], err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockUpdateParams{ctx, pp1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockUpdateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("DeviceServiceHandlerMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdate.t.Errorf("DeviceServiceHandlerMock.Update got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("DeviceServiceHandlerMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the DeviceServiceHandlerMock.Update")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, pp1)
	}
	mmUpdate.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.Update. %v %v", ctx, pp1)
	return
}

// UpdateAfterCounter returns a count of finished DeviceServiceHandlerMock.Update invocations
func (mmUpdate *DeviceServiceHandlerMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of DeviceServiceHandlerMock.Update invocations
func (mmUpdate *DeviceServiceHandlerMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mDeviceServiceHandlerMockUpdate) Calls() []*DeviceServiceHandlerMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

type mDeviceServiceHandlerMockUpdatePresence struct {
	optional           bool
	mock               *DeviceServiceHandlerMock
	defaultExpectation *DeviceServiceHandlerMockUpdatePresenceExpectation
	expectations       []*DeviceServiceHandlerMockUpdatePresenceExpectation

	callArgs []*DeviceServiceHandlerMockUpdatePresenceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// DeviceServiceHandlerMockUpdatePresenceExpectation specifies expectation struct of the DeviceServiceHandler.UpdatePresence
type DeviceServiceHandlerMockUpdatePresenceExpectation struct {
	mock               *DeviceServiceHandlerMock
	params             *DeviceServiceHandlerMockUpdatePresenceParams
	paramPtrs          *DeviceServiceHandlerMockUpdatePresenceParamPtrs
	expectationOrigins DeviceServiceHandlerMockUpdatePresenceExpectationOrigins
	results            *DeviceServiceHandlerMockUpdatePresenceResults
	returnOrigin       string
	Counter            uint64
}

// DeviceServiceHandlerMockUpdatePresenceParams contains parameters of the DeviceServiceHandler.UpdatePresence
type DeviceServiceHandlerMockUpdatePresenceParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdatePresenceRequest]
}

// DeviceServiceHandlerMockUpdatePresenceParamPtrs contains pointers to parameters of the DeviceServiceHandler.UpdatePresence
type DeviceServiceHandlerMockUpdatePresenceParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdatePresenceRequest]
}

// DeviceServiceHandlerMockUpdatePresenceResults contains results of the DeviceServiceHandler.UpdatePresence
type DeviceServiceHandlerMockUpdatePresenceResults struct {
	pp2 *connect.Response[v1.UpdatePresenceResponse]
	err error
}

// DeviceServiceHandlerMockUpdatePresenceOrigins contains origins of expectations of the DeviceServiceHandler.UpdatePresence
type DeviceServiceHandlerMockUpdatePresenceExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Optional() *mDeviceServiceHandlerMockUpdatePresence {
	mmUpdatePresence.optional = true
	return mmUpdatePresence
}

// Expect sets up expected params for DeviceServiceHandler.UpdatePresence
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) *mDeviceServiceHandlerMockUpdatePresence {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceHandlerMockUpdatePresenceExpectation{}
	}

	if mmUpdatePresence.defaultExpectation.paramPtrs != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by ExpectParams functions")
	}

	mmUpdatePresence.defaultExpectation.params = &DeviceServiceHandlerMockUpdatePresenceParams{ctx, pp1}
	mmUpdatePresence.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePresence.expectations {
		if minimock.Equal(e.params, mmUpdatePresence.defaultExpectation.params) {
			mmUpdatePresence.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePresence.defaultExpectation.params)
		}
	}

	return mmUpdatePresence
}

// ExpectCtxParam1 sets up expected param ctx for DeviceServiceHandler.UpdatePresence
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) ExpectCtxParam1(ctx context.Context) *mDeviceServiceHandlerMockUpdatePresence {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceHandlerMockUpdatePresenceExpectation{}
	}

	if mmUpdatePresence.defaultExpectation.params != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Expect")
	}

	if mmUpdatePresence.defaultExpectation.paramPtrs == nil {
		mmUpdatePresence.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockUpdatePresenceParamPtrs{}
	}
	mmUpdatePresence.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePresence.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePresence
}

// ExpectPp1Param2 sets up expected param pp1 for DeviceServiceHandler.UpdatePresence
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) ExpectPp1Param2(pp1 *connect.Request[v1.UpdatePresenceRequest]) *mDeviceServiceHandlerMockUpdatePresence {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceHandlerMockUpdatePresenceExpectation{}
	}

	if mmUpdatePresence.defaultExpectation.params != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Expect")
	}

	if mmUpdatePresence.defaultExpectation.paramPtrs == nil {
		mmUpdatePresence.defaultExpectation.paramPtrs = &DeviceServiceHandlerMockUpdatePresenceParamPtrs{}
	}
	mmUpdatePresence.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdatePresence.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdatePresence
}

// Inspect accepts an inspector function that has same arguments as the DeviceServiceHandler.UpdatePresence
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest])) *mDeviceServiceHandlerMockUpdatePresence {
	if mmUpdatePresence.mock.inspectFuncUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("Inspect function is already set for DeviceServiceHandlerMock.UpdatePresence")
	}

	mmUpdatePresence.mock.inspectFuncUpdatePresence = f

	return mmUpdatePresence
}

// Return sets up results that will be returned by DeviceServiceHandler.UpdatePresence
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Return(pp2 *connect.Response[v1.UpdatePresenceResponse], err error) *DeviceServiceHandlerMock {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Set")
	}

	if mmUpdatePresence.defaultExpectation == nil {
		mmUpdatePresence.defaultExpectation = &DeviceServiceHandlerMockUpdatePresenceExpectation{mock: mmUpdatePresence.mock}
	}
	mmUpdatePresence.defaultExpectation.results = &DeviceServiceHandlerMockUpdatePresenceResults{pp2, err}
	mmUpdatePresence.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePresence.mock
}

// Set uses given function f to mock the DeviceServiceHandler.UpdatePresence method
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) (pp2 *connect.Response[v1.UpdatePresenceResponse], err error)) *DeviceServiceHandlerMock {
	if mmUpdatePresence.defaultExpectation != nil {
		mmUpdatePresence.mock.t.Fatalf("Default expectation is already set for the DeviceServiceHandler.UpdatePresence method")
	}

	if len(mmUpdatePresence.expectations) > 0 {
		mmUpdatePresence.mock.t.Fatalf("Some expectations are already set for the DeviceServiceHandler.UpdatePresence method")
	}

	mmUpdatePresence.mock.funcUpdatePresence = f
	mmUpdatePresence.mock.funcUpdatePresenceOrigin = minimock.CallerInfo(1)
	return mmUpdatePresence.mock
}

// When sets expectation for the DeviceServiceHandler.UpdatePresence which will trigger the result defined by the following
// Then helper
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) When(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) *DeviceServiceHandlerMockUpdatePresenceExpectation {
	if mmUpdatePresence.mock.funcUpdatePresence != nil {
		mmUpdatePresence.mock.t.Fatalf("DeviceServiceHandlerMock.UpdatePresence mock is already set by Set")
	}

	expectation := &DeviceServiceHandlerMockUpdatePresenceExpectation{
		mock:               mmUpdatePresence.mock,
		params:             &DeviceServiceHandlerMockUpdatePresenceParams{ctx, pp1},
		expectationOrigins: DeviceServiceHandlerMockUpdatePresenceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePresence.expectations = append(mmUpdatePresence.expectations, expectation)
	return expectation
}

// Then sets up DeviceServiceHandler.UpdatePresence return parameters for the expectation previously defined by the When method
func (e *DeviceServiceHandlerMockUpdatePresenceExpectation) Then(pp2 *connect.Response[v1.UpdatePresenceResponse], err error) *DeviceServiceHandlerMock {
	e.results = &DeviceServiceHandlerMockUpdatePresenceResults{pp2, err}
	return e.mock
}

// Times sets number of times DeviceServiceHandler.UpdatePresence should be invoked
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Times(n uint64) *mDeviceServiceHandlerMockUpdatePresence {
	if n == 0 {
		mmUpdatePresence.mock.t.Fatalf("Times of DeviceServiceHandlerMock.UpdatePresence mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePresence.expectedInvocations, n)
	mmUpdatePresence.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePresence
}

func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) invocationsDone() bool {
	if len(mmUpdatePresence.expectations) == 0 && mmUpdatePresence.defaultExpectation == nil && mmUpdatePresence.mock.funcUpdatePresence == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePresence.mock.afterUpdatePresenceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePresence.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePresence implements mm_devicev1connect.DeviceServiceHandler
func (mmUpdatePresence *DeviceServiceHandlerMock) UpdatePresence(ctx context.Context, pp1 *connect.Request[v1.UpdatePresenceRequest]) (pp2 *connect.Response[v1.UpdatePresenceResponse], err error) {
	mm_atomic.AddUint64(&mmUpdatePresence.beforeUpdatePresenceCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePresence.afterUpdatePresenceCounter, 1)

	mmUpdatePresence.t.Helper()

	if mmUpdatePresence.inspectFuncUpdatePresence != nil {
		mmUpdatePresence.inspectFuncUpdatePresence(ctx, pp1)
	}

	mm_params := DeviceServiceHandlerMockUpdatePresenceParams{ctx, pp1}

	// Record call args
	mmUpdatePresence.UpdatePresenceMock.mutex.Lock()
	mmUpdatePresence.UpdatePresenceMock.callArgs = append(mmUpdatePresence.UpdatePresenceMock.callArgs, &mm_params)
	mmUpdatePresence.UpdatePresenceMock.mutex.Unlock()

	for _, e := range mmUpdatePresence.UpdatePresenceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdatePresence.UpdatePresenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePresence.UpdatePresenceMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePresence.UpdatePresenceMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePresence.UpdatePresenceMock.defaultExpectation.paramPtrs

		mm_got := DeviceServiceHandlerMockUpdatePresenceParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePresence.t.Errorf("DeviceServiceHandlerMock.UpdatePresence got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePresence.UpdatePresenceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdatePresence.t.Errorf("DeviceServiceHandlerMock.UpdatePresence got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePresence.UpdatePresenceMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePresence.t.Errorf("DeviceServiceHandlerMock.UpdatePresence got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePresence.UpdatePresenceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePresence.UpdatePresenceMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePresence.t.Fatal("No results are set for the DeviceServiceHandlerMock.UpdatePresence")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdatePresence.funcUpdatePresence != nil {
		return mmUpdatePresence.funcUpdatePresence(ctx, pp1)
	}
	mmUpdatePresence.t.Fatalf("Unexpected call to DeviceServiceHandlerMock.UpdatePresence. %v %v", ctx, pp1)
	return
}

// UpdatePresenceAfterCounter returns a count of finished DeviceServiceHandlerMock.UpdatePresence invocations
func (mmUpdatePresence *DeviceServiceHandlerMock) UpdatePresenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePresence.afterUpdatePresenceCounter)
}

// UpdatePresenceBeforeCounter returns a count of DeviceServiceHandlerMock.UpdatePresence invocations
func (mmUpdatePresence *DeviceServiceHandlerMock) UpdatePresenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePresence.beforeUpdatePresenceCounter)
}

// Calls returns a list of arguments used in each call to DeviceServiceHandlerMock.UpdatePresence.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePresence *mDeviceServiceHandlerMockUpdatePresence) Calls() []*DeviceServiceHandlerMockUpdatePresenceParams {
	mmUpdatePresence.mutex.RLock()

	argCopy := make([]*DeviceServiceHandlerMockUpdatePresenceParams, len(mmUpdatePresence.callArgs))
	copy(argCopy, mmUpdatePresence.callArgs)

	mmUpdatePresence.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePresenceDone returns true if the count of the UpdatePresence invocations corresponds
// the number of defined expectations
func (m *DeviceServiceHandlerMock) MinimockUpdatePresenceDone() bool {
	if m.UpdatePresenceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePresenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePresenceMock.invocationsDone()
}

// MinimockUpdatePresenceInspect logs each unmet expectation
func (m *DeviceServiceHandlerMock) MinimockUpdatePresenceInspect() {
	for _, e := range m.UpdatePresenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.UpdatePresence at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePresenceCounter := mm_atomic.LoadUint64(&m.afterUpdatePresenceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePresenceMock.defaultExpectation != nil && afterUpdatePresenceCounter < 1 {
		if m.UpdatePresenceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.UpdatePresence at\n%s", m.UpdatePresenceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to DeviceServiceHandlerMock.UpdatePresence at\n%s with params: %#v", m.UpdatePresenceMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePresenceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePresence != nil && afterUpdatePresenceCounter < 1 {
		m.t.Errorf("Expected call to DeviceServiceHandlerMock.UpdatePresence at\n%s", m.funcUpdatePresenceOrigin)
	}

	if !m.UpdatePresenceMock.invocationsDone() && afterUpdatePresenceCounter > 0 {
		m.t.Errorf("Expected %d calls to DeviceServiceHandlerMock.UpdatePresence at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePresenceMock.expectedInvocations), m.UpdatePresenceMock.expectedInvocationsOrigin, afterUpdatePresenceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DeviceServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddKeyInspect()

			m.MinimockCreateInspect()

			m.MinimockDeRegisterKeyInspect()

			m.MinimockGetByIdInspect()

			m.MinimockGetBySessionIdInspect()

			m.MinimockLinkInspect()

			m.MinimockListLogsInspect()

			m.MinimockLogInspect()

			m.MinimockNotifyInspect()

			m.MinimockRegisterKeyInspect()

			m.MinimockRemoveInspect()

			m.MinimockRemoveKeyInspect()

			m.MinimockSearchInspect()

			m.MinimockSearchKeyInspect()

			m.MinimockUpdateInspect()

			m.MinimockUpdatePresenceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DeviceServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DeviceServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddKeyDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeRegisterKeyDone() &&
		m.MinimockGetByIdDone() &&
		m.MinimockGetBySessionIdDone() &&
		m.MinimockLinkDone() &&
		m.MinimockListLogsDone() &&
		m.MinimockLogDone() &&
		m.MinimockNotifyDone() &&
		m.MinimockRegisterKeyDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockRemoveKeyDone() &&
		m.MinimockSearchDone() &&
		m.MinimockSearchKeyDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdatePresenceDone()
}
