// Copyright 2023-2024 Ant Investor Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: ocr/v1/ocr.proto

package ocrv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	v1 "github.com/antinvestor/apis/go/common/v1"
	_ "github.com/google/gnostic/openapiv3"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// OCRFile represents the result of OCR processing for a single file.
type OCRFile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FileId        string                 `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`          // Unique identifier of the processed file
	Language      string                 `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`                    // Detected or specified language code (ISO 639-1)
	Status        v1.STATUS              `protobuf:"varint,3,opt,name=status,proto3,enum=common.v1.STATUS" json:"status,omitempty"` // Processing status (QUEUED, IN_PROCESS, SUCCESSFUL, FAILED)
	Text          string                 `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`                            // Extracted text content
	Properties    *structpb.Struct       `protobuf:"bytes,5,opt,name=properties,proto3" json:"properties,omitempty"`                // Additional metadata (confidence scores, bounding boxes, etc.)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OCRFile) Reset() {
	*x = OCRFile{}
	mi := &file_ocr_v1_ocr_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OCRFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OCRFile) ProtoMessage() {}

func (x *OCRFile) ProtoReflect() protoreflect.Message {
	mi := &file_ocr_v1_ocr_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OCRFile.ProtoReflect.Descriptor instead.
func (*OCRFile) Descriptor() ([]byte, []int) {
	return file_ocr_v1_ocr_proto_rawDescGZIP(), []int{0}
}

func (x *OCRFile) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

func (x *OCRFile) GetLanguage() string {
	if x != nil {
		return x.Language
	}
	return ""
}

func (x *OCRFile) GetStatus() v1.STATUS {
	if x != nil {
		return x.Status
	}
	return v1.STATUS(0)
}

func (x *OCRFile) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *OCRFile) GetProperties() *structpb.Struct {
	if x != nil {
		return x.Properties
	}
	return nil
}

// RecognizeRequest initiates OCR processing for one or more files.
// Supports both synchronous and asynchronous processing modes.
type RecognizeRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ReferenceId   string                 `protobuf:"bytes,1,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"` // Client-provided reference ID for tracking
	LanguageId    string                 `protobuf:"bytes,2,opt,name=language_id,json=languageId,proto3" json:"language_id,omitempty"`    // Expected language code (e.g., "en", "es", "fr") for improved accuracy
	Properties    *structpb.Struct       `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`                      // Processing options (DPI, preprocessing, output format)
	Async         bool                   `protobuf:"varint,4,opt,name=async,proto3" json:"async,omitempty"`                               // If true, process asynchronously and return immediately
	FileId        []string               `protobuf:"bytes,5,rep,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`                // List of file IDs to process (1-5 files per request)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecognizeRequest) Reset() {
	*x = RecognizeRequest{}
	mi := &file_ocr_v1_ocr_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecognizeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognizeRequest) ProtoMessage() {}

func (x *RecognizeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ocr_v1_ocr_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognizeRequest.ProtoReflect.Descriptor instead.
func (*RecognizeRequest) Descriptor() ([]byte, []int) {
	return file_ocr_v1_ocr_proto_rawDescGZIP(), []int{1}
}

func (x *RecognizeRequest) GetReferenceId() string {
	if x != nil {
		return x.ReferenceId
	}
	return ""
}

func (x *RecognizeRequest) GetLanguageId() string {
	if x != nil {
		return x.LanguageId
	}
	return ""
}

func (x *RecognizeRequest) GetProperties() *structpb.Struct {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *RecognizeRequest) GetAsync() bool {
	if x != nil {
		return x.Async
	}
	return false
}

func (x *RecognizeRequest) GetFileId() []string {
	if x != nil {
		return x.FileId
	}
	return nil
}

// RecognizeResponse returns OCR results for the requested files.
type RecognizeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ReferenceId   string                 `protobuf:"bytes,1,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"` // Reference ID from the request
	Result        []*OCRFile             `protobuf:"bytes,2,rep,name=result,proto3" json:"result,omitempty"`                              // OCR results for each processed file
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecognizeResponse) Reset() {
	*x = RecognizeResponse{}
	mi := &file_ocr_v1_ocr_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecognizeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognizeResponse) ProtoMessage() {}

func (x *RecognizeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ocr_v1_ocr_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognizeResponse.ProtoReflect.Descriptor instead.
func (*RecognizeResponse) Descriptor() ([]byte, []int) {
	return file_ocr_v1_ocr_proto_rawDescGZIP(), []int{2}
}

func (x *RecognizeResponse) GetReferenceId() string {
	if x != nil {
		return x.ReferenceId
	}
	return ""
}

func (x *RecognizeResponse) GetResult() []*OCRFile {
	if x != nil {
		return x.Result
	}
	return nil
}

// StatusResponse returns the status of an async OCR request.
type StatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          *RecognizeResponse     `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"` // Current OCR results and status
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusResponse) Reset() {
	*x = StatusResponse{}
	mi := &file_ocr_v1_ocr_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusResponse) ProtoMessage() {}

func (x *StatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ocr_v1_ocr_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return file_ocr_v1_ocr_proto_rawDescGZIP(), []int{3}
}

func (x *StatusResponse) GetData() *RecognizeResponse {
	if x != nil {
		return x.Data
	}
	return nil
}

var File_ocr_v1_ocr_proto protoreflect.FileDescriptor

const file_ocr_v1_ocr_proto_rawDesc = "" +
	"\n" +
	"\x10ocr/v1/ocr.proto\x12\x06ocr.v1\x1a\x1bbuf/validate/validate.proto\x1a\x16common/v1/common.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a$gnostic/openapi/v3/annotations.proto\"\xb6\x01\n" +
	"\aOCRFile\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\x12\x1a\n" +
	"\blanguage\x18\x02 \x01(\tR\blanguage\x12)\n" +
	"\x06status\x18\x03 \x01(\x0e2\x11.common.v1.STATUSR\x06status\x12\x12\n" +
	"\x04text\x18\x04 \x01(\tR\x04text\x127\n" +
	"\n" +
	"properties\x18\x05 \x01(\v2\x17.google.protobuf.StructR\n" +
	"properties\"\x98\x02\n" +
	"\x10RecognizeRequest\x12>\n" +
	"\freference_id\x18\x01 \x01(\tB\x1b\xbaH\x18r\x16\x10\x03\x18(2\x10[0-9a-z_-]{3,20}R\vreferenceId\x126\n" +
	"\vlanguage_id\x18\x02 \x01(\tB\x15\xbaH\x12r\x10\x10\x02\x18\x032\n" +
	"[a-z]{2,3}R\n" +
	"languageId\x127\n" +
	"\n" +
	"properties\x18\x03 \x01(\v2\x17.google.protobuf.StructR\n" +
	"properties\x12\x14\n" +
	"\x05async\x18\x04 \x01(\bR\x05async\x12=\n" +
	"\afile_id\x18\x05 \x03(\tB$\xbaH!\x92\x01\x1e\b\x01\x10\x05\"\x18r\x16\x10\x03\x18(2\x10[0-9a-z_-]{3,20}R\x06fileId\"_\n" +
	"\x11RecognizeResponse\x12!\n" +
	"\freference_id\x18\x01 \x01(\tR\vreferenceId\x12'\n" +
	"\x06result\x18\x02 \x03(\v2\x0f.ocr.v1.OCRFileR\x06result\"?\n" +
	"\x0eStatusResponse\x12-\n" +
	"\x04data\x18\x01 \x01(\v2\x19.ocr.v1.RecognizeResponseR\x04data2\xac\x05\n" +
	"\n" +
	"OCRService\x12\xfe\x02\n" +
	"\tRecognize\x12\x18.ocr.v1.RecognizeRequest\x1a\x19.ocr.v1.RecognizeResponse\"\xbb\x02\xbaG\xb7\x02\n" +
	"\x03OCR\x12\x14Perform OCR on files\x1a\x8a\x02Performs optical character recognition on one or more files (images or PDFs). Supports both synchronous processing (returns immediately with results) and asynchronous processing (queues for background processing). Batch processing supports up to 5 files per request.*\rrecognizeText\x12\x9c\x02\n" +
	"\x06Status\x12\x18.common.v1.StatusRequest\x1a\x16.ocr.v1.StatusResponse\"\xdf\x01\xbaG\xdb\x01\n" +
	"\x03OCR\x12\x16Get OCR request status\x1a\xad\x01Retrieves the current status of an asynchronous OCR request. Returns processing status (queued, in-process, successful, failed) and extracted text if processing is complete.*\fgetOCRStatusB\xe4\x05\xbaG\xd3\x04\x12\xa7\x04\n" +
	"\vOCR Service\x12\xee\x02The OCR (Optical Character Recognition) Service provides text extraction capabilities from images and documents. It supports multiple languages, various file formats (PDF, images), and both synchronous and asynchronous processing modes. The service is optimized for document processing workflows including invoice parsing, ID verification, and document digitization.\"T\n" +
	"\x10Ant Investor Ltd\x12*https://github.com/antinvestor/service-ocr\x1a\x14info@antinvestor.com*I\n" +
	"\x0eApache License\x127https://github.com/antinvestor/apis/blob/master/LICENSE2\x06v1.0.0*':%\n" +
	"#\n" +
	"\n" +
	"BearerAuth\x12\x15\n" +
	"\x13\n" +
	"\x04http*\x06bearer2\x03JWT\n" +
	"\x1bcom.antinvestor.apis.ocr.v1B\bOcrProtoP\x01Z+github.com/antinvestor/apis/go/ocr/v1;ocrv1\xa2\x02\x03OXX\xaa\x02\x06Ocr.V1\xca\x02\x06Ocr\\V1\xe2\x02\x12Ocr\\V1\\GPBMetadata\xea\x02\aOcr::V1b\x06proto3"

var (
	file_ocr_v1_ocr_proto_rawDescOnce sync.Once
	file_ocr_v1_ocr_proto_rawDescData []byte
)

func file_ocr_v1_ocr_proto_rawDescGZIP() []byte {
	file_ocr_v1_ocr_proto_rawDescOnce.Do(func() {
		file_ocr_v1_ocr_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ocr_v1_ocr_proto_rawDesc), len(file_ocr_v1_ocr_proto_rawDesc)))
	})
	return file_ocr_v1_ocr_proto_rawDescData
}

var file_ocr_v1_ocr_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_ocr_v1_ocr_proto_goTypes = []any{
	(*OCRFile)(nil),           // 0: ocr.v1.OCRFile
	(*RecognizeRequest)(nil),  // 1: ocr.v1.RecognizeRequest
	(*RecognizeResponse)(nil), // 2: ocr.v1.RecognizeResponse
	(*StatusResponse)(nil),    // 3: ocr.v1.StatusResponse
	(v1.STATUS)(0),            // 4: common.v1.STATUS
	(*structpb.Struct)(nil),   // 5: google.protobuf.Struct
	(*v1.StatusRequest)(nil),  // 6: common.v1.StatusRequest
}
var file_ocr_v1_ocr_proto_depIdxs = []int32{
	4, // 0: ocr.v1.OCRFile.status:type_name -> common.v1.STATUS
	5, // 1: ocr.v1.OCRFile.properties:type_name -> google.protobuf.Struct
	5, // 2: ocr.v1.RecognizeRequest.properties:type_name -> google.protobuf.Struct
	0, // 3: ocr.v1.RecognizeResponse.result:type_name -> ocr.v1.OCRFile
	2, // 4: ocr.v1.StatusResponse.data:type_name -> ocr.v1.RecognizeResponse
	1, // 5: ocr.v1.OCRService.Recognize:input_type -> ocr.v1.RecognizeRequest
	6, // 6: ocr.v1.OCRService.Status:input_type -> common.v1.StatusRequest
	2, // 7: ocr.v1.OCRService.Recognize:output_type -> ocr.v1.RecognizeResponse
	3, // 8: ocr.v1.OCRService.Status:output_type -> ocr.v1.StatusResponse
	7, // [7:9] is the sub-list for method output_type
	5, // [5:7] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_ocr_v1_ocr_proto_init() }
func file_ocr_v1_ocr_proto_init() {
	if File_ocr_v1_ocr_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ocr_v1_ocr_proto_rawDesc), len(file_ocr_v1_ocr_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_ocr_v1_ocr_proto_goTypes,
		DependencyIndexes: file_ocr_v1_ocr_proto_depIdxs,
		MessageInfos:      file_ocr_v1_ocr_proto_msgTypes,
	}.Build()
	File_ocr_v1_ocr_proto = out.File
	file_ocr_v1_ocr_proto_goTypes = nil
	file_ocr_v1_ocr_proto_depIdxs = nil
}
