// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/payment/connectrpc/go/payment/v1/paymentv1connect.PaymentServiceClient -o payment_handler.gen.go -n PaymentServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v1 "buf.build/gen/go/antinvestor/payment/protocolbuffers/go/payment/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// PaymentServiceClientMock implements mm_paymentv1connect.PaymentServiceClient
type PaymentServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePaymentLink          func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) (pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error)
	funcCreatePaymentLinkOrigin    string
	inspectFuncCreatePaymentLink   func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest])
	afterCreatePaymentLinkCounter  uint64
	beforeCreatePaymentLinkCounter uint64
	CreatePaymentLinkMock          mPaymentServiceClientMockCreatePaymentLink

	funcInitiatePrompt          func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) (pp2 *connect.Response[v1.InitiatePromptResponse], err error)
	funcInitiatePromptOrigin    string
	inspectFuncInitiatePrompt   func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest])
	afterInitiatePromptCounter  uint64
	beforeInitiatePromptCounter uint64
	InitiatePromptMock          mPaymentServiceClientMockInitiatePrompt

	funcReceive          func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.Response[v1.ReceiveResponse], err error)
	funcReceiveOrigin    string
	inspectFuncReceive   func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest])
	afterReceiveCounter  uint64
	beforeReceiveCounter uint64
	ReceiveMock          mPaymentServiceClientMockReceive

	funcReconcile          func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) (pp2 *connect.Response[v1.ReconcileResponse], err error)
	funcReconcileOrigin    string
	inspectFuncReconcile   func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest])
	afterReconcileCounter  uint64
	beforeReconcileCounter uint64
	ReconcileMock          mPaymentServiceClientMockReconcile

	funcRelease          func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.Response[v1.ReleaseResponse], err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest])
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mPaymentServiceClientMockRelease

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mPaymentServiceClientMockSearch

	funcSend          func(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.Response[v1.SendResponse], err error)
	funcSendOrigin    string
	inspectFuncSend   func(ctx context.Context, pp1 *connect.Request[v1.SendRequest])
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mPaymentServiceClientMockSend

	funcStatus          func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)
	funcStatusOrigin    string
	inspectFuncStatus   func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])
	afterStatusCounter  uint64
	beforeStatusCounter uint64
	StatusMock          mPaymentServiceClientMockStatus

	funcStatusUpdate          func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)
	funcStatusUpdateOrigin    string
	inspectFuncStatusUpdate   func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])
	afterStatusUpdateCounter  uint64
	beforeStatusUpdateCounter uint64
	StatusUpdateMock          mPaymentServiceClientMockStatusUpdate
}

// NewPaymentServiceClientMock returns a mock for mm_paymentv1connect.PaymentServiceClient
func NewPaymentServiceClientMock(t minimock.Tester) *PaymentServiceClientMock {
	m := &PaymentServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePaymentLinkMock = mPaymentServiceClientMockCreatePaymentLink{mock: m}
	m.CreatePaymentLinkMock.callArgs = []*PaymentServiceClientMockCreatePaymentLinkParams{}

	m.InitiatePromptMock = mPaymentServiceClientMockInitiatePrompt{mock: m}
	m.InitiatePromptMock.callArgs = []*PaymentServiceClientMockInitiatePromptParams{}

	m.ReceiveMock = mPaymentServiceClientMockReceive{mock: m}
	m.ReceiveMock.callArgs = []*PaymentServiceClientMockReceiveParams{}

	m.ReconcileMock = mPaymentServiceClientMockReconcile{mock: m}
	m.ReconcileMock.callArgs = []*PaymentServiceClientMockReconcileParams{}

	m.ReleaseMock = mPaymentServiceClientMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*PaymentServiceClientMockReleaseParams{}

	m.SearchMock = mPaymentServiceClientMockSearch{mock: m}
	m.SearchMock.callArgs = []*PaymentServiceClientMockSearchParams{}

	m.SendMock = mPaymentServiceClientMockSend{mock: m}
	m.SendMock.callArgs = []*PaymentServiceClientMockSendParams{}

	m.StatusMock = mPaymentServiceClientMockStatus{mock: m}
	m.StatusMock.callArgs = []*PaymentServiceClientMockStatusParams{}

	m.StatusUpdateMock = mPaymentServiceClientMockStatusUpdate{mock: m}
	m.StatusUpdateMock.callArgs = []*PaymentServiceClientMockStatusUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPaymentServiceClientMockCreatePaymentLink struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockCreatePaymentLinkExpectation
	expectations       []*PaymentServiceClientMockCreatePaymentLinkExpectation

	callArgs []*PaymentServiceClientMockCreatePaymentLinkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockCreatePaymentLinkExpectation specifies expectation struct of the PaymentServiceClient.CreatePaymentLink
type PaymentServiceClientMockCreatePaymentLinkExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockCreatePaymentLinkParams
	paramPtrs          *PaymentServiceClientMockCreatePaymentLinkParamPtrs
	expectationOrigins PaymentServiceClientMockCreatePaymentLinkExpectationOrigins
	results            *PaymentServiceClientMockCreatePaymentLinkResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockCreatePaymentLinkParams contains parameters of the PaymentServiceClient.CreatePaymentLink
type PaymentServiceClientMockCreatePaymentLinkParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePaymentLinkRequest]
}

// PaymentServiceClientMockCreatePaymentLinkParamPtrs contains pointers to parameters of the PaymentServiceClient.CreatePaymentLink
type PaymentServiceClientMockCreatePaymentLinkParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePaymentLinkRequest]
}

// PaymentServiceClientMockCreatePaymentLinkResults contains results of the PaymentServiceClient.CreatePaymentLink
type PaymentServiceClientMockCreatePaymentLinkResults struct {
	pp2 *connect.Response[v1.CreatePaymentLinkResponse]
	err error
}

// PaymentServiceClientMockCreatePaymentLinkOrigins contains origins of expectations of the PaymentServiceClient.CreatePaymentLink
type PaymentServiceClientMockCreatePaymentLinkExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Optional() *mPaymentServiceClientMockCreatePaymentLink {
	mmCreatePaymentLink.optional = true
	return mmCreatePaymentLink
}

// Expect sets up expected params for PaymentServiceClient.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) *mPaymentServiceClientMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceClientMockCreatePaymentLinkExpectation{}
	}

	if mmCreatePaymentLink.defaultExpectation.paramPtrs != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by ExpectParams functions")
	}

	mmCreatePaymentLink.defaultExpectation.params = &PaymentServiceClientMockCreatePaymentLinkParams{ctx, pp1}
	mmCreatePaymentLink.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePaymentLink.expectations {
		if minimock.Equal(e.params, mmCreatePaymentLink.defaultExpectation.params) {
			mmCreatePaymentLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePaymentLink.defaultExpectation.params)
		}
	}

	return mmCreatePaymentLink
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceClientMockCreatePaymentLinkExpectation{}
	}

	if mmCreatePaymentLink.defaultExpectation.params != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Expect")
	}

	if mmCreatePaymentLink.defaultExpectation.paramPtrs == nil {
		mmCreatePaymentLink.defaultExpectation.paramPtrs = &PaymentServiceClientMockCreatePaymentLinkParamPtrs{}
	}
	mmCreatePaymentLink.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePaymentLink.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePaymentLink
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePaymentLinkRequest]) *mPaymentServiceClientMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceClientMockCreatePaymentLinkExpectation{}
	}

	if mmCreatePaymentLink.defaultExpectation.params != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Expect")
	}

	if mmCreatePaymentLink.defaultExpectation.paramPtrs == nil {
		mmCreatePaymentLink.defaultExpectation.paramPtrs = &PaymentServiceClientMockCreatePaymentLinkParamPtrs{}
	}
	mmCreatePaymentLink.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePaymentLink.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePaymentLink
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest])) *mPaymentServiceClientMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.inspectFuncCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.CreatePaymentLink")
	}

	mmCreatePaymentLink.mock.inspectFuncCreatePaymentLink = f

	return mmCreatePaymentLink
}

// Return sets up results that will be returned by PaymentServiceClient.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Return(pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error) *PaymentServiceClientMock {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceClientMockCreatePaymentLinkExpectation{mock: mmCreatePaymentLink.mock}
	}
	mmCreatePaymentLink.defaultExpectation.results = &PaymentServiceClientMockCreatePaymentLinkResults{pp2, err}
	mmCreatePaymentLink.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePaymentLink.mock
}

// Set uses given function f to mock the PaymentServiceClient.CreatePaymentLink method
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) (pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error)) *PaymentServiceClientMock {
	if mmCreatePaymentLink.defaultExpectation != nil {
		mmCreatePaymentLink.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.CreatePaymentLink method")
	}

	if len(mmCreatePaymentLink.expectations) > 0 {
		mmCreatePaymentLink.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.CreatePaymentLink method")
	}

	mmCreatePaymentLink.mock.funcCreatePaymentLink = f
	mmCreatePaymentLink.mock.funcCreatePaymentLinkOrigin = minimock.CallerInfo(1)
	return mmCreatePaymentLink.mock
}

// When sets expectation for the PaymentServiceClient.CreatePaymentLink which will trigger the result defined by the following
// Then helper
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) When(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) *PaymentServiceClientMockCreatePaymentLinkExpectation {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceClientMock.CreatePaymentLink mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockCreatePaymentLinkExpectation{
		mock:               mmCreatePaymentLink.mock,
		params:             &PaymentServiceClientMockCreatePaymentLinkParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockCreatePaymentLinkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePaymentLink.expectations = append(mmCreatePaymentLink.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.CreatePaymentLink return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockCreatePaymentLinkExpectation) Then(pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockCreatePaymentLinkResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.CreatePaymentLink should be invoked
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Times(n uint64) *mPaymentServiceClientMockCreatePaymentLink {
	if n == 0 {
		mmCreatePaymentLink.mock.t.Fatalf("Times of PaymentServiceClientMock.CreatePaymentLink mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePaymentLink.expectedInvocations, n)
	mmCreatePaymentLink.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePaymentLink
}

func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) invocationsDone() bool {
	if len(mmCreatePaymentLink.expectations) == 0 && mmCreatePaymentLink.defaultExpectation == nil && mmCreatePaymentLink.mock.funcCreatePaymentLink == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePaymentLink.mock.afterCreatePaymentLinkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePaymentLink.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePaymentLink implements mm_paymentv1connect.PaymentServiceClient
func (mmCreatePaymentLink *PaymentServiceClientMock) CreatePaymentLink(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) (pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePaymentLink.beforeCreatePaymentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePaymentLink.afterCreatePaymentLinkCounter, 1)

	mmCreatePaymentLink.t.Helper()

	if mmCreatePaymentLink.inspectFuncCreatePaymentLink != nil {
		mmCreatePaymentLink.inspectFuncCreatePaymentLink(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockCreatePaymentLinkParams{ctx, pp1}

	// Record call args
	mmCreatePaymentLink.CreatePaymentLinkMock.mutex.Lock()
	mmCreatePaymentLink.CreatePaymentLinkMock.callArgs = append(mmCreatePaymentLink.CreatePaymentLinkMock.callArgs, &mm_params)
	mmCreatePaymentLink.CreatePaymentLinkMock.mutex.Unlock()

	for _, e := range mmCreatePaymentLink.CreatePaymentLinkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockCreatePaymentLinkParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePaymentLink.t.Errorf("PaymentServiceClientMock.CreatePaymentLink got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePaymentLink.t.Errorf("PaymentServiceClientMock.CreatePaymentLink got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePaymentLink.t.Errorf("PaymentServiceClientMock.CreatePaymentLink got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePaymentLink.t.Fatal("No results are set for the PaymentServiceClientMock.CreatePaymentLink")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePaymentLink.funcCreatePaymentLink != nil {
		return mmCreatePaymentLink.funcCreatePaymentLink(ctx, pp1)
	}
	mmCreatePaymentLink.t.Fatalf("Unexpected call to PaymentServiceClientMock.CreatePaymentLink. %v %v", ctx, pp1)
	return
}

// CreatePaymentLinkAfterCounter returns a count of finished PaymentServiceClientMock.CreatePaymentLink invocations
func (mmCreatePaymentLink *PaymentServiceClientMock) CreatePaymentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePaymentLink.afterCreatePaymentLinkCounter)
}

// CreatePaymentLinkBeforeCounter returns a count of PaymentServiceClientMock.CreatePaymentLink invocations
func (mmCreatePaymentLink *PaymentServiceClientMock) CreatePaymentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePaymentLink.beforeCreatePaymentLinkCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.CreatePaymentLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePaymentLink *mPaymentServiceClientMockCreatePaymentLink) Calls() []*PaymentServiceClientMockCreatePaymentLinkParams {
	mmCreatePaymentLink.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockCreatePaymentLinkParams, len(mmCreatePaymentLink.callArgs))
	copy(argCopy, mmCreatePaymentLink.callArgs)

	mmCreatePaymentLink.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePaymentLinkDone returns true if the count of the CreatePaymentLink invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockCreatePaymentLinkDone() bool {
	if m.CreatePaymentLinkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePaymentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePaymentLinkMock.invocationsDone()
}

// MinimockCreatePaymentLinkInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockCreatePaymentLinkInspect() {
	for _, e := range m.CreatePaymentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.CreatePaymentLink at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePaymentLinkCounter := mm_atomic.LoadUint64(&m.afterCreatePaymentLinkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePaymentLinkMock.defaultExpectation != nil && afterCreatePaymentLinkCounter < 1 {
		if m.CreatePaymentLinkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.CreatePaymentLink at\n%s", m.CreatePaymentLinkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.CreatePaymentLink at\n%s with params: %#v", m.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.origin, *m.CreatePaymentLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePaymentLink != nil && afterCreatePaymentLinkCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.CreatePaymentLink at\n%s", m.funcCreatePaymentLinkOrigin)
	}

	if !m.CreatePaymentLinkMock.invocationsDone() && afterCreatePaymentLinkCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.CreatePaymentLink at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePaymentLinkMock.expectedInvocations), m.CreatePaymentLinkMock.expectedInvocationsOrigin, afterCreatePaymentLinkCounter)
	}
}

type mPaymentServiceClientMockInitiatePrompt struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockInitiatePromptExpectation
	expectations       []*PaymentServiceClientMockInitiatePromptExpectation

	callArgs []*PaymentServiceClientMockInitiatePromptParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockInitiatePromptExpectation specifies expectation struct of the PaymentServiceClient.InitiatePrompt
type PaymentServiceClientMockInitiatePromptExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockInitiatePromptParams
	paramPtrs          *PaymentServiceClientMockInitiatePromptParamPtrs
	expectationOrigins PaymentServiceClientMockInitiatePromptExpectationOrigins
	results            *PaymentServiceClientMockInitiatePromptResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockInitiatePromptParams contains parameters of the PaymentServiceClient.InitiatePrompt
type PaymentServiceClientMockInitiatePromptParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.InitiatePromptRequest]
}

// PaymentServiceClientMockInitiatePromptParamPtrs contains pointers to parameters of the PaymentServiceClient.InitiatePrompt
type PaymentServiceClientMockInitiatePromptParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.InitiatePromptRequest]
}

// PaymentServiceClientMockInitiatePromptResults contains results of the PaymentServiceClient.InitiatePrompt
type PaymentServiceClientMockInitiatePromptResults struct {
	pp2 *connect.Response[v1.InitiatePromptResponse]
	err error
}

// PaymentServiceClientMockInitiatePromptOrigins contains origins of expectations of the PaymentServiceClient.InitiatePrompt
type PaymentServiceClientMockInitiatePromptExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Optional() *mPaymentServiceClientMockInitiatePrompt {
	mmInitiatePrompt.optional = true
	return mmInitiatePrompt
}

// Expect sets up expected params for PaymentServiceClient.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Expect(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) *mPaymentServiceClientMockInitiatePrompt {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceClientMockInitiatePromptExpectation{}
	}

	if mmInitiatePrompt.defaultExpectation.paramPtrs != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by ExpectParams functions")
	}

	mmInitiatePrompt.defaultExpectation.params = &PaymentServiceClientMockInitiatePromptParams{ctx, pp1}
	mmInitiatePrompt.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInitiatePrompt.expectations {
		if minimock.Equal(e.params, mmInitiatePrompt.defaultExpectation.params) {
			mmInitiatePrompt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitiatePrompt.defaultExpectation.params)
		}
	}

	return mmInitiatePrompt
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockInitiatePrompt {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceClientMockInitiatePromptExpectation{}
	}

	if mmInitiatePrompt.defaultExpectation.params != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Expect")
	}

	if mmInitiatePrompt.defaultExpectation.paramPtrs == nil {
		mmInitiatePrompt.defaultExpectation.paramPtrs = &PaymentServiceClientMockInitiatePromptParamPtrs{}
	}
	mmInitiatePrompt.defaultExpectation.paramPtrs.ctx = &ctx
	mmInitiatePrompt.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInitiatePrompt
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) ExpectPp1Param2(pp1 *connect.Request[v1.InitiatePromptRequest]) *mPaymentServiceClientMockInitiatePrompt {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceClientMockInitiatePromptExpectation{}
	}

	if mmInitiatePrompt.defaultExpectation.params != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Expect")
	}

	if mmInitiatePrompt.defaultExpectation.paramPtrs == nil {
		mmInitiatePrompt.defaultExpectation.paramPtrs = &PaymentServiceClientMockInitiatePromptParamPtrs{}
	}
	mmInitiatePrompt.defaultExpectation.paramPtrs.pp1 = &pp1
	mmInitiatePrompt.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmInitiatePrompt
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest])) *mPaymentServiceClientMockInitiatePrompt {
	if mmInitiatePrompt.mock.inspectFuncInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.InitiatePrompt")
	}

	mmInitiatePrompt.mock.inspectFuncInitiatePrompt = f

	return mmInitiatePrompt
}

// Return sets up results that will be returned by PaymentServiceClient.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Return(pp2 *connect.Response[v1.InitiatePromptResponse], err error) *PaymentServiceClientMock {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceClientMockInitiatePromptExpectation{mock: mmInitiatePrompt.mock}
	}
	mmInitiatePrompt.defaultExpectation.results = &PaymentServiceClientMockInitiatePromptResults{pp2, err}
	mmInitiatePrompt.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInitiatePrompt.mock
}

// Set uses given function f to mock the PaymentServiceClient.InitiatePrompt method
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Set(f func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) (pp2 *connect.Response[v1.InitiatePromptResponse], err error)) *PaymentServiceClientMock {
	if mmInitiatePrompt.defaultExpectation != nil {
		mmInitiatePrompt.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.InitiatePrompt method")
	}

	if len(mmInitiatePrompt.expectations) > 0 {
		mmInitiatePrompt.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.InitiatePrompt method")
	}

	mmInitiatePrompt.mock.funcInitiatePrompt = f
	mmInitiatePrompt.mock.funcInitiatePromptOrigin = minimock.CallerInfo(1)
	return mmInitiatePrompt.mock
}

// When sets expectation for the PaymentServiceClient.InitiatePrompt which will trigger the result defined by the following
// Then helper
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) When(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) *PaymentServiceClientMockInitiatePromptExpectation {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceClientMock.InitiatePrompt mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockInitiatePromptExpectation{
		mock:               mmInitiatePrompt.mock,
		params:             &PaymentServiceClientMockInitiatePromptParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockInitiatePromptExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInitiatePrompt.expectations = append(mmInitiatePrompt.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.InitiatePrompt return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockInitiatePromptExpectation) Then(pp2 *connect.Response[v1.InitiatePromptResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockInitiatePromptResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.InitiatePrompt should be invoked
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Times(n uint64) *mPaymentServiceClientMockInitiatePrompt {
	if n == 0 {
		mmInitiatePrompt.mock.t.Fatalf("Times of PaymentServiceClientMock.InitiatePrompt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInitiatePrompt.expectedInvocations, n)
	mmInitiatePrompt.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInitiatePrompt
}

func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) invocationsDone() bool {
	if len(mmInitiatePrompt.expectations) == 0 && mmInitiatePrompt.defaultExpectation == nil && mmInitiatePrompt.mock.funcInitiatePrompt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInitiatePrompt.mock.afterInitiatePromptCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInitiatePrompt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InitiatePrompt implements mm_paymentv1connect.PaymentServiceClient
func (mmInitiatePrompt *PaymentServiceClientMock) InitiatePrompt(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) (pp2 *connect.Response[v1.InitiatePromptResponse], err error) {
	mm_atomic.AddUint64(&mmInitiatePrompt.beforeInitiatePromptCounter, 1)
	defer mm_atomic.AddUint64(&mmInitiatePrompt.afterInitiatePromptCounter, 1)

	mmInitiatePrompt.t.Helper()

	if mmInitiatePrompt.inspectFuncInitiatePrompt != nil {
		mmInitiatePrompt.inspectFuncInitiatePrompt(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockInitiatePromptParams{ctx, pp1}

	// Record call args
	mmInitiatePrompt.InitiatePromptMock.mutex.Lock()
	mmInitiatePrompt.InitiatePromptMock.callArgs = append(mmInitiatePrompt.InitiatePromptMock.callArgs, &mm_params)
	mmInitiatePrompt.InitiatePromptMock.mutex.Unlock()

	for _, e := range mmInitiatePrompt.InitiatePromptMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmInitiatePrompt.InitiatePromptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitiatePrompt.InitiatePromptMock.defaultExpectation.Counter, 1)
		mm_want := mmInitiatePrompt.InitiatePromptMock.defaultExpectation.params
		mm_want_ptrs := mmInitiatePrompt.InitiatePromptMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockInitiatePromptParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInitiatePrompt.t.Errorf("PaymentServiceClientMock.InitiatePrompt got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInitiatePrompt.InitiatePromptMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmInitiatePrompt.t.Errorf("PaymentServiceClientMock.InitiatePrompt got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInitiatePrompt.InitiatePromptMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitiatePrompt.t.Errorf("PaymentServiceClientMock.InitiatePrompt got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInitiatePrompt.InitiatePromptMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitiatePrompt.InitiatePromptMock.defaultExpectation.results
		if mm_results == nil {
			mmInitiatePrompt.t.Fatal("No results are set for the PaymentServiceClientMock.InitiatePrompt")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmInitiatePrompt.funcInitiatePrompt != nil {
		return mmInitiatePrompt.funcInitiatePrompt(ctx, pp1)
	}
	mmInitiatePrompt.t.Fatalf("Unexpected call to PaymentServiceClientMock.InitiatePrompt. %v %v", ctx, pp1)
	return
}

// InitiatePromptAfterCounter returns a count of finished PaymentServiceClientMock.InitiatePrompt invocations
func (mmInitiatePrompt *PaymentServiceClientMock) InitiatePromptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitiatePrompt.afterInitiatePromptCounter)
}

// InitiatePromptBeforeCounter returns a count of PaymentServiceClientMock.InitiatePrompt invocations
func (mmInitiatePrompt *PaymentServiceClientMock) InitiatePromptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitiatePrompt.beforeInitiatePromptCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.InitiatePrompt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitiatePrompt *mPaymentServiceClientMockInitiatePrompt) Calls() []*PaymentServiceClientMockInitiatePromptParams {
	mmInitiatePrompt.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockInitiatePromptParams, len(mmInitiatePrompt.callArgs))
	copy(argCopy, mmInitiatePrompt.callArgs)

	mmInitiatePrompt.mutex.RUnlock()

	return argCopy
}

// MinimockInitiatePromptDone returns true if the count of the InitiatePrompt invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockInitiatePromptDone() bool {
	if m.InitiatePromptMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitiatePromptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitiatePromptMock.invocationsDone()
}

// MinimockInitiatePromptInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockInitiatePromptInspect() {
	for _, e := range m.InitiatePromptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.InitiatePrompt at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInitiatePromptCounter := mm_atomic.LoadUint64(&m.afterInitiatePromptCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitiatePromptMock.defaultExpectation != nil && afterInitiatePromptCounter < 1 {
		if m.InitiatePromptMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.InitiatePrompt at\n%s", m.InitiatePromptMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.InitiatePrompt at\n%s with params: %#v", m.InitiatePromptMock.defaultExpectation.expectationOrigins.origin, *m.InitiatePromptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitiatePrompt != nil && afterInitiatePromptCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.InitiatePrompt at\n%s", m.funcInitiatePromptOrigin)
	}

	if !m.InitiatePromptMock.invocationsDone() && afterInitiatePromptCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.InitiatePrompt at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InitiatePromptMock.expectedInvocations), m.InitiatePromptMock.expectedInvocationsOrigin, afterInitiatePromptCounter)
	}
}

type mPaymentServiceClientMockReceive struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockReceiveExpectation
	expectations       []*PaymentServiceClientMockReceiveExpectation

	callArgs []*PaymentServiceClientMockReceiveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockReceiveExpectation specifies expectation struct of the PaymentServiceClient.Receive
type PaymentServiceClientMockReceiveExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockReceiveParams
	paramPtrs          *PaymentServiceClientMockReceiveParamPtrs
	expectationOrigins PaymentServiceClientMockReceiveExpectationOrigins
	results            *PaymentServiceClientMockReceiveResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockReceiveParams contains parameters of the PaymentServiceClient.Receive
type PaymentServiceClientMockReceiveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReceiveRequest]
}

// PaymentServiceClientMockReceiveParamPtrs contains pointers to parameters of the PaymentServiceClient.Receive
type PaymentServiceClientMockReceiveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReceiveRequest]
}

// PaymentServiceClientMockReceiveResults contains results of the PaymentServiceClient.Receive
type PaymentServiceClientMockReceiveResults struct {
	pp2 *connect.Response[v1.ReceiveResponse]
	err error
}

// PaymentServiceClientMockReceiveOrigins contains origins of expectations of the PaymentServiceClient.Receive
type PaymentServiceClientMockReceiveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReceive *mPaymentServiceClientMockReceive) Optional() *mPaymentServiceClientMockReceive {
	mmReceive.optional = true
	return mmReceive
}

// Expect sets up expected params for PaymentServiceClient.Receive
func (mmReceive *mPaymentServiceClientMockReceive) Expect(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) *mPaymentServiceClientMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceClientMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.paramPtrs != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by ExpectParams functions")
	}

	mmReceive.defaultExpectation.params = &PaymentServiceClientMockReceiveParams{ctx, pp1}
	mmReceive.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReceive.expectations {
		if minimock.Equal(e.params, mmReceive.defaultExpectation.params) {
			mmReceive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceive.defaultExpectation.params)
		}
	}

	return mmReceive
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.Receive
func (mmReceive *mPaymentServiceClientMockReceive) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceClientMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &PaymentServiceClientMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.ctx = &ctx
	mmReceive.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReceive
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.Receive
func (mmReceive *mPaymentServiceClientMockReceive) ExpectPp1Param2(pp1 *connect.Request[v1.ReceiveRequest]) *mPaymentServiceClientMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceClientMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &PaymentServiceClientMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReceive.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReceive
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.Receive
func (mmReceive *mPaymentServiceClientMockReceive) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest])) *mPaymentServiceClientMockReceive {
	if mmReceive.mock.inspectFuncReceive != nil {
		mmReceive.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.Receive")
	}

	mmReceive.mock.inspectFuncReceive = f

	return mmReceive
}

// Return sets up results that will be returned by PaymentServiceClient.Receive
func (mmReceive *mPaymentServiceClientMockReceive) Return(pp2 *connect.Response[v1.ReceiveResponse], err error) *PaymentServiceClientMock {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceClientMockReceiveExpectation{mock: mmReceive.mock}
	}
	mmReceive.defaultExpectation.results = &PaymentServiceClientMockReceiveResults{pp2, err}
	mmReceive.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// Set uses given function f to mock the PaymentServiceClient.Receive method
func (mmReceive *mPaymentServiceClientMockReceive) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.Response[v1.ReceiveResponse], err error)) *PaymentServiceClientMock {
	if mmReceive.defaultExpectation != nil {
		mmReceive.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.Receive method")
	}

	if len(mmReceive.expectations) > 0 {
		mmReceive.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.Receive method")
	}

	mmReceive.mock.funcReceive = f
	mmReceive.mock.funcReceiveOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// When sets expectation for the PaymentServiceClient.Receive which will trigger the result defined by the following
// Then helper
func (mmReceive *mPaymentServiceClientMockReceive) When(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) *PaymentServiceClientMockReceiveExpectation {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceClientMock.Receive mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockReceiveExpectation{
		mock:               mmReceive.mock,
		params:             &PaymentServiceClientMockReceiveParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockReceiveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReceive.expectations = append(mmReceive.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.Receive return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockReceiveExpectation) Then(pp2 *connect.Response[v1.ReceiveResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockReceiveResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.Receive should be invoked
func (mmReceive *mPaymentServiceClientMockReceive) Times(n uint64) *mPaymentServiceClientMockReceive {
	if n == 0 {
		mmReceive.mock.t.Fatalf("Times of PaymentServiceClientMock.Receive mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReceive.expectedInvocations, n)
	mmReceive.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReceive
}

func (mmReceive *mPaymentServiceClientMockReceive) invocationsDone() bool {
	if len(mmReceive.expectations) == 0 && mmReceive.defaultExpectation == nil && mmReceive.mock.funcReceive == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReceive.mock.afterReceiveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReceive.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Receive implements mm_paymentv1connect.PaymentServiceClient
func (mmReceive *PaymentServiceClientMock) Receive(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.Response[v1.ReceiveResponse], err error) {
	mm_atomic.AddUint64(&mmReceive.beforeReceiveCounter, 1)
	defer mm_atomic.AddUint64(&mmReceive.afterReceiveCounter, 1)

	mmReceive.t.Helper()

	if mmReceive.inspectFuncReceive != nil {
		mmReceive.inspectFuncReceive(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockReceiveParams{ctx, pp1}

	// Record call args
	mmReceive.ReceiveMock.mutex.Lock()
	mmReceive.ReceiveMock.callArgs = append(mmReceive.ReceiveMock.callArgs, &mm_params)
	mmReceive.ReceiveMock.mutex.Unlock()

	for _, e := range mmReceive.ReceiveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReceive.ReceiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceive.ReceiveMock.defaultExpectation.Counter, 1)
		mm_want := mmReceive.ReceiveMock.defaultExpectation.params
		mm_want_ptrs := mmReceive.ReceiveMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockReceiveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReceive.t.Errorf("PaymentServiceClientMock.Receive got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReceive.t.Errorf("PaymentServiceClientMock.Receive got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceive.t.Errorf("PaymentServiceClientMock.Receive got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReceive.ReceiveMock.defaultExpectation.results
		if mm_results == nil {
			mmReceive.t.Fatal("No results are set for the PaymentServiceClientMock.Receive")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReceive.funcReceive != nil {
		return mmReceive.funcReceive(ctx, pp1)
	}
	mmReceive.t.Fatalf("Unexpected call to PaymentServiceClientMock.Receive. %v %v", ctx, pp1)
	return
}

// ReceiveAfterCounter returns a count of finished PaymentServiceClientMock.Receive invocations
func (mmReceive *PaymentServiceClientMock) ReceiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.afterReceiveCounter)
}

// ReceiveBeforeCounter returns a count of PaymentServiceClientMock.Receive invocations
func (mmReceive *PaymentServiceClientMock) ReceiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.beforeReceiveCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.Receive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceive *mPaymentServiceClientMockReceive) Calls() []*PaymentServiceClientMockReceiveParams {
	mmReceive.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockReceiveParams, len(mmReceive.callArgs))
	copy(argCopy, mmReceive.callArgs)

	mmReceive.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveDone returns true if the count of the Receive invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockReceiveDone() bool {
	if m.ReceiveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReceiveMock.invocationsDone()
}

// MinimockReceiveInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockReceiveInspect() {
	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Receive at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReceiveCounter := mm_atomic.LoadUint64(&m.afterReceiveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveMock.defaultExpectation != nil && afterReceiveCounter < 1 {
		if m.ReceiveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Receive at\n%s", m.ReceiveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Receive at\n%s with params: %#v", m.ReceiveMock.defaultExpectation.expectationOrigins.origin, *m.ReceiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceive != nil && afterReceiveCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.Receive at\n%s", m.funcReceiveOrigin)
	}

	if !m.ReceiveMock.invocationsDone() && afterReceiveCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.Receive at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReceiveMock.expectedInvocations), m.ReceiveMock.expectedInvocationsOrigin, afterReceiveCounter)
	}
}

type mPaymentServiceClientMockReconcile struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockReconcileExpectation
	expectations       []*PaymentServiceClientMockReconcileExpectation

	callArgs []*PaymentServiceClientMockReconcileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockReconcileExpectation specifies expectation struct of the PaymentServiceClient.Reconcile
type PaymentServiceClientMockReconcileExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockReconcileParams
	paramPtrs          *PaymentServiceClientMockReconcileParamPtrs
	expectationOrigins PaymentServiceClientMockReconcileExpectationOrigins
	results            *PaymentServiceClientMockReconcileResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockReconcileParams contains parameters of the PaymentServiceClient.Reconcile
type PaymentServiceClientMockReconcileParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReconcileRequest]
}

// PaymentServiceClientMockReconcileParamPtrs contains pointers to parameters of the PaymentServiceClient.Reconcile
type PaymentServiceClientMockReconcileParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReconcileRequest]
}

// PaymentServiceClientMockReconcileResults contains results of the PaymentServiceClient.Reconcile
type PaymentServiceClientMockReconcileResults struct {
	pp2 *connect.Response[v1.ReconcileResponse]
	err error
}

// PaymentServiceClientMockReconcileOrigins contains origins of expectations of the PaymentServiceClient.Reconcile
type PaymentServiceClientMockReconcileExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReconcile *mPaymentServiceClientMockReconcile) Optional() *mPaymentServiceClientMockReconcile {
	mmReconcile.optional = true
	return mmReconcile
}

// Expect sets up expected params for PaymentServiceClient.Reconcile
func (mmReconcile *mPaymentServiceClientMockReconcile) Expect(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) *mPaymentServiceClientMockReconcile {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceClientMockReconcileExpectation{}
	}

	if mmReconcile.defaultExpectation.paramPtrs != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by ExpectParams functions")
	}

	mmReconcile.defaultExpectation.params = &PaymentServiceClientMockReconcileParams{ctx, pp1}
	mmReconcile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReconcile.expectations {
		if minimock.Equal(e.params, mmReconcile.defaultExpectation.params) {
			mmReconcile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReconcile.defaultExpectation.params)
		}
	}

	return mmReconcile
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.Reconcile
func (mmReconcile *mPaymentServiceClientMockReconcile) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockReconcile {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceClientMockReconcileExpectation{}
	}

	if mmReconcile.defaultExpectation.params != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Expect")
	}

	if mmReconcile.defaultExpectation.paramPtrs == nil {
		mmReconcile.defaultExpectation.paramPtrs = &PaymentServiceClientMockReconcileParamPtrs{}
	}
	mmReconcile.defaultExpectation.paramPtrs.ctx = &ctx
	mmReconcile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReconcile
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.Reconcile
func (mmReconcile *mPaymentServiceClientMockReconcile) ExpectPp1Param2(pp1 *connect.Request[v1.ReconcileRequest]) *mPaymentServiceClientMockReconcile {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceClientMockReconcileExpectation{}
	}

	if mmReconcile.defaultExpectation.params != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Expect")
	}

	if mmReconcile.defaultExpectation.paramPtrs == nil {
		mmReconcile.defaultExpectation.paramPtrs = &PaymentServiceClientMockReconcileParamPtrs{}
	}
	mmReconcile.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReconcile.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReconcile
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.Reconcile
func (mmReconcile *mPaymentServiceClientMockReconcile) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest])) *mPaymentServiceClientMockReconcile {
	if mmReconcile.mock.inspectFuncReconcile != nil {
		mmReconcile.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.Reconcile")
	}

	mmReconcile.mock.inspectFuncReconcile = f

	return mmReconcile
}

// Return sets up results that will be returned by PaymentServiceClient.Reconcile
func (mmReconcile *mPaymentServiceClientMockReconcile) Return(pp2 *connect.Response[v1.ReconcileResponse], err error) *PaymentServiceClientMock {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceClientMockReconcileExpectation{mock: mmReconcile.mock}
	}
	mmReconcile.defaultExpectation.results = &PaymentServiceClientMockReconcileResults{pp2, err}
	mmReconcile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReconcile.mock
}

// Set uses given function f to mock the PaymentServiceClient.Reconcile method
func (mmReconcile *mPaymentServiceClientMockReconcile) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) (pp2 *connect.Response[v1.ReconcileResponse], err error)) *PaymentServiceClientMock {
	if mmReconcile.defaultExpectation != nil {
		mmReconcile.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.Reconcile method")
	}

	if len(mmReconcile.expectations) > 0 {
		mmReconcile.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.Reconcile method")
	}

	mmReconcile.mock.funcReconcile = f
	mmReconcile.mock.funcReconcileOrigin = minimock.CallerInfo(1)
	return mmReconcile.mock
}

// When sets expectation for the PaymentServiceClient.Reconcile which will trigger the result defined by the following
// Then helper
func (mmReconcile *mPaymentServiceClientMockReconcile) When(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) *PaymentServiceClientMockReconcileExpectation {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceClientMock.Reconcile mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockReconcileExpectation{
		mock:               mmReconcile.mock,
		params:             &PaymentServiceClientMockReconcileParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockReconcileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReconcile.expectations = append(mmReconcile.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.Reconcile return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockReconcileExpectation) Then(pp2 *connect.Response[v1.ReconcileResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockReconcileResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.Reconcile should be invoked
func (mmReconcile *mPaymentServiceClientMockReconcile) Times(n uint64) *mPaymentServiceClientMockReconcile {
	if n == 0 {
		mmReconcile.mock.t.Fatalf("Times of PaymentServiceClientMock.Reconcile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReconcile.expectedInvocations, n)
	mmReconcile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReconcile
}

func (mmReconcile *mPaymentServiceClientMockReconcile) invocationsDone() bool {
	if len(mmReconcile.expectations) == 0 && mmReconcile.defaultExpectation == nil && mmReconcile.mock.funcReconcile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReconcile.mock.afterReconcileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReconcile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reconcile implements mm_paymentv1connect.PaymentServiceClient
func (mmReconcile *PaymentServiceClientMock) Reconcile(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) (pp2 *connect.Response[v1.ReconcileResponse], err error) {
	mm_atomic.AddUint64(&mmReconcile.beforeReconcileCounter, 1)
	defer mm_atomic.AddUint64(&mmReconcile.afterReconcileCounter, 1)

	mmReconcile.t.Helper()

	if mmReconcile.inspectFuncReconcile != nil {
		mmReconcile.inspectFuncReconcile(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockReconcileParams{ctx, pp1}

	// Record call args
	mmReconcile.ReconcileMock.mutex.Lock()
	mmReconcile.ReconcileMock.callArgs = append(mmReconcile.ReconcileMock.callArgs, &mm_params)
	mmReconcile.ReconcileMock.mutex.Unlock()

	for _, e := range mmReconcile.ReconcileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReconcile.ReconcileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReconcile.ReconcileMock.defaultExpectation.Counter, 1)
		mm_want := mmReconcile.ReconcileMock.defaultExpectation.params
		mm_want_ptrs := mmReconcile.ReconcileMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockReconcileParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReconcile.t.Errorf("PaymentServiceClientMock.Reconcile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReconcile.ReconcileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReconcile.t.Errorf("PaymentServiceClientMock.Reconcile got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReconcile.ReconcileMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReconcile.t.Errorf("PaymentServiceClientMock.Reconcile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReconcile.ReconcileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReconcile.ReconcileMock.defaultExpectation.results
		if mm_results == nil {
			mmReconcile.t.Fatal("No results are set for the PaymentServiceClientMock.Reconcile")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReconcile.funcReconcile != nil {
		return mmReconcile.funcReconcile(ctx, pp1)
	}
	mmReconcile.t.Fatalf("Unexpected call to PaymentServiceClientMock.Reconcile. %v %v", ctx, pp1)
	return
}

// ReconcileAfterCounter returns a count of finished PaymentServiceClientMock.Reconcile invocations
func (mmReconcile *PaymentServiceClientMock) ReconcileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReconcile.afterReconcileCounter)
}

// ReconcileBeforeCounter returns a count of PaymentServiceClientMock.Reconcile invocations
func (mmReconcile *PaymentServiceClientMock) ReconcileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReconcile.beforeReconcileCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.Reconcile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReconcile *mPaymentServiceClientMockReconcile) Calls() []*PaymentServiceClientMockReconcileParams {
	mmReconcile.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockReconcileParams, len(mmReconcile.callArgs))
	copy(argCopy, mmReconcile.callArgs)

	mmReconcile.mutex.RUnlock()

	return argCopy
}

// MinimockReconcileDone returns true if the count of the Reconcile invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockReconcileDone() bool {
	if m.ReconcileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReconcileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReconcileMock.invocationsDone()
}

// MinimockReconcileInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockReconcileInspect() {
	for _, e := range m.ReconcileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Reconcile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReconcileCounter := mm_atomic.LoadUint64(&m.afterReconcileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReconcileMock.defaultExpectation != nil && afterReconcileCounter < 1 {
		if m.ReconcileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Reconcile at\n%s", m.ReconcileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Reconcile at\n%s with params: %#v", m.ReconcileMock.defaultExpectation.expectationOrigins.origin, *m.ReconcileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReconcile != nil && afterReconcileCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.Reconcile at\n%s", m.funcReconcileOrigin)
	}

	if !m.ReconcileMock.invocationsDone() && afterReconcileCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.Reconcile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReconcileMock.expectedInvocations), m.ReconcileMock.expectedInvocationsOrigin, afterReconcileCounter)
	}
}

type mPaymentServiceClientMockRelease struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockReleaseExpectation
	expectations       []*PaymentServiceClientMockReleaseExpectation

	callArgs []*PaymentServiceClientMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockReleaseExpectation specifies expectation struct of the PaymentServiceClient.Release
type PaymentServiceClientMockReleaseExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockReleaseParams
	paramPtrs          *PaymentServiceClientMockReleaseParamPtrs
	expectationOrigins PaymentServiceClientMockReleaseExpectationOrigins
	results            *PaymentServiceClientMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockReleaseParams contains parameters of the PaymentServiceClient.Release
type PaymentServiceClientMockReleaseParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReleaseRequest]
}

// PaymentServiceClientMockReleaseParamPtrs contains pointers to parameters of the PaymentServiceClient.Release
type PaymentServiceClientMockReleaseParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReleaseRequest]
}

// PaymentServiceClientMockReleaseResults contains results of the PaymentServiceClient.Release
type PaymentServiceClientMockReleaseResults struct {
	pp2 *connect.Response[v1.ReleaseResponse]
	err error
}

// PaymentServiceClientMockReleaseOrigins contains origins of expectations of the PaymentServiceClient.Release
type PaymentServiceClientMockReleaseExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mPaymentServiceClientMockRelease) Optional() *mPaymentServiceClientMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for PaymentServiceClient.Release
func (mmRelease *mPaymentServiceClientMockRelease) Expect(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) *mPaymentServiceClientMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceClientMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &PaymentServiceClientMockReleaseParams{ctx, pp1}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.Release
func (mmRelease *mPaymentServiceClientMockRelease) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceClientMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &PaymentServiceClientMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.Release
func (mmRelease *mPaymentServiceClientMockRelease) ExpectPp1Param2(pp1 *connect.Request[v1.ReleaseRequest]) *mPaymentServiceClientMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceClientMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &PaymentServiceClientMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRelease.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.Release
func (mmRelease *mPaymentServiceClientMockRelease) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest])) *mPaymentServiceClientMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by PaymentServiceClient.Release
func (mmRelease *mPaymentServiceClientMockRelease) Return(pp2 *connect.Response[v1.ReleaseResponse], err error) *PaymentServiceClientMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceClientMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &PaymentServiceClientMockReleaseResults{pp2, err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the PaymentServiceClient.Release method
func (mmRelease *mPaymentServiceClientMockRelease) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.Response[v1.ReleaseResponse], err error)) *PaymentServiceClientMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the PaymentServiceClient.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mPaymentServiceClientMockRelease) When(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) *PaymentServiceClientMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceClientMock.Release mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &PaymentServiceClientMockReleaseParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.Release return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockReleaseExpectation) Then(pp2 *connect.Response[v1.ReleaseResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockReleaseResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.Release should be invoked
func (mmRelease *mPaymentServiceClientMockRelease) Times(n uint64) *mPaymentServiceClientMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of PaymentServiceClientMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mPaymentServiceClientMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_paymentv1connect.PaymentServiceClient
func (mmRelease *PaymentServiceClientMock) Release(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.Response[v1.ReleaseResponse], err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockReleaseParams{ctx, pp1}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockReleaseParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("PaymentServiceClientMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRelease.t.Errorf("PaymentServiceClientMock.Release got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("PaymentServiceClientMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the PaymentServiceClientMock.Release")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, pp1)
	}
	mmRelease.t.Fatalf("Unexpected call to PaymentServiceClientMock.Release. %v %v", ctx, pp1)
	return
}

// ReleaseAfterCounter returns a count of finished PaymentServiceClientMock.Release invocations
func (mmRelease *PaymentServiceClientMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of PaymentServiceClientMock.Release invocations
func (mmRelease *PaymentServiceClientMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mPaymentServiceClientMockRelease) Calls() []*PaymentServiceClientMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mPaymentServiceClientMockSearch struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockSearchExpectation
	expectations       []*PaymentServiceClientMockSearchExpectation

	callArgs []*PaymentServiceClientMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockSearchExpectation specifies expectation struct of the PaymentServiceClient.Search
type PaymentServiceClientMockSearchExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockSearchParams
	paramPtrs          *PaymentServiceClientMockSearchParamPtrs
	expectationOrigins PaymentServiceClientMockSearchExpectationOrigins
	results            *PaymentServiceClientMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockSearchParams contains parameters of the PaymentServiceClient.Search
type PaymentServiceClientMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// PaymentServiceClientMockSearchParamPtrs contains pointers to parameters of the PaymentServiceClient.Search
type PaymentServiceClientMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// PaymentServiceClientMockSearchResults contains results of the PaymentServiceClient.Search
type PaymentServiceClientMockSearchResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchResponse]
	err error
}

// PaymentServiceClientMockSearchOrigins contains origins of expectations of the PaymentServiceClient.Search
type PaymentServiceClientMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mPaymentServiceClientMockSearch) Optional() *mPaymentServiceClientMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for PaymentServiceClient.Search
func (mmSearch *mPaymentServiceClientMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mPaymentServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &PaymentServiceClientMockSearchParams{ctx, pp1}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.Search
func (mmSearch *mPaymentServiceClientMockSearch) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &PaymentServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.Search
func (mmSearch *mPaymentServiceClientMockSearch) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mPaymentServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &PaymentServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.Search
func (mmSearch *mPaymentServiceClientMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mPaymentServiceClientMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by PaymentServiceClient.Search
func (mmSearch *mPaymentServiceClientMockSearch) Return(pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) *PaymentServiceClientMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceClientMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &PaymentServiceClientMockSearchResults{pp2, err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the PaymentServiceClient.Search method
func (mmSearch *mPaymentServiceClientMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error)) *PaymentServiceClientMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the PaymentServiceClient.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mPaymentServiceClientMockSearch) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *PaymentServiceClientMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceClientMock.Search mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &PaymentServiceClientMockSearchParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.Search return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockSearchExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.Search should be invoked
func (mmSearch *mPaymentServiceClientMockSearch) Times(n uint64) *mPaymentServiceClientMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of PaymentServiceClientMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mPaymentServiceClientMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_paymentv1connect.PaymentServiceClient
func (mmSearch *PaymentServiceClientMock) Search(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockSearchParams{ctx, pp1}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("PaymentServiceClientMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("PaymentServiceClientMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("PaymentServiceClientMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the PaymentServiceClientMock.Search")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1)
	}
	mmSearch.t.Fatalf("Unexpected call to PaymentServiceClientMock.Search. %v %v", ctx, pp1)
	return
}

// SearchAfterCounter returns a count of finished PaymentServiceClientMock.Search invocations
func (mmSearch *PaymentServiceClientMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of PaymentServiceClientMock.Search invocations
func (mmSearch *PaymentServiceClientMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mPaymentServiceClientMockSearch) Calls() []*PaymentServiceClientMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

type mPaymentServiceClientMockSend struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockSendExpectation
	expectations       []*PaymentServiceClientMockSendExpectation

	callArgs []*PaymentServiceClientMockSendParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockSendExpectation specifies expectation struct of the PaymentServiceClient.Send
type PaymentServiceClientMockSendExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockSendParams
	paramPtrs          *PaymentServiceClientMockSendParamPtrs
	expectationOrigins PaymentServiceClientMockSendExpectationOrigins
	results            *PaymentServiceClientMockSendResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockSendParams contains parameters of the PaymentServiceClient.Send
type PaymentServiceClientMockSendParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SendRequest]
}

// PaymentServiceClientMockSendParamPtrs contains pointers to parameters of the PaymentServiceClient.Send
type PaymentServiceClientMockSendParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SendRequest]
}

// PaymentServiceClientMockSendResults contains results of the PaymentServiceClient.Send
type PaymentServiceClientMockSendResults struct {
	pp2 *connect.Response[v1.SendResponse]
	err error
}

// PaymentServiceClientMockSendOrigins contains origins of expectations of the PaymentServiceClient.Send
type PaymentServiceClientMockSendExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSend *mPaymentServiceClientMockSend) Optional() *mPaymentServiceClientMockSend {
	mmSend.optional = true
	return mmSend
}

// Expect sets up expected params for PaymentServiceClient.Send
func (mmSend *mPaymentServiceClientMockSend) Expect(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) *mPaymentServiceClientMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceClientMockSendExpectation{}
	}

	if mmSend.defaultExpectation.paramPtrs != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by ExpectParams functions")
	}

	mmSend.defaultExpectation.params = &PaymentServiceClientMockSendParams{ctx, pp1}
	mmSend.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.Send
func (mmSend *mPaymentServiceClientMockSend) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceClientMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &PaymentServiceClientMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.ctx = &ctx
	mmSend.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSend
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.Send
func (mmSend *mPaymentServiceClientMockSend) ExpectPp1Param2(pp1 *connect.Request[v1.SendRequest]) *mPaymentServiceClientMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceClientMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &PaymentServiceClientMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSend.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.Send
func (mmSend *mPaymentServiceClientMockSend) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest])) *mPaymentServiceClientMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by PaymentServiceClient.Send
func (mmSend *mPaymentServiceClientMockSend) Return(pp2 *connect.Response[v1.SendResponse], err error) *PaymentServiceClientMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceClientMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &PaymentServiceClientMockSendResults{pp2, err}
	mmSend.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// Set uses given function f to mock the PaymentServiceClient.Send method
func (mmSend *mPaymentServiceClientMockSend) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.Response[v1.SendResponse], err error)) *PaymentServiceClientMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.Send method")
	}

	mmSend.mock.funcSend = f
	mmSend.mock.funcSendOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// When sets expectation for the PaymentServiceClient.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mPaymentServiceClientMockSend) When(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) *PaymentServiceClientMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceClientMock.Send mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockSendExpectation{
		mock:               mmSend.mock,
		params:             &PaymentServiceClientMockSendParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockSendExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.Send return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockSendExpectation) Then(pp2 *connect.Response[v1.SendResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockSendResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.Send should be invoked
func (mmSend *mPaymentServiceClientMockSend) Times(n uint64) *mPaymentServiceClientMockSend {
	if n == 0 {
		mmSend.mock.t.Fatalf("Times of PaymentServiceClientMock.Send mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSend.expectedInvocations, n)
	mmSend.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSend
}

func (mmSend *mPaymentServiceClientMockSend) invocationsDone() bool {
	if len(mmSend.expectations) == 0 && mmSend.defaultExpectation == nil && mmSend.mock.funcSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSend.mock.afterSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Send implements mm_paymentv1connect.PaymentServiceClient
func (mmSend *PaymentServiceClientMock) Send(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.Response[v1.SendResponse], err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	mmSend.t.Helper()

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockSendParams{ctx, pp1}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, &mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_want_ptrs := mmSend.SendMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockSendParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSend.t.Errorf("PaymentServiceClientMock.Send got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSend.t.Errorf("PaymentServiceClientMock.Send got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("PaymentServiceClientMock.Send got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSend.SendMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the PaymentServiceClientMock.Send")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(ctx, pp1)
	}
	mmSend.t.Fatalf("Unexpected call to PaymentServiceClientMock.Send. %v %v", ctx, pp1)
	return
}

// SendAfterCounter returns a count of finished PaymentServiceClientMock.Send invocations
func (mmSend *PaymentServiceClientMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of PaymentServiceClientMock.Send invocations
func (mmSend *PaymentServiceClientMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mPaymentServiceClientMockSend) Calls() []*PaymentServiceClientMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockSendDone() bool {
	if m.SendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMock.invocationsDone()
}

// MinimockSendInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Send at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCounter := mm_atomic.LoadUint64(&m.afterSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && afterSendCounter < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Send at\n%s", m.SendMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Send at\n%s with params: %#v", m.SendMock.defaultExpectation.expectationOrigins.origin, *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && afterSendCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.Send at\n%s", m.funcSendOrigin)
	}

	if !m.SendMock.invocationsDone() && afterSendCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.Send at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMock.expectedInvocations), m.SendMock.expectedInvocationsOrigin, afterSendCounter)
	}
}

type mPaymentServiceClientMockStatus struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockStatusExpectation
	expectations       []*PaymentServiceClientMockStatusExpectation

	callArgs []*PaymentServiceClientMockStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockStatusExpectation specifies expectation struct of the PaymentServiceClient.Status
type PaymentServiceClientMockStatusExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockStatusParams
	paramPtrs          *PaymentServiceClientMockStatusParamPtrs
	expectationOrigins PaymentServiceClientMockStatusExpectationOrigins
	results            *PaymentServiceClientMockStatusResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockStatusParams contains parameters of the PaymentServiceClient.Status
type PaymentServiceClientMockStatusParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusRequest]
}

// PaymentServiceClientMockStatusParamPtrs contains pointers to parameters of the PaymentServiceClient.Status
type PaymentServiceClientMockStatusParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusRequest]
}

// PaymentServiceClientMockStatusResults contains results of the PaymentServiceClient.Status
type PaymentServiceClientMockStatusResults struct {
	pp2 *connect.Response[v11.StatusResponse]
	err error
}

// PaymentServiceClientMockStatusOrigins contains origins of expectations of the PaymentServiceClient.Status
type PaymentServiceClientMockStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatus *mPaymentServiceClientMockStatus) Optional() *mPaymentServiceClientMockStatus {
	mmStatus.optional = true
	return mmStatus
}

// Expect sets up expected params for PaymentServiceClient.Status
func (mmStatus *mPaymentServiceClientMockStatus) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *mPaymentServiceClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceClientMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.paramPtrs != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by ExpectParams functions")
	}

	mmStatus.defaultExpectation.params = &PaymentServiceClientMockStatusParams{ctx, pp1}
	mmStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatus.expectations {
		if minimock.Equal(e.params, mmStatus.defaultExpectation.params) {
			mmStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatus.defaultExpectation.params)
		}
	}

	return mmStatus
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.Status
func (mmStatus *mPaymentServiceClientMockStatus) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceClientMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &PaymentServiceClientMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatus
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.Status
func (mmStatus *mPaymentServiceClientMockStatus) ExpectPp1Param2(pp1 *connect.Request[v11.StatusRequest]) *mPaymentServiceClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceClientMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &PaymentServiceClientMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatus.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatus
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.Status
func (mmStatus *mPaymentServiceClientMockStatus) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])) *mPaymentServiceClientMockStatus {
	if mmStatus.mock.inspectFuncStatus != nil {
		mmStatus.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.Status")
	}

	mmStatus.mock.inspectFuncStatus = f

	return mmStatus
}

// Return sets up results that will be returned by PaymentServiceClient.Status
func (mmStatus *mPaymentServiceClientMockStatus) Return(pp2 *connect.Response[v11.StatusResponse], err error) *PaymentServiceClientMock {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceClientMockStatusExpectation{mock: mmStatus.mock}
	}
	mmStatus.defaultExpectation.results = &PaymentServiceClientMockStatusResults{pp2, err}
	mmStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// Set uses given function f to mock the PaymentServiceClient.Status method
func (mmStatus *mPaymentServiceClientMockStatus) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)) *PaymentServiceClientMock {
	if mmStatus.defaultExpectation != nil {
		mmStatus.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.Status method")
	}

	if len(mmStatus.expectations) > 0 {
		mmStatus.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.Status method")
	}

	mmStatus.mock.funcStatus = f
	mmStatus.mock.funcStatusOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// When sets expectation for the PaymentServiceClient.Status which will trigger the result defined by the following
// Then helper
func (mmStatus *mPaymentServiceClientMockStatus) When(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *PaymentServiceClientMockStatusExpectation {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceClientMock.Status mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockStatusExpectation{
		mock:               mmStatus.mock,
		params:             &PaymentServiceClientMockStatusParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatus.expectations = append(mmStatus.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.Status return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockStatusExpectation) Then(pp2 *connect.Response[v11.StatusResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockStatusResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.Status should be invoked
func (mmStatus *mPaymentServiceClientMockStatus) Times(n uint64) *mPaymentServiceClientMockStatus {
	if n == 0 {
		mmStatus.mock.t.Fatalf("Times of PaymentServiceClientMock.Status mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatus.expectedInvocations, n)
	mmStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatus
}

func (mmStatus *mPaymentServiceClientMockStatus) invocationsDone() bool {
	if len(mmStatus.expectations) == 0 && mmStatus.defaultExpectation == nil && mmStatus.mock.funcStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatus.mock.afterStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Status implements mm_paymentv1connect.PaymentServiceClient
func (mmStatus *PaymentServiceClientMock) Status(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error) {
	mm_atomic.AddUint64(&mmStatus.beforeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmStatus.afterStatusCounter, 1)

	mmStatus.t.Helper()

	if mmStatus.inspectFuncStatus != nil {
		mmStatus.inspectFuncStatus(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockStatusParams{ctx, pp1}

	// Record call args
	mmStatus.StatusMock.mutex.Lock()
	mmStatus.StatusMock.callArgs = append(mmStatus.StatusMock.callArgs, &mm_params)
	mmStatus.StatusMock.mutex.Unlock()

	for _, e := range mmStatus.StatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatus.StatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatus.StatusMock.defaultExpectation.Counter, 1)
		mm_want := mmStatus.StatusMock.defaultExpectation.params
		mm_want_ptrs := mmStatus.StatusMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockStatusParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatus.t.Errorf("PaymentServiceClientMock.Status got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatus.t.Errorf("PaymentServiceClientMock.Status got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatus.t.Errorf("PaymentServiceClientMock.Status got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatus.StatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatus.StatusMock.defaultExpectation.results
		if mm_results == nil {
			mmStatus.t.Fatal("No results are set for the PaymentServiceClientMock.Status")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatus.funcStatus != nil {
		return mmStatus.funcStatus(ctx, pp1)
	}
	mmStatus.t.Fatalf("Unexpected call to PaymentServiceClientMock.Status. %v %v", ctx, pp1)
	return
}

// StatusAfterCounter returns a count of finished PaymentServiceClientMock.Status invocations
func (mmStatus *PaymentServiceClientMock) StatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.afterStatusCounter)
}

// StatusBeforeCounter returns a count of PaymentServiceClientMock.Status invocations
func (mmStatus *PaymentServiceClientMock) StatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.beforeStatusCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.Status.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatus *mPaymentServiceClientMockStatus) Calls() []*PaymentServiceClientMockStatusParams {
	mmStatus.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockStatusParams, len(mmStatus.callArgs))
	copy(argCopy, mmStatus.callArgs)

	mmStatus.mutex.RUnlock()

	return argCopy
}

// MinimockStatusDone returns true if the count of the Status invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockStatusDone() bool {
	if m.StatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusMock.invocationsDone()
}

// MinimockStatusInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockStatusInspect() {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Status at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusCounter := mm_atomic.LoadUint64(&m.afterStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && afterStatusCounter < 1 {
		if m.StatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Status at\n%s", m.StatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.Status at\n%s with params: %#v", m.StatusMock.defaultExpectation.expectationOrigins.origin, *m.StatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && afterStatusCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.Status at\n%s", m.funcStatusOrigin)
	}

	if !m.StatusMock.invocationsDone() && afterStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.Status at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusMock.expectedInvocations), m.StatusMock.expectedInvocationsOrigin, afterStatusCounter)
	}
}

type mPaymentServiceClientMockStatusUpdate struct {
	optional           bool
	mock               *PaymentServiceClientMock
	defaultExpectation *PaymentServiceClientMockStatusUpdateExpectation
	expectations       []*PaymentServiceClientMockStatusUpdateExpectation

	callArgs []*PaymentServiceClientMockStatusUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceClientMockStatusUpdateExpectation specifies expectation struct of the PaymentServiceClient.StatusUpdate
type PaymentServiceClientMockStatusUpdateExpectation struct {
	mock               *PaymentServiceClientMock
	params             *PaymentServiceClientMockStatusUpdateParams
	paramPtrs          *PaymentServiceClientMockStatusUpdateParamPtrs
	expectationOrigins PaymentServiceClientMockStatusUpdateExpectationOrigins
	results            *PaymentServiceClientMockStatusUpdateResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceClientMockStatusUpdateParams contains parameters of the PaymentServiceClient.StatusUpdate
type PaymentServiceClientMockStatusUpdateParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusUpdateRequest]
}

// PaymentServiceClientMockStatusUpdateParamPtrs contains pointers to parameters of the PaymentServiceClient.StatusUpdate
type PaymentServiceClientMockStatusUpdateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusUpdateRequest]
}

// PaymentServiceClientMockStatusUpdateResults contains results of the PaymentServiceClient.StatusUpdate
type PaymentServiceClientMockStatusUpdateResults struct {
	pp2 *connect.Response[v11.StatusUpdateResponse]
	err error
}

// PaymentServiceClientMockStatusUpdateOrigins contains origins of expectations of the PaymentServiceClient.StatusUpdate
type PaymentServiceClientMockStatusUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Optional() *mPaymentServiceClientMockStatusUpdate {
	mmStatusUpdate.optional = true
	return mmStatusUpdate
}

// Expect sets up expected params for PaymentServiceClient.StatusUpdate
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *mPaymentServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceClientMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by ExpectParams functions")
	}

	mmStatusUpdate.defaultExpectation.params = &PaymentServiceClientMockStatusUpdateParams{ctx, pp1}
	mmStatusUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatusUpdate.expectations {
		if minimock.Equal(e.params, mmStatusUpdate.defaultExpectation.params) {
			mmStatusUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatusUpdate.defaultExpectation.params)
		}
	}

	return mmStatusUpdate
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceClient.StatusUpdate
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) ExpectCtxParam1(ctx context.Context) *mPaymentServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceClientMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &PaymentServiceClientMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatusUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceClient.StatusUpdate
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) ExpectPp1Param2(pp1 *connect.Request[v11.StatusUpdateRequest]) *mPaymentServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceClientMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &PaymentServiceClientMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatusUpdate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceClient.StatusUpdate
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])) *mPaymentServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("Inspect function is already set for PaymentServiceClientMock.StatusUpdate")
	}

	mmStatusUpdate.mock.inspectFuncStatusUpdate = f

	return mmStatusUpdate
}

// Return sets up results that will be returned by PaymentServiceClient.StatusUpdate
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Return(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *PaymentServiceClientMock {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceClientMockStatusUpdateExpectation{mock: mmStatusUpdate.mock}
	}
	mmStatusUpdate.defaultExpectation.results = &PaymentServiceClientMockStatusUpdateResults{pp2, err}
	mmStatusUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// Set uses given function f to mock the PaymentServiceClient.StatusUpdate method
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)) *PaymentServiceClientMock {
	if mmStatusUpdate.defaultExpectation != nil {
		mmStatusUpdate.mock.t.Fatalf("Default expectation is already set for the PaymentServiceClient.StatusUpdate method")
	}

	if len(mmStatusUpdate.expectations) > 0 {
		mmStatusUpdate.mock.t.Fatalf("Some expectations are already set for the PaymentServiceClient.StatusUpdate method")
	}

	mmStatusUpdate.mock.funcStatusUpdate = f
	mmStatusUpdate.mock.funcStatusUpdateOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// When sets expectation for the PaymentServiceClient.StatusUpdate which will trigger the result defined by the following
// Then helper
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) When(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *PaymentServiceClientMockStatusUpdateExpectation {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceClientMock.StatusUpdate mock is already set by Set")
	}

	expectation := &PaymentServiceClientMockStatusUpdateExpectation{
		mock:               mmStatusUpdate.mock,
		params:             &PaymentServiceClientMockStatusUpdateParams{ctx, pp1},
		expectationOrigins: PaymentServiceClientMockStatusUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatusUpdate.expectations = append(mmStatusUpdate.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceClient.StatusUpdate return parameters for the expectation previously defined by the When method
func (e *PaymentServiceClientMockStatusUpdateExpectation) Then(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *PaymentServiceClientMock {
	e.results = &PaymentServiceClientMockStatusUpdateResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceClient.StatusUpdate should be invoked
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Times(n uint64) *mPaymentServiceClientMockStatusUpdate {
	if n == 0 {
		mmStatusUpdate.mock.t.Fatalf("Times of PaymentServiceClientMock.StatusUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatusUpdate.expectedInvocations, n)
	mmStatusUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate
}

func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) invocationsDone() bool {
	if len(mmStatusUpdate.expectations) == 0 && mmStatusUpdate.defaultExpectation == nil && mmStatusUpdate.mock.funcStatusUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.mock.afterStatusUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StatusUpdate implements mm_paymentv1connect.PaymentServiceClient
func (mmStatusUpdate *PaymentServiceClientMock) StatusUpdate(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error) {
	mm_atomic.AddUint64(&mmStatusUpdate.beforeStatusUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmStatusUpdate.afterStatusUpdateCounter, 1)

	mmStatusUpdate.t.Helper()

	if mmStatusUpdate.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.inspectFuncStatusUpdate(ctx, pp1)
	}

	mm_params := PaymentServiceClientMockStatusUpdateParams{ctx, pp1}

	// Record call args
	mmStatusUpdate.StatusUpdateMock.mutex.Lock()
	mmStatusUpdate.StatusUpdateMock.callArgs = append(mmStatusUpdate.StatusUpdateMock.callArgs, &mm_params)
	mmStatusUpdate.StatusUpdateMock.mutex.Unlock()

	for _, e := range mmStatusUpdate.StatusUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatusUpdate.StatusUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatusUpdate.StatusUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmStatusUpdate.StatusUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmStatusUpdate.StatusUpdateMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceClientMockStatusUpdateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatusUpdate.t.Errorf("PaymentServiceClientMock.StatusUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatusUpdate.t.Errorf("PaymentServiceClientMock.StatusUpdate got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatusUpdate.t.Errorf("PaymentServiceClientMock.StatusUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatusUpdate.StatusUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmStatusUpdate.t.Fatal("No results are set for the PaymentServiceClientMock.StatusUpdate")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatusUpdate.funcStatusUpdate != nil {
		return mmStatusUpdate.funcStatusUpdate(ctx, pp1)
	}
	mmStatusUpdate.t.Fatalf("Unexpected call to PaymentServiceClientMock.StatusUpdate. %v %v", ctx, pp1)
	return
}

// StatusUpdateAfterCounter returns a count of finished PaymentServiceClientMock.StatusUpdate invocations
func (mmStatusUpdate *PaymentServiceClientMock) StatusUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.afterStatusUpdateCounter)
}

// StatusUpdateBeforeCounter returns a count of PaymentServiceClientMock.StatusUpdate invocations
func (mmStatusUpdate *PaymentServiceClientMock) StatusUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.beforeStatusUpdateCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceClientMock.StatusUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatusUpdate *mPaymentServiceClientMockStatusUpdate) Calls() []*PaymentServiceClientMockStatusUpdateParams {
	mmStatusUpdate.mutex.RLock()

	argCopy := make([]*PaymentServiceClientMockStatusUpdateParams, len(mmStatusUpdate.callArgs))
	copy(argCopy, mmStatusUpdate.callArgs)

	mmStatusUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockStatusUpdateDone returns true if the count of the StatusUpdate invocations corresponds
// the number of defined expectations
func (m *PaymentServiceClientMock) MinimockStatusUpdateDone() bool {
	if m.StatusUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusUpdateMock.invocationsDone()
}

// MinimockStatusUpdateInspect logs each unmet expectation
func (m *PaymentServiceClientMock) MinimockStatusUpdateInspect() {
	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceClientMock.StatusUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusUpdateCounter := mm_atomic.LoadUint64(&m.afterStatusUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusUpdateMock.defaultExpectation != nil && afterStatusUpdateCounter < 1 {
		if m.StatusUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceClientMock.StatusUpdate at\n%s", m.StatusUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceClientMock.StatusUpdate at\n%s with params: %#v", m.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *m.StatusUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatusUpdate != nil && afterStatusUpdateCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceClientMock.StatusUpdate at\n%s", m.funcStatusUpdateOrigin)
	}

	if !m.StatusUpdateMock.invocationsDone() && afterStatusUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceClientMock.StatusUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusUpdateMock.expectedInvocations), m.StatusUpdateMock.expectedInvocationsOrigin, afterStatusUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PaymentServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePaymentLinkInspect()

			m.MinimockInitiatePromptInspect()

			m.MinimockReceiveInspect()

			m.MinimockReconcileInspect()

			m.MinimockReleaseInspect()

			m.MinimockSearchInspect()

			m.MinimockSendInspect()

			m.MinimockStatusInspect()

			m.MinimockStatusUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PaymentServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PaymentServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePaymentLinkDone() &&
		m.MinimockInitiatePromptDone() &&
		m.MinimockReceiveDone() &&
		m.MinimockReconcileDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockSearchDone() &&
		m.MinimockSendDone() &&
		m.MinimockStatusDone() &&
		m.MinimockStatusUpdateDone()
}
