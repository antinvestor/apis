// Copyright 2023-2024 Ant Investor Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/payment/connectrpc/go/payment/v1/paymentv1connect.PaymentServiceHandler -o payment_handler.gen.go -n PaymentServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v1 "buf.build/gen/go/antinvestor/payment/protocolbuffers/go/payment/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// PaymentServiceHandlerMock implements mm_paymentv1connect.PaymentServiceHandler
type PaymentServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePaymentLink          func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) (pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error)
	funcCreatePaymentLinkOrigin    string
	inspectFuncCreatePaymentLink   func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest])
	afterCreatePaymentLinkCounter  uint64
	beforeCreatePaymentLinkCounter uint64
	CreatePaymentLinkMock          mPaymentServiceHandlerMockCreatePaymentLink

	funcInitiatePrompt          func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) (pp2 *connect.Response[v1.InitiatePromptResponse], err error)
	funcInitiatePromptOrigin    string
	inspectFuncInitiatePrompt   func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest])
	afterInitiatePromptCounter  uint64
	beforeInitiatePromptCounter uint64
	InitiatePromptMock          mPaymentServiceHandlerMockInitiatePrompt

	funcReceive          func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.Response[v1.ReceiveResponse], err error)
	funcReceiveOrigin    string
	inspectFuncReceive   func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest])
	afterReceiveCounter  uint64
	beforeReceiveCounter uint64
	ReceiveMock          mPaymentServiceHandlerMockReceive

	funcReconcile          func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) (pp2 *connect.Response[v1.ReconcileResponse], err error)
	funcReconcileOrigin    string
	inspectFuncReconcile   func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest])
	afterReconcileCounter  uint64
	beforeReconcileCounter uint64
	ReconcileMock          mPaymentServiceHandlerMockReconcile

	funcRelease          func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.Response[v1.ReleaseResponse], err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest])
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mPaymentServiceHandlerMockRelease

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mPaymentServiceHandlerMockSearch

	funcSend          func(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.Response[v1.SendResponse], err error)
	funcSendOrigin    string
	inspectFuncSend   func(ctx context.Context, pp1 *connect.Request[v1.SendRequest])
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mPaymentServiceHandlerMockSend

	funcStatus          func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)
	funcStatusOrigin    string
	inspectFuncStatus   func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])
	afterStatusCounter  uint64
	beforeStatusCounter uint64
	StatusMock          mPaymentServiceHandlerMockStatus

	funcStatusUpdate          func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)
	funcStatusUpdateOrigin    string
	inspectFuncStatusUpdate   func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])
	afterStatusUpdateCounter  uint64
	beforeStatusUpdateCounter uint64
	StatusUpdateMock          mPaymentServiceHandlerMockStatusUpdate
}

// NewPaymentServiceHandlerMock returns a mock for mm_paymentv1connect.PaymentServiceHandler
func NewPaymentServiceHandlerMock(t minimock.Tester) *PaymentServiceHandlerMock {
	m := &PaymentServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePaymentLinkMock = mPaymentServiceHandlerMockCreatePaymentLink{mock: m}
	m.CreatePaymentLinkMock.callArgs = []*PaymentServiceHandlerMockCreatePaymentLinkParams{}

	m.InitiatePromptMock = mPaymentServiceHandlerMockInitiatePrompt{mock: m}
	m.InitiatePromptMock.callArgs = []*PaymentServiceHandlerMockInitiatePromptParams{}

	m.ReceiveMock = mPaymentServiceHandlerMockReceive{mock: m}
	m.ReceiveMock.callArgs = []*PaymentServiceHandlerMockReceiveParams{}

	m.ReconcileMock = mPaymentServiceHandlerMockReconcile{mock: m}
	m.ReconcileMock.callArgs = []*PaymentServiceHandlerMockReconcileParams{}

	m.ReleaseMock = mPaymentServiceHandlerMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*PaymentServiceHandlerMockReleaseParams{}

	m.SearchMock = mPaymentServiceHandlerMockSearch{mock: m}
	m.SearchMock.callArgs = []*PaymentServiceHandlerMockSearchParams{}

	m.SendMock = mPaymentServiceHandlerMockSend{mock: m}
	m.SendMock.callArgs = []*PaymentServiceHandlerMockSendParams{}

	m.StatusMock = mPaymentServiceHandlerMockStatus{mock: m}
	m.StatusMock.callArgs = []*PaymentServiceHandlerMockStatusParams{}

	m.StatusUpdateMock = mPaymentServiceHandlerMockStatusUpdate{mock: m}
	m.StatusUpdateMock.callArgs = []*PaymentServiceHandlerMockStatusUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPaymentServiceHandlerMockCreatePaymentLink struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockCreatePaymentLinkExpectation
	expectations       []*PaymentServiceHandlerMockCreatePaymentLinkExpectation

	callArgs []*PaymentServiceHandlerMockCreatePaymentLinkParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockCreatePaymentLinkExpectation specifies expectation struct of the PaymentServiceHandler.CreatePaymentLink
type PaymentServiceHandlerMockCreatePaymentLinkExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockCreatePaymentLinkParams
	paramPtrs          *PaymentServiceHandlerMockCreatePaymentLinkParamPtrs
	expectationOrigins PaymentServiceHandlerMockCreatePaymentLinkExpectationOrigins
	results            *PaymentServiceHandlerMockCreatePaymentLinkResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockCreatePaymentLinkParams contains parameters of the PaymentServiceHandler.CreatePaymentLink
type PaymentServiceHandlerMockCreatePaymentLinkParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePaymentLinkRequest]
}

// PaymentServiceHandlerMockCreatePaymentLinkParamPtrs contains pointers to parameters of the PaymentServiceHandler.CreatePaymentLink
type PaymentServiceHandlerMockCreatePaymentLinkParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePaymentLinkRequest]
}

// PaymentServiceHandlerMockCreatePaymentLinkResults contains results of the PaymentServiceHandler.CreatePaymentLink
type PaymentServiceHandlerMockCreatePaymentLinkResults struct {
	pp2 *connect.Response[v1.CreatePaymentLinkResponse]
	err error
}

// PaymentServiceHandlerMockCreatePaymentLinkOrigins contains origins of expectations of the PaymentServiceHandler.CreatePaymentLink
type PaymentServiceHandlerMockCreatePaymentLinkExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Optional() *mPaymentServiceHandlerMockCreatePaymentLink {
	mmCreatePaymentLink.optional = true
	return mmCreatePaymentLink
}

// Expect sets up expected params for PaymentServiceHandler.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) *mPaymentServiceHandlerMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceHandlerMockCreatePaymentLinkExpectation{}
	}

	if mmCreatePaymentLink.defaultExpectation.paramPtrs != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by ExpectParams functions")
	}

	mmCreatePaymentLink.defaultExpectation.params = &PaymentServiceHandlerMockCreatePaymentLinkParams{ctx, pp1}
	mmCreatePaymentLink.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePaymentLink.expectations {
		if minimock.Equal(e.params, mmCreatePaymentLink.defaultExpectation.params) {
			mmCreatePaymentLink.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePaymentLink.defaultExpectation.params)
		}
	}

	return mmCreatePaymentLink
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceHandlerMockCreatePaymentLinkExpectation{}
	}

	if mmCreatePaymentLink.defaultExpectation.params != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Expect")
	}

	if mmCreatePaymentLink.defaultExpectation.paramPtrs == nil {
		mmCreatePaymentLink.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockCreatePaymentLinkParamPtrs{}
	}
	mmCreatePaymentLink.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePaymentLink.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePaymentLink
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePaymentLinkRequest]) *mPaymentServiceHandlerMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceHandlerMockCreatePaymentLinkExpectation{}
	}

	if mmCreatePaymentLink.defaultExpectation.params != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Expect")
	}

	if mmCreatePaymentLink.defaultExpectation.paramPtrs == nil {
		mmCreatePaymentLink.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockCreatePaymentLinkParamPtrs{}
	}
	mmCreatePaymentLink.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePaymentLink.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePaymentLink
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest])) *mPaymentServiceHandlerMockCreatePaymentLink {
	if mmCreatePaymentLink.mock.inspectFuncCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.CreatePaymentLink")
	}

	mmCreatePaymentLink.mock.inspectFuncCreatePaymentLink = f

	return mmCreatePaymentLink
}

// Return sets up results that will be returned by PaymentServiceHandler.CreatePaymentLink
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Return(pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error) *PaymentServiceHandlerMock {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Set")
	}

	if mmCreatePaymentLink.defaultExpectation == nil {
		mmCreatePaymentLink.defaultExpectation = &PaymentServiceHandlerMockCreatePaymentLinkExpectation{mock: mmCreatePaymentLink.mock}
	}
	mmCreatePaymentLink.defaultExpectation.results = &PaymentServiceHandlerMockCreatePaymentLinkResults{pp2, err}
	mmCreatePaymentLink.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePaymentLink.mock
}

// Set uses given function f to mock the PaymentServiceHandler.CreatePaymentLink method
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) (pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error)) *PaymentServiceHandlerMock {
	if mmCreatePaymentLink.defaultExpectation != nil {
		mmCreatePaymentLink.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.CreatePaymentLink method")
	}

	if len(mmCreatePaymentLink.expectations) > 0 {
		mmCreatePaymentLink.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.CreatePaymentLink method")
	}

	mmCreatePaymentLink.mock.funcCreatePaymentLink = f
	mmCreatePaymentLink.mock.funcCreatePaymentLinkOrigin = minimock.CallerInfo(1)
	return mmCreatePaymentLink.mock
}

// When sets expectation for the PaymentServiceHandler.CreatePaymentLink which will trigger the result defined by the following
// Then helper
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) When(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) *PaymentServiceHandlerMockCreatePaymentLinkExpectation {
	if mmCreatePaymentLink.mock.funcCreatePaymentLink != nil {
		mmCreatePaymentLink.mock.t.Fatalf("PaymentServiceHandlerMock.CreatePaymentLink mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockCreatePaymentLinkExpectation{
		mock:               mmCreatePaymentLink.mock,
		params:             &PaymentServiceHandlerMockCreatePaymentLinkParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockCreatePaymentLinkExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePaymentLink.expectations = append(mmCreatePaymentLink.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.CreatePaymentLink return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockCreatePaymentLinkExpectation) Then(pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockCreatePaymentLinkResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.CreatePaymentLink should be invoked
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Times(n uint64) *mPaymentServiceHandlerMockCreatePaymentLink {
	if n == 0 {
		mmCreatePaymentLink.mock.t.Fatalf("Times of PaymentServiceHandlerMock.CreatePaymentLink mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePaymentLink.expectedInvocations, n)
	mmCreatePaymentLink.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePaymentLink
}

func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) invocationsDone() bool {
	if len(mmCreatePaymentLink.expectations) == 0 && mmCreatePaymentLink.defaultExpectation == nil && mmCreatePaymentLink.mock.funcCreatePaymentLink == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePaymentLink.mock.afterCreatePaymentLinkCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePaymentLink.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePaymentLink implements mm_paymentv1connect.PaymentServiceHandler
func (mmCreatePaymentLink *PaymentServiceHandlerMock) CreatePaymentLink(ctx context.Context, pp1 *connect.Request[v1.CreatePaymentLinkRequest]) (pp2 *connect.Response[v1.CreatePaymentLinkResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePaymentLink.beforeCreatePaymentLinkCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePaymentLink.afterCreatePaymentLinkCounter, 1)

	mmCreatePaymentLink.t.Helper()

	if mmCreatePaymentLink.inspectFuncCreatePaymentLink != nil {
		mmCreatePaymentLink.inspectFuncCreatePaymentLink(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockCreatePaymentLinkParams{ctx, pp1}

	// Record call args
	mmCreatePaymentLink.CreatePaymentLinkMock.mutex.Lock()
	mmCreatePaymentLink.CreatePaymentLinkMock.callArgs = append(mmCreatePaymentLink.CreatePaymentLinkMock.callArgs, &mm_params)
	mmCreatePaymentLink.CreatePaymentLinkMock.mutex.Unlock()

	for _, e := range mmCreatePaymentLink.CreatePaymentLinkMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockCreatePaymentLinkParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePaymentLink.t.Errorf("PaymentServiceHandlerMock.CreatePaymentLink got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePaymentLink.t.Errorf("PaymentServiceHandlerMock.CreatePaymentLink got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePaymentLink.t.Errorf("PaymentServiceHandlerMock.CreatePaymentLink got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePaymentLink.CreatePaymentLinkMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePaymentLink.t.Fatal("No results are set for the PaymentServiceHandlerMock.CreatePaymentLink")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePaymentLink.funcCreatePaymentLink != nil {
		return mmCreatePaymentLink.funcCreatePaymentLink(ctx, pp1)
	}
	mmCreatePaymentLink.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.CreatePaymentLink. %v %v", ctx, pp1)
	return
}

// CreatePaymentLinkAfterCounter returns a count of finished PaymentServiceHandlerMock.CreatePaymentLink invocations
func (mmCreatePaymentLink *PaymentServiceHandlerMock) CreatePaymentLinkAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePaymentLink.afterCreatePaymentLinkCounter)
}

// CreatePaymentLinkBeforeCounter returns a count of PaymentServiceHandlerMock.CreatePaymentLink invocations
func (mmCreatePaymentLink *PaymentServiceHandlerMock) CreatePaymentLinkBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePaymentLink.beforeCreatePaymentLinkCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.CreatePaymentLink.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePaymentLink *mPaymentServiceHandlerMockCreatePaymentLink) Calls() []*PaymentServiceHandlerMockCreatePaymentLinkParams {
	mmCreatePaymentLink.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockCreatePaymentLinkParams, len(mmCreatePaymentLink.callArgs))
	copy(argCopy, mmCreatePaymentLink.callArgs)

	mmCreatePaymentLink.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePaymentLinkDone returns true if the count of the CreatePaymentLink invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockCreatePaymentLinkDone() bool {
	if m.CreatePaymentLinkMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePaymentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePaymentLinkMock.invocationsDone()
}

// MinimockCreatePaymentLinkInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockCreatePaymentLinkInspect() {
	for _, e := range m.CreatePaymentLinkMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.CreatePaymentLink at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePaymentLinkCounter := mm_atomic.LoadUint64(&m.afterCreatePaymentLinkCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePaymentLinkMock.defaultExpectation != nil && afterCreatePaymentLinkCounter < 1 {
		if m.CreatePaymentLinkMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.CreatePaymentLink at\n%s", m.CreatePaymentLinkMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.CreatePaymentLink at\n%s with params: %#v", m.CreatePaymentLinkMock.defaultExpectation.expectationOrigins.origin, *m.CreatePaymentLinkMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePaymentLink != nil && afterCreatePaymentLinkCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.CreatePaymentLink at\n%s", m.funcCreatePaymentLinkOrigin)
	}

	if !m.CreatePaymentLinkMock.invocationsDone() && afterCreatePaymentLinkCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.CreatePaymentLink at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePaymentLinkMock.expectedInvocations), m.CreatePaymentLinkMock.expectedInvocationsOrigin, afterCreatePaymentLinkCounter)
	}
}

type mPaymentServiceHandlerMockInitiatePrompt struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockInitiatePromptExpectation
	expectations       []*PaymentServiceHandlerMockInitiatePromptExpectation

	callArgs []*PaymentServiceHandlerMockInitiatePromptParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockInitiatePromptExpectation specifies expectation struct of the PaymentServiceHandler.InitiatePrompt
type PaymentServiceHandlerMockInitiatePromptExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockInitiatePromptParams
	paramPtrs          *PaymentServiceHandlerMockInitiatePromptParamPtrs
	expectationOrigins PaymentServiceHandlerMockInitiatePromptExpectationOrigins
	results            *PaymentServiceHandlerMockInitiatePromptResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockInitiatePromptParams contains parameters of the PaymentServiceHandler.InitiatePrompt
type PaymentServiceHandlerMockInitiatePromptParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.InitiatePromptRequest]
}

// PaymentServiceHandlerMockInitiatePromptParamPtrs contains pointers to parameters of the PaymentServiceHandler.InitiatePrompt
type PaymentServiceHandlerMockInitiatePromptParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.InitiatePromptRequest]
}

// PaymentServiceHandlerMockInitiatePromptResults contains results of the PaymentServiceHandler.InitiatePrompt
type PaymentServiceHandlerMockInitiatePromptResults struct {
	pp2 *connect.Response[v1.InitiatePromptResponse]
	err error
}

// PaymentServiceHandlerMockInitiatePromptOrigins contains origins of expectations of the PaymentServiceHandler.InitiatePrompt
type PaymentServiceHandlerMockInitiatePromptExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Optional() *mPaymentServiceHandlerMockInitiatePrompt {
	mmInitiatePrompt.optional = true
	return mmInitiatePrompt
}

// Expect sets up expected params for PaymentServiceHandler.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Expect(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) *mPaymentServiceHandlerMockInitiatePrompt {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceHandlerMockInitiatePromptExpectation{}
	}

	if mmInitiatePrompt.defaultExpectation.paramPtrs != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by ExpectParams functions")
	}

	mmInitiatePrompt.defaultExpectation.params = &PaymentServiceHandlerMockInitiatePromptParams{ctx, pp1}
	mmInitiatePrompt.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInitiatePrompt.expectations {
		if minimock.Equal(e.params, mmInitiatePrompt.defaultExpectation.params) {
			mmInitiatePrompt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitiatePrompt.defaultExpectation.params)
		}
	}

	return mmInitiatePrompt
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockInitiatePrompt {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceHandlerMockInitiatePromptExpectation{}
	}

	if mmInitiatePrompt.defaultExpectation.params != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Expect")
	}

	if mmInitiatePrompt.defaultExpectation.paramPtrs == nil {
		mmInitiatePrompt.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockInitiatePromptParamPtrs{}
	}
	mmInitiatePrompt.defaultExpectation.paramPtrs.ctx = &ctx
	mmInitiatePrompt.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInitiatePrompt
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) ExpectPp1Param2(pp1 *connect.Request[v1.InitiatePromptRequest]) *mPaymentServiceHandlerMockInitiatePrompt {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceHandlerMockInitiatePromptExpectation{}
	}

	if mmInitiatePrompt.defaultExpectation.params != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Expect")
	}

	if mmInitiatePrompt.defaultExpectation.paramPtrs == nil {
		mmInitiatePrompt.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockInitiatePromptParamPtrs{}
	}
	mmInitiatePrompt.defaultExpectation.paramPtrs.pp1 = &pp1
	mmInitiatePrompt.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmInitiatePrompt
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest])) *mPaymentServiceHandlerMockInitiatePrompt {
	if mmInitiatePrompt.mock.inspectFuncInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.InitiatePrompt")
	}

	mmInitiatePrompt.mock.inspectFuncInitiatePrompt = f

	return mmInitiatePrompt
}

// Return sets up results that will be returned by PaymentServiceHandler.InitiatePrompt
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Return(pp2 *connect.Response[v1.InitiatePromptResponse], err error) *PaymentServiceHandlerMock {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Set")
	}

	if mmInitiatePrompt.defaultExpectation == nil {
		mmInitiatePrompt.defaultExpectation = &PaymentServiceHandlerMockInitiatePromptExpectation{mock: mmInitiatePrompt.mock}
	}
	mmInitiatePrompt.defaultExpectation.results = &PaymentServiceHandlerMockInitiatePromptResults{pp2, err}
	mmInitiatePrompt.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInitiatePrompt.mock
}

// Set uses given function f to mock the PaymentServiceHandler.InitiatePrompt method
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Set(f func(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) (pp2 *connect.Response[v1.InitiatePromptResponse], err error)) *PaymentServiceHandlerMock {
	if mmInitiatePrompt.defaultExpectation != nil {
		mmInitiatePrompt.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.InitiatePrompt method")
	}

	if len(mmInitiatePrompt.expectations) > 0 {
		mmInitiatePrompt.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.InitiatePrompt method")
	}

	mmInitiatePrompt.mock.funcInitiatePrompt = f
	mmInitiatePrompt.mock.funcInitiatePromptOrigin = minimock.CallerInfo(1)
	return mmInitiatePrompt.mock
}

// When sets expectation for the PaymentServiceHandler.InitiatePrompt which will trigger the result defined by the following
// Then helper
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) When(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) *PaymentServiceHandlerMockInitiatePromptExpectation {
	if mmInitiatePrompt.mock.funcInitiatePrompt != nil {
		mmInitiatePrompt.mock.t.Fatalf("PaymentServiceHandlerMock.InitiatePrompt mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockInitiatePromptExpectation{
		mock:               mmInitiatePrompt.mock,
		params:             &PaymentServiceHandlerMockInitiatePromptParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockInitiatePromptExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInitiatePrompt.expectations = append(mmInitiatePrompt.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.InitiatePrompt return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockInitiatePromptExpectation) Then(pp2 *connect.Response[v1.InitiatePromptResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockInitiatePromptResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.InitiatePrompt should be invoked
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Times(n uint64) *mPaymentServiceHandlerMockInitiatePrompt {
	if n == 0 {
		mmInitiatePrompt.mock.t.Fatalf("Times of PaymentServiceHandlerMock.InitiatePrompt mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInitiatePrompt.expectedInvocations, n)
	mmInitiatePrompt.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInitiatePrompt
}

func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) invocationsDone() bool {
	if len(mmInitiatePrompt.expectations) == 0 && mmInitiatePrompt.defaultExpectation == nil && mmInitiatePrompt.mock.funcInitiatePrompt == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInitiatePrompt.mock.afterInitiatePromptCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInitiatePrompt.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InitiatePrompt implements mm_paymentv1connect.PaymentServiceHandler
func (mmInitiatePrompt *PaymentServiceHandlerMock) InitiatePrompt(ctx context.Context, pp1 *connect.Request[v1.InitiatePromptRequest]) (pp2 *connect.Response[v1.InitiatePromptResponse], err error) {
	mm_atomic.AddUint64(&mmInitiatePrompt.beforeInitiatePromptCounter, 1)
	defer mm_atomic.AddUint64(&mmInitiatePrompt.afterInitiatePromptCounter, 1)

	mmInitiatePrompt.t.Helper()

	if mmInitiatePrompt.inspectFuncInitiatePrompt != nil {
		mmInitiatePrompt.inspectFuncInitiatePrompt(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockInitiatePromptParams{ctx, pp1}

	// Record call args
	mmInitiatePrompt.InitiatePromptMock.mutex.Lock()
	mmInitiatePrompt.InitiatePromptMock.callArgs = append(mmInitiatePrompt.InitiatePromptMock.callArgs, &mm_params)
	mmInitiatePrompt.InitiatePromptMock.mutex.Unlock()

	for _, e := range mmInitiatePrompt.InitiatePromptMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmInitiatePrompt.InitiatePromptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitiatePrompt.InitiatePromptMock.defaultExpectation.Counter, 1)
		mm_want := mmInitiatePrompt.InitiatePromptMock.defaultExpectation.params
		mm_want_ptrs := mmInitiatePrompt.InitiatePromptMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockInitiatePromptParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInitiatePrompt.t.Errorf("PaymentServiceHandlerMock.InitiatePrompt got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInitiatePrompt.InitiatePromptMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmInitiatePrompt.t.Errorf("PaymentServiceHandlerMock.InitiatePrompt got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInitiatePrompt.InitiatePromptMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitiatePrompt.t.Errorf("PaymentServiceHandlerMock.InitiatePrompt got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInitiatePrompt.InitiatePromptMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitiatePrompt.InitiatePromptMock.defaultExpectation.results
		if mm_results == nil {
			mmInitiatePrompt.t.Fatal("No results are set for the PaymentServiceHandlerMock.InitiatePrompt")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmInitiatePrompt.funcInitiatePrompt != nil {
		return mmInitiatePrompt.funcInitiatePrompt(ctx, pp1)
	}
	mmInitiatePrompt.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.InitiatePrompt. %v %v", ctx, pp1)
	return
}

// InitiatePromptAfterCounter returns a count of finished PaymentServiceHandlerMock.InitiatePrompt invocations
func (mmInitiatePrompt *PaymentServiceHandlerMock) InitiatePromptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitiatePrompt.afterInitiatePromptCounter)
}

// InitiatePromptBeforeCounter returns a count of PaymentServiceHandlerMock.InitiatePrompt invocations
func (mmInitiatePrompt *PaymentServiceHandlerMock) InitiatePromptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitiatePrompt.beforeInitiatePromptCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.InitiatePrompt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitiatePrompt *mPaymentServiceHandlerMockInitiatePrompt) Calls() []*PaymentServiceHandlerMockInitiatePromptParams {
	mmInitiatePrompt.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockInitiatePromptParams, len(mmInitiatePrompt.callArgs))
	copy(argCopy, mmInitiatePrompt.callArgs)

	mmInitiatePrompt.mutex.RUnlock()

	return argCopy
}

// MinimockInitiatePromptDone returns true if the count of the InitiatePrompt invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockInitiatePromptDone() bool {
	if m.InitiatePromptMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitiatePromptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitiatePromptMock.invocationsDone()
}

// MinimockInitiatePromptInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockInitiatePromptInspect() {
	for _, e := range m.InitiatePromptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.InitiatePrompt at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInitiatePromptCounter := mm_atomic.LoadUint64(&m.afterInitiatePromptCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitiatePromptMock.defaultExpectation != nil && afterInitiatePromptCounter < 1 {
		if m.InitiatePromptMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.InitiatePrompt at\n%s", m.InitiatePromptMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.InitiatePrompt at\n%s with params: %#v", m.InitiatePromptMock.defaultExpectation.expectationOrigins.origin, *m.InitiatePromptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitiatePrompt != nil && afterInitiatePromptCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.InitiatePrompt at\n%s", m.funcInitiatePromptOrigin)
	}

	if !m.InitiatePromptMock.invocationsDone() && afterInitiatePromptCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.InitiatePrompt at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InitiatePromptMock.expectedInvocations), m.InitiatePromptMock.expectedInvocationsOrigin, afterInitiatePromptCounter)
	}
}

type mPaymentServiceHandlerMockReceive struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockReceiveExpectation
	expectations       []*PaymentServiceHandlerMockReceiveExpectation

	callArgs []*PaymentServiceHandlerMockReceiveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockReceiveExpectation specifies expectation struct of the PaymentServiceHandler.Receive
type PaymentServiceHandlerMockReceiveExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockReceiveParams
	paramPtrs          *PaymentServiceHandlerMockReceiveParamPtrs
	expectationOrigins PaymentServiceHandlerMockReceiveExpectationOrigins
	results            *PaymentServiceHandlerMockReceiveResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockReceiveParams contains parameters of the PaymentServiceHandler.Receive
type PaymentServiceHandlerMockReceiveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReceiveRequest]
}

// PaymentServiceHandlerMockReceiveParamPtrs contains pointers to parameters of the PaymentServiceHandler.Receive
type PaymentServiceHandlerMockReceiveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReceiveRequest]
}

// PaymentServiceHandlerMockReceiveResults contains results of the PaymentServiceHandler.Receive
type PaymentServiceHandlerMockReceiveResults struct {
	pp2 *connect.Response[v1.ReceiveResponse]
	err error
}

// PaymentServiceHandlerMockReceiveOrigins contains origins of expectations of the PaymentServiceHandler.Receive
type PaymentServiceHandlerMockReceiveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReceive *mPaymentServiceHandlerMockReceive) Optional() *mPaymentServiceHandlerMockReceive {
	mmReceive.optional = true
	return mmReceive
}

// Expect sets up expected params for PaymentServiceHandler.Receive
func (mmReceive *mPaymentServiceHandlerMockReceive) Expect(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) *mPaymentServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.paramPtrs != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by ExpectParams functions")
	}

	mmReceive.defaultExpectation.params = &PaymentServiceHandlerMockReceiveParams{ctx, pp1}
	mmReceive.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReceive.expectations {
		if minimock.Equal(e.params, mmReceive.defaultExpectation.params) {
			mmReceive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceive.defaultExpectation.params)
		}
	}

	return mmReceive
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.Receive
func (mmReceive *mPaymentServiceHandlerMockReceive) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.ctx = &ctx
	mmReceive.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReceive
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.Receive
func (mmReceive *mPaymentServiceHandlerMockReceive) ExpectPp1Param2(pp1 *connect.Request[v1.ReceiveRequest]) *mPaymentServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReceive.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReceive
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.Receive
func (mmReceive *mPaymentServiceHandlerMockReceive) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest])) *mPaymentServiceHandlerMockReceive {
	if mmReceive.mock.inspectFuncReceive != nil {
		mmReceive.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.Receive")
	}

	mmReceive.mock.inspectFuncReceive = f

	return mmReceive
}

// Return sets up results that will be returned by PaymentServiceHandler.Receive
func (mmReceive *mPaymentServiceHandlerMockReceive) Return(pp2 *connect.Response[v1.ReceiveResponse], err error) *PaymentServiceHandlerMock {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &PaymentServiceHandlerMockReceiveExpectation{mock: mmReceive.mock}
	}
	mmReceive.defaultExpectation.results = &PaymentServiceHandlerMockReceiveResults{pp2, err}
	mmReceive.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// Set uses given function f to mock the PaymentServiceHandler.Receive method
func (mmReceive *mPaymentServiceHandlerMockReceive) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.Response[v1.ReceiveResponse], err error)) *PaymentServiceHandlerMock {
	if mmReceive.defaultExpectation != nil {
		mmReceive.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.Receive method")
	}

	if len(mmReceive.expectations) > 0 {
		mmReceive.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.Receive method")
	}

	mmReceive.mock.funcReceive = f
	mmReceive.mock.funcReceiveOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// When sets expectation for the PaymentServiceHandler.Receive which will trigger the result defined by the following
// Then helper
func (mmReceive *mPaymentServiceHandlerMockReceive) When(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) *PaymentServiceHandlerMockReceiveExpectation {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("PaymentServiceHandlerMock.Receive mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockReceiveExpectation{
		mock:               mmReceive.mock,
		params:             &PaymentServiceHandlerMockReceiveParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockReceiveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReceive.expectations = append(mmReceive.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.Receive return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockReceiveExpectation) Then(pp2 *connect.Response[v1.ReceiveResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockReceiveResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.Receive should be invoked
func (mmReceive *mPaymentServiceHandlerMockReceive) Times(n uint64) *mPaymentServiceHandlerMockReceive {
	if n == 0 {
		mmReceive.mock.t.Fatalf("Times of PaymentServiceHandlerMock.Receive mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReceive.expectedInvocations, n)
	mmReceive.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReceive
}

func (mmReceive *mPaymentServiceHandlerMockReceive) invocationsDone() bool {
	if len(mmReceive.expectations) == 0 && mmReceive.defaultExpectation == nil && mmReceive.mock.funcReceive == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReceive.mock.afterReceiveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReceive.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Receive implements mm_paymentv1connect.PaymentServiceHandler
func (mmReceive *PaymentServiceHandlerMock) Receive(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.Response[v1.ReceiveResponse], err error) {
	mm_atomic.AddUint64(&mmReceive.beforeReceiveCounter, 1)
	defer mm_atomic.AddUint64(&mmReceive.afterReceiveCounter, 1)

	mmReceive.t.Helper()

	if mmReceive.inspectFuncReceive != nil {
		mmReceive.inspectFuncReceive(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockReceiveParams{ctx, pp1}

	// Record call args
	mmReceive.ReceiveMock.mutex.Lock()
	mmReceive.ReceiveMock.callArgs = append(mmReceive.ReceiveMock.callArgs, &mm_params)
	mmReceive.ReceiveMock.mutex.Unlock()

	for _, e := range mmReceive.ReceiveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReceive.ReceiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceive.ReceiveMock.defaultExpectation.Counter, 1)
		mm_want := mmReceive.ReceiveMock.defaultExpectation.params
		mm_want_ptrs := mmReceive.ReceiveMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockReceiveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReceive.t.Errorf("PaymentServiceHandlerMock.Receive got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReceive.t.Errorf("PaymentServiceHandlerMock.Receive got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceive.t.Errorf("PaymentServiceHandlerMock.Receive got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReceive.ReceiveMock.defaultExpectation.results
		if mm_results == nil {
			mmReceive.t.Fatal("No results are set for the PaymentServiceHandlerMock.Receive")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReceive.funcReceive != nil {
		return mmReceive.funcReceive(ctx, pp1)
	}
	mmReceive.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.Receive. %v %v", ctx, pp1)
	return
}

// ReceiveAfterCounter returns a count of finished PaymentServiceHandlerMock.Receive invocations
func (mmReceive *PaymentServiceHandlerMock) ReceiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.afterReceiveCounter)
}

// ReceiveBeforeCounter returns a count of PaymentServiceHandlerMock.Receive invocations
func (mmReceive *PaymentServiceHandlerMock) ReceiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.beforeReceiveCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.Receive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceive *mPaymentServiceHandlerMockReceive) Calls() []*PaymentServiceHandlerMockReceiveParams {
	mmReceive.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockReceiveParams, len(mmReceive.callArgs))
	copy(argCopy, mmReceive.callArgs)

	mmReceive.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveDone returns true if the count of the Receive invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockReceiveDone() bool {
	if m.ReceiveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReceiveMock.invocationsDone()
}

// MinimockReceiveInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockReceiveInspect() {
	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Receive at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReceiveCounter := mm_atomic.LoadUint64(&m.afterReceiveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveMock.defaultExpectation != nil && afterReceiveCounter < 1 {
		if m.ReceiveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Receive at\n%s", m.ReceiveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Receive at\n%s with params: %#v", m.ReceiveMock.defaultExpectation.expectationOrigins.origin, *m.ReceiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceive != nil && afterReceiveCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.Receive at\n%s", m.funcReceiveOrigin)
	}

	if !m.ReceiveMock.invocationsDone() && afterReceiveCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.Receive at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReceiveMock.expectedInvocations), m.ReceiveMock.expectedInvocationsOrigin, afterReceiveCounter)
	}
}

type mPaymentServiceHandlerMockReconcile struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockReconcileExpectation
	expectations       []*PaymentServiceHandlerMockReconcileExpectation

	callArgs []*PaymentServiceHandlerMockReconcileParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockReconcileExpectation specifies expectation struct of the PaymentServiceHandler.Reconcile
type PaymentServiceHandlerMockReconcileExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockReconcileParams
	paramPtrs          *PaymentServiceHandlerMockReconcileParamPtrs
	expectationOrigins PaymentServiceHandlerMockReconcileExpectationOrigins
	results            *PaymentServiceHandlerMockReconcileResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockReconcileParams contains parameters of the PaymentServiceHandler.Reconcile
type PaymentServiceHandlerMockReconcileParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReconcileRequest]
}

// PaymentServiceHandlerMockReconcileParamPtrs contains pointers to parameters of the PaymentServiceHandler.Reconcile
type PaymentServiceHandlerMockReconcileParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReconcileRequest]
}

// PaymentServiceHandlerMockReconcileResults contains results of the PaymentServiceHandler.Reconcile
type PaymentServiceHandlerMockReconcileResults struct {
	pp2 *connect.Response[v1.ReconcileResponse]
	err error
}

// PaymentServiceHandlerMockReconcileOrigins contains origins of expectations of the PaymentServiceHandler.Reconcile
type PaymentServiceHandlerMockReconcileExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Optional() *mPaymentServiceHandlerMockReconcile {
	mmReconcile.optional = true
	return mmReconcile
}

// Expect sets up expected params for PaymentServiceHandler.Reconcile
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Expect(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) *mPaymentServiceHandlerMockReconcile {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceHandlerMockReconcileExpectation{}
	}

	if mmReconcile.defaultExpectation.paramPtrs != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by ExpectParams functions")
	}

	mmReconcile.defaultExpectation.params = &PaymentServiceHandlerMockReconcileParams{ctx, pp1}
	mmReconcile.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReconcile.expectations {
		if minimock.Equal(e.params, mmReconcile.defaultExpectation.params) {
			mmReconcile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReconcile.defaultExpectation.params)
		}
	}

	return mmReconcile
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.Reconcile
func (mmReconcile *mPaymentServiceHandlerMockReconcile) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockReconcile {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceHandlerMockReconcileExpectation{}
	}

	if mmReconcile.defaultExpectation.params != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Expect")
	}

	if mmReconcile.defaultExpectation.paramPtrs == nil {
		mmReconcile.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockReconcileParamPtrs{}
	}
	mmReconcile.defaultExpectation.paramPtrs.ctx = &ctx
	mmReconcile.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReconcile
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.Reconcile
func (mmReconcile *mPaymentServiceHandlerMockReconcile) ExpectPp1Param2(pp1 *connect.Request[v1.ReconcileRequest]) *mPaymentServiceHandlerMockReconcile {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceHandlerMockReconcileExpectation{}
	}

	if mmReconcile.defaultExpectation.params != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Expect")
	}

	if mmReconcile.defaultExpectation.paramPtrs == nil {
		mmReconcile.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockReconcileParamPtrs{}
	}
	mmReconcile.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReconcile.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReconcile
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.Reconcile
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest])) *mPaymentServiceHandlerMockReconcile {
	if mmReconcile.mock.inspectFuncReconcile != nil {
		mmReconcile.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.Reconcile")
	}

	mmReconcile.mock.inspectFuncReconcile = f

	return mmReconcile
}

// Return sets up results that will be returned by PaymentServiceHandler.Reconcile
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Return(pp2 *connect.Response[v1.ReconcileResponse], err error) *PaymentServiceHandlerMock {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Set")
	}

	if mmReconcile.defaultExpectation == nil {
		mmReconcile.defaultExpectation = &PaymentServiceHandlerMockReconcileExpectation{mock: mmReconcile.mock}
	}
	mmReconcile.defaultExpectation.results = &PaymentServiceHandlerMockReconcileResults{pp2, err}
	mmReconcile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReconcile.mock
}

// Set uses given function f to mock the PaymentServiceHandler.Reconcile method
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) (pp2 *connect.Response[v1.ReconcileResponse], err error)) *PaymentServiceHandlerMock {
	if mmReconcile.defaultExpectation != nil {
		mmReconcile.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.Reconcile method")
	}

	if len(mmReconcile.expectations) > 0 {
		mmReconcile.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.Reconcile method")
	}

	mmReconcile.mock.funcReconcile = f
	mmReconcile.mock.funcReconcileOrigin = minimock.CallerInfo(1)
	return mmReconcile.mock
}

// When sets expectation for the PaymentServiceHandler.Reconcile which will trigger the result defined by the following
// Then helper
func (mmReconcile *mPaymentServiceHandlerMockReconcile) When(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) *PaymentServiceHandlerMockReconcileExpectation {
	if mmReconcile.mock.funcReconcile != nil {
		mmReconcile.mock.t.Fatalf("PaymentServiceHandlerMock.Reconcile mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockReconcileExpectation{
		mock:               mmReconcile.mock,
		params:             &PaymentServiceHandlerMockReconcileParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockReconcileExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReconcile.expectations = append(mmReconcile.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.Reconcile return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockReconcileExpectation) Then(pp2 *connect.Response[v1.ReconcileResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockReconcileResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.Reconcile should be invoked
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Times(n uint64) *mPaymentServiceHandlerMockReconcile {
	if n == 0 {
		mmReconcile.mock.t.Fatalf("Times of PaymentServiceHandlerMock.Reconcile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReconcile.expectedInvocations, n)
	mmReconcile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReconcile
}

func (mmReconcile *mPaymentServiceHandlerMockReconcile) invocationsDone() bool {
	if len(mmReconcile.expectations) == 0 && mmReconcile.defaultExpectation == nil && mmReconcile.mock.funcReconcile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReconcile.mock.afterReconcileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReconcile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reconcile implements mm_paymentv1connect.PaymentServiceHandler
func (mmReconcile *PaymentServiceHandlerMock) Reconcile(ctx context.Context, pp1 *connect.Request[v1.ReconcileRequest]) (pp2 *connect.Response[v1.ReconcileResponse], err error) {
	mm_atomic.AddUint64(&mmReconcile.beforeReconcileCounter, 1)
	defer mm_atomic.AddUint64(&mmReconcile.afterReconcileCounter, 1)

	mmReconcile.t.Helper()

	if mmReconcile.inspectFuncReconcile != nil {
		mmReconcile.inspectFuncReconcile(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockReconcileParams{ctx, pp1}

	// Record call args
	mmReconcile.ReconcileMock.mutex.Lock()
	mmReconcile.ReconcileMock.callArgs = append(mmReconcile.ReconcileMock.callArgs, &mm_params)
	mmReconcile.ReconcileMock.mutex.Unlock()

	for _, e := range mmReconcile.ReconcileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReconcile.ReconcileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReconcile.ReconcileMock.defaultExpectation.Counter, 1)
		mm_want := mmReconcile.ReconcileMock.defaultExpectation.params
		mm_want_ptrs := mmReconcile.ReconcileMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockReconcileParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReconcile.t.Errorf("PaymentServiceHandlerMock.Reconcile got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReconcile.ReconcileMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReconcile.t.Errorf("PaymentServiceHandlerMock.Reconcile got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReconcile.ReconcileMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReconcile.t.Errorf("PaymentServiceHandlerMock.Reconcile got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReconcile.ReconcileMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReconcile.ReconcileMock.defaultExpectation.results
		if mm_results == nil {
			mmReconcile.t.Fatal("No results are set for the PaymentServiceHandlerMock.Reconcile")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReconcile.funcReconcile != nil {
		return mmReconcile.funcReconcile(ctx, pp1)
	}
	mmReconcile.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.Reconcile. %v %v", ctx, pp1)
	return
}

// ReconcileAfterCounter returns a count of finished PaymentServiceHandlerMock.Reconcile invocations
func (mmReconcile *PaymentServiceHandlerMock) ReconcileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReconcile.afterReconcileCounter)
}

// ReconcileBeforeCounter returns a count of PaymentServiceHandlerMock.Reconcile invocations
func (mmReconcile *PaymentServiceHandlerMock) ReconcileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReconcile.beforeReconcileCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.Reconcile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReconcile *mPaymentServiceHandlerMockReconcile) Calls() []*PaymentServiceHandlerMockReconcileParams {
	mmReconcile.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockReconcileParams, len(mmReconcile.callArgs))
	copy(argCopy, mmReconcile.callArgs)

	mmReconcile.mutex.RUnlock()

	return argCopy
}

// MinimockReconcileDone returns true if the count of the Reconcile invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockReconcileDone() bool {
	if m.ReconcileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReconcileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReconcileMock.invocationsDone()
}

// MinimockReconcileInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockReconcileInspect() {
	for _, e := range m.ReconcileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Reconcile at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReconcileCounter := mm_atomic.LoadUint64(&m.afterReconcileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReconcileMock.defaultExpectation != nil && afterReconcileCounter < 1 {
		if m.ReconcileMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Reconcile at\n%s", m.ReconcileMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Reconcile at\n%s with params: %#v", m.ReconcileMock.defaultExpectation.expectationOrigins.origin, *m.ReconcileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReconcile != nil && afterReconcileCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.Reconcile at\n%s", m.funcReconcileOrigin)
	}

	if !m.ReconcileMock.invocationsDone() && afterReconcileCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.Reconcile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReconcileMock.expectedInvocations), m.ReconcileMock.expectedInvocationsOrigin, afterReconcileCounter)
	}
}

type mPaymentServiceHandlerMockRelease struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockReleaseExpectation
	expectations       []*PaymentServiceHandlerMockReleaseExpectation

	callArgs []*PaymentServiceHandlerMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockReleaseExpectation specifies expectation struct of the PaymentServiceHandler.Release
type PaymentServiceHandlerMockReleaseExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockReleaseParams
	paramPtrs          *PaymentServiceHandlerMockReleaseParamPtrs
	expectationOrigins PaymentServiceHandlerMockReleaseExpectationOrigins
	results            *PaymentServiceHandlerMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockReleaseParams contains parameters of the PaymentServiceHandler.Release
type PaymentServiceHandlerMockReleaseParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReleaseRequest]
}

// PaymentServiceHandlerMockReleaseParamPtrs contains pointers to parameters of the PaymentServiceHandler.Release
type PaymentServiceHandlerMockReleaseParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReleaseRequest]
}

// PaymentServiceHandlerMockReleaseResults contains results of the PaymentServiceHandler.Release
type PaymentServiceHandlerMockReleaseResults struct {
	pp2 *connect.Response[v1.ReleaseResponse]
	err error
}

// PaymentServiceHandlerMockReleaseOrigins contains origins of expectations of the PaymentServiceHandler.Release
type PaymentServiceHandlerMockReleaseExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mPaymentServiceHandlerMockRelease) Optional() *mPaymentServiceHandlerMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for PaymentServiceHandler.Release
func (mmRelease *mPaymentServiceHandlerMockRelease) Expect(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) *mPaymentServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &PaymentServiceHandlerMockReleaseParams{ctx, pp1}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.Release
func (mmRelease *mPaymentServiceHandlerMockRelease) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.Release
func (mmRelease *mPaymentServiceHandlerMockRelease) ExpectPp1Param2(pp1 *connect.Request[v1.ReleaseRequest]) *mPaymentServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRelease.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.Release
func (mmRelease *mPaymentServiceHandlerMockRelease) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest])) *mPaymentServiceHandlerMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by PaymentServiceHandler.Release
func (mmRelease *mPaymentServiceHandlerMockRelease) Return(pp2 *connect.Response[v1.ReleaseResponse], err error) *PaymentServiceHandlerMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &PaymentServiceHandlerMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &PaymentServiceHandlerMockReleaseResults{pp2, err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the PaymentServiceHandler.Release method
func (mmRelease *mPaymentServiceHandlerMockRelease) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.Response[v1.ReleaseResponse], err error)) *PaymentServiceHandlerMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the PaymentServiceHandler.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mPaymentServiceHandlerMockRelease) When(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) *PaymentServiceHandlerMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("PaymentServiceHandlerMock.Release mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &PaymentServiceHandlerMockReleaseParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.Release return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockReleaseExpectation) Then(pp2 *connect.Response[v1.ReleaseResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockReleaseResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.Release should be invoked
func (mmRelease *mPaymentServiceHandlerMockRelease) Times(n uint64) *mPaymentServiceHandlerMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of PaymentServiceHandlerMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mPaymentServiceHandlerMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_paymentv1connect.PaymentServiceHandler
func (mmRelease *PaymentServiceHandlerMock) Release(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.Response[v1.ReleaseResponse], err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockReleaseParams{ctx, pp1}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockReleaseParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("PaymentServiceHandlerMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRelease.t.Errorf("PaymentServiceHandlerMock.Release got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("PaymentServiceHandlerMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the PaymentServiceHandlerMock.Release")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, pp1)
	}
	mmRelease.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.Release. %v %v", ctx, pp1)
	return
}

// ReleaseAfterCounter returns a count of finished PaymentServiceHandlerMock.Release invocations
func (mmRelease *PaymentServiceHandlerMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of PaymentServiceHandlerMock.Release invocations
func (mmRelease *PaymentServiceHandlerMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mPaymentServiceHandlerMockRelease) Calls() []*PaymentServiceHandlerMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mPaymentServiceHandlerMockSearch struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockSearchExpectation
	expectations       []*PaymentServiceHandlerMockSearchExpectation

	callArgs []*PaymentServiceHandlerMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockSearchExpectation specifies expectation struct of the PaymentServiceHandler.Search
type PaymentServiceHandlerMockSearchExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockSearchParams
	paramPtrs          *PaymentServiceHandlerMockSearchParamPtrs
	expectationOrigins PaymentServiceHandlerMockSearchExpectationOrigins
	results            *PaymentServiceHandlerMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockSearchParams contains parameters of the PaymentServiceHandler.Search
type PaymentServiceHandlerMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
	pp2 *connect.ServerStream[v1.SearchResponse]
}

// PaymentServiceHandlerMockSearchParamPtrs contains pointers to parameters of the PaymentServiceHandler.Search
type PaymentServiceHandlerMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
	pp2 **connect.ServerStream[v1.SearchResponse]
}

// PaymentServiceHandlerMockSearchResults contains results of the PaymentServiceHandler.Search
type PaymentServiceHandlerMockSearchResults struct {
	err error
}

// PaymentServiceHandlerMockSearchOrigins contains origins of expectations of the PaymentServiceHandler.Search
type PaymentServiceHandlerMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mPaymentServiceHandlerMockSearch) Optional() *mPaymentServiceHandlerMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for PaymentServiceHandler.Search
func (mmSearch *mPaymentServiceHandlerMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) *mPaymentServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &PaymentServiceHandlerMockSearchParams{ctx, pp1, pp2}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.Search
func (mmSearch *mPaymentServiceHandlerMockSearch) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.Search
func (mmSearch *mPaymentServiceHandlerMockSearch) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mPaymentServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp2Param3 sets up expected param pp2 for PaymentServiceHandler.Search
func (mmSearch *mPaymentServiceHandlerMockSearch) ExpectPp2Param3(pp2 *connect.ServerStream[v1.SearchResponse]) *mPaymentServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearch.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.Search
func (mmSearch *mPaymentServiceHandlerMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse])) *mPaymentServiceHandlerMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by PaymentServiceHandler.Search
func (mmSearch *mPaymentServiceHandlerMockSearch) Return(err error) *PaymentServiceHandlerMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &PaymentServiceHandlerMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &PaymentServiceHandlerMockSearchResults{err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the PaymentServiceHandler.Search method
func (mmSearch *mPaymentServiceHandlerMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error)) *PaymentServiceHandlerMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the PaymentServiceHandler.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mPaymentServiceHandlerMockSearch) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) *PaymentServiceHandlerMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("PaymentServiceHandlerMock.Search mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &PaymentServiceHandlerMockSearchParams{ctx, pp1, pp2},
		expectationOrigins: PaymentServiceHandlerMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.Search return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockSearchExpectation) Then(err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockSearchResults{err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.Search should be invoked
func (mmSearch *mPaymentServiceHandlerMockSearch) Times(n uint64) *mPaymentServiceHandlerMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of PaymentServiceHandlerMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mPaymentServiceHandlerMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_paymentv1connect.PaymentServiceHandler
func (mmSearch *PaymentServiceHandlerMock) Search(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1, pp2)
	}

	mm_params := PaymentServiceHandlerMockSearchParams{ctx, pp1, pp2}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockSearchParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("PaymentServiceHandlerMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("PaymentServiceHandlerMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearch.t.Errorf("PaymentServiceHandlerMock.Search got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("PaymentServiceHandlerMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the PaymentServiceHandlerMock.Search")
		}
		return (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1, pp2)
	}
	mmSearch.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.Search. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchAfterCounter returns a count of finished PaymentServiceHandlerMock.Search invocations
func (mmSearch *PaymentServiceHandlerMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of PaymentServiceHandlerMock.Search invocations
func (mmSearch *PaymentServiceHandlerMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mPaymentServiceHandlerMockSearch) Calls() []*PaymentServiceHandlerMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

type mPaymentServiceHandlerMockSend struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockSendExpectation
	expectations       []*PaymentServiceHandlerMockSendExpectation

	callArgs []*PaymentServiceHandlerMockSendParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockSendExpectation specifies expectation struct of the PaymentServiceHandler.Send
type PaymentServiceHandlerMockSendExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockSendParams
	paramPtrs          *PaymentServiceHandlerMockSendParamPtrs
	expectationOrigins PaymentServiceHandlerMockSendExpectationOrigins
	results            *PaymentServiceHandlerMockSendResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockSendParams contains parameters of the PaymentServiceHandler.Send
type PaymentServiceHandlerMockSendParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SendRequest]
}

// PaymentServiceHandlerMockSendParamPtrs contains pointers to parameters of the PaymentServiceHandler.Send
type PaymentServiceHandlerMockSendParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SendRequest]
}

// PaymentServiceHandlerMockSendResults contains results of the PaymentServiceHandler.Send
type PaymentServiceHandlerMockSendResults struct {
	pp2 *connect.Response[v1.SendResponse]
	err error
}

// PaymentServiceHandlerMockSendOrigins contains origins of expectations of the PaymentServiceHandler.Send
type PaymentServiceHandlerMockSendExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSend *mPaymentServiceHandlerMockSend) Optional() *mPaymentServiceHandlerMockSend {
	mmSend.optional = true
	return mmSend
}

// Expect sets up expected params for PaymentServiceHandler.Send
func (mmSend *mPaymentServiceHandlerMockSend) Expect(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) *mPaymentServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.paramPtrs != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by ExpectParams functions")
	}

	mmSend.defaultExpectation.params = &PaymentServiceHandlerMockSendParams{ctx, pp1}
	mmSend.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.Send
func (mmSend *mPaymentServiceHandlerMockSend) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.ctx = &ctx
	mmSend.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSend
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.Send
func (mmSend *mPaymentServiceHandlerMockSend) ExpectPp1Param2(pp1 *connect.Request[v1.SendRequest]) *mPaymentServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSend.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.Send
func (mmSend *mPaymentServiceHandlerMockSend) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest])) *mPaymentServiceHandlerMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by PaymentServiceHandler.Send
func (mmSend *mPaymentServiceHandlerMockSend) Return(pp2 *connect.Response[v1.SendResponse], err error) *PaymentServiceHandlerMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &PaymentServiceHandlerMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &PaymentServiceHandlerMockSendResults{pp2, err}
	mmSend.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// Set uses given function f to mock the PaymentServiceHandler.Send method
func (mmSend *mPaymentServiceHandlerMockSend) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.Response[v1.SendResponse], err error)) *PaymentServiceHandlerMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.Send method")
	}

	mmSend.mock.funcSend = f
	mmSend.mock.funcSendOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// When sets expectation for the PaymentServiceHandler.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mPaymentServiceHandlerMockSend) When(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) *PaymentServiceHandlerMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("PaymentServiceHandlerMock.Send mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockSendExpectation{
		mock:               mmSend.mock,
		params:             &PaymentServiceHandlerMockSendParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockSendExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.Send return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockSendExpectation) Then(pp2 *connect.Response[v1.SendResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockSendResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.Send should be invoked
func (mmSend *mPaymentServiceHandlerMockSend) Times(n uint64) *mPaymentServiceHandlerMockSend {
	if n == 0 {
		mmSend.mock.t.Fatalf("Times of PaymentServiceHandlerMock.Send mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSend.expectedInvocations, n)
	mmSend.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSend
}

func (mmSend *mPaymentServiceHandlerMockSend) invocationsDone() bool {
	if len(mmSend.expectations) == 0 && mmSend.defaultExpectation == nil && mmSend.mock.funcSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSend.mock.afterSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Send implements mm_paymentv1connect.PaymentServiceHandler
func (mmSend *PaymentServiceHandlerMock) Send(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.Response[v1.SendResponse], err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	mmSend.t.Helper()

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockSendParams{ctx, pp1}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, &mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_want_ptrs := mmSend.SendMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockSendParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSend.t.Errorf("PaymentServiceHandlerMock.Send got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSend.t.Errorf("PaymentServiceHandlerMock.Send got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("PaymentServiceHandlerMock.Send got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSend.SendMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the PaymentServiceHandlerMock.Send")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(ctx, pp1)
	}
	mmSend.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.Send. %v %v", ctx, pp1)
	return
}

// SendAfterCounter returns a count of finished PaymentServiceHandlerMock.Send invocations
func (mmSend *PaymentServiceHandlerMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of PaymentServiceHandlerMock.Send invocations
func (mmSend *PaymentServiceHandlerMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mPaymentServiceHandlerMockSend) Calls() []*PaymentServiceHandlerMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockSendDone() bool {
	if m.SendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMock.invocationsDone()
}

// MinimockSendInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Send at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCounter := mm_atomic.LoadUint64(&m.afterSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && afterSendCounter < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Send at\n%s", m.SendMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Send at\n%s with params: %#v", m.SendMock.defaultExpectation.expectationOrigins.origin, *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && afterSendCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.Send at\n%s", m.funcSendOrigin)
	}

	if !m.SendMock.invocationsDone() && afterSendCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.Send at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMock.expectedInvocations), m.SendMock.expectedInvocationsOrigin, afterSendCounter)
	}
}

type mPaymentServiceHandlerMockStatus struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockStatusExpectation
	expectations       []*PaymentServiceHandlerMockStatusExpectation

	callArgs []*PaymentServiceHandlerMockStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockStatusExpectation specifies expectation struct of the PaymentServiceHandler.Status
type PaymentServiceHandlerMockStatusExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockStatusParams
	paramPtrs          *PaymentServiceHandlerMockStatusParamPtrs
	expectationOrigins PaymentServiceHandlerMockStatusExpectationOrigins
	results            *PaymentServiceHandlerMockStatusResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockStatusParams contains parameters of the PaymentServiceHandler.Status
type PaymentServiceHandlerMockStatusParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusRequest]
}

// PaymentServiceHandlerMockStatusParamPtrs contains pointers to parameters of the PaymentServiceHandler.Status
type PaymentServiceHandlerMockStatusParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusRequest]
}

// PaymentServiceHandlerMockStatusResults contains results of the PaymentServiceHandler.Status
type PaymentServiceHandlerMockStatusResults struct {
	pp2 *connect.Response[v11.StatusResponse]
	err error
}

// PaymentServiceHandlerMockStatusOrigins contains origins of expectations of the PaymentServiceHandler.Status
type PaymentServiceHandlerMockStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatus *mPaymentServiceHandlerMockStatus) Optional() *mPaymentServiceHandlerMockStatus {
	mmStatus.optional = true
	return mmStatus
}

// Expect sets up expected params for PaymentServiceHandler.Status
func (mmStatus *mPaymentServiceHandlerMockStatus) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *mPaymentServiceHandlerMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceHandlerMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.paramPtrs != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by ExpectParams functions")
	}

	mmStatus.defaultExpectation.params = &PaymentServiceHandlerMockStatusParams{ctx, pp1}
	mmStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatus.expectations {
		if minimock.Equal(e.params, mmStatus.defaultExpectation.params) {
			mmStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatus.defaultExpectation.params)
		}
	}

	return mmStatus
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.Status
func (mmStatus *mPaymentServiceHandlerMockStatus) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceHandlerMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatus
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.Status
func (mmStatus *mPaymentServiceHandlerMockStatus) ExpectPp1Param2(pp1 *connect.Request[v11.StatusRequest]) *mPaymentServiceHandlerMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceHandlerMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatus.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatus
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.Status
func (mmStatus *mPaymentServiceHandlerMockStatus) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])) *mPaymentServiceHandlerMockStatus {
	if mmStatus.mock.inspectFuncStatus != nil {
		mmStatus.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.Status")
	}

	mmStatus.mock.inspectFuncStatus = f

	return mmStatus
}

// Return sets up results that will be returned by PaymentServiceHandler.Status
func (mmStatus *mPaymentServiceHandlerMockStatus) Return(pp2 *connect.Response[v11.StatusResponse], err error) *PaymentServiceHandlerMock {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &PaymentServiceHandlerMockStatusExpectation{mock: mmStatus.mock}
	}
	mmStatus.defaultExpectation.results = &PaymentServiceHandlerMockStatusResults{pp2, err}
	mmStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// Set uses given function f to mock the PaymentServiceHandler.Status method
func (mmStatus *mPaymentServiceHandlerMockStatus) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)) *PaymentServiceHandlerMock {
	if mmStatus.defaultExpectation != nil {
		mmStatus.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.Status method")
	}

	if len(mmStatus.expectations) > 0 {
		mmStatus.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.Status method")
	}

	mmStatus.mock.funcStatus = f
	mmStatus.mock.funcStatusOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// When sets expectation for the PaymentServiceHandler.Status which will trigger the result defined by the following
// Then helper
func (mmStatus *mPaymentServiceHandlerMockStatus) When(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *PaymentServiceHandlerMockStatusExpectation {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("PaymentServiceHandlerMock.Status mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockStatusExpectation{
		mock:               mmStatus.mock,
		params:             &PaymentServiceHandlerMockStatusParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatus.expectations = append(mmStatus.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.Status return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockStatusExpectation) Then(pp2 *connect.Response[v11.StatusResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockStatusResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.Status should be invoked
func (mmStatus *mPaymentServiceHandlerMockStatus) Times(n uint64) *mPaymentServiceHandlerMockStatus {
	if n == 0 {
		mmStatus.mock.t.Fatalf("Times of PaymentServiceHandlerMock.Status mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatus.expectedInvocations, n)
	mmStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatus
}

func (mmStatus *mPaymentServiceHandlerMockStatus) invocationsDone() bool {
	if len(mmStatus.expectations) == 0 && mmStatus.defaultExpectation == nil && mmStatus.mock.funcStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatus.mock.afterStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Status implements mm_paymentv1connect.PaymentServiceHandler
func (mmStatus *PaymentServiceHandlerMock) Status(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error) {
	mm_atomic.AddUint64(&mmStatus.beforeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmStatus.afterStatusCounter, 1)

	mmStatus.t.Helper()

	if mmStatus.inspectFuncStatus != nil {
		mmStatus.inspectFuncStatus(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockStatusParams{ctx, pp1}

	// Record call args
	mmStatus.StatusMock.mutex.Lock()
	mmStatus.StatusMock.callArgs = append(mmStatus.StatusMock.callArgs, &mm_params)
	mmStatus.StatusMock.mutex.Unlock()

	for _, e := range mmStatus.StatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatus.StatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatus.StatusMock.defaultExpectation.Counter, 1)
		mm_want := mmStatus.StatusMock.defaultExpectation.params
		mm_want_ptrs := mmStatus.StatusMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockStatusParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatus.t.Errorf("PaymentServiceHandlerMock.Status got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatus.t.Errorf("PaymentServiceHandlerMock.Status got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatus.t.Errorf("PaymentServiceHandlerMock.Status got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatus.StatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatus.StatusMock.defaultExpectation.results
		if mm_results == nil {
			mmStatus.t.Fatal("No results are set for the PaymentServiceHandlerMock.Status")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatus.funcStatus != nil {
		return mmStatus.funcStatus(ctx, pp1)
	}
	mmStatus.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.Status. %v %v", ctx, pp1)
	return
}

// StatusAfterCounter returns a count of finished PaymentServiceHandlerMock.Status invocations
func (mmStatus *PaymentServiceHandlerMock) StatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.afterStatusCounter)
}

// StatusBeforeCounter returns a count of PaymentServiceHandlerMock.Status invocations
func (mmStatus *PaymentServiceHandlerMock) StatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.beforeStatusCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.Status.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatus *mPaymentServiceHandlerMockStatus) Calls() []*PaymentServiceHandlerMockStatusParams {
	mmStatus.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockStatusParams, len(mmStatus.callArgs))
	copy(argCopy, mmStatus.callArgs)

	mmStatus.mutex.RUnlock()

	return argCopy
}

// MinimockStatusDone returns true if the count of the Status invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockStatusDone() bool {
	if m.StatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusMock.invocationsDone()
}

// MinimockStatusInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockStatusInspect() {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Status at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusCounter := mm_atomic.LoadUint64(&m.afterStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && afterStatusCounter < 1 {
		if m.StatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Status at\n%s", m.StatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.Status at\n%s with params: %#v", m.StatusMock.defaultExpectation.expectationOrigins.origin, *m.StatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && afterStatusCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.Status at\n%s", m.funcStatusOrigin)
	}

	if !m.StatusMock.invocationsDone() && afterStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.Status at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusMock.expectedInvocations), m.StatusMock.expectedInvocationsOrigin, afterStatusCounter)
	}
}

type mPaymentServiceHandlerMockStatusUpdate struct {
	optional           bool
	mock               *PaymentServiceHandlerMock
	defaultExpectation *PaymentServiceHandlerMockStatusUpdateExpectation
	expectations       []*PaymentServiceHandlerMockStatusUpdateExpectation

	callArgs []*PaymentServiceHandlerMockStatusUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PaymentServiceHandlerMockStatusUpdateExpectation specifies expectation struct of the PaymentServiceHandler.StatusUpdate
type PaymentServiceHandlerMockStatusUpdateExpectation struct {
	mock               *PaymentServiceHandlerMock
	params             *PaymentServiceHandlerMockStatusUpdateParams
	paramPtrs          *PaymentServiceHandlerMockStatusUpdateParamPtrs
	expectationOrigins PaymentServiceHandlerMockStatusUpdateExpectationOrigins
	results            *PaymentServiceHandlerMockStatusUpdateResults
	returnOrigin       string
	Counter            uint64
}

// PaymentServiceHandlerMockStatusUpdateParams contains parameters of the PaymentServiceHandler.StatusUpdate
type PaymentServiceHandlerMockStatusUpdateParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusUpdateRequest]
}

// PaymentServiceHandlerMockStatusUpdateParamPtrs contains pointers to parameters of the PaymentServiceHandler.StatusUpdate
type PaymentServiceHandlerMockStatusUpdateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusUpdateRequest]
}

// PaymentServiceHandlerMockStatusUpdateResults contains results of the PaymentServiceHandler.StatusUpdate
type PaymentServiceHandlerMockStatusUpdateResults struct {
	pp2 *connect.Response[v11.StatusUpdateResponse]
	err error
}

// PaymentServiceHandlerMockStatusUpdateOrigins contains origins of expectations of the PaymentServiceHandler.StatusUpdate
type PaymentServiceHandlerMockStatusUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Optional() *mPaymentServiceHandlerMockStatusUpdate {
	mmStatusUpdate.optional = true
	return mmStatusUpdate
}

// Expect sets up expected params for PaymentServiceHandler.StatusUpdate
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *mPaymentServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceHandlerMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by ExpectParams functions")
	}

	mmStatusUpdate.defaultExpectation.params = &PaymentServiceHandlerMockStatusUpdateParams{ctx, pp1}
	mmStatusUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatusUpdate.expectations {
		if minimock.Equal(e.params, mmStatusUpdate.defaultExpectation.params) {
			mmStatusUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatusUpdate.defaultExpectation.params)
		}
	}

	return mmStatusUpdate
}

// ExpectCtxParam1 sets up expected param ctx for PaymentServiceHandler.StatusUpdate
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) ExpectCtxParam1(ctx context.Context) *mPaymentServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceHandlerMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatusUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// ExpectPp1Param2 sets up expected param pp1 for PaymentServiceHandler.StatusUpdate
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) ExpectPp1Param2(pp1 *connect.Request[v11.StatusUpdateRequest]) *mPaymentServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceHandlerMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &PaymentServiceHandlerMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatusUpdate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// Inspect accepts an inspector function that has same arguments as the PaymentServiceHandler.StatusUpdate
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])) *mPaymentServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("Inspect function is already set for PaymentServiceHandlerMock.StatusUpdate")
	}

	mmStatusUpdate.mock.inspectFuncStatusUpdate = f

	return mmStatusUpdate
}

// Return sets up results that will be returned by PaymentServiceHandler.StatusUpdate
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Return(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *PaymentServiceHandlerMock {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &PaymentServiceHandlerMockStatusUpdateExpectation{mock: mmStatusUpdate.mock}
	}
	mmStatusUpdate.defaultExpectation.results = &PaymentServiceHandlerMockStatusUpdateResults{pp2, err}
	mmStatusUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// Set uses given function f to mock the PaymentServiceHandler.StatusUpdate method
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)) *PaymentServiceHandlerMock {
	if mmStatusUpdate.defaultExpectation != nil {
		mmStatusUpdate.mock.t.Fatalf("Default expectation is already set for the PaymentServiceHandler.StatusUpdate method")
	}

	if len(mmStatusUpdate.expectations) > 0 {
		mmStatusUpdate.mock.t.Fatalf("Some expectations are already set for the PaymentServiceHandler.StatusUpdate method")
	}

	mmStatusUpdate.mock.funcStatusUpdate = f
	mmStatusUpdate.mock.funcStatusUpdateOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// When sets expectation for the PaymentServiceHandler.StatusUpdate which will trigger the result defined by the following
// Then helper
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) When(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *PaymentServiceHandlerMockStatusUpdateExpectation {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("PaymentServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	expectation := &PaymentServiceHandlerMockStatusUpdateExpectation{
		mock:               mmStatusUpdate.mock,
		params:             &PaymentServiceHandlerMockStatusUpdateParams{ctx, pp1},
		expectationOrigins: PaymentServiceHandlerMockStatusUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatusUpdate.expectations = append(mmStatusUpdate.expectations, expectation)
	return expectation
}

// Then sets up PaymentServiceHandler.StatusUpdate return parameters for the expectation previously defined by the When method
func (e *PaymentServiceHandlerMockStatusUpdateExpectation) Then(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *PaymentServiceHandlerMock {
	e.results = &PaymentServiceHandlerMockStatusUpdateResults{pp2, err}
	return e.mock
}

// Times sets number of times PaymentServiceHandler.StatusUpdate should be invoked
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Times(n uint64) *mPaymentServiceHandlerMockStatusUpdate {
	if n == 0 {
		mmStatusUpdate.mock.t.Fatalf("Times of PaymentServiceHandlerMock.StatusUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatusUpdate.expectedInvocations, n)
	mmStatusUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate
}

func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) invocationsDone() bool {
	if len(mmStatusUpdate.expectations) == 0 && mmStatusUpdate.defaultExpectation == nil && mmStatusUpdate.mock.funcStatusUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.mock.afterStatusUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StatusUpdate implements mm_paymentv1connect.PaymentServiceHandler
func (mmStatusUpdate *PaymentServiceHandlerMock) StatusUpdate(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error) {
	mm_atomic.AddUint64(&mmStatusUpdate.beforeStatusUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmStatusUpdate.afterStatusUpdateCounter, 1)

	mmStatusUpdate.t.Helper()

	if mmStatusUpdate.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.inspectFuncStatusUpdate(ctx, pp1)
	}

	mm_params := PaymentServiceHandlerMockStatusUpdateParams{ctx, pp1}

	// Record call args
	mmStatusUpdate.StatusUpdateMock.mutex.Lock()
	mmStatusUpdate.StatusUpdateMock.callArgs = append(mmStatusUpdate.StatusUpdateMock.callArgs, &mm_params)
	mmStatusUpdate.StatusUpdateMock.mutex.Unlock()

	for _, e := range mmStatusUpdate.StatusUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatusUpdate.StatusUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatusUpdate.StatusUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmStatusUpdate.StatusUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmStatusUpdate.StatusUpdateMock.defaultExpectation.paramPtrs

		mm_got := PaymentServiceHandlerMockStatusUpdateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatusUpdate.t.Errorf("PaymentServiceHandlerMock.StatusUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatusUpdate.t.Errorf("PaymentServiceHandlerMock.StatusUpdate got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatusUpdate.t.Errorf("PaymentServiceHandlerMock.StatusUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatusUpdate.StatusUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmStatusUpdate.t.Fatal("No results are set for the PaymentServiceHandlerMock.StatusUpdate")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatusUpdate.funcStatusUpdate != nil {
		return mmStatusUpdate.funcStatusUpdate(ctx, pp1)
	}
	mmStatusUpdate.t.Fatalf("Unexpected call to PaymentServiceHandlerMock.StatusUpdate. %v %v", ctx, pp1)
	return
}

// StatusUpdateAfterCounter returns a count of finished PaymentServiceHandlerMock.StatusUpdate invocations
func (mmStatusUpdate *PaymentServiceHandlerMock) StatusUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.afterStatusUpdateCounter)
}

// StatusUpdateBeforeCounter returns a count of PaymentServiceHandlerMock.StatusUpdate invocations
func (mmStatusUpdate *PaymentServiceHandlerMock) StatusUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.beforeStatusUpdateCounter)
}

// Calls returns a list of arguments used in each call to PaymentServiceHandlerMock.StatusUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatusUpdate *mPaymentServiceHandlerMockStatusUpdate) Calls() []*PaymentServiceHandlerMockStatusUpdateParams {
	mmStatusUpdate.mutex.RLock()

	argCopy := make([]*PaymentServiceHandlerMockStatusUpdateParams, len(mmStatusUpdate.callArgs))
	copy(argCopy, mmStatusUpdate.callArgs)

	mmStatusUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockStatusUpdateDone returns true if the count of the StatusUpdate invocations corresponds
// the number of defined expectations
func (m *PaymentServiceHandlerMock) MinimockStatusUpdateDone() bool {
	if m.StatusUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusUpdateMock.invocationsDone()
}

// MinimockStatusUpdateInspect logs each unmet expectation
func (m *PaymentServiceHandlerMock) MinimockStatusUpdateInspect() {
	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.StatusUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusUpdateCounter := mm_atomic.LoadUint64(&m.afterStatusUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusUpdateMock.defaultExpectation != nil && afterStatusUpdateCounter < 1 {
		if m.StatusUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.StatusUpdate at\n%s", m.StatusUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PaymentServiceHandlerMock.StatusUpdate at\n%s with params: %#v", m.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *m.StatusUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatusUpdate != nil && afterStatusUpdateCounter < 1 {
		m.t.Errorf("Expected call to PaymentServiceHandlerMock.StatusUpdate at\n%s", m.funcStatusUpdateOrigin)
	}

	if !m.StatusUpdateMock.invocationsDone() && afterStatusUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to PaymentServiceHandlerMock.StatusUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusUpdateMock.expectedInvocations), m.StatusUpdateMock.expectedInvocationsOrigin, afterStatusUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PaymentServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePaymentLinkInspect()

			m.MinimockInitiatePromptInspect()

			m.MinimockReceiveInspect()

			m.MinimockReconcileInspect()

			m.MinimockReleaseInspect()

			m.MinimockSearchInspect()

			m.MinimockSendInspect()

			m.MinimockStatusInspect()

			m.MinimockStatusUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PaymentServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PaymentServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePaymentLinkDone() &&
		m.MinimockInitiatePromptDone() &&
		m.MinimockReceiveDone() &&
		m.MinimockReconcileDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockSearchDone() &&
		m.MinimockSendDone() &&
		m.MinimockStatusDone() &&
		m.MinimockStatusUpdateDone()
}
