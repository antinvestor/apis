// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	commonv1 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	"buf.build/gen/go/antinvestor/payment/connectrpc/go/payment/v1/paymentv1connect"
	paymentv1 "buf.build/gen/go/antinvestor/payment/protocolbuffers/go/payment/v1"
	"connectrpc.com/connect"
)

type FakePaymentServiceHandler struct {
	CreatePaymentLinkStub        func(context.Context, *connect.Request[paymentv1.CreatePaymentLinkRequest]) (*connect.Response[paymentv1.CreatePaymentLinkResponse], error)
	createPaymentLinkMutex       sync.RWMutex
	createPaymentLinkArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.CreatePaymentLinkRequest]
	}
	createPaymentLinkReturns struct {
		result1 *connect.Response[paymentv1.CreatePaymentLinkResponse]
		result2 error
	}
	createPaymentLinkReturnsOnCall map[int]struct {
		result1 *connect.Response[paymentv1.CreatePaymentLinkResponse]
		result2 error
	}
	InitiatePromptStub        func(context.Context, *connect.Request[paymentv1.InitiatePromptRequest]) (*connect.Response[paymentv1.InitiatePromptResponse], error)
	initiatePromptMutex       sync.RWMutex
	initiatePromptArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.InitiatePromptRequest]
	}
	initiatePromptReturns struct {
		result1 *connect.Response[paymentv1.InitiatePromptResponse]
		result2 error
	}
	initiatePromptReturnsOnCall map[int]struct {
		result1 *connect.Response[paymentv1.InitiatePromptResponse]
		result2 error
	}
	ReceiveStub        func(context.Context, *connect.Request[paymentv1.ReceiveRequest]) (*connect.Response[paymentv1.ReceiveResponse], error)
	receiveMutex       sync.RWMutex
	receiveArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.ReceiveRequest]
	}
	receiveReturns struct {
		result1 *connect.Response[paymentv1.ReceiveResponse]
		result2 error
	}
	receiveReturnsOnCall map[int]struct {
		result1 *connect.Response[paymentv1.ReceiveResponse]
		result2 error
	}
	ReconcileStub        func(context.Context, *connect.Request[paymentv1.ReconcileRequest]) (*connect.Response[paymentv1.ReconcileResponse], error)
	reconcileMutex       sync.RWMutex
	reconcileArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.ReconcileRequest]
	}
	reconcileReturns struct {
		result1 *connect.Response[paymentv1.ReconcileResponse]
		result2 error
	}
	reconcileReturnsOnCall map[int]struct {
		result1 *connect.Response[paymentv1.ReconcileResponse]
		result2 error
	}
	ReleaseStub        func(context.Context, *connect.Request[paymentv1.ReleaseRequest]) (*connect.Response[paymentv1.ReleaseResponse], error)
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.ReleaseRequest]
	}
	releaseReturns struct {
		result1 *connect.Response[paymentv1.ReleaseResponse]
		result2 error
	}
	releaseReturnsOnCall map[int]struct {
		result1 *connect.Response[paymentv1.ReleaseResponse]
		result2 error
	}
	SearchStub        func(context.Context, *connect.Request[commonv1.SearchRequest], *connect.ServerStream[paymentv1.SearchResponse]) error
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.SearchRequest]
		arg3 *connect.ServerStream[paymentv1.SearchResponse]
	}
	searchReturns struct {
		result1 error
	}
	searchReturnsOnCall map[int]struct {
		result1 error
	}
	SendStub        func(context.Context, *connect.Request[paymentv1.SendRequest]) (*connect.Response[paymentv1.SendResponse], error)
	sendMutex       sync.RWMutex
	sendArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.SendRequest]
	}
	sendReturns struct {
		result1 *connect.Response[paymentv1.SendResponse]
		result2 error
	}
	sendReturnsOnCall map[int]struct {
		result1 *connect.Response[paymentv1.SendResponse]
		result2 error
	}
	StatusStub        func(context.Context, *connect.Request[commonv1.StatusRequest]) (*connect.Response[commonv1.StatusResponse], error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusRequest]
	}
	statusReturns struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}
	StatusUpdateStub        func(context.Context, *connect.Request[commonv1.StatusUpdateRequest]) (*connect.Response[commonv1.StatusUpdateResponse], error)
	statusUpdateMutex       sync.RWMutex
	statusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusUpdateRequest]
	}
	statusUpdateReturns struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}
	statusUpdateReturnsOnCall map[int]struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePaymentServiceHandler) CreatePaymentLink(arg1 context.Context, arg2 *connect.Request[paymentv1.CreatePaymentLinkRequest]) (*connect.Response[paymentv1.CreatePaymentLinkResponse], error) {
	fake.createPaymentLinkMutex.Lock()
	ret, specificReturn := fake.createPaymentLinkReturnsOnCall[len(fake.createPaymentLinkArgsForCall)]
	fake.createPaymentLinkArgsForCall = append(fake.createPaymentLinkArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.CreatePaymentLinkRequest]
	}{arg1, arg2})
	stub := fake.CreatePaymentLinkStub
	fakeReturns := fake.createPaymentLinkReturns
	fake.recordInvocation("CreatePaymentLink", []interface{}{arg1, arg2})
	fake.createPaymentLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) CreatePaymentLinkCallCount() int {
	fake.createPaymentLinkMutex.RLock()
	defer fake.createPaymentLinkMutex.RUnlock()
	return len(fake.createPaymentLinkArgsForCall)
}

func (fake *FakePaymentServiceHandler) CreatePaymentLinkCalls(stub func(context.Context, *connect.Request[paymentv1.CreatePaymentLinkRequest]) (*connect.Response[paymentv1.CreatePaymentLinkResponse], error)) {
	fake.createPaymentLinkMutex.Lock()
	defer fake.createPaymentLinkMutex.Unlock()
	fake.CreatePaymentLinkStub = stub
}

func (fake *FakePaymentServiceHandler) CreatePaymentLinkArgsForCall(i int) (context.Context, *connect.Request[paymentv1.CreatePaymentLinkRequest]) {
	fake.createPaymentLinkMutex.RLock()
	defer fake.createPaymentLinkMutex.RUnlock()
	argsForCall := fake.createPaymentLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) CreatePaymentLinkReturns(result1 *connect.Response[paymentv1.CreatePaymentLinkResponse], result2 error) {
	fake.createPaymentLinkMutex.Lock()
	defer fake.createPaymentLinkMutex.Unlock()
	fake.CreatePaymentLinkStub = nil
	fake.createPaymentLinkReturns = struct {
		result1 *connect.Response[paymentv1.CreatePaymentLinkResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) CreatePaymentLinkReturnsOnCall(i int, result1 *connect.Response[paymentv1.CreatePaymentLinkResponse], result2 error) {
	fake.createPaymentLinkMutex.Lock()
	defer fake.createPaymentLinkMutex.Unlock()
	fake.CreatePaymentLinkStub = nil
	if fake.createPaymentLinkReturnsOnCall == nil {
		fake.createPaymentLinkReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[paymentv1.CreatePaymentLinkResponse]
			result2 error
		})
	}
	fake.createPaymentLinkReturnsOnCall[i] = struct {
		result1 *connect.Response[paymentv1.CreatePaymentLinkResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) InitiatePrompt(arg1 context.Context, arg2 *connect.Request[paymentv1.InitiatePromptRequest]) (*connect.Response[paymentv1.InitiatePromptResponse], error) {
	fake.initiatePromptMutex.Lock()
	ret, specificReturn := fake.initiatePromptReturnsOnCall[len(fake.initiatePromptArgsForCall)]
	fake.initiatePromptArgsForCall = append(fake.initiatePromptArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.InitiatePromptRequest]
	}{arg1, arg2})
	stub := fake.InitiatePromptStub
	fakeReturns := fake.initiatePromptReturns
	fake.recordInvocation("InitiatePrompt", []interface{}{arg1, arg2})
	fake.initiatePromptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) InitiatePromptCallCount() int {
	fake.initiatePromptMutex.RLock()
	defer fake.initiatePromptMutex.RUnlock()
	return len(fake.initiatePromptArgsForCall)
}

func (fake *FakePaymentServiceHandler) InitiatePromptCalls(stub func(context.Context, *connect.Request[paymentv1.InitiatePromptRequest]) (*connect.Response[paymentv1.InitiatePromptResponse], error)) {
	fake.initiatePromptMutex.Lock()
	defer fake.initiatePromptMutex.Unlock()
	fake.InitiatePromptStub = stub
}

func (fake *FakePaymentServiceHandler) InitiatePromptArgsForCall(i int) (context.Context, *connect.Request[paymentv1.InitiatePromptRequest]) {
	fake.initiatePromptMutex.RLock()
	defer fake.initiatePromptMutex.RUnlock()
	argsForCall := fake.initiatePromptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) InitiatePromptReturns(result1 *connect.Response[paymentv1.InitiatePromptResponse], result2 error) {
	fake.initiatePromptMutex.Lock()
	defer fake.initiatePromptMutex.Unlock()
	fake.InitiatePromptStub = nil
	fake.initiatePromptReturns = struct {
		result1 *connect.Response[paymentv1.InitiatePromptResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) InitiatePromptReturnsOnCall(i int, result1 *connect.Response[paymentv1.InitiatePromptResponse], result2 error) {
	fake.initiatePromptMutex.Lock()
	defer fake.initiatePromptMutex.Unlock()
	fake.InitiatePromptStub = nil
	if fake.initiatePromptReturnsOnCall == nil {
		fake.initiatePromptReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[paymentv1.InitiatePromptResponse]
			result2 error
		})
	}
	fake.initiatePromptReturnsOnCall[i] = struct {
		result1 *connect.Response[paymentv1.InitiatePromptResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) Receive(arg1 context.Context, arg2 *connect.Request[paymentv1.ReceiveRequest]) (*connect.Response[paymentv1.ReceiveResponse], error) {
	fake.receiveMutex.Lock()
	ret, specificReturn := fake.receiveReturnsOnCall[len(fake.receiveArgsForCall)]
	fake.receiveArgsForCall = append(fake.receiveArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.ReceiveRequest]
	}{arg1, arg2})
	stub := fake.ReceiveStub
	fakeReturns := fake.receiveReturns
	fake.recordInvocation("Receive", []interface{}{arg1, arg2})
	fake.receiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) ReceiveCallCount() int {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	return len(fake.receiveArgsForCall)
}

func (fake *FakePaymentServiceHandler) ReceiveCalls(stub func(context.Context, *connect.Request[paymentv1.ReceiveRequest]) (*connect.Response[paymentv1.ReceiveResponse], error)) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = stub
}

func (fake *FakePaymentServiceHandler) ReceiveArgsForCall(i int) (context.Context, *connect.Request[paymentv1.ReceiveRequest]) {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	argsForCall := fake.receiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) ReceiveReturns(result1 *connect.Response[paymentv1.ReceiveResponse], result2 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	fake.receiveReturns = struct {
		result1 *connect.Response[paymentv1.ReceiveResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) ReceiveReturnsOnCall(i int, result1 *connect.Response[paymentv1.ReceiveResponse], result2 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	if fake.receiveReturnsOnCall == nil {
		fake.receiveReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[paymentv1.ReceiveResponse]
			result2 error
		})
	}
	fake.receiveReturnsOnCall[i] = struct {
		result1 *connect.Response[paymentv1.ReceiveResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) Reconcile(arg1 context.Context, arg2 *connect.Request[paymentv1.ReconcileRequest]) (*connect.Response[paymentv1.ReconcileResponse], error) {
	fake.reconcileMutex.Lock()
	ret, specificReturn := fake.reconcileReturnsOnCall[len(fake.reconcileArgsForCall)]
	fake.reconcileArgsForCall = append(fake.reconcileArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.ReconcileRequest]
	}{arg1, arg2})
	stub := fake.ReconcileStub
	fakeReturns := fake.reconcileReturns
	fake.recordInvocation("Reconcile", []interface{}{arg1, arg2})
	fake.reconcileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) ReconcileCallCount() int {
	fake.reconcileMutex.RLock()
	defer fake.reconcileMutex.RUnlock()
	return len(fake.reconcileArgsForCall)
}

func (fake *FakePaymentServiceHandler) ReconcileCalls(stub func(context.Context, *connect.Request[paymentv1.ReconcileRequest]) (*connect.Response[paymentv1.ReconcileResponse], error)) {
	fake.reconcileMutex.Lock()
	defer fake.reconcileMutex.Unlock()
	fake.ReconcileStub = stub
}

func (fake *FakePaymentServiceHandler) ReconcileArgsForCall(i int) (context.Context, *connect.Request[paymentv1.ReconcileRequest]) {
	fake.reconcileMutex.RLock()
	defer fake.reconcileMutex.RUnlock()
	argsForCall := fake.reconcileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) ReconcileReturns(result1 *connect.Response[paymentv1.ReconcileResponse], result2 error) {
	fake.reconcileMutex.Lock()
	defer fake.reconcileMutex.Unlock()
	fake.ReconcileStub = nil
	fake.reconcileReturns = struct {
		result1 *connect.Response[paymentv1.ReconcileResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) ReconcileReturnsOnCall(i int, result1 *connect.Response[paymentv1.ReconcileResponse], result2 error) {
	fake.reconcileMutex.Lock()
	defer fake.reconcileMutex.Unlock()
	fake.ReconcileStub = nil
	if fake.reconcileReturnsOnCall == nil {
		fake.reconcileReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[paymentv1.ReconcileResponse]
			result2 error
		})
	}
	fake.reconcileReturnsOnCall[i] = struct {
		result1 *connect.Response[paymentv1.ReconcileResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) Release(arg1 context.Context, arg2 *connect.Request[paymentv1.ReleaseRequest]) (*connect.Response[paymentv1.ReleaseResponse], error) {
	fake.releaseMutex.Lock()
	ret, specificReturn := fake.releaseReturnsOnCall[len(fake.releaseArgsForCall)]
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.ReleaseRequest]
	}{arg1, arg2})
	stub := fake.ReleaseStub
	fakeReturns := fake.releaseReturns
	fake.recordInvocation("Release", []interface{}{arg1, arg2})
	fake.releaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

func (fake *FakePaymentServiceHandler) ReleaseCalls(stub func(context.Context, *connect.Request[paymentv1.ReleaseRequest]) (*connect.Response[paymentv1.ReleaseResponse], error)) {
	fake.releaseMutex.Lock()
	defer fake.releaseMutex.Unlock()
	fake.ReleaseStub = stub
}

func (fake *FakePaymentServiceHandler) ReleaseArgsForCall(i int) (context.Context, *connect.Request[paymentv1.ReleaseRequest]) {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	argsForCall := fake.releaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) ReleaseReturns(result1 *connect.Response[paymentv1.ReleaseResponse], result2 error) {
	fake.releaseMutex.Lock()
	defer fake.releaseMutex.Unlock()
	fake.ReleaseStub = nil
	fake.releaseReturns = struct {
		result1 *connect.Response[paymentv1.ReleaseResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) ReleaseReturnsOnCall(i int, result1 *connect.Response[paymentv1.ReleaseResponse], result2 error) {
	fake.releaseMutex.Lock()
	defer fake.releaseMutex.Unlock()
	fake.ReleaseStub = nil
	if fake.releaseReturnsOnCall == nil {
		fake.releaseReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[paymentv1.ReleaseResponse]
			result2 error
		})
	}
	fake.releaseReturnsOnCall[i] = struct {
		result1 *connect.Response[paymentv1.ReleaseResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) Search(arg1 context.Context, arg2 *connect.Request[commonv1.SearchRequest], arg3 *connect.ServerStream[paymentv1.SearchResponse]) error {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.SearchRequest]
		arg3 *connect.ServerStream[paymentv1.SearchResponse]
	}{arg1, arg2, arg3})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1, arg2, arg3})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePaymentServiceHandler) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *FakePaymentServiceHandler) SearchCalls(stub func(context.Context, *connect.Request[commonv1.SearchRequest], *connect.ServerStream[paymentv1.SearchResponse]) error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *FakePaymentServiceHandler) SearchArgsForCall(i int) (context.Context, *connect.Request[commonv1.SearchRequest], *connect.ServerStream[paymentv1.SearchResponse]) {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePaymentServiceHandler) SearchReturns(result1 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentServiceHandler) SearchReturnsOnCall(i int, result1 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePaymentServiceHandler) Send(arg1 context.Context, arg2 *connect.Request[paymentv1.SendRequest]) (*connect.Response[paymentv1.SendResponse], error) {
	fake.sendMutex.Lock()
	ret, specificReturn := fake.sendReturnsOnCall[len(fake.sendArgsForCall)]
	fake.sendArgsForCall = append(fake.sendArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[paymentv1.SendRequest]
	}{arg1, arg2})
	stub := fake.SendStub
	fakeReturns := fake.sendReturns
	fake.recordInvocation("Send", []interface{}{arg1, arg2})
	fake.sendMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) SendCallCount() int {
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	return len(fake.sendArgsForCall)
}

func (fake *FakePaymentServiceHandler) SendCalls(stub func(context.Context, *connect.Request[paymentv1.SendRequest]) (*connect.Response[paymentv1.SendResponse], error)) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = stub
}

func (fake *FakePaymentServiceHandler) SendArgsForCall(i int) (context.Context, *connect.Request[paymentv1.SendRequest]) {
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	argsForCall := fake.sendArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) SendReturns(result1 *connect.Response[paymentv1.SendResponse], result2 error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = nil
	fake.sendReturns = struct {
		result1 *connect.Response[paymentv1.SendResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) SendReturnsOnCall(i int, result1 *connect.Response[paymentv1.SendResponse], result2 error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = nil
	if fake.sendReturnsOnCall == nil {
		fake.sendReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[paymentv1.SendResponse]
			result2 error
		})
	}
	fake.sendReturnsOnCall[i] = struct {
		result1 *connect.Response[paymentv1.SendResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) Status(arg1 context.Context, arg2 *connect.Request[commonv1.StatusRequest]) (*connect.Response[commonv1.StatusResponse], error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusRequest]
	}{arg1, arg2})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{arg1, arg2})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakePaymentServiceHandler) StatusCalls(stub func(context.Context, *connect.Request[commonv1.StatusRequest]) (*connect.Response[commonv1.StatusResponse], error)) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakePaymentServiceHandler) StatusArgsForCall(i int) (context.Context, *connect.Request[commonv1.StatusRequest]) {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	argsForCall := fake.statusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) StatusReturns(result1 *connect.Response[commonv1.StatusResponse], result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) StatusReturnsOnCall(i int, result1 *connect.Response[commonv1.StatusResponse], result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[commonv1.StatusResponse]
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) StatusUpdate(arg1 context.Context, arg2 *connect.Request[commonv1.StatusUpdateRequest]) (*connect.Response[commonv1.StatusUpdateResponse], error) {
	fake.statusUpdateMutex.Lock()
	ret, specificReturn := fake.statusUpdateReturnsOnCall[len(fake.statusUpdateArgsForCall)]
	fake.statusUpdateArgsForCall = append(fake.statusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusUpdateRequest]
	}{arg1, arg2})
	stub := fake.StatusUpdateStub
	fakeReturns := fake.statusUpdateReturns
	fake.recordInvocation("StatusUpdate", []interface{}{arg1, arg2})
	fake.statusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePaymentServiceHandler) StatusUpdateCallCount() int {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	return len(fake.statusUpdateArgsForCall)
}

func (fake *FakePaymentServiceHandler) StatusUpdateCalls(stub func(context.Context, *connect.Request[commonv1.StatusUpdateRequest]) (*connect.Response[commonv1.StatusUpdateResponse], error)) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = stub
}

func (fake *FakePaymentServiceHandler) StatusUpdateArgsForCall(i int) (context.Context, *connect.Request[commonv1.StatusUpdateRequest]) {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	argsForCall := fake.statusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePaymentServiceHandler) StatusUpdateReturns(result1 *connect.Response[commonv1.StatusUpdateResponse], result2 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	fake.statusUpdateReturns = struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) StatusUpdateReturnsOnCall(i int, result1 *connect.Response[commonv1.StatusUpdateResponse], result2 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	if fake.statusUpdateReturnsOnCall == nil {
		fake.statusUpdateReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[commonv1.StatusUpdateResponse]
			result2 error
		})
	}
	fake.statusUpdateReturnsOnCall[i] = struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePaymentServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePaymentServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ paymentv1connect.PaymentServiceHandler = new(FakePaymentServiceHandler)
