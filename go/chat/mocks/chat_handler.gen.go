// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/chat/connectrpc/go/chat/v1/chatv1connect.ChatServiceClient -o chat_handler.gen.go -n ChatServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/chat/protocolbuffers/go/chat/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// ChatServiceClientMock implements mm_chatv1connect.ChatServiceClient
type ChatServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddRoomSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error)
	funcAddRoomSubscriptionsOrigin    string
	inspectFuncAddRoomSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest])
	afterAddRoomSubscriptionsCounter  uint64
	beforeAddRoomSubscriptionsCounter uint64
	AddRoomSubscriptionsMock          mChatServiceClientMockAddRoomSubscriptions

	funcCreateRoom          func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) (pp2 *connect.Response[v1.CreateRoomResponse], err error)
	funcCreateRoomOrigin    string
	inspectFuncCreateRoom   func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest])
	afterCreateRoomCounter  uint64
	beforeCreateRoomCounter uint64
	CreateRoomMock          mChatServiceClientMockCreateRoom

	funcDeleteRoom          func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) (pp2 *connect.Response[v1.DeleteRoomResponse], err error)
	funcDeleteRoomOrigin    string
	inspectFuncDeleteRoom   func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest])
	afterDeleteRoomCounter  uint64
	beforeDeleteRoomCounter uint64
	DeleteRoomMock          mChatServiceClientMockDeleteRoom

	funcGetClientState          func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) (pp2 *connect.Response[v1.GetClientStateResponse], err error)
	funcGetClientStateOrigin    string
	inspectFuncGetClientState   func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest])
	afterGetClientStateCounter  uint64
	beforeGetClientStateCounter uint64
	GetClientStateMock          mChatServiceClientMockGetClientState

	funcGetHistory          func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) (pp2 *connect.Response[v1.GetHistoryResponse], err error)
	funcGetHistoryOrigin    string
	inspectFuncGetHistory   func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest])
	afterGetHistoryCounter  uint64
	beforeGetHistoryCounter uint64
	GetHistoryMock          mChatServiceClientMockGetHistory

	funcRemoveRoomSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error)
	funcRemoveRoomSubscriptionsOrigin    string
	inspectFuncRemoveRoomSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest])
	afterRemoveRoomSubscriptionsCounter  uint64
	beforeRemoveRoomSubscriptionsCounter uint64
	RemoveRoomSubscriptionsMock          mChatServiceClientMockRemoveRoomSubscriptions

	funcSearchRoomSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error)
	funcSearchRoomSubscriptionsOrigin    string
	inspectFuncSearchRoomSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest])
	afterSearchRoomSubscriptionsCounter  uint64
	beforeSearchRoomSubscriptionsCounter uint64
	SearchRoomSubscriptionsMock          mChatServiceClientMockSearchRoomSubscriptions

	funcSearchRooms          func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchRoomsResponse], err error)
	funcSearchRoomsOrigin    string
	inspectFuncSearchRooms   func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest])
	afterSearchRoomsCounter  uint64
	beforeSearchRoomsCounter uint64
	SearchRoomsMock          mChatServiceClientMockSearchRooms

	funcSendEvent          func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) (pp2 *connect.Response[v1.SendEventResponse], err error)
	funcSendEventOrigin    string
	inspectFuncSendEvent   func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest])
	afterSendEventCounter  uint64
	beforeSendEventCounter uint64
	SendEventMock          mChatServiceClientMockSendEvent

	funcUpdateClientState          func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) (pp2 *connect.Response[v1.UpdateClientStateResponse], err error)
	funcUpdateClientStateOrigin    string
	inspectFuncUpdateClientState   func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest])
	afterUpdateClientStateCounter  uint64
	beforeUpdateClientStateCounter uint64
	UpdateClientStateMock          mChatServiceClientMockUpdateClientState

	funcUpdateRoom          func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) (pp2 *connect.Response[v1.UpdateRoomResponse], err error)
	funcUpdateRoomOrigin    string
	inspectFuncUpdateRoom   func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest])
	afterUpdateRoomCounter  uint64
	beforeUpdateRoomCounter uint64
	UpdateRoomMock          mChatServiceClientMockUpdateRoom

	funcUpdateSubscriptionRole          func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) (pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error)
	funcUpdateSubscriptionRoleOrigin    string
	inspectFuncUpdateSubscriptionRole   func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest])
	afterUpdateSubscriptionRoleCounter  uint64
	beforeUpdateSubscriptionRoleCounter uint64
	UpdateSubscriptionRoleMock          mChatServiceClientMockUpdateSubscriptionRole
}

// NewChatServiceClientMock returns a mock for mm_chatv1connect.ChatServiceClient
func NewChatServiceClientMock(t minimock.Tester) *ChatServiceClientMock {
	m := &ChatServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddRoomSubscriptionsMock = mChatServiceClientMockAddRoomSubscriptions{mock: m}
	m.AddRoomSubscriptionsMock.callArgs = []*ChatServiceClientMockAddRoomSubscriptionsParams{}

	m.CreateRoomMock = mChatServiceClientMockCreateRoom{mock: m}
	m.CreateRoomMock.callArgs = []*ChatServiceClientMockCreateRoomParams{}

	m.DeleteRoomMock = mChatServiceClientMockDeleteRoom{mock: m}
	m.DeleteRoomMock.callArgs = []*ChatServiceClientMockDeleteRoomParams{}

	m.GetClientStateMock = mChatServiceClientMockGetClientState{mock: m}
	m.GetClientStateMock.callArgs = []*ChatServiceClientMockGetClientStateParams{}

	m.GetHistoryMock = mChatServiceClientMockGetHistory{mock: m}
	m.GetHistoryMock.callArgs = []*ChatServiceClientMockGetHistoryParams{}

	m.RemoveRoomSubscriptionsMock = mChatServiceClientMockRemoveRoomSubscriptions{mock: m}
	m.RemoveRoomSubscriptionsMock.callArgs = []*ChatServiceClientMockRemoveRoomSubscriptionsParams{}

	m.SearchRoomSubscriptionsMock = mChatServiceClientMockSearchRoomSubscriptions{mock: m}
	m.SearchRoomSubscriptionsMock.callArgs = []*ChatServiceClientMockSearchRoomSubscriptionsParams{}

	m.SearchRoomsMock = mChatServiceClientMockSearchRooms{mock: m}
	m.SearchRoomsMock.callArgs = []*ChatServiceClientMockSearchRoomsParams{}

	m.SendEventMock = mChatServiceClientMockSendEvent{mock: m}
	m.SendEventMock.callArgs = []*ChatServiceClientMockSendEventParams{}

	m.UpdateClientStateMock = mChatServiceClientMockUpdateClientState{mock: m}
	m.UpdateClientStateMock.callArgs = []*ChatServiceClientMockUpdateClientStateParams{}

	m.UpdateRoomMock = mChatServiceClientMockUpdateRoom{mock: m}
	m.UpdateRoomMock.callArgs = []*ChatServiceClientMockUpdateRoomParams{}

	m.UpdateSubscriptionRoleMock = mChatServiceClientMockUpdateSubscriptionRole{mock: m}
	m.UpdateSubscriptionRoleMock.callArgs = []*ChatServiceClientMockUpdateSubscriptionRoleParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceClientMockAddRoomSubscriptions struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockAddRoomSubscriptionsExpectation
	expectations       []*ChatServiceClientMockAddRoomSubscriptionsExpectation

	callArgs []*ChatServiceClientMockAddRoomSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockAddRoomSubscriptionsExpectation specifies expectation struct of the ChatServiceClient.AddRoomSubscriptions
type ChatServiceClientMockAddRoomSubscriptionsExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockAddRoomSubscriptionsParams
	paramPtrs          *ChatServiceClientMockAddRoomSubscriptionsParamPtrs
	expectationOrigins ChatServiceClientMockAddRoomSubscriptionsExpectationOrigins
	results            *ChatServiceClientMockAddRoomSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockAddRoomSubscriptionsParams contains parameters of the ChatServiceClient.AddRoomSubscriptions
type ChatServiceClientMockAddRoomSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]
}

// ChatServiceClientMockAddRoomSubscriptionsParamPtrs contains pointers to parameters of the ChatServiceClient.AddRoomSubscriptions
type ChatServiceClientMockAddRoomSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddRoomSubscriptionsRequest]
}

// ChatServiceClientMockAddRoomSubscriptionsResults contains results of the ChatServiceClient.AddRoomSubscriptions
type ChatServiceClientMockAddRoomSubscriptionsResults struct {
	pp2 *connect.Response[v1.AddRoomSubscriptionsResponse]
	err error
}

// ChatServiceClientMockAddRoomSubscriptionsOrigins contains origins of expectations of the ChatServiceClient.AddRoomSubscriptions
type ChatServiceClientMockAddRoomSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Optional() *mChatServiceClientMockAddRoomSubscriptions {
	mmAddRoomSubscriptions.optional = true
	return mmAddRoomSubscriptions
}

// Expect sets up expected params for ChatServiceClient.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) *mChatServiceClientMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceClientMockAddRoomSubscriptionsExpectation{}
	}

	if mmAddRoomSubscriptions.defaultExpectation.paramPtrs != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by ExpectParams functions")
	}

	mmAddRoomSubscriptions.defaultExpectation.params = &ChatServiceClientMockAddRoomSubscriptionsParams{ctx, pp1}
	mmAddRoomSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddRoomSubscriptions.expectations {
		if minimock.Equal(e.params, mmAddRoomSubscriptions.defaultExpectation.params) {
			mmAddRoomSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRoomSubscriptions.defaultExpectation.params)
		}
	}

	return mmAddRoomSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceClientMockAddRoomSubscriptionsExpectation{}
	}

	if mmAddRoomSubscriptions.defaultExpectation.params != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Expect")
	}

	if mmAddRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmAddRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceClientMockAddRoomSubscriptionsParamPtrs{}
	}
	mmAddRoomSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddRoomSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddRoomSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) *mChatServiceClientMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceClientMockAddRoomSubscriptionsExpectation{}
	}

	if mmAddRoomSubscriptions.defaultExpectation.params != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Expect")
	}

	if mmAddRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmAddRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceClientMockAddRoomSubscriptionsParamPtrs{}
	}
	mmAddRoomSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddRoomSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddRoomSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest])) *mChatServiceClientMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.inspectFuncAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.AddRoomSubscriptions")
	}

	mmAddRoomSubscriptions.mock.inspectFuncAddRoomSubscriptions = f

	return mmAddRoomSubscriptions
}

// Return sets up results that will be returned by ChatServiceClient.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Return(pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error) *ChatServiceClientMock {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceClientMockAddRoomSubscriptionsExpectation{mock: mmAddRoomSubscriptions.mock}
	}
	mmAddRoomSubscriptions.defaultExpectation.results = &ChatServiceClientMockAddRoomSubscriptionsResults{pp2, err}
	mmAddRoomSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddRoomSubscriptions.mock
}

// Set uses given function f to mock the ChatServiceClient.AddRoomSubscriptions method
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error)) *ChatServiceClientMock {
	if mmAddRoomSubscriptions.defaultExpectation != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.AddRoomSubscriptions method")
	}

	if len(mmAddRoomSubscriptions.expectations) > 0 {
		mmAddRoomSubscriptions.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.AddRoomSubscriptions method")
	}

	mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions = f
	mmAddRoomSubscriptions.mock.funcAddRoomSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmAddRoomSubscriptions.mock
}

// When sets expectation for the ChatServiceClient.AddRoomSubscriptions which will trigger the result defined by the following
// Then helper
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) *ChatServiceClientMockAddRoomSubscriptionsExpectation {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.AddRoomSubscriptions mock is already set by Set")
	}

	expectation := &ChatServiceClientMockAddRoomSubscriptionsExpectation{
		mock:               mmAddRoomSubscriptions.mock,
		params:             &ChatServiceClientMockAddRoomSubscriptionsParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockAddRoomSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddRoomSubscriptions.expectations = append(mmAddRoomSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.AddRoomSubscriptions return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockAddRoomSubscriptionsExpectation) Then(pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockAddRoomSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.AddRoomSubscriptions should be invoked
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Times(n uint64) *mChatServiceClientMockAddRoomSubscriptions {
	if n == 0 {
		mmAddRoomSubscriptions.mock.t.Fatalf("Times of ChatServiceClientMock.AddRoomSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddRoomSubscriptions.expectedInvocations, n)
	mmAddRoomSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddRoomSubscriptions
}

func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) invocationsDone() bool {
	if len(mmAddRoomSubscriptions.expectations) == 0 && mmAddRoomSubscriptions.defaultExpectation == nil && mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddRoomSubscriptions.mock.afterAddRoomSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddRoomSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddRoomSubscriptions implements mm_chatv1connect.ChatServiceClient
func (mmAddRoomSubscriptions *ChatServiceClientMock) AddRoomSubscriptions(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmAddRoomSubscriptions.beforeAddRoomSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRoomSubscriptions.afterAddRoomSubscriptionsCounter, 1)

	mmAddRoomSubscriptions.t.Helper()

	if mmAddRoomSubscriptions.inspectFuncAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.inspectFuncAddRoomSubscriptions(ctx, pp1)
	}

	mm_params := ChatServiceClientMockAddRoomSubscriptionsParams{ctx, pp1}

	// Record call args
	mmAddRoomSubscriptions.AddRoomSubscriptionsMock.mutex.Lock()
	mmAddRoomSubscriptions.AddRoomSubscriptionsMock.callArgs = append(mmAddRoomSubscriptions.AddRoomSubscriptionsMock.callArgs, &mm_params)
	mmAddRoomSubscriptions.AddRoomSubscriptionsMock.mutex.Unlock()

	for _, e := range mmAddRoomSubscriptions.AddRoomSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockAddRoomSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddRoomSubscriptions.t.Errorf("ChatServiceClientMock.AddRoomSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddRoomSubscriptions.t.Errorf("ChatServiceClientMock.AddRoomSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddRoomSubscriptions.t.Errorf("ChatServiceClientMock.AddRoomSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddRoomSubscriptions.t.Fatal("No results are set for the ChatServiceClientMock.AddRoomSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddRoomSubscriptions.funcAddRoomSubscriptions != nil {
		return mmAddRoomSubscriptions.funcAddRoomSubscriptions(ctx, pp1)
	}
	mmAddRoomSubscriptions.t.Fatalf("Unexpected call to ChatServiceClientMock.AddRoomSubscriptions. %v %v", ctx, pp1)
	return
}

// AddRoomSubscriptionsAfterCounter returns a count of finished ChatServiceClientMock.AddRoomSubscriptions invocations
func (mmAddRoomSubscriptions *ChatServiceClientMock) AddRoomSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRoomSubscriptions.afterAddRoomSubscriptionsCounter)
}

// AddRoomSubscriptionsBeforeCounter returns a count of ChatServiceClientMock.AddRoomSubscriptions invocations
func (mmAddRoomSubscriptions *ChatServiceClientMock) AddRoomSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRoomSubscriptions.beforeAddRoomSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.AddRoomSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRoomSubscriptions *mChatServiceClientMockAddRoomSubscriptions) Calls() []*ChatServiceClientMockAddRoomSubscriptionsParams {
	mmAddRoomSubscriptions.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockAddRoomSubscriptionsParams, len(mmAddRoomSubscriptions.callArgs))
	copy(argCopy, mmAddRoomSubscriptions.callArgs)

	mmAddRoomSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockAddRoomSubscriptionsDone returns true if the count of the AddRoomSubscriptions invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockAddRoomSubscriptionsDone() bool {
	if m.AddRoomSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddRoomSubscriptionsMock.invocationsDone()
}

// MinimockAddRoomSubscriptionsInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockAddRoomSubscriptionsInspect() {
	for _, e := range m.AddRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.AddRoomSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddRoomSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterAddRoomSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddRoomSubscriptionsMock.defaultExpectation != nil && afterAddRoomSubscriptionsCounter < 1 {
		if m.AddRoomSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.AddRoomSubscriptions at\n%s", m.AddRoomSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.AddRoomSubscriptions at\n%s with params: %#v", m.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.AddRoomSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRoomSubscriptions != nil && afterAddRoomSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.AddRoomSubscriptions at\n%s", m.funcAddRoomSubscriptionsOrigin)
	}

	if !m.AddRoomSubscriptionsMock.invocationsDone() && afterAddRoomSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.AddRoomSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddRoomSubscriptionsMock.expectedInvocations), m.AddRoomSubscriptionsMock.expectedInvocationsOrigin, afterAddRoomSubscriptionsCounter)
	}
}

type mChatServiceClientMockCreateRoom struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockCreateRoomExpectation
	expectations       []*ChatServiceClientMockCreateRoomExpectation

	callArgs []*ChatServiceClientMockCreateRoomParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockCreateRoomExpectation specifies expectation struct of the ChatServiceClient.CreateRoom
type ChatServiceClientMockCreateRoomExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockCreateRoomParams
	paramPtrs          *ChatServiceClientMockCreateRoomParamPtrs
	expectationOrigins ChatServiceClientMockCreateRoomExpectationOrigins
	results            *ChatServiceClientMockCreateRoomResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockCreateRoomParams contains parameters of the ChatServiceClient.CreateRoom
type ChatServiceClientMockCreateRoomParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateRoomRequest]
}

// ChatServiceClientMockCreateRoomParamPtrs contains pointers to parameters of the ChatServiceClient.CreateRoom
type ChatServiceClientMockCreateRoomParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateRoomRequest]
}

// ChatServiceClientMockCreateRoomResults contains results of the ChatServiceClient.CreateRoom
type ChatServiceClientMockCreateRoomResults struct {
	pp2 *connect.Response[v1.CreateRoomResponse]
	err error
}

// ChatServiceClientMockCreateRoomOrigins contains origins of expectations of the ChatServiceClient.CreateRoom
type ChatServiceClientMockCreateRoomExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Optional() *mChatServiceClientMockCreateRoom {
	mmCreateRoom.optional = true
	return mmCreateRoom
}

// Expect sets up expected params for ChatServiceClient.CreateRoom
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) *mChatServiceClientMockCreateRoom {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceClientMockCreateRoomExpectation{}
	}

	if mmCreateRoom.defaultExpectation.paramPtrs != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by ExpectParams functions")
	}

	mmCreateRoom.defaultExpectation.params = &ChatServiceClientMockCreateRoomParams{ctx, pp1}
	mmCreateRoom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRoom.expectations {
		if minimock.Equal(e.params, mmCreateRoom.defaultExpectation.params) {
			mmCreateRoom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRoom.defaultExpectation.params)
		}
	}

	return mmCreateRoom
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.CreateRoom
func (mmCreateRoom *mChatServiceClientMockCreateRoom) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockCreateRoom {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceClientMockCreateRoomExpectation{}
	}

	if mmCreateRoom.defaultExpectation.params != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Expect")
	}

	if mmCreateRoom.defaultExpectation.paramPtrs == nil {
		mmCreateRoom.defaultExpectation.paramPtrs = &ChatServiceClientMockCreateRoomParamPtrs{}
	}
	mmCreateRoom.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRoom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRoom
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.CreateRoom
func (mmCreateRoom *mChatServiceClientMockCreateRoom) ExpectPp1Param2(pp1 *connect.Request[v1.CreateRoomRequest]) *mChatServiceClientMockCreateRoom {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceClientMockCreateRoomExpectation{}
	}

	if mmCreateRoom.defaultExpectation.params != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Expect")
	}

	if mmCreateRoom.defaultExpectation.paramPtrs == nil {
		mmCreateRoom.defaultExpectation.paramPtrs = &ChatServiceClientMockCreateRoomParamPtrs{}
	}
	mmCreateRoom.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateRoom.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateRoom
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.CreateRoom
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest])) *mChatServiceClientMockCreateRoom {
	if mmCreateRoom.mock.inspectFuncCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.CreateRoom")
	}

	mmCreateRoom.mock.inspectFuncCreateRoom = f

	return mmCreateRoom
}

// Return sets up results that will be returned by ChatServiceClient.CreateRoom
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Return(pp2 *connect.Response[v1.CreateRoomResponse], err error) *ChatServiceClientMock {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceClientMockCreateRoomExpectation{mock: mmCreateRoom.mock}
	}
	mmCreateRoom.defaultExpectation.results = &ChatServiceClientMockCreateRoomResults{pp2, err}
	mmCreateRoom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRoom.mock
}

// Set uses given function f to mock the ChatServiceClient.CreateRoom method
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) (pp2 *connect.Response[v1.CreateRoomResponse], err error)) *ChatServiceClientMock {
	if mmCreateRoom.defaultExpectation != nil {
		mmCreateRoom.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.CreateRoom method")
	}

	if len(mmCreateRoom.expectations) > 0 {
		mmCreateRoom.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.CreateRoom method")
	}

	mmCreateRoom.mock.funcCreateRoom = f
	mmCreateRoom.mock.funcCreateRoomOrigin = minimock.CallerInfo(1)
	return mmCreateRoom.mock
}

// When sets expectation for the ChatServiceClient.CreateRoom which will trigger the result defined by the following
// Then helper
func (mmCreateRoom *mChatServiceClientMockCreateRoom) When(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) *ChatServiceClientMockCreateRoomExpectation {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceClientMock.CreateRoom mock is already set by Set")
	}

	expectation := &ChatServiceClientMockCreateRoomExpectation{
		mock:               mmCreateRoom.mock,
		params:             &ChatServiceClientMockCreateRoomParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockCreateRoomExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRoom.expectations = append(mmCreateRoom.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.CreateRoom return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockCreateRoomExpectation) Then(pp2 *connect.Response[v1.CreateRoomResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockCreateRoomResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.CreateRoom should be invoked
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Times(n uint64) *mChatServiceClientMockCreateRoom {
	if n == 0 {
		mmCreateRoom.mock.t.Fatalf("Times of ChatServiceClientMock.CreateRoom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRoom.expectedInvocations, n)
	mmCreateRoom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRoom
}

func (mmCreateRoom *mChatServiceClientMockCreateRoom) invocationsDone() bool {
	if len(mmCreateRoom.expectations) == 0 && mmCreateRoom.defaultExpectation == nil && mmCreateRoom.mock.funcCreateRoom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRoom.mock.afterCreateRoomCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRoom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRoom implements mm_chatv1connect.ChatServiceClient
func (mmCreateRoom *ChatServiceClientMock) CreateRoom(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) (pp2 *connect.Response[v1.CreateRoomResponse], err error) {
	mm_atomic.AddUint64(&mmCreateRoom.beforeCreateRoomCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRoom.afterCreateRoomCounter, 1)

	mmCreateRoom.t.Helper()

	if mmCreateRoom.inspectFuncCreateRoom != nil {
		mmCreateRoom.inspectFuncCreateRoom(ctx, pp1)
	}

	mm_params := ChatServiceClientMockCreateRoomParams{ctx, pp1}

	// Record call args
	mmCreateRoom.CreateRoomMock.mutex.Lock()
	mmCreateRoom.CreateRoomMock.callArgs = append(mmCreateRoom.CreateRoomMock.callArgs, &mm_params)
	mmCreateRoom.CreateRoomMock.mutex.Unlock()

	for _, e := range mmCreateRoom.CreateRoomMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateRoom.CreateRoomMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRoom.CreateRoomMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRoom.CreateRoomMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRoom.CreateRoomMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockCreateRoomParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRoom.t.Errorf("ChatServiceClientMock.CreateRoom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRoom.CreateRoomMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateRoom.t.Errorf("ChatServiceClientMock.CreateRoom got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRoom.CreateRoomMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRoom.t.Errorf("ChatServiceClientMock.CreateRoom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRoom.CreateRoomMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRoom.CreateRoomMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRoom.t.Fatal("No results are set for the ChatServiceClientMock.CreateRoom")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateRoom.funcCreateRoom != nil {
		return mmCreateRoom.funcCreateRoom(ctx, pp1)
	}
	mmCreateRoom.t.Fatalf("Unexpected call to ChatServiceClientMock.CreateRoom. %v %v", ctx, pp1)
	return
}

// CreateRoomAfterCounter returns a count of finished ChatServiceClientMock.CreateRoom invocations
func (mmCreateRoom *ChatServiceClientMock) CreateRoomAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRoom.afterCreateRoomCounter)
}

// CreateRoomBeforeCounter returns a count of ChatServiceClientMock.CreateRoom invocations
func (mmCreateRoom *ChatServiceClientMock) CreateRoomBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRoom.beforeCreateRoomCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.CreateRoom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRoom *mChatServiceClientMockCreateRoom) Calls() []*ChatServiceClientMockCreateRoomParams {
	mmCreateRoom.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockCreateRoomParams, len(mmCreateRoom.callArgs))
	copy(argCopy, mmCreateRoom.callArgs)

	mmCreateRoom.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRoomDone returns true if the count of the CreateRoom invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockCreateRoomDone() bool {
	if m.CreateRoomMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRoomMock.invocationsDone()
}

// MinimockCreateRoomInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockCreateRoomInspect() {
	for _, e := range m.CreateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.CreateRoom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRoomCounter := mm_atomic.LoadUint64(&m.afterCreateRoomCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRoomMock.defaultExpectation != nil && afterCreateRoomCounter < 1 {
		if m.CreateRoomMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.CreateRoom at\n%s", m.CreateRoomMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.CreateRoom at\n%s with params: %#v", m.CreateRoomMock.defaultExpectation.expectationOrigins.origin, *m.CreateRoomMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRoom != nil && afterCreateRoomCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.CreateRoom at\n%s", m.funcCreateRoomOrigin)
	}

	if !m.CreateRoomMock.invocationsDone() && afterCreateRoomCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.CreateRoom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRoomMock.expectedInvocations), m.CreateRoomMock.expectedInvocationsOrigin, afterCreateRoomCounter)
	}
}

type mChatServiceClientMockDeleteRoom struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockDeleteRoomExpectation
	expectations       []*ChatServiceClientMockDeleteRoomExpectation

	callArgs []*ChatServiceClientMockDeleteRoomParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockDeleteRoomExpectation specifies expectation struct of the ChatServiceClient.DeleteRoom
type ChatServiceClientMockDeleteRoomExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockDeleteRoomParams
	paramPtrs          *ChatServiceClientMockDeleteRoomParamPtrs
	expectationOrigins ChatServiceClientMockDeleteRoomExpectationOrigins
	results            *ChatServiceClientMockDeleteRoomResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockDeleteRoomParams contains parameters of the ChatServiceClient.DeleteRoom
type ChatServiceClientMockDeleteRoomParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeleteRoomRequest]
}

// ChatServiceClientMockDeleteRoomParamPtrs contains pointers to parameters of the ChatServiceClient.DeleteRoom
type ChatServiceClientMockDeleteRoomParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeleteRoomRequest]
}

// ChatServiceClientMockDeleteRoomResults contains results of the ChatServiceClient.DeleteRoom
type ChatServiceClientMockDeleteRoomResults struct {
	pp2 *connect.Response[v1.DeleteRoomResponse]
	err error
}

// ChatServiceClientMockDeleteRoomOrigins contains origins of expectations of the ChatServiceClient.DeleteRoom
type ChatServiceClientMockDeleteRoomExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Optional() *mChatServiceClientMockDeleteRoom {
	mmDeleteRoom.optional = true
	return mmDeleteRoom
}

// Expect sets up expected params for ChatServiceClient.DeleteRoom
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Expect(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) *mChatServiceClientMockDeleteRoom {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceClientMockDeleteRoomExpectation{}
	}

	if mmDeleteRoom.defaultExpectation.paramPtrs != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by ExpectParams functions")
	}

	mmDeleteRoom.defaultExpectation.params = &ChatServiceClientMockDeleteRoomParams{ctx, pp1}
	mmDeleteRoom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRoom.expectations {
		if minimock.Equal(e.params, mmDeleteRoom.defaultExpectation.params) {
			mmDeleteRoom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRoom.defaultExpectation.params)
		}
	}

	return mmDeleteRoom
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.DeleteRoom
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockDeleteRoom {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceClientMockDeleteRoomExpectation{}
	}

	if mmDeleteRoom.defaultExpectation.params != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Expect")
	}

	if mmDeleteRoom.defaultExpectation.paramPtrs == nil {
		mmDeleteRoom.defaultExpectation.paramPtrs = &ChatServiceClientMockDeleteRoomParamPtrs{}
	}
	mmDeleteRoom.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRoom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRoom
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.DeleteRoom
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) ExpectPp1Param2(pp1 *connect.Request[v1.DeleteRoomRequest]) *mChatServiceClientMockDeleteRoom {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceClientMockDeleteRoomExpectation{}
	}

	if mmDeleteRoom.defaultExpectation.params != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Expect")
	}

	if mmDeleteRoom.defaultExpectation.paramPtrs == nil {
		mmDeleteRoom.defaultExpectation.paramPtrs = &ChatServiceClientMockDeleteRoomParamPtrs{}
	}
	mmDeleteRoom.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteRoom.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteRoom
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.DeleteRoom
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest])) *mChatServiceClientMockDeleteRoom {
	if mmDeleteRoom.mock.inspectFuncDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.DeleteRoom")
	}

	mmDeleteRoom.mock.inspectFuncDeleteRoom = f

	return mmDeleteRoom
}

// Return sets up results that will be returned by ChatServiceClient.DeleteRoom
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Return(pp2 *connect.Response[v1.DeleteRoomResponse], err error) *ChatServiceClientMock {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceClientMockDeleteRoomExpectation{mock: mmDeleteRoom.mock}
	}
	mmDeleteRoom.defaultExpectation.results = &ChatServiceClientMockDeleteRoomResults{pp2, err}
	mmDeleteRoom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRoom.mock
}

// Set uses given function f to mock the ChatServiceClient.DeleteRoom method
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) (pp2 *connect.Response[v1.DeleteRoomResponse], err error)) *ChatServiceClientMock {
	if mmDeleteRoom.defaultExpectation != nil {
		mmDeleteRoom.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.DeleteRoom method")
	}

	if len(mmDeleteRoom.expectations) > 0 {
		mmDeleteRoom.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.DeleteRoom method")
	}

	mmDeleteRoom.mock.funcDeleteRoom = f
	mmDeleteRoom.mock.funcDeleteRoomOrigin = minimock.CallerInfo(1)
	return mmDeleteRoom.mock
}

// When sets expectation for the ChatServiceClient.DeleteRoom which will trigger the result defined by the following
// Then helper
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) When(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) *ChatServiceClientMockDeleteRoomExpectation {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceClientMock.DeleteRoom mock is already set by Set")
	}

	expectation := &ChatServiceClientMockDeleteRoomExpectation{
		mock:               mmDeleteRoom.mock,
		params:             &ChatServiceClientMockDeleteRoomParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockDeleteRoomExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRoom.expectations = append(mmDeleteRoom.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.DeleteRoom return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockDeleteRoomExpectation) Then(pp2 *connect.Response[v1.DeleteRoomResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockDeleteRoomResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.DeleteRoom should be invoked
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Times(n uint64) *mChatServiceClientMockDeleteRoom {
	if n == 0 {
		mmDeleteRoom.mock.t.Fatalf("Times of ChatServiceClientMock.DeleteRoom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRoom.expectedInvocations, n)
	mmDeleteRoom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRoom
}

func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) invocationsDone() bool {
	if len(mmDeleteRoom.expectations) == 0 && mmDeleteRoom.defaultExpectation == nil && mmDeleteRoom.mock.funcDeleteRoom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRoom.mock.afterDeleteRoomCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRoom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRoom implements mm_chatv1connect.ChatServiceClient
func (mmDeleteRoom *ChatServiceClientMock) DeleteRoom(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) (pp2 *connect.Response[v1.DeleteRoomResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteRoom.beforeDeleteRoomCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRoom.afterDeleteRoomCounter, 1)

	mmDeleteRoom.t.Helper()

	if mmDeleteRoom.inspectFuncDeleteRoom != nil {
		mmDeleteRoom.inspectFuncDeleteRoom(ctx, pp1)
	}

	mm_params := ChatServiceClientMockDeleteRoomParams{ctx, pp1}

	// Record call args
	mmDeleteRoom.DeleteRoomMock.mutex.Lock()
	mmDeleteRoom.DeleteRoomMock.callArgs = append(mmDeleteRoom.DeleteRoomMock.callArgs, &mm_params)
	mmDeleteRoom.DeleteRoomMock.mutex.Unlock()

	for _, e := range mmDeleteRoom.DeleteRoomMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteRoom.DeleteRoomMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRoom.DeleteRoomMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRoom.DeleteRoomMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRoom.DeleteRoomMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockDeleteRoomParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRoom.t.Errorf("ChatServiceClientMock.DeleteRoom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRoom.DeleteRoomMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteRoom.t.Errorf("ChatServiceClientMock.DeleteRoom got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRoom.DeleteRoomMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRoom.t.Errorf("ChatServiceClientMock.DeleteRoom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRoom.DeleteRoomMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRoom.DeleteRoomMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRoom.t.Fatal("No results are set for the ChatServiceClientMock.DeleteRoom")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteRoom.funcDeleteRoom != nil {
		return mmDeleteRoom.funcDeleteRoom(ctx, pp1)
	}
	mmDeleteRoom.t.Fatalf("Unexpected call to ChatServiceClientMock.DeleteRoom. %v %v", ctx, pp1)
	return
}

// DeleteRoomAfterCounter returns a count of finished ChatServiceClientMock.DeleteRoom invocations
func (mmDeleteRoom *ChatServiceClientMock) DeleteRoomAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRoom.afterDeleteRoomCounter)
}

// DeleteRoomBeforeCounter returns a count of ChatServiceClientMock.DeleteRoom invocations
func (mmDeleteRoom *ChatServiceClientMock) DeleteRoomBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRoom.beforeDeleteRoomCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.DeleteRoom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRoom *mChatServiceClientMockDeleteRoom) Calls() []*ChatServiceClientMockDeleteRoomParams {
	mmDeleteRoom.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockDeleteRoomParams, len(mmDeleteRoom.callArgs))
	copy(argCopy, mmDeleteRoom.callArgs)

	mmDeleteRoom.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRoomDone returns true if the count of the DeleteRoom invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockDeleteRoomDone() bool {
	if m.DeleteRoomMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRoomMock.invocationsDone()
}

// MinimockDeleteRoomInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockDeleteRoomInspect() {
	for _, e := range m.DeleteRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.DeleteRoom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRoomCounter := mm_atomic.LoadUint64(&m.afterDeleteRoomCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRoomMock.defaultExpectation != nil && afterDeleteRoomCounter < 1 {
		if m.DeleteRoomMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.DeleteRoom at\n%s", m.DeleteRoomMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.DeleteRoom at\n%s with params: %#v", m.DeleteRoomMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRoomMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRoom != nil && afterDeleteRoomCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.DeleteRoom at\n%s", m.funcDeleteRoomOrigin)
	}

	if !m.DeleteRoomMock.invocationsDone() && afterDeleteRoomCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.DeleteRoom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRoomMock.expectedInvocations), m.DeleteRoomMock.expectedInvocationsOrigin, afterDeleteRoomCounter)
	}
}

type mChatServiceClientMockGetClientState struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockGetClientStateExpectation
	expectations       []*ChatServiceClientMockGetClientStateExpectation

	callArgs []*ChatServiceClientMockGetClientStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockGetClientStateExpectation specifies expectation struct of the ChatServiceClient.GetClientState
type ChatServiceClientMockGetClientStateExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockGetClientStateParams
	paramPtrs          *ChatServiceClientMockGetClientStateParamPtrs
	expectationOrigins ChatServiceClientMockGetClientStateExpectationOrigins
	results            *ChatServiceClientMockGetClientStateResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockGetClientStateParams contains parameters of the ChatServiceClient.GetClientState
type ChatServiceClientMockGetClientStateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetClientStateRequest]
}

// ChatServiceClientMockGetClientStateParamPtrs contains pointers to parameters of the ChatServiceClient.GetClientState
type ChatServiceClientMockGetClientStateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetClientStateRequest]
}

// ChatServiceClientMockGetClientStateResults contains results of the ChatServiceClient.GetClientState
type ChatServiceClientMockGetClientStateResults struct {
	pp2 *connect.Response[v1.GetClientStateResponse]
	err error
}

// ChatServiceClientMockGetClientStateOrigins contains origins of expectations of the ChatServiceClient.GetClientState
type ChatServiceClientMockGetClientStateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClientState *mChatServiceClientMockGetClientState) Optional() *mChatServiceClientMockGetClientState {
	mmGetClientState.optional = true
	return mmGetClientState
}

// Expect sets up expected params for ChatServiceClient.GetClientState
func (mmGetClientState *mChatServiceClientMockGetClientState) Expect(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) *mChatServiceClientMockGetClientState {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceClientMockGetClientStateExpectation{}
	}

	if mmGetClientState.defaultExpectation.paramPtrs != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by ExpectParams functions")
	}

	mmGetClientState.defaultExpectation.params = &ChatServiceClientMockGetClientStateParams{ctx, pp1}
	mmGetClientState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClientState.expectations {
		if minimock.Equal(e.params, mmGetClientState.defaultExpectation.params) {
			mmGetClientState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClientState.defaultExpectation.params)
		}
	}

	return mmGetClientState
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.GetClientState
func (mmGetClientState *mChatServiceClientMockGetClientState) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockGetClientState {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceClientMockGetClientStateExpectation{}
	}

	if mmGetClientState.defaultExpectation.params != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Expect")
	}

	if mmGetClientState.defaultExpectation.paramPtrs == nil {
		mmGetClientState.defaultExpectation.paramPtrs = &ChatServiceClientMockGetClientStateParamPtrs{}
	}
	mmGetClientState.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetClientState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetClientState
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.GetClientState
func (mmGetClientState *mChatServiceClientMockGetClientState) ExpectPp1Param2(pp1 *connect.Request[v1.GetClientStateRequest]) *mChatServiceClientMockGetClientState {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceClientMockGetClientStateExpectation{}
	}

	if mmGetClientState.defaultExpectation.params != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Expect")
	}

	if mmGetClientState.defaultExpectation.paramPtrs == nil {
		mmGetClientState.defaultExpectation.paramPtrs = &ChatServiceClientMockGetClientStateParamPtrs{}
	}
	mmGetClientState.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetClientState.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetClientState
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.GetClientState
func (mmGetClientState *mChatServiceClientMockGetClientState) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest])) *mChatServiceClientMockGetClientState {
	if mmGetClientState.mock.inspectFuncGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.GetClientState")
	}

	mmGetClientState.mock.inspectFuncGetClientState = f

	return mmGetClientState
}

// Return sets up results that will be returned by ChatServiceClient.GetClientState
func (mmGetClientState *mChatServiceClientMockGetClientState) Return(pp2 *connect.Response[v1.GetClientStateResponse], err error) *ChatServiceClientMock {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceClientMockGetClientStateExpectation{mock: mmGetClientState.mock}
	}
	mmGetClientState.defaultExpectation.results = &ChatServiceClientMockGetClientStateResults{pp2, err}
	mmGetClientState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClientState.mock
}

// Set uses given function f to mock the ChatServiceClient.GetClientState method
func (mmGetClientState *mChatServiceClientMockGetClientState) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) (pp2 *connect.Response[v1.GetClientStateResponse], err error)) *ChatServiceClientMock {
	if mmGetClientState.defaultExpectation != nil {
		mmGetClientState.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.GetClientState method")
	}

	if len(mmGetClientState.expectations) > 0 {
		mmGetClientState.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.GetClientState method")
	}

	mmGetClientState.mock.funcGetClientState = f
	mmGetClientState.mock.funcGetClientStateOrigin = minimock.CallerInfo(1)
	return mmGetClientState.mock
}

// When sets expectation for the ChatServiceClient.GetClientState which will trigger the result defined by the following
// Then helper
func (mmGetClientState *mChatServiceClientMockGetClientState) When(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) *ChatServiceClientMockGetClientStateExpectation {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceClientMock.GetClientState mock is already set by Set")
	}

	expectation := &ChatServiceClientMockGetClientStateExpectation{
		mock:               mmGetClientState.mock,
		params:             &ChatServiceClientMockGetClientStateParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockGetClientStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClientState.expectations = append(mmGetClientState.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.GetClientState return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockGetClientStateExpectation) Then(pp2 *connect.Response[v1.GetClientStateResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockGetClientStateResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.GetClientState should be invoked
func (mmGetClientState *mChatServiceClientMockGetClientState) Times(n uint64) *mChatServiceClientMockGetClientState {
	if n == 0 {
		mmGetClientState.mock.t.Fatalf("Times of ChatServiceClientMock.GetClientState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClientState.expectedInvocations, n)
	mmGetClientState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClientState
}

func (mmGetClientState *mChatServiceClientMockGetClientState) invocationsDone() bool {
	if len(mmGetClientState.expectations) == 0 && mmGetClientState.defaultExpectation == nil && mmGetClientState.mock.funcGetClientState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClientState.mock.afterGetClientStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClientState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClientState implements mm_chatv1connect.ChatServiceClient
func (mmGetClientState *ChatServiceClientMock) GetClientState(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) (pp2 *connect.Response[v1.GetClientStateResponse], err error) {
	mm_atomic.AddUint64(&mmGetClientState.beforeGetClientStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClientState.afterGetClientStateCounter, 1)

	mmGetClientState.t.Helper()

	if mmGetClientState.inspectFuncGetClientState != nil {
		mmGetClientState.inspectFuncGetClientState(ctx, pp1)
	}

	mm_params := ChatServiceClientMockGetClientStateParams{ctx, pp1}

	// Record call args
	mmGetClientState.GetClientStateMock.mutex.Lock()
	mmGetClientState.GetClientStateMock.callArgs = append(mmGetClientState.GetClientStateMock.callArgs, &mm_params)
	mmGetClientState.GetClientStateMock.mutex.Unlock()

	for _, e := range mmGetClientState.GetClientStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetClientState.GetClientStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClientState.GetClientStateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClientState.GetClientStateMock.defaultExpectation.params
		mm_want_ptrs := mmGetClientState.GetClientStateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockGetClientStateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClientState.t.Errorf("ChatServiceClientMock.GetClientState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientState.GetClientStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetClientState.t.Errorf("ChatServiceClientMock.GetClientState got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientState.GetClientStateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClientState.t.Errorf("ChatServiceClientMock.GetClientState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClientState.GetClientStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClientState.GetClientStateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClientState.t.Fatal("No results are set for the ChatServiceClientMock.GetClientState")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetClientState.funcGetClientState != nil {
		return mmGetClientState.funcGetClientState(ctx, pp1)
	}
	mmGetClientState.t.Fatalf("Unexpected call to ChatServiceClientMock.GetClientState. %v %v", ctx, pp1)
	return
}

// GetClientStateAfterCounter returns a count of finished ChatServiceClientMock.GetClientState invocations
func (mmGetClientState *ChatServiceClientMock) GetClientStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientState.afterGetClientStateCounter)
}

// GetClientStateBeforeCounter returns a count of ChatServiceClientMock.GetClientState invocations
func (mmGetClientState *ChatServiceClientMock) GetClientStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientState.beforeGetClientStateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.GetClientState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClientState *mChatServiceClientMockGetClientState) Calls() []*ChatServiceClientMockGetClientStateParams {
	mmGetClientState.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockGetClientStateParams, len(mmGetClientState.callArgs))
	copy(argCopy, mmGetClientState.callArgs)

	mmGetClientState.mutex.RUnlock()

	return argCopy
}

// MinimockGetClientStateDone returns true if the count of the GetClientState invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockGetClientStateDone() bool {
	if m.GetClientStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClientStateMock.invocationsDone()
}

// MinimockGetClientStateInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockGetClientStateInspect() {
	for _, e := range m.GetClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.GetClientState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClientStateCounter := mm_atomic.LoadUint64(&m.afterGetClientStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientStateMock.defaultExpectation != nil && afterGetClientStateCounter < 1 {
		if m.GetClientStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.GetClientState at\n%s", m.GetClientStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.GetClientState at\n%s with params: %#v", m.GetClientStateMock.defaultExpectation.expectationOrigins.origin, *m.GetClientStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClientState != nil && afterGetClientStateCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.GetClientState at\n%s", m.funcGetClientStateOrigin)
	}

	if !m.GetClientStateMock.invocationsDone() && afterGetClientStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.GetClientState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClientStateMock.expectedInvocations), m.GetClientStateMock.expectedInvocationsOrigin, afterGetClientStateCounter)
	}
}

type mChatServiceClientMockGetHistory struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockGetHistoryExpectation
	expectations       []*ChatServiceClientMockGetHistoryExpectation

	callArgs []*ChatServiceClientMockGetHistoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockGetHistoryExpectation specifies expectation struct of the ChatServiceClient.GetHistory
type ChatServiceClientMockGetHistoryExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockGetHistoryParams
	paramPtrs          *ChatServiceClientMockGetHistoryParamPtrs
	expectationOrigins ChatServiceClientMockGetHistoryExpectationOrigins
	results            *ChatServiceClientMockGetHistoryResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockGetHistoryParams contains parameters of the ChatServiceClient.GetHistory
type ChatServiceClientMockGetHistoryParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetHistoryRequest]
}

// ChatServiceClientMockGetHistoryParamPtrs contains pointers to parameters of the ChatServiceClient.GetHistory
type ChatServiceClientMockGetHistoryParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetHistoryRequest]
}

// ChatServiceClientMockGetHistoryResults contains results of the ChatServiceClient.GetHistory
type ChatServiceClientMockGetHistoryResults struct {
	pp2 *connect.Response[v1.GetHistoryResponse]
	err error
}

// ChatServiceClientMockGetHistoryOrigins contains origins of expectations of the ChatServiceClient.GetHistory
type ChatServiceClientMockGetHistoryExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHistory *mChatServiceClientMockGetHistory) Optional() *mChatServiceClientMockGetHistory {
	mmGetHistory.optional = true
	return mmGetHistory
}

// Expect sets up expected params for ChatServiceClient.GetHistory
func (mmGetHistory *mChatServiceClientMockGetHistory) Expect(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) *mChatServiceClientMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceClientMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.paramPtrs != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by ExpectParams functions")
	}

	mmGetHistory.defaultExpectation.params = &ChatServiceClientMockGetHistoryParams{ctx, pp1}
	mmGetHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHistory.expectations {
		if minimock.Equal(e.params, mmGetHistory.defaultExpectation.params) {
			mmGetHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistory.defaultExpectation.params)
		}
	}

	return mmGetHistory
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.GetHistory
func (mmGetHistory *mChatServiceClientMockGetHistory) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceClientMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &ChatServiceClientMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetHistory
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.GetHistory
func (mmGetHistory *mChatServiceClientMockGetHistory) ExpectPp1Param2(pp1 *connect.Request[v1.GetHistoryRequest]) *mChatServiceClientMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceClientMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &ChatServiceClientMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetHistory.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetHistory
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.GetHistory
func (mmGetHistory *mChatServiceClientMockGetHistory) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest])) *mChatServiceClientMockGetHistory {
	if mmGetHistory.mock.inspectFuncGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.GetHistory")
	}

	mmGetHistory.mock.inspectFuncGetHistory = f

	return mmGetHistory
}

// Return sets up results that will be returned by ChatServiceClient.GetHistory
func (mmGetHistory *mChatServiceClientMockGetHistory) Return(pp2 *connect.Response[v1.GetHistoryResponse], err error) *ChatServiceClientMock {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceClientMockGetHistoryExpectation{mock: mmGetHistory.mock}
	}
	mmGetHistory.defaultExpectation.results = &ChatServiceClientMockGetHistoryResults{pp2, err}
	mmGetHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHistory.mock
}

// Set uses given function f to mock the ChatServiceClient.GetHistory method
func (mmGetHistory *mChatServiceClientMockGetHistory) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) (pp2 *connect.Response[v1.GetHistoryResponse], err error)) *ChatServiceClientMock {
	if mmGetHistory.defaultExpectation != nil {
		mmGetHistory.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.GetHistory method")
	}

	if len(mmGetHistory.expectations) > 0 {
		mmGetHistory.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.GetHistory method")
	}

	mmGetHistory.mock.funcGetHistory = f
	mmGetHistory.mock.funcGetHistoryOrigin = minimock.CallerInfo(1)
	return mmGetHistory.mock
}

// When sets expectation for the ChatServiceClient.GetHistory which will trigger the result defined by the following
// Then helper
func (mmGetHistory *mChatServiceClientMockGetHistory) When(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) *ChatServiceClientMockGetHistoryExpectation {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceClientMock.GetHistory mock is already set by Set")
	}

	expectation := &ChatServiceClientMockGetHistoryExpectation{
		mock:               mmGetHistory.mock,
		params:             &ChatServiceClientMockGetHistoryParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockGetHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHistory.expectations = append(mmGetHistory.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.GetHistory return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockGetHistoryExpectation) Then(pp2 *connect.Response[v1.GetHistoryResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockGetHistoryResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.GetHistory should be invoked
func (mmGetHistory *mChatServiceClientMockGetHistory) Times(n uint64) *mChatServiceClientMockGetHistory {
	if n == 0 {
		mmGetHistory.mock.t.Fatalf("Times of ChatServiceClientMock.GetHistory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHistory.expectedInvocations, n)
	mmGetHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHistory
}

func (mmGetHistory *mChatServiceClientMockGetHistory) invocationsDone() bool {
	if len(mmGetHistory.expectations) == 0 && mmGetHistory.defaultExpectation == nil && mmGetHistory.mock.funcGetHistory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHistory.mock.afterGetHistoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHistory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHistory implements mm_chatv1connect.ChatServiceClient
func (mmGetHistory *ChatServiceClientMock) GetHistory(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) (pp2 *connect.Response[v1.GetHistoryResponse], err error) {
	mm_atomic.AddUint64(&mmGetHistory.beforeGetHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHistory.afterGetHistoryCounter, 1)

	mmGetHistory.t.Helper()

	if mmGetHistory.inspectFuncGetHistory != nil {
		mmGetHistory.inspectFuncGetHistory(ctx, pp1)
	}

	mm_params := ChatServiceClientMockGetHistoryParams{ctx, pp1}

	// Record call args
	mmGetHistory.GetHistoryMock.mutex.Lock()
	mmGetHistory.GetHistoryMock.callArgs = append(mmGetHistory.GetHistoryMock.callArgs, &mm_params)
	mmGetHistory.GetHistoryMock.mutex.Unlock()

	for _, e := range mmGetHistory.GetHistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetHistory.GetHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHistory.GetHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHistory.GetHistoryMock.defaultExpectation.params
		mm_want_ptrs := mmGetHistory.GetHistoryMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockGetHistoryParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetHistory.t.Errorf("ChatServiceClientMock.GetHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetHistory.t.Errorf("ChatServiceClientMock.GetHistory got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHistory.t.Errorf("ChatServiceClientMock.GetHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHistory.GetHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHistory.t.Fatal("No results are set for the ChatServiceClientMock.GetHistory")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetHistory.funcGetHistory != nil {
		return mmGetHistory.funcGetHistory(ctx, pp1)
	}
	mmGetHistory.t.Fatalf("Unexpected call to ChatServiceClientMock.GetHistory. %v %v", ctx, pp1)
	return
}

// GetHistoryAfterCounter returns a count of finished ChatServiceClientMock.GetHistory invocations
func (mmGetHistory *ChatServiceClientMock) GetHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.afterGetHistoryCounter)
}

// GetHistoryBeforeCounter returns a count of ChatServiceClientMock.GetHistory invocations
func (mmGetHistory *ChatServiceClientMock) GetHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.beforeGetHistoryCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.GetHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistory *mChatServiceClientMockGetHistory) Calls() []*ChatServiceClientMockGetHistoryParams {
	mmGetHistory.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockGetHistoryParams, len(mmGetHistory.callArgs))
	copy(argCopy, mmGetHistory.callArgs)

	mmGetHistory.mutex.RUnlock()

	return argCopy
}

// MinimockGetHistoryDone returns true if the count of the GetHistory invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockGetHistoryDone() bool {
	if m.GetHistoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHistoryMock.invocationsDone()
}

// MinimockGetHistoryInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockGetHistoryInspect() {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.GetHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHistoryCounter := mm_atomic.LoadUint64(&m.afterGetHistoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && afterGetHistoryCounter < 1 {
		if m.GetHistoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.GetHistory at\n%s", m.GetHistoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.GetHistory at\n%s with params: %#v", m.GetHistoryMock.defaultExpectation.expectationOrigins.origin, *m.GetHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && afterGetHistoryCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.GetHistory at\n%s", m.funcGetHistoryOrigin)
	}

	if !m.GetHistoryMock.invocationsDone() && afterGetHistoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.GetHistory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHistoryMock.expectedInvocations), m.GetHistoryMock.expectedInvocationsOrigin, afterGetHistoryCounter)
	}
}

type mChatServiceClientMockRemoveRoomSubscriptions struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockRemoveRoomSubscriptionsExpectation
	expectations       []*ChatServiceClientMockRemoveRoomSubscriptionsExpectation

	callArgs []*ChatServiceClientMockRemoveRoomSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockRemoveRoomSubscriptionsExpectation specifies expectation struct of the ChatServiceClient.RemoveRoomSubscriptions
type ChatServiceClientMockRemoveRoomSubscriptionsExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockRemoveRoomSubscriptionsParams
	paramPtrs          *ChatServiceClientMockRemoveRoomSubscriptionsParamPtrs
	expectationOrigins ChatServiceClientMockRemoveRoomSubscriptionsExpectationOrigins
	results            *ChatServiceClientMockRemoveRoomSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockRemoveRoomSubscriptionsParams contains parameters of the ChatServiceClient.RemoveRoomSubscriptions
type ChatServiceClientMockRemoveRoomSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]
}

// ChatServiceClientMockRemoveRoomSubscriptionsParamPtrs contains pointers to parameters of the ChatServiceClient.RemoveRoomSubscriptions
type ChatServiceClientMockRemoveRoomSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveRoomSubscriptionsRequest]
}

// ChatServiceClientMockRemoveRoomSubscriptionsResults contains results of the ChatServiceClient.RemoveRoomSubscriptions
type ChatServiceClientMockRemoveRoomSubscriptionsResults struct {
	pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse]
	err error
}

// ChatServiceClientMockRemoveRoomSubscriptionsOrigins contains origins of expectations of the ChatServiceClient.RemoveRoomSubscriptions
type ChatServiceClientMockRemoveRoomSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Optional() *mChatServiceClientMockRemoveRoomSubscriptions {
	mmRemoveRoomSubscriptions.optional = true
	return mmRemoveRoomSubscriptions
}

// Expect sets up expected params for ChatServiceClient.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) *mChatServiceClientMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceClientMockRemoveRoomSubscriptionsExpectation{}
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by ExpectParams functions")
	}

	mmRemoveRoomSubscriptions.defaultExpectation.params = &ChatServiceClientMockRemoveRoomSubscriptionsParams{ctx, pp1}
	mmRemoveRoomSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveRoomSubscriptions.expectations {
		if minimock.Equal(e.params, mmRemoveRoomSubscriptions.defaultExpectation.params) {
			mmRemoveRoomSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveRoomSubscriptions.defaultExpectation.params)
		}
	}

	return mmRemoveRoomSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceClientMockRemoveRoomSubscriptionsExpectation{}
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.params != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Expect")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceClientMockRemoveRoomSubscriptionsParamPtrs{}
	}
	mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveRoomSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveRoomSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) *mChatServiceClientMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceClientMockRemoveRoomSubscriptionsExpectation{}
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.params != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Expect")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceClientMockRemoveRoomSubscriptionsParamPtrs{}
	}
	mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveRoomSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveRoomSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest])) *mChatServiceClientMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.inspectFuncRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.RemoveRoomSubscriptions")
	}

	mmRemoveRoomSubscriptions.mock.inspectFuncRemoveRoomSubscriptions = f

	return mmRemoveRoomSubscriptions
}

// Return sets up results that will be returned by ChatServiceClient.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Return(pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error) *ChatServiceClientMock {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceClientMockRemoveRoomSubscriptionsExpectation{mock: mmRemoveRoomSubscriptions.mock}
	}
	mmRemoveRoomSubscriptions.defaultExpectation.results = &ChatServiceClientMockRemoveRoomSubscriptionsResults{pp2, err}
	mmRemoveRoomSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveRoomSubscriptions.mock
}

// Set uses given function f to mock the ChatServiceClient.RemoveRoomSubscriptions method
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error)) *ChatServiceClientMock {
	if mmRemoveRoomSubscriptions.defaultExpectation != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.RemoveRoomSubscriptions method")
	}

	if len(mmRemoveRoomSubscriptions.expectations) > 0 {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.RemoveRoomSubscriptions method")
	}

	mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions = f
	mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmRemoveRoomSubscriptions.mock
}

// When sets expectation for the ChatServiceClient.RemoveRoomSubscriptions which will trigger the result defined by the following
// Then helper
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) *ChatServiceClientMockRemoveRoomSubscriptionsExpectation {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	expectation := &ChatServiceClientMockRemoveRoomSubscriptionsExpectation{
		mock:               mmRemoveRoomSubscriptions.mock,
		params:             &ChatServiceClientMockRemoveRoomSubscriptionsParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockRemoveRoomSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveRoomSubscriptions.expectations = append(mmRemoveRoomSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.RemoveRoomSubscriptions return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockRemoveRoomSubscriptionsExpectation) Then(pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockRemoveRoomSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.RemoveRoomSubscriptions should be invoked
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Times(n uint64) *mChatServiceClientMockRemoveRoomSubscriptions {
	if n == 0 {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Times of ChatServiceClientMock.RemoveRoomSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveRoomSubscriptions.expectedInvocations, n)
	mmRemoveRoomSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveRoomSubscriptions
}

func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) invocationsDone() bool {
	if len(mmRemoveRoomSubscriptions.expectations) == 0 && mmRemoveRoomSubscriptions.defaultExpectation == nil && mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.mock.afterRemoveRoomSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveRoomSubscriptions implements mm_chatv1connect.ChatServiceClient
func (mmRemoveRoomSubscriptions *ChatServiceClientMock) RemoveRoomSubscriptions(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveRoomSubscriptions.beforeRemoveRoomSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveRoomSubscriptions.afterRemoveRoomSubscriptionsCounter, 1)

	mmRemoveRoomSubscriptions.t.Helper()

	if mmRemoveRoomSubscriptions.inspectFuncRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.inspectFuncRemoveRoomSubscriptions(ctx, pp1)
	}

	mm_params := ChatServiceClientMockRemoveRoomSubscriptionsParams{ctx, pp1}

	// Record call args
	mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.mutex.Lock()
	mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.callArgs = append(mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.callArgs, &mm_params)
	mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.mutex.Unlock()

	for _, e := range mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockRemoveRoomSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveRoomSubscriptions.t.Errorf("ChatServiceClientMock.RemoveRoomSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveRoomSubscriptions.t.Errorf("ChatServiceClientMock.RemoveRoomSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveRoomSubscriptions.t.Errorf("ChatServiceClientMock.RemoveRoomSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveRoomSubscriptions.t.Fatal("No results are set for the ChatServiceClientMock.RemoveRoomSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveRoomSubscriptions.funcRemoveRoomSubscriptions != nil {
		return mmRemoveRoomSubscriptions.funcRemoveRoomSubscriptions(ctx, pp1)
	}
	mmRemoveRoomSubscriptions.t.Fatalf("Unexpected call to ChatServiceClientMock.RemoveRoomSubscriptions. %v %v", ctx, pp1)
	return
}

// RemoveRoomSubscriptionsAfterCounter returns a count of finished ChatServiceClientMock.RemoveRoomSubscriptions invocations
func (mmRemoveRoomSubscriptions *ChatServiceClientMock) RemoveRoomSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.afterRemoveRoomSubscriptionsCounter)
}

// RemoveRoomSubscriptionsBeforeCounter returns a count of ChatServiceClientMock.RemoveRoomSubscriptions invocations
func (mmRemoveRoomSubscriptions *ChatServiceClientMock) RemoveRoomSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.beforeRemoveRoomSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.RemoveRoomSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveRoomSubscriptions *mChatServiceClientMockRemoveRoomSubscriptions) Calls() []*ChatServiceClientMockRemoveRoomSubscriptionsParams {
	mmRemoveRoomSubscriptions.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockRemoveRoomSubscriptionsParams, len(mmRemoveRoomSubscriptions.callArgs))
	copy(argCopy, mmRemoveRoomSubscriptions.callArgs)

	mmRemoveRoomSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveRoomSubscriptionsDone returns true if the count of the RemoveRoomSubscriptions invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockRemoveRoomSubscriptionsDone() bool {
	if m.RemoveRoomSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveRoomSubscriptionsMock.invocationsDone()
}

// MinimockRemoveRoomSubscriptionsInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockRemoveRoomSubscriptionsInspect() {
	for _, e := range m.RemoveRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.RemoveRoomSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveRoomSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterRemoveRoomSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveRoomSubscriptionsMock.defaultExpectation != nil && afterRemoveRoomSubscriptionsCounter < 1 {
		if m.RemoveRoomSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.RemoveRoomSubscriptions at\n%s", m.RemoveRoomSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.RemoveRoomSubscriptions at\n%s with params: %#v", m.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.RemoveRoomSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveRoomSubscriptions != nil && afterRemoveRoomSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.RemoveRoomSubscriptions at\n%s", m.funcRemoveRoomSubscriptionsOrigin)
	}

	if !m.RemoveRoomSubscriptionsMock.invocationsDone() && afterRemoveRoomSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.RemoveRoomSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveRoomSubscriptionsMock.expectedInvocations), m.RemoveRoomSubscriptionsMock.expectedInvocationsOrigin, afterRemoveRoomSubscriptionsCounter)
	}
}

type mChatServiceClientMockSearchRoomSubscriptions struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockSearchRoomSubscriptionsExpectation
	expectations       []*ChatServiceClientMockSearchRoomSubscriptionsExpectation

	callArgs []*ChatServiceClientMockSearchRoomSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockSearchRoomSubscriptionsExpectation specifies expectation struct of the ChatServiceClient.SearchRoomSubscriptions
type ChatServiceClientMockSearchRoomSubscriptionsExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockSearchRoomSubscriptionsParams
	paramPtrs          *ChatServiceClientMockSearchRoomSubscriptionsParamPtrs
	expectationOrigins ChatServiceClientMockSearchRoomSubscriptionsExpectationOrigins
	results            *ChatServiceClientMockSearchRoomSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockSearchRoomSubscriptionsParams contains parameters of the ChatServiceClient.SearchRoomSubscriptions
type ChatServiceClientMockSearchRoomSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]
}

// ChatServiceClientMockSearchRoomSubscriptionsParamPtrs contains pointers to parameters of the ChatServiceClient.SearchRoomSubscriptions
type ChatServiceClientMockSearchRoomSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRoomSubscriptionsRequest]
}

// ChatServiceClientMockSearchRoomSubscriptionsResults contains results of the ChatServiceClient.SearchRoomSubscriptions
type ChatServiceClientMockSearchRoomSubscriptionsResults struct {
	pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse]
	err error
}

// ChatServiceClientMockSearchRoomSubscriptionsOrigins contains origins of expectations of the ChatServiceClient.SearchRoomSubscriptions
type ChatServiceClientMockSearchRoomSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Optional() *mChatServiceClientMockSearchRoomSubscriptions {
	mmSearchRoomSubscriptions.optional = true
	return mmSearchRoomSubscriptions
}

// Expect sets up expected params for ChatServiceClient.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) *mChatServiceClientMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceClientMockSearchRoomSubscriptionsExpectation{}
	}

	if mmSearchRoomSubscriptions.defaultExpectation.paramPtrs != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by ExpectParams functions")
	}

	mmSearchRoomSubscriptions.defaultExpectation.params = &ChatServiceClientMockSearchRoomSubscriptionsParams{ctx, pp1}
	mmSearchRoomSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchRoomSubscriptions.expectations {
		if minimock.Equal(e.params, mmSearchRoomSubscriptions.defaultExpectation.params) {
			mmSearchRoomSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchRoomSubscriptions.defaultExpectation.params)
		}
	}

	return mmSearchRoomSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceClientMockSearchRoomSubscriptionsExpectation{}
	}

	if mmSearchRoomSubscriptions.defaultExpectation.params != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Expect")
	}

	if mmSearchRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmSearchRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceClientMockSearchRoomSubscriptionsParamPtrs{}
	}
	mmSearchRoomSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchRoomSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchRoomSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) *mChatServiceClientMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceClientMockSearchRoomSubscriptionsExpectation{}
	}

	if mmSearchRoomSubscriptions.defaultExpectation.params != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Expect")
	}

	if mmSearchRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmSearchRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceClientMockSearchRoomSubscriptionsParamPtrs{}
	}
	mmSearchRoomSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchRoomSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchRoomSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest])) *mChatServiceClientMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.inspectFuncSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.SearchRoomSubscriptions")
	}

	mmSearchRoomSubscriptions.mock.inspectFuncSearchRoomSubscriptions = f

	return mmSearchRoomSubscriptions
}

// Return sets up results that will be returned by ChatServiceClient.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Return(pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error) *ChatServiceClientMock {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceClientMockSearchRoomSubscriptionsExpectation{mock: mmSearchRoomSubscriptions.mock}
	}
	mmSearchRoomSubscriptions.defaultExpectation.results = &ChatServiceClientMockSearchRoomSubscriptionsResults{pp2, err}
	mmSearchRoomSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchRoomSubscriptions.mock
}

// Set uses given function f to mock the ChatServiceClient.SearchRoomSubscriptions method
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error)) *ChatServiceClientMock {
	if mmSearchRoomSubscriptions.defaultExpectation != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.SearchRoomSubscriptions method")
	}

	if len(mmSearchRoomSubscriptions.expectations) > 0 {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.SearchRoomSubscriptions method")
	}

	mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions = f
	mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmSearchRoomSubscriptions.mock
}

// When sets expectation for the ChatServiceClient.SearchRoomSubscriptions which will trigger the result defined by the following
// Then helper
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) *ChatServiceClientMockSearchRoomSubscriptionsExpectation {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceClientMock.SearchRoomSubscriptions mock is already set by Set")
	}

	expectation := &ChatServiceClientMockSearchRoomSubscriptionsExpectation{
		mock:               mmSearchRoomSubscriptions.mock,
		params:             &ChatServiceClientMockSearchRoomSubscriptionsParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockSearchRoomSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchRoomSubscriptions.expectations = append(mmSearchRoomSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.SearchRoomSubscriptions return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockSearchRoomSubscriptionsExpectation) Then(pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockSearchRoomSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.SearchRoomSubscriptions should be invoked
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Times(n uint64) *mChatServiceClientMockSearchRoomSubscriptions {
	if n == 0 {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Times of ChatServiceClientMock.SearchRoomSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchRoomSubscriptions.expectedInvocations, n)
	mmSearchRoomSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchRoomSubscriptions
}

func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) invocationsDone() bool {
	if len(mmSearchRoomSubscriptions.expectations) == 0 && mmSearchRoomSubscriptions.defaultExpectation == nil && mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.mock.afterSearchRoomSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchRoomSubscriptions implements mm_chatv1connect.ChatServiceClient
func (mmSearchRoomSubscriptions *ChatServiceClientMock) SearchRoomSubscriptions(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchRoomSubscriptions.beforeSearchRoomSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchRoomSubscriptions.afterSearchRoomSubscriptionsCounter, 1)

	mmSearchRoomSubscriptions.t.Helper()

	if mmSearchRoomSubscriptions.inspectFuncSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.inspectFuncSearchRoomSubscriptions(ctx, pp1)
	}

	mm_params := ChatServiceClientMockSearchRoomSubscriptionsParams{ctx, pp1}

	// Record call args
	mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.mutex.Lock()
	mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.callArgs = append(mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.callArgs, &mm_params)
	mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.mutex.Unlock()

	for _, e := range mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockSearchRoomSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchRoomSubscriptions.t.Errorf("ChatServiceClientMock.SearchRoomSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchRoomSubscriptions.t.Errorf("ChatServiceClientMock.SearchRoomSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchRoomSubscriptions.t.Errorf("ChatServiceClientMock.SearchRoomSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchRoomSubscriptions.t.Fatal("No results are set for the ChatServiceClientMock.SearchRoomSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchRoomSubscriptions.funcSearchRoomSubscriptions != nil {
		return mmSearchRoomSubscriptions.funcSearchRoomSubscriptions(ctx, pp1)
	}
	mmSearchRoomSubscriptions.t.Fatalf("Unexpected call to ChatServiceClientMock.SearchRoomSubscriptions. %v %v", ctx, pp1)
	return
}

// SearchRoomSubscriptionsAfterCounter returns a count of finished ChatServiceClientMock.SearchRoomSubscriptions invocations
func (mmSearchRoomSubscriptions *ChatServiceClientMock) SearchRoomSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.afterSearchRoomSubscriptionsCounter)
}

// SearchRoomSubscriptionsBeforeCounter returns a count of ChatServiceClientMock.SearchRoomSubscriptions invocations
func (mmSearchRoomSubscriptions *ChatServiceClientMock) SearchRoomSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.beforeSearchRoomSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.SearchRoomSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchRoomSubscriptions *mChatServiceClientMockSearchRoomSubscriptions) Calls() []*ChatServiceClientMockSearchRoomSubscriptionsParams {
	mmSearchRoomSubscriptions.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockSearchRoomSubscriptionsParams, len(mmSearchRoomSubscriptions.callArgs))
	copy(argCopy, mmSearchRoomSubscriptions.callArgs)

	mmSearchRoomSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockSearchRoomSubscriptionsDone returns true if the count of the SearchRoomSubscriptions invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockSearchRoomSubscriptionsDone() bool {
	if m.SearchRoomSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchRoomSubscriptionsMock.invocationsDone()
}

// MinimockSearchRoomSubscriptionsInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockSearchRoomSubscriptionsInspect() {
	for _, e := range m.SearchRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.SearchRoomSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchRoomSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterSearchRoomSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchRoomSubscriptionsMock.defaultExpectation != nil && afterSearchRoomSubscriptionsCounter < 1 {
		if m.SearchRoomSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.SearchRoomSubscriptions at\n%s", m.SearchRoomSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.SearchRoomSubscriptions at\n%s with params: %#v", m.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.SearchRoomSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchRoomSubscriptions != nil && afterSearchRoomSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.SearchRoomSubscriptions at\n%s", m.funcSearchRoomSubscriptionsOrigin)
	}

	if !m.SearchRoomSubscriptionsMock.invocationsDone() && afterSearchRoomSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.SearchRoomSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchRoomSubscriptionsMock.expectedInvocations), m.SearchRoomSubscriptionsMock.expectedInvocationsOrigin, afterSearchRoomSubscriptionsCounter)
	}
}

type mChatServiceClientMockSearchRooms struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockSearchRoomsExpectation
	expectations       []*ChatServiceClientMockSearchRoomsExpectation

	callArgs []*ChatServiceClientMockSearchRoomsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockSearchRoomsExpectation specifies expectation struct of the ChatServiceClient.SearchRooms
type ChatServiceClientMockSearchRoomsExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockSearchRoomsParams
	paramPtrs          *ChatServiceClientMockSearchRoomsParamPtrs
	expectationOrigins ChatServiceClientMockSearchRoomsExpectationOrigins
	results            *ChatServiceClientMockSearchRoomsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockSearchRoomsParams contains parameters of the ChatServiceClient.SearchRooms
type ChatServiceClientMockSearchRoomsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRoomsRequest]
}

// ChatServiceClientMockSearchRoomsParamPtrs contains pointers to parameters of the ChatServiceClient.SearchRooms
type ChatServiceClientMockSearchRoomsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRoomsRequest]
}

// ChatServiceClientMockSearchRoomsResults contains results of the ChatServiceClient.SearchRooms
type ChatServiceClientMockSearchRoomsResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchRoomsResponse]
	err error
}

// ChatServiceClientMockSearchRoomsOrigins contains origins of expectations of the ChatServiceClient.SearchRooms
type ChatServiceClientMockSearchRoomsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Optional() *mChatServiceClientMockSearchRooms {
	mmSearchRooms.optional = true
	return mmSearchRooms
}

// Expect sets up expected params for ChatServiceClient.SearchRooms
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest]) *mChatServiceClientMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceClientMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.paramPtrs != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by ExpectParams functions")
	}

	mmSearchRooms.defaultExpectation.params = &ChatServiceClientMockSearchRoomsParams{ctx, pp1}
	mmSearchRooms.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchRooms.expectations {
		if minimock.Equal(e.params, mmSearchRooms.defaultExpectation.params) {
			mmSearchRooms.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchRooms.defaultExpectation.params)
		}
	}

	return mmSearchRooms
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.SearchRooms
func (mmSearchRooms *mChatServiceClientMockSearchRooms) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceClientMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.params != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Expect")
	}

	if mmSearchRooms.defaultExpectation.paramPtrs == nil {
		mmSearchRooms.defaultExpectation.paramPtrs = &ChatServiceClientMockSearchRoomsParamPtrs{}
	}
	mmSearchRooms.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchRooms.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchRooms
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.SearchRooms
func (mmSearchRooms *mChatServiceClientMockSearchRooms) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRoomsRequest]) *mChatServiceClientMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceClientMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.params != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Expect")
	}

	if mmSearchRooms.defaultExpectation.paramPtrs == nil {
		mmSearchRooms.defaultExpectation.paramPtrs = &ChatServiceClientMockSearchRoomsParamPtrs{}
	}
	mmSearchRooms.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchRooms.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchRooms
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.SearchRooms
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest])) *mChatServiceClientMockSearchRooms {
	if mmSearchRooms.mock.inspectFuncSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.SearchRooms")
	}

	mmSearchRooms.mock.inspectFuncSearchRooms = f

	return mmSearchRooms
}

// Return sets up results that will be returned by ChatServiceClient.SearchRooms
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Return(pp2 *connect.ServerStreamForClient[v1.SearchRoomsResponse], err error) *ChatServiceClientMock {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceClientMockSearchRoomsExpectation{mock: mmSearchRooms.mock}
	}
	mmSearchRooms.defaultExpectation.results = &ChatServiceClientMockSearchRoomsResults{pp2, err}
	mmSearchRooms.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchRooms.mock
}

// Set uses given function f to mock the ChatServiceClient.SearchRooms method
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchRoomsResponse], err error)) *ChatServiceClientMock {
	if mmSearchRooms.defaultExpectation != nil {
		mmSearchRooms.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.SearchRooms method")
	}

	if len(mmSearchRooms.expectations) > 0 {
		mmSearchRooms.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.SearchRooms method")
	}

	mmSearchRooms.mock.funcSearchRooms = f
	mmSearchRooms.mock.funcSearchRoomsOrigin = minimock.CallerInfo(1)
	return mmSearchRooms.mock
}

// When sets expectation for the ChatServiceClient.SearchRooms which will trigger the result defined by the following
// Then helper
func (mmSearchRooms *mChatServiceClientMockSearchRooms) When(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest]) *ChatServiceClientMockSearchRoomsExpectation {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceClientMock.SearchRooms mock is already set by Set")
	}

	expectation := &ChatServiceClientMockSearchRoomsExpectation{
		mock:               mmSearchRooms.mock,
		params:             &ChatServiceClientMockSearchRoomsParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockSearchRoomsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchRooms.expectations = append(mmSearchRooms.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.SearchRooms return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockSearchRoomsExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchRoomsResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockSearchRoomsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.SearchRooms should be invoked
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Times(n uint64) *mChatServiceClientMockSearchRooms {
	if n == 0 {
		mmSearchRooms.mock.t.Fatalf("Times of ChatServiceClientMock.SearchRooms mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchRooms.expectedInvocations, n)
	mmSearchRooms.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchRooms
}

func (mmSearchRooms *mChatServiceClientMockSearchRooms) invocationsDone() bool {
	if len(mmSearchRooms.expectations) == 0 && mmSearchRooms.defaultExpectation == nil && mmSearchRooms.mock.funcSearchRooms == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchRooms.mock.afterSearchRoomsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchRooms.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchRooms implements mm_chatv1connect.ChatServiceClient
func (mmSearchRooms *ChatServiceClientMock) SearchRooms(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchRoomsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchRooms.beforeSearchRoomsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchRooms.afterSearchRoomsCounter, 1)

	mmSearchRooms.t.Helper()

	if mmSearchRooms.inspectFuncSearchRooms != nil {
		mmSearchRooms.inspectFuncSearchRooms(ctx, pp1)
	}

	mm_params := ChatServiceClientMockSearchRoomsParams{ctx, pp1}

	// Record call args
	mmSearchRooms.SearchRoomsMock.mutex.Lock()
	mmSearchRooms.SearchRoomsMock.callArgs = append(mmSearchRooms.SearchRoomsMock.callArgs, &mm_params)
	mmSearchRooms.SearchRoomsMock.mutex.Unlock()

	for _, e := range mmSearchRooms.SearchRoomsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchRooms.SearchRoomsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchRooms.SearchRoomsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchRooms.SearchRoomsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchRooms.SearchRoomsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockSearchRoomsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchRooms.t.Errorf("ChatServiceClientMock.SearchRooms got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchRooms.t.Errorf("ChatServiceClientMock.SearchRooms got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchRooms.t.Errorf("ChatServiceClientMock.SearchRooms got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchRooms.SearchRoomsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchRooms.t.Fatal("No results are set for the ChatServiceClientMock.SearchRooms")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchRooms.funcSearchRooms != nil {
		return mmSearchRooms.funcSearchRooms(ctx, pp1)
	}
	mmSearchRooms.t.Fatalf("Unexpected call to ChatServiceClientMock.SearchRooms. %v %v", ctx, pp1)
	return
}

// SearchRoomsAfterCounter returns a count of finished ChatServiceClientMock.SearchRooms invocations
func (mmSearchRooms *ChatServiceClientMock) SearchRoomsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRooms.afterSearchRoomsCounter)
}

// SearchRoomsBeforeCounter returns a count of ChatServiceClientMock.SearchRooms invocations
func (mmSearchRooms *ChatServiceClientMock) SearchRoomsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRooms.beforeSearchRoomsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.SearchRooms.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchRooms *mChatServiceClientMockSearchRooms) Calls() []*ChatServiceClientMockSearchRoomsParams {
	mmSearchRooms.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockSearchRoomsParams, len(mmSearchRooms.callArgs))
	copy(argCopy, mmSearchRooms.callArgs)

	mmSearchRooms.mutex.RUnlock()

	return argCopy
}

// MinimockSearchRoomsDone returns true if the count of the SearchRooms invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockSearchRoomsDone() bool {
	if m.SearchRoomsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchRoomsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchRoomsMock.invocationsDone()
}

// MinimockSearchRoomsInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockSearchRoomsInspect() {
	for _, e := range m.SearchRoomsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.SearchRooms at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchRoomsCounter := mm_atomic.LoadUint64(&m.afterSearchRoomsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchRoomsMock.defaultExpectation != nil && afterSearchRoomsCounter < 1 {
		if m.SearchRoomsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.SearchRooms at\n%s", m.SearchRoomsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.SearchRooms at\n%s with params: %#v", m.SearchRoomsMock.defaultExpectation.expectationOrigins.origin, *m.SearchRoomsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchRooms != nil && afterSearchRoomsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.SearchRooms at\n%s", m.funcSearchRoomsOrigin)
	}

	if !m.SearchRoomsMock.invocationsDone() && afterSearchRoomsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.SearchRooms at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchRoomsMock.expectedInvocations), m.SearchRoomsMock.expectedInvocationsOrigin, afterSearchRoomsCounter)
	}
}

type mChatServiceClientMockSendEvent struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockSendEventExpectation
	expectations       []*ChatServiceClientMockSendEventExpectation

	callArgs []*ChatServiceClientMockSendEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockSendEventExpectation specifies expectation struct of the ChatServiceClient.SendEvent
type ChatServiceClientMockSendEventExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockSendEventParams
	paramPtrs          *ChatServiceClientMockSendEventParamPtrs
	expectationOrigins ChatServiceClientMockSendEventExpectationOrigins
	results            *ChatServiceClientMockSendEventResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockSendEventParams contains parameters of the ChatServiceClient.SendEvent
type ChatServiceClientMockSendEventParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SendEventRequest]
}

// ChatServiceClientMockSendEventParamPtrs contains pointers to parameters of the ChatServiceClient.SendEvent
type ChatServiceClientMockSendEventParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SendEventRequest]
}

// ChatServiceClientMockSendEventResults contains results of the ChatServiceClient.SendEvent
type ChatServiceClientMockSendEventResults struct {
	pp2 *connect.Response[v1.SendEventResponse]
	err error
}

// ChatServiceClientMockSendEventOrigins contains origins of expectations of the ChatServiceClient.SendEvent
type ChatServiceClientMockSendEventExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendEvent *mChatServiceClientMockSendEvent) Optional() *mChatServiceClientMockSendEvent {
	mmSendEvent.optional = true
	return mmSendEvent
}

// Expect sets up expected params for ChatServiceClient.SendEvent
func (mmSendEvent *mChatServiceClientMockSendEvent) Expect(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) *mChatServiceClientMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceClientMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.paramPtrs != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by ExpectParams functions")
	}

	mmSendEvent.defaultExpectation.params = &ChatServiceClientMockSendEventParams{ctx, pp1}
	mmSendEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendEvent.expectations {
		if minimock.Equal(e.params, mmSendEvent.defaultExpectation.params) {
			mmSendEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendEvent.defaultExpectation.params)
		}
	}

	return mmSendEvent
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.SendEvent
func (mmSendEvent *mChatServiceClientMockSendEvent) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceClientMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.params != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Expect")
	}

	if mmSendEvent.defaultExpectation.paramPtrs == nil {
		mmSendEvent.defaultExpectation.paramPtrs = &ChatServiceClientMockSendEventParamPtrs{}
	}
	mmSendEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendEvent
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.SendEvent
func (mmSendEvent *mChatServiceClientMockSendEvent) ExpectPp1Param2(pp1 *connect.Request[v1.SendEventRequest]) *mChatServiceClientMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceClientMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.params != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Expect")
	}

	if mmSendEvent.defaultExpectation.paramPtrs == nil {
		mmSendEvent.defaultExpectation.paramPtrs = &ChatServiceClientMockSendEventParamPtrs{}
	}
	mmSendEvent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSendEvent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSendEvent
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.SendEvent
func (mmSendEvent *mChatServiceClientMockSendEvent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest])) *mChatServiceClientMockSendEvent {
	if mmSendEvent.mock.inspectFuncSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.SendEvent")
	}

	mmSendEvent.mock.inspectFuncSendEvent = f

	return mmSendEvent
}

// Return sets up results that will be returned by ChatServiceClient.SendEvent
func (mmSendEvent *mChatServiceClientMockSendEvent) Return(pp2 *connect.Response[v1.SendEventResponse], err error) *ChatServiceClientMock {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceClientMockSendEventExpectation{mock: mmSendEvent.mock}
	}
	mmSendEvent.defaultExpectation.results = &ChatServiceClientMockSendEventResults{pp2, err}
	mmSendEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendEvent.mock
}

// Set uses given function f to mock the ChatServiceClient.SendEvent method
func (mmSendEvent *mChatServiceClientMockSendEvent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) (pp2 *connect.Response[v1.SendEventResponse], err error)) *ChatServiceClientMock {
	if mmSendEvent.defaultExpectation != nil {
		mmSendEvent.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.SendEvent method")
	}

	if len(mmSendEvent.expectations) > 0 {
		mmSendEvent.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.SendEvent method")
	}

	mmSendEvent.mock.funcSendEvent = f
	mmSendEvent.mock.funcSendEventOrigin = minimock.CallerInfo(1)
	return mmSendEvent.mock
}

// When sets expectation for the ChatServiceClient.SendEvent which will trigger the result defined by the following
// Then helper
func (mmSendEvent *mChatServiceClientMockSendEvent) When(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) *ChatServiceClientMockSendEventExpectation {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceClientMock.SendEvent mock is already set by Set")
	}

	expectation := &ChatServiceClientMockSendEventExpectation{
		mock:               mmSendEvent.mock,
		params:             &ChatServiceClientMockSendEventParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockSendEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendEvent.expectations = append(mmSendEvent.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.SendEvent return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockSendEventExpectation) Then(pp2 *connect.Response[v1.SendEventResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockSendEventResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.SendEvent should be invoked
func (mmSendEvent *mChatServiceClientMockSendEvent) Times(n uint64) *mChatServiceClientMockSendEvent {
	if n == 0 {
		mmSendEvent.mock.t.Fatalf("Times of ChatServiceClientMock.SendEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendEvent.expectedInvocations, n)
	mmSendEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendEvent
}

func (mmSendEvent *mChatServiceClientMockSendEvent) invocationsDone() bool {
	if len(mmSendEvent.expectations) == 0 && mmSendEvent.defaultExpectation == nil && mmSendEvent.mock.funcSendEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendEvent.mock.afterSendEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendEvent implements mm_chatv1connect.ChatServiceClient
func (mmSendEvent *ChatServiceClientMock) SendEvent(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) (pp2 *connect.Response[v1.SendEventResponse], err error) {
	mm_atomic.AddUint64(&mmSendEvent.beforeSendEventCounter, 1)
	defer mm_atomic.AddUint64(&mmSendEvent.afterSendEventCounter, 1)

	mmSendEvent.t.Helper()

	if mmSendEvent.inspectFuncSendEvent != nil {
		mmSendEvent.inspectFuncSendEvent(ctx, pp1)
	}

	mm_params := ChatServiceClientMockSendEventParams{ctx, pp1}

	// Record call args
	mmSendEvent.SendEventMock.mutex.Lock()
	mmSendEvent.SendEventMock.callArgs = append(mmSendEvent.SendEventMock.callArgs, &mm_params)
	mmSendEvent.SendEventMock.mutex.Unlock()

	for _, e := range mmSendEvent.SendEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSendEvent.SendEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendEvent.SendEventMock.defaultExpectation.Counter, 1)
		mm_want := mmSendEvent.SendEventMock.defaultExpectation.params
		mm_want_ptrs := mmSendEvent.SendEventMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockSendEventParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendEvent.t.Errorf("ChatServiceClientMock.SendEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSendEvent.t.Errorf("ChatServiceClientMock.SendEvent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendEvent.t.Errorf("ChatServiceClientMock.SendEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendEvent.SendEventMock.defaultExpectation.results
		if mm_results == nil {
			mmSendEvent.t.Fatal("No results are set for the ChatServiceClientMock.SendEvent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSendEvent.funcSendEvent != nil {
		return mmSendEvent.funcSendEvent(ctx, pp1)
	}
	mmSendEvent.t.Fatalf("Unexpected call to ChatServiceClientMock.SendEvent. %v %v", ctx, pp1)
	return
}

// SendEventAfterCounter returns a count of finished ChatServiceClientMock.SendEvent invocations
func (mmSendEvent *ChatServiceClientMock) SendEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendEvent.afterSendEventCounter)
}

// SendEventBeforeCounter returns a count of ChatServiceClientMock.SendEvent invocations
func (mmSendEvent *ChatServiceClientMock) SendEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendEvent.beforeSendEventCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.SendEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendEvent *mChatServiceClientMockSendEvent) Calls() []*ChatServiceClientMockSendEventParams {
	mmSendEvent.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockSendEventParams, len(mmSendEvent.callArgs))
	copy(argCopy, mmSendEvent.callArgs)

	mmSendEvent.mutex.RUnlock()

	return argCopy
}

// MinimockSendEventDone returns true if the count of the SendEvent invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockSendEventDone() bool {
	if m.SendEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendEventMock.invocationsDone()
}

// MinimockSendEventInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockSendEventInspect() {
	for _, e := range m.SendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.SendEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendEventCounter := mm_atomic.LoadUint64(&m.afterSendEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendEventMock.defaultExpectation != nil && afterSendEventCounter < 1 {
		if m.SendEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.SendEvent at\n%s", m.SendEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.SendEvent at\n%s with params: %#v", m.SendEventMock.defaultExpectation.expectationOrigins.origin, *m.SendEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendEvent != nil && afterSendEventCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.SendEvent at\n%s", m.funcSendEventOrigin)
	}

	if !m.SendEventMock.invocationsDone() && afterSendEventCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.SendEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendEventMock.expectedInvocations), m.SendEventMock.expectedInvocationsOrigin, afterSendEventCounter)
	}
}

type mChatServiceClientMockUpdateClientState struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockUpdateClientStateExpectation
	expectations       []*ChatServiceClientMockUpdateClientStateExpectation

	callArgs []*ChatServiceClientMockUpdateClientStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockUpdateClientStateExpectation specifies expectation struct of the ChatServiceClient.UpdateClientState
type ChatServiceClientMockUpdateClientStateExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockUpdateClientStateParams
	paramPtrs          *ChatServiceClientMockUpdateClientStateParamPtrs
	expectationOrigins ChatServiceClientMockUpdateClientStateExpectationOrigins
	results            *ChatServiceClientMockUpdateClientStateResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockUpdateClientStateParams contains parameters of the ChatServiceClient.UpdateClientState
type ChatServiceClientMockUpdateClientStateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateClientStateRequest]
}

// ChatServiceClientMockUpdateClientStateParamPtrs contains pointers to parameters of the ChatServiceClient.UpdateClientState
type ChatServiceClientMockUpdateClientStateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateClientStateRequest]
}

// ChatServiceClientMockUpdateClientStateResults contains results of the ChatServiceClient.UpdateClientState
type ChatServiceClientMockUpdateClientStateResults struct {
	pp2 *connect.Response[v1.UpdateClientStateResponse]
	err error
}

// ChatServiceClientMockUpdateClientStateOrigins contains origins of expectations of the ChatServiceClient.UpdateClientState
type ChatServiceClientMockUpdateClientStateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Optional() *mChatServiceClientMockUpdateClientState {
	mmUpdateClientState.optional = true
	return mmUpdateClientState
}

// Expect sets up expected params for ChatServiceClient.UpdateClientState
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) *mChatServiceClientMockUpdateClientState {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceClientMockUpdateClientStateExpectation{}
	}

	if mmUpdateClientState.defaultExpectation.paramPtrs != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by ExpectParams functions")
	}

	mmUpdateClientState.defaultExpectation.params = &ChatServiceClientMockUpdateClientStateParams{ctx, pp1}
	mmUpdateClientState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateClientState.expectations {
		if minimock.Equal(e.params, mmUpdateClientState.defaultExpectation.params) {
			mmUpdateClientState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateClientState.defaultExpectation.params)
		}
	}

	return mmUpdateClientState
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.UpdateClientState
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockUpdateClientState {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceClientMockUpdateClientStateExpectation{}
	}

	if mmUpdateClientState.defaultExpectation.params != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Expect")
	}

	if mmUpdateClientState.defaultExpectation.paramPtrs == nil {
		mmUpdateClientState.defaultExpectation.paramPtrs = &ChatServiceClientMockUpdateClientStateParamPtrs{}
	}
	mmUpdateClientState.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateClientState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateClientState
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.UpdateClientState
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateClientStateRequest]) *mChatServiceClientMockUpdateClientState {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceClientMockUpdateClientStateExpectation{}
	}

	if mmUpdateClientState.defaultExpectation.params != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Expect")
	}

	if mmUpdateClientState.defaultExpectation.paramPtrs == nil {
		mmUpdateClientState.defaultExpectation.paramPtrs = &ChatServiceClientMockUpdateClientStateParamPtrs{}
	}
	mmUpdateClientState.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateClientState.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateClientState
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.UpdateClientState
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest])) *mChatServiceClientMockUpdateClientState {
	if mmUpdateClientState.mock.inspectFuncUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.UpdateClientState")
	}

	mmUpdateClientState.mock.inspectFuncUpdateClientState = f

	return mmUpdateClientState
}

// Return sets up results that will be returned by ChatServiceClient.UpdateClientState
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Return(pp2 *connect.Response[v1.UpdateClientStateResponse], err error) *ChatServiceClientMock {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceClientMockUpdateClientStateExpectation{mock: mmUpdateClientState.mock}
	}
	mmUpdateClientState.defaultExpectation.results = &ChatServiceClientMockUpdateClientStateResults{pp2, err}
	mmUpdateClientState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateClientState.mock
}

// Set uses given function f to mock the ChatServiceClient.UpdateClientState method
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) (pp2 *connect.Response[v1.UpdateClientStateResponse], err error)) *ChatServiceClientMock {
	if mmUpdateClientState.defaultExpectation != nil {
		mmUpdateClientState.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.UpdateClientState method")
	}

	if len(mmUpdateClientState.expectations) > 0 {
		mmUpdateClientState.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.UpdateClientState method")
	}

	mmUpdateClientState.mock.funcUpdateClientState = f
	mmUpdateClientState.mock.funcUpdateClientStateOrigin = minimock.CallerInfo(1)
	return mmUpdateClientState.mock
}

// When sets expectation for the ChatServiceClient.UpdateClientState which will trigger the result defined by the following
// Then helper
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) When(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) *ChatServiceClientMockUpdateClientStateExpectation {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceClientMock.UpdateClientState mock is already set by Set")
	}

	expectation := &ChatServiceClientMockUpdateClientStateExpectation{
		mock:               mmUpdateClientState.mock,
		params:             &ChatServiceClientMockUpdateClientStateParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockUpdateClientStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateClientState.expectations = append(mmUpdateClientState.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.UpdateClientState return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockUpdateClientStateExpectation) Then(pp2 *connect.Response[v1.UpdateClientStateResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockUpdateClientStateResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.UpdateClientState should be invoked
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Times(n uint64) *mChatServiceClientMockUpdateClientState {
	if n == 0 {
		mmUpdateClientState.mock.t.Fatalf("Times of ChatServiceClientMock.UpdateClientState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateClientState.expectedInvocations, n)
	mmUpdateClientState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateClientState
}

func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) invocationsDone() bool {
	if len(mmUpdateClientState.expectations) == 0 && mmUpdateClientState.defaultExpectation == nil && mmUpdateClientState.mock.funcUpdateClientState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateClientState.mock.afterUpdateClientStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateClientState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateClientState implements mm_chatv1connect.ChatServiceClient
func (mmUpdateClientState *ChatServiceClientMock) UpdateClientState(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) (pp2 *connect.Response[v1.UpdateClientStateResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateClientState.beforeUpdateClientStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateClientState.afterUpdateClientStateCounter, 1)

	mmUpdateClientState.t.Helper()

	if mmUpdateClientState.inspectFuncUpdateClientState != nil {
		mmUpdateClientState.inspectFuncUpdateClientState(ctx, pp1)
	}

	mm_params := ChatServiceClientMockUpdateClientStateParams{ctx, pp1}

	// Record call args
	mmUpdateClientState.UpdateClientStateMock.mutex.Lock()
	mmUpdateClientState.UpdateClientStateMock.callArgs = append(mmUpdateClientState.UpdateClientStateMock.callArgs, &mm_params)
	mmUpdateClientState.UpdateClientStateMock.mutex.Unlock()

	for _, e := range mmUpdateClientState.UpdateClientStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateClientState.UpdateClientStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateClientState.UpdateClientStateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateClientState.UpdateClientStateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateClientState.UpdateClientStateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockUpdateClientStateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateClientState.t.Errorf("ChatServiceClientMock.UpdateClientState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClientState.UpdateClientStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateClientState.t.Errorf("ChatServiceClientMock.UpdateClientState got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClientState.UpdateClientStateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateClientState.t.Errorf("ChatServiceClientMock.UpdateClientState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateClientState.UpdateClientStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateClientState.UpdateClientStateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateClientState.t.Fatal("No results are set for the ChatServiceClientMock.UpdateClientState")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateClientState.funcUpdateClientState != nil {
		return mmUpdateClientState.funcUpdateClientState(ctx, pp1)
	}
	mmUpdateClientState.t.Fatalf("Unexpected call to ChatServiceClientMock.UpdateClientState. %v %v", ctx, pp1)
	return
}

// UpdateClientStateAfterCounter returns a count of finished ChatServiceClientMock.UpdateClientState invocations
func (mmUpdateClientState *ChatServiceClientMock) UpdateClientStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClientState.afterUpdateClientStateCounter)
}

// UpdateClientStateBeforeCounter returns a count of ChatServiceClientMock.UpdateClientState invocations
func (mmUpdateClientState *ChatServiceClientMock) UpdateClientStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClientState.beforeUpdateClientStateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.UpdateClientState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateClientState *mChatServiceClientMockUpdateClientState) Calls() []*ChatServiceClientMockUpdateClientStateParams {
	mmUpdateClientState.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockUpdateClientStateParams, len(mmUpdateClientState.callArgs))
	copy(argCopy, mmUpdateClientState.callArgs)

	mmUpdateClientState.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateClientStateDone returns true if the count of the UpdateClientState invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockUpdateClientStateDone() bool {
	if m.UpdateClientStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateClientStateMock.invocationsDone()
}

// MinimockUpdateClientStateInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockUpdateClientStateInspect() {
	for _, e := range m.UpdateClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateClientState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateClientStateCounter := mm_atomic.LoadUint64(&m.afterUpdateClientStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClientStateMock.defaultExpectation != nil && afterUpdateClientStateCounter < 1 {
		if m.UpdateClientStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateClientState at\n%s", m.UpdateClientStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateClientState at\n%s with params: %#v", m.UpdateClientStateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateClientStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClientState != nil && afterUpdateClientStateCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.UpdateClientState at\n%s", m.funcUpdateClientStateOrigin)
	}

	if !m.UpdateClientStateMock.invocationsDone() && afterUpdateClientStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.UpdateClientState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateClientStateMock.expectedInvocations), m.UpdateClientStateMock.expectedInvocationsOrigin, afterUpdateClientStateCounter)
	}
}

type mChatServiceClientMockUpdateRoom struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockUpdateRoomExpectation
	expectations       []*ChatServiceClientMockUpdateRoomExpectation

	callArgs []*ChatServiceClientMockUpdateRoomParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockUpdateRoomExpectation specifies expectation struct of the ChatServiceClient.UpdateRoom
type ChatServiceClientMockUpdateRoomExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockUpdateRoomParams
	paramPtrs          *ChatServiceClientMockUpdateRoomParamPtrs
	expectationOrigins ChatServiceClientMockUpdateRoomExpectationOrigins
	results            *ChatServiceClientMockUpdateRoomResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockUpdateRoomParams contains parameters of the ChatServiceClient.UpdateRoom
type ChatServiceClientMockUpdateRoomParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateRoomRequest]
}

// ChatServiceClientMockUpdateRoomParamPtrs contains pointers to parameters of the ChatServiceClient.UpdateRoom
type ChatServiceClientMockUpdateRoomParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateRoomRequest]
}

// ChatServiceClientMockUpdateRoomResults contains results of the ChatServiceClient.UpdateRoom
type ChatServiceClientMockUpdateRoomResults struct {
	pp2 *connect.Response[v1.UpdateRoomResponse]
	err error
}

// ChatServiceClientMockUpdateRoomOrigins contains origins of expectations of the ChatServiceClient.UpdateRoom
type ChatServiceClientMockUpdateRoomExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Optional() *mChatServiceClientMockUpdateRoom {
	mmUpdateRoom.optional = true
	return mmUpdateRoom
}

// Expect sets up expected params for ChatServiceClient.UpdateRoom
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) *mChatServiceClientMockUpdateRoom {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceClientMockUpdateRoomExpectation{}
	}

	if mmUpdateRoom.defaultExpectation.paramPtrs != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by ExpectParams functions")
	}

	mmUpdateRoom.defaultExpectation.params = &ChatServiceClientMockUpdateRoomParams{ctx, pp1}
	mmUpdateRoom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateRoom.expectations {
		if minimock.Equal(e.params, mmUpdateRoom.defaultExpectation.params) {
			mmUpdateRoom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateRoom.defaultExpectation.params)
		}
	}

	return mmUpdateRoom
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.UpdateRoom
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockUpdateRoom {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceClientMockUpdateRoomExpectation{}
	}

	if mmUpdateRoom.defaultExpectation.params != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Expect")
	}

	if mmUpdateRoom.defaultExpectation.paramPtrs == nil {
		mmUpdateRoom.defaultExpectation.paramPtrs = &ChatServiceClientMockUpdateRoomParamPtrs{}
	}
	mmUpdateRoom.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateRoom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateRoom
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.UpdateRoom
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateRoomRequest]) *mChatServiceClientMockUpdateRoom {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceClientMockUpdateRoomExpectation{}
	}

	if mmUpdateRoom.defaultExpectation.params != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Expect")
	}

	if mmUpdateRoom.defaultExpectation.paramPtrs == nil {
		mmUpdateRoom.defaultExpectation.paramPtrs = &ChatServiceClientMockUpdateRoomParamPtrs{}
	}
	mmUpdateRoom.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateRoom.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateRoom
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.UpdateRoom
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest])) *mChatServiceClientMockUpdateRoom {
	if mmUpdateRoom.mock.inspectFuncUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.UpdateRoom")
	}

	mmUpdateRoom.mock.inspectFuncUpdateRoom = f

	return mmUpdateRoom
}

// Return sets up results that will be returned by ChatServiceClient.UpdateRoom
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Return(pp2 *connect.Response[v1.UpdateRoomResponse], err error) *ChatServiceClientMock {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceClientMockUpdateRoomExpectation{mock: mmUpdateRoom.mock}
	}
	mmUpdateRoom.defaultExpectation.results = &ChatServiceClientMockUpdateRoomResults{pp2, err}
	mmUpdateRoom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateRoom.mock
}

// Set uses given function f to mock the ChatServiceClient.UpdateRoom method
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) (pp2 *connect.Response[v1.UpdateRoomResponse], err error)) *ChatServiceClientMock {
	if mmUpdateRoom.defaultExpectation != nil {
		mmUpdateRoom.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.UpdateRoom method")
	}

	if len(mmUpdateRoom.expectations) > 0 {
		mmUpdateRoom.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.UpdateRoom method")
	}

	mmUpdateRoom.mock.funcUpdateRoom = f
	mmUpdateRoom.mock.funcUpdateRoomOrigin = minimock.CallerInfo(1)
	return mmUpdateRoom.mock
}

// When sets expectation for the ChatServiceClient.UpdateRoom which will trigger the result defined by the following
// Then helper
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) When(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) *ChatServiceClientMockUpdateRoomExpectation {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceClientMock.UpdateRoom mock is already set by Set")
	}

	expectation := &ChatServiceClientMockUpdateRoomExpectation{
		mock:               mmUpdateRoom.mock,
		params:             &ChatServiceClientMockUpdateRoomParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockUpdateRoomExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateRoom.expectations = append(mmUpdateRoom.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.UpdateRoom return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockUpdateRoomExpectation) Then(pp2 *connect.Response[v1.UpdateRoomResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockUpdateRoomResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.UpdateRoom should be invoked
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Times(n uint64) *mChatServiceClientMockUpdateRoom {
	if n == 0 {
		mmUpdateRoom.mock.t.Fatalf("Times of ChatServiceClientMock.UpdateRoom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateRoom.expectedInvocations, n)
	mmUpdateRoom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateRoom
}

func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) invocationsDone() bool {
	if len(mmUpdateRoom.expectations) == 0 && mmUpdateRoom.defaultExpectation == nil && mmUpdateRoom.mock.funcUpdateRoom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateRoom.mock.afterUpdateRoomCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateRoom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateRoom implements mm_chatv1connect.ChatServiceClient
func (mmUpdateRoom *ChatServiceClientMock) UpdateRoom(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) (pp2 *connect.Response[v1.UpdateRoomResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateRoom.beforeUpdateRoomCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateRoom.afterUpdateRoomCounter, 1)

	mmUpdateRoom.t.Helper()

	if mmUpdateRoom.inspectFuncUpdateRoom != nil {
		mmUpdateRoom.inspectFuncUpdateRoom(ctx, pp1)
	}

	mm_params := ChatServiceClientMockUpdateRoomParams{ctx, pp1}

	// Record call args
	mmUpdateRoom.UpdateRoomMock.mutex.Lock()
	mmUpdateRoom.UpdateRoomMock.callArgs = append(mmUpdateRoom.UpdateRoomMock.callArgs, &mm_params)
	mmUpdateRoom.UpdateRoomMock.mutex.Unlock()

	for _, e := range mmUpdateRoom.UpdateRoomMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateRoom.UpdateRoomMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateRoom.UpdateRoomMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateRoom.UpdateRoomMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateRoom.UpdateRoomMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockUpdateRoomParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateRoom.t.Errorf("ChatServiceClientMock.UpdateRoom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateRoom.UpdateRoomMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateRoom.t.Errorf("ChatServiceClientMock.UpdateRoom got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateRoom.UpdateRoomMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateRoom.t.Errorf("ChatServiceClientMock.UpdateRoom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateRoom.UpdateRoomMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateRoom.UpdateRoomMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateRoom.t.Fatal("No results are set for the ChatServiceClientMock.UpdateRoom")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateRoom.funcUpdateRoom != nil {
		return mmUpdateRoom.funcUpdateRoom(ctx, pp1)
	}
	mmUpdateRoom.t.Fatalf("Unexpected call to ChatServiceClientMock.UpdateRoom. %v %v", ctx, pp1)
	return
}

// UpdateRoomAfterCounter returns a count of finished ChatServiceClientMock.UpdateRoom invocations
func (mmUpdateRoom *ChatServiceClientMock) UpdateRoomAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRoom.afterUpdateRoomCounter)
}

// UpdateRoomBeforeCounter returns a count of ChatServiceClientMock.UpdateRoom invocations
func (mmUpdateRoom *ChatServiceClientMock) UpdateRoomBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRoom.beforeUpdateRoomCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.UpdateRoom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateRoom *mChatServiceClientMockUpdateRoom) Calls() []*ChatServiceClientMockUpdateRoomParams {
	mmUpdateRoom.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockUpdateRoomParams, len(mmUpdateRoom.callArgs))
	copy(argCopy, mmUpdateRoom.callArgs)

	mmUpdateRoom.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateRoomDone returns true if the count of the UpdateRoom invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockUpdateRoomDone() bool {
	if m.UpdateRoomMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateRoomMock.invocationsDone()
}

// MinimockUpdateRoomInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockUpdateRoomInspect() {
	for _, e := range m.UpdateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateRoom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateRoomCounter := mm_atomic.LoadUint64(&m.afterUpdateRoomCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateRoomMock.defaultExpectation != nil && afterUpdateRoomCounter < 1 {
		if m.UpdateRoomMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateRoom at\n%s", m.UpdateRoomMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateRoom at\n%s with params: %#v", m.UpdateRoomMock.defaultExpectation.expectationOrigins.origin, *m.UpdateRoomMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateRoom != nil && afterUpdateRoomCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.UpdateRoom at\n%s", m.funcUpdateRoomOrigin)
	}

	if !m.UpdateRoomMock.invocationsDone() && afterUpdateRoomCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.UpdateRoom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateRoomMock.expectedInvocations), m.UpdateRoomMock.expectedInvocationsOrigin, afterUpdateRoomCounter)
	}
}

type mChatServiceClientMockUpdateSubscriptionRole struct {
	optional           bool
	mock               *ChatServiceClientMock
	defaultExpectation *ChatServiceClientMockUpdateSubscriptionRoleExpectation
	expectations       []*ChatServiceClientMockUpdateSubscriptionRoleExpectation

	callArgs []*ChatServiceClientMockUpdateSubscriptionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceClientMockUpdateSubscriptionRoleExpectation specifies expectation struct of the ChatServiceClient.UpdateSubscriptionRole
type ChatServiceClientMockUpdateSubscriptionRoleExpectation struct {
	mock               *ChatServiceClientMock
	params             *ChatServiceClientMockUpdateSubscriptionRoleParams
	paramPtrs          *ChatServiceClientMockUpdateSubscriptionRoleParamPtrs
	expectationOrigins ChatServiceClientMockUpdateSubscriptionRoleExpectationOrigins
	results            *ChatServiceClientMockUpdateSubscriptionRoleResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceClientMockUpdateSubscriptionRoleParams contains parameters of the ChatServiceClient.UpdateSubscriptionRole
type ChatServiceClientMockUpdateSubscriptionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]
}

// ChatServiceClientMockUpdateSubscriptionRoleParamPtrs contains pointers to parameters of the ChatServiceClient.UpdateSubscriptionRole
type ChatServiceClientMockUpdateSubscriptionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateSubscriptionRoleRequest]
}

// ChatServiceClientMockUpdateSubscriptionRoleResults contains results of the ChatServiceClient.UpdateSubscriptionRole
type ChatServiceClientMockUpdateSubscriptionRoleResults struct {
	pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse]
	err error
}

// ChatServiceClientMockUpdateSubscriptionRoleOrigins contains origins of expectations of the ChatServiceClient.UpdateSubscriptionRole
type ChatServiceClientMockUpdateSubscriptionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Optional() *mChatServiceClientMockUpdateSubscriptionRole {
	mmUpdateSubscriptionRole.optional = true
	return mmUpdateSubscriptionRole
}

// Expect sets up expected params for ChatServiceClient.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) *mChatServiceClientMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceClientMockUpdateSubscriptionRoleExpectation{}
	}

	if mmUpdateSubscriptionRole.defaultExpectation.paramPtrs != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by ExpectParams functions")
	}

	mmUpdateSubscriptionRole.defaultExpectation.params = &ChatServiceClientMockUpdateSubscriptionRoleParams{ctx, pp1}
	mmUpdateSubscriptionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateSubscriptionRole.expectations {
		if minimock.Equal(e.params, mmUpdateSubscriptionRole.defaultExpectation.params) {
			mmUpdateSubscriptionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscriptionRole.defaultExpectation.params)
		}
	}

	return mmUpdateSubscriptionRole
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceClient.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) ExpectCtxParam1(ctx context.Context) *mChatServiceClientMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceClientMockUpdateSubscriptionRoleExpectation{}
	}

	if mmUpdateSubscriptionRole.defaultExpectation.params != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Expect")
	}

	if mmUpdateSubscriptionRole.defaultExpectation.paramPtrs == nil {
		mmUpdateSubscriptionRole.defaultExpectation.paramPtrs = &ChatServiceClientMockUpdateSubscriptionRoleParamPtrs{}
	}
	mmUpdateSubscriptionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateSubscriptionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateSubscriptionRole
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceClient.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) *mChatServiceClientMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceClientMockUpdateSubscriptionRoleExpectation{}
	}

	if mmUpdateSubscriptionRole.defaultExpectation.params != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Expect")
	}

	if mmUpdateSubscriptionRole.defaultExpectation.paramPtrs == nil {
		mmUpdateSubscriptionRole.defaultExpectation.paramPtrs = &ChatServiceClientMockUpdateSubscriptionRoleParamPtrs{}
	}
	mmUpdateSubscriptionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateSubscriptionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateSubscriptionRole
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceClient.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest])) *mChatServiceClientMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.inspectFuncUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Inspect function is already set for ChatServiceClientMock.UpdateSubscriptionRole")
	}

	mmUpdateSubscriptionRole.mock.inspectFuncUpdateSubscriptionRole = f

	return mmUpdateSubscriptionRole
}

// Return sets up results that will be returned by ChatServiceClient.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Return(pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error) *ChatServiceClientMock {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceClientMockUpdateSubscriptionRoleExpectation{mock: mmUpdateSubscriptionRole.mock}
	}
	mmUpdateSubscriptionRole.defaultExpectation.results = &ChatServiceClientMockUpdateSubscriptionRoleResults{pp2, err}
	mmUpdateSubscriptionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateSubscriptionRole.mock
}

// Set uses given function f to mock the ChatServiceClient.UpdateSubscriptionRole method
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) (pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error)) *ChatServiceClientMock {
	if mmUpdateSubscriptionRole.defaultExpectation != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Default expectation is already set for the ChatServiceClient.UpdateSubscriptionRole method")
	}

	if len(mmUpdateSubscriptionRole.expectations) > 0 {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Some expectations are already set for the ChatServiceClient.UpdateSubscriptionRole method")
	}

	mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole = f
	mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRoleOrigin = minimock.CallerInfo(1)
	return mmUpdateSubscriptionRole.mock
}

// When sets expectation for the ChatServiceClient.UpdateSubscriptionRole which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) When(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) *ChatServiceClientMockUpdateSubscriptionRoleExpectation {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceClientMock.UpdateSubscriptionRole mock is already set by Set")
	}

	expectation := &ChatServiceClientMockUpdateSubscriptionRoleExpectation{
		mock:               mmUpdateSubscriptionRole.mock,
		params:             &ChatServiceClientMockUpdateSubscriptionRoleParams{ctx, pp1},
		expectationOrigins: ChatServiceClientMockUpdateSubscriptionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateSubscriptionRole.expectations = append(mmUpdateSubscriptionRole.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceClient.UpdateSubscriptionRole return parameters for the expectation previously defined by the When method
func (e *ChatServiceClientMockUpdateSubscriptionRoleExpectation) Then(pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error) *ChatServiceClientMock {
	e.results = &ChatServiceClientMockUpdateSubscriptionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceClient.UpdateSubscriptionRole should be invoked
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Times(n uint64) *mChatServiceClientMockUpdateSubscriptionRole {
	if n == 0 {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Times of ChatServiceClientMock.UpdateSubscriptionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateSubscriptionRole.expectedInvocations, n)
	mmUpdateSubscriptionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateSubscriptionRole
}

func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) invocationsDone() bool {
	if len(mmUpdateSubscriptionRole.expectations) == 0 && mmUpdateSubscriptionRole.defaultExpectation == nil && mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.mock.afterUpdateSubscriptionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateSubscriptionRole implements mm_chatv1connect.ChatServiceClient
func (mmUpdateSubscriptionRole *ChatServiceClientMock) UpdateSubscriptionRole(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) (pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateSubscriptionRole.beforeUpdateSubscriptionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscriptionRole.afterUpdateSubscriptionRoleCounter, 1)

	mmUpdateSubscriptionRole.t.Helper()

	if mmUpdateSubscriptionRole.inspectFuncUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.inspectFuncUpdateSubscriptionRole(ctx, pp1)
	}

	mm_params := ChatServiceClientMockUpdateSubscriptionRoleParams{ctx, pp1}

	// Record call args
	mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.mutex.Lock()
	mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.callArgs = append(mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.callArgs, &mm_params)
	mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.mutex.Unlock()

	for _, e := range mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceClientMockUpdateSubscriptionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateSubscriptionRole.t.Errorf("ChatServiceClientMock.UpdateSubscriptionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateSubscriptionRole.t.Errorf("ChatServiceClientMock.UpdateSubscriptionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscriptionRole.t.Errorf("ChatServiceClientMock.UpdateSubscriptionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscriptionRole.t.Fatal("No results are set for the ChatServiceClientMock.UpdateSubscriptionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateSubscriptionRole.funcUpdateSubscriptionRole != nil {
		return mmUpdateSubscriptionRole.funcUpdateSubscriptionRole(ctx, pp1)
	}
	mmUpdateSubscriptionRole.t.Fatalf("Unexpected call to ChatServiceClientMock.UpdateSubscriptionRole. %v %v", ctx, pp1)
	return
}

// UpdateSubscriptionRoleAfterCounter returns a count of finished ChatServiceClientMock.UpdateSubscriptionRole invocations
func (mmUpdateSubscriptionRole *ChatServiceClientMock) UpdateSubscriptionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.afterUpdateSubscriptionRoleCounter)
}

// UpdateSubscriptionRoleBeforeCounter returns a count of ChatServiceClientMock.UpdateSubscriptionRole invocations
func (mmUpdateSubscriptionRole *ChatServiceClientMock) UpdateSubscriptionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.beforeUpdateSubscriptionRoleCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceClientMock.UpdateSubscriptionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscriptionRole *mChatServiceClientMockUpdateSubscriptionRole) Calls() []*ChatServiceClientMockUpdateSubscriptionRoleParams {
	mmUpdateSubscriptionRole.mutex.RLock()

	argCopy := make([]*ChatServiceClientMockUpdateSubscriptionRoleParams, len(mmUpdateSubscriptionRole.callArgs))
	copy(argCopy, mmUpdateSubscriptionRole.callArgs)

	mmUpdateSubscriptionRole.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriptionRoleDone returns true if the count of the UpdateSubscriptionRole invocations corresponds
// the number of defined expectations
func (m *ChatServiceClientMock) MinimockUpdateSubscriptionRoleDone() bool {
	if m.UpdateSubscriptionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateSubscriptionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateSubscriptionRoleMock.invocationsDone()
}

// MinimockUpdateSubscriptionRoleInspect logs each unmet expectation
func (m *ChatServiceClientMock) MinimockUpdateSubscriptionRoleInspect() {
	for _, e := range m.UpdateSubscriptionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateSubscriptionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateSubscriptionRoleCounter := mm_atomic.LoadUint64(&m.afterUpdateSubscriptionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionRoleMock.defaultExpectation != nil && afterUpdateSubscriptionRoleCounter < 1 {
		if m.UpdateSubscriptionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateSubscriptionRole at\n%s", m.UpdateSubscriptionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceClientMock.UpdateSubscriptionRole at\n%s with params: %#v", m.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.origin, *m.UpdateSubscriptionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriptionRole != nil && afterUpdateSubscriptionRoleCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceClientMock.UpdateSubscriptionRole at\n%s", m.funcUpdateSubscriptionRoleOrigin)
	}

	if !m.UpdateSubscriptionRoleMock.invocationsDone() && afterUpdateSubscriptionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceClientMock.UpdateSubscriptionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateSubscriptionRoleMock.expectedInvocations), m.UpdateSubscriptionRoleMock.expectedInvocationsOrigin, afterUpdateSubscriptionRoleCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddRoomSubscriptionsInspect()

			m.MinimockCreateRoomInspect()

			m.MinimockDeleteRoomInspect()

			m.MinimockGetClientStateInspect()

			m.MinimockGetHistoryInspect()

			m.MinimockRemoveRoomSubscriptionsInspect()

			m.MinimockSearchRoomSubscriptionsInspect()

			m.MinimockSearchRoomsInspect()

			m.MinimockSendEventInspect()

			m.MinimockUpdateClientStateInspect()

			m.MinimockUpdateRoomInspect()

			m.MinimockUpdateSubscriptionRoleInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddRoomSubscriptionsDone() &&
		m.MinimockCreateRoomDone() &&
		m.MinimockDeleteRoomDone() &&
		m.MinimockGetClientStateDone() &&
		m.MinimockGetHistoryDone() &&
		m.MinimockRemoveRoomSubscriptionsDone() &&
		m.MinimockSearchRoomSubscriptionsDone() &&
		m.MinimockSearchRoomsDone() &&
		m.MinimockSendEventDone() &&
		m.MinimockUpdateClientStateDone() &&
		m.MinimockUpdateRoomDone() &&
		m.MinimockUpdateSubscriptionRoleDone()
}
