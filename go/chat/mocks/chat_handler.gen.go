// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/chat/connectrpc/go/chat/v1/chatv1connect.ChatServiceHandler -o chat_handler.gen.go -n ChatServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/chat/protocolbuffers/go/chat/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// ChatServiceHandlerMock implements mm_chatv1connect.ChatServiceHandler
type ChatServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddRoomSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error)
	funcAddRoomSubscriptionsOrigin    string
	inspectFuncAddRoomSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest])
	afterAddRoomSubscriptionsCounter  uint64
	beforeAddRoomSubscriptionsCounter uint64
	AddRoomSubscriptionsMock          mChatServiceHandlerMockAddRoomSubscriptions

	funcCreateRoom          func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) (pp2 *connect.Response[v1.CreateRoomResponse], err error)
	funcCreateRoomOrigin    string
	inspectFuncCreateRoom   func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest])
	afterCreateRoomCounter  uint64
	beforeCreateRoomCounter uint64
	CreateRoomMock          mChatServiceHandlerMockCreateRoom

	funcDeleteRoom          func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) (pp2 *connect.Response[v1.DeleteRoomResponse], err error)
	funcDeleteRoomOrigin    string
	inspectFuncDeleteRoom   func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest])
	afterDeleteRoomCounter  uint64
	beforeDeleteRoomCounter uint64
	DeleteRoomMock          mChatServiceHandlerMockDeleteRoom

	funcGetClientState          func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) (pp2 *connect.Response[v1.GetClientStateResponse], err error)
	funcGetClientStateOrigin    string
	inspectFuncGetClientState   func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest])
	afterGetClientStateCounter  uint64
	beforeGetClientStateCounter uint64
	GetClientStateMock          mChatServiceHandlerMockGetClientState

	funcGetHistory          func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) (pp2 *connect.Response[v1.GetHistoryResponse], err error)
	funcGetHistoryOrigin    string
	inspectFuncGetHistory   func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest])
	afterGetHistoryCounter  uint64
	beforeGetHistoryCounter uint64
	GetHistoryMock          mChatServiceHandlerMockGetHistory

	funcRemoveRoomSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error)
	funcRemoveRoomSubscriptionsOrigin    string
	inspectFuncRemoveRoomSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest])
	afterRemoveRoomSubscriptionsCounter  uint64
	beforeRemoveRoomSubscriptionsCounter uint64
	RemoveRoomSubscriptionsMock          mChatServiceHandlerMockRemoveRoomSubscriptions

	funcSearchRoomSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error)
	funcSearchRoomSubscriptionsOrigin    string
	inspectFuncSearchRoomSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest])
	afterSearchRoomSubscriptionsCounter  uint64
	beforeSearchRoomSubscriptionsCounter uint64
	SearchRoomSubscriptionsMock          mChatServiceHandlerMockSearchRoomSubscriptions

	funcSearchRooms          func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse]) (err error)
	funcSearchRoomsOrigin    string
	inspectFuncSearchRooms   func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse])
	afterSearchRoomsCounter  uint64
	beforeSearchRoomsCounter uint64
	SearchRoomsMock          mChatServiceHandlerMockSearchRooms

	funcSendEvent          func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) (pp2 *connect.Response[v1.SendEventResponse], err error)
	funcSendEventOrigin    string
	inspectFuncSendEvent   func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest])
	afterSendEventCounter  uint64
	beforeSendEventCounter uint64
	SendEventMock          mChatServiceHandlerMockSendEvent

	funcUpdateClientState          func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) (pp2 *connect.Response[v1.UpdateClientStateResponse], err error)
	funcUpdateClientStateOrigin    string
	inspectFuncUpdateClientState   func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest])
	afterUpdateClientStateCounter  uint64
	beforeUpdateClientStateCounter uint64
	UpdateClientStateMock          mChatServiceHandlerMockUpdateClientState

	funcUpdateRoom          func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) (pp2 *connect.Response[v1.UpdateRoomResponse], err error)
	funcUpdateRoomOrigin    string
	inspectFuncUpdateRoom   func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest])
	afterUpdateRoomCounter  uint64
	beforeUpdateRoomCounter uint64
	UpdateRoomMock          mChatServiceHandlerMockUpdateRoom

	funcUpdateSubscriptionRole          func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) (pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error)
	funcUpdateSubscriptionRoleOrigin    string
	inspectFuncUpdateSubscriptionRole   func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest])
	afterUpdateSubscriptionRoleCounter  uint64
	beforeUpdateSubscriptionRoleCounter uint64
	UpdateSubscriptionRoleMock          mChatServiceHandlerMockUpdateSubscriptionRole
}

// NewChatServiceHandlerMock returns a mock for mm_chatv1connect.ChatServiceHandler
func NewChatServiceHandlerMock(t minimock.Tester) *ChatServiceHandlerMock {
	m := &ChatServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddRoomSubscriptionsMock = mChatServiceHandlerMockAddRoomSubscriptions{mock: m}
	m.AddRoomSubscriptionsMock.callArgs = []*ChatServiceHandlerMockAddRoomSubscriptionsParams{}

	m.CreateRoomMock = mChatServiceHandlerMockCreateRoom{mock: m}
	m.CreateRoomMock.callArgs = []*ChatServiceHandlerMockCreateRoomParams{}

	m.DeleteRoomMock = mChatServiceHandlerMockDeleteRoom{mock: m}
	m.DeleteRoomMock.callArgs = []*ChatServiceHandlerMockDeleteRoomParams{}

	m.GetClientStateMock = mChatServiceHandlerMockGetClientState{mock: m}
	m.GetClientStateMock.callArgs = []*ChatServiceHandlerMockGetClientStateParams{}

	m.GetHistoryMock = mChatServiceHandlerMockGetHistory{mock: m}
	m.GetHistoryMock.callArgs = []*ChatServiceHandlerMockGetHistoryParams{}

	m.RemoveRoomSubscriptionsMock = mChatServiceHandlerMockRemoveRoomSubscriptions{mock: m}
	m.RemoveRoomSubscriptionsMock.callArgs = []*ChatServiceHandlerMockRemoveRoomSubscriptionsParams{}

	m.SearchRoomSubscriptionsMock = mChatServiceHandlerMockSearchRoomSubscriptions{mock: m}
	m.SearchRoomSubscriptionsMock.callArgs = []*ChatServiceHandlerMockSearchRoomSubscriptionsParams{}

	m.SearchRoomsMock = mChatServiceHandlerMockSearchRooms{mock: m}
	m.SearchRoomsMock.callArgs = []*ChatServiceHandlerMockSearchRoomsParams{}

	m.SendEventMock = mChatServiceHandlerMockSendEvent{mock: m}
	m.SendEventMock.callArgs = []*ChatServiceHandlerMockSendEventParams{}

	m.UpdateClientStateMock = mChatServiceHandlerMockUpdateClientState{mock: m}
	m.UpdateClientStateMock.callArgs = []*ChatServiceHandlerMockUpdateClientStateParams{}

	m.UpdateRoomMock = mChatServiceHandlerMockUpdateRoom{mock: m}
	m.UpdateRoomMock.callArgs = []*ChatServiceHandlerMockUpdateRoomParams{}

	m.UpdateSubscriptionRoleMock = mChatServiceHandlerMockUpdateSubscriptionRole{mock: m}
	m.UpdateSubscriptionRoleMock.callArgs = []*ChatServiceHandlerMockUpdateSubscriptionRoleParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceHandlerMockAddRoomSubscriptions struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockAddRoomSubscriptionsExpectation
	expectations       []*ChatServiceHandlerMockAddRoomSubscriptionsExpectation

	callArgs []*ChatServiceHandlerMockAddRoomSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockAddRoomSubscriptionsExpectation specifies expectation struct of the ChatServiceHandler.AddRoomSubscriptions
type ChatServiceHandlerMockAddRoomSubscriptionsExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockAddRoomSubscriptionsParams
	paramPtrs          *ChatServiceHandlerMockAddRoomSubscriptionsParamPtrs
	expectationOrigins ChatServiceHandlerMockAddRoomSubscriptionsExpectationOrigins
	results            *ChatServiceHandlerMockAddRoomSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockAddRoomSubscriptionsParams contains parameters of the ChatServiceHandler.AddRoomSubscriptions
type ChatServiceHandlerMockAddRoomSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]
}

// ChatServiceHandlerMockAddRoomSubscriptionsParamPtrs contains pointers to parameters of the ChatServiceHandler.AddRoomSubscriptions
type ChatServiceHandlerMockAddRoomSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddRoomSubscriptionsRequest]
}

// ChatServiceHandlerMockAddRoomSubscriptionsResults contains results of the ChatServiceHandler.AddRoomSubscriptions
type ChatServiceHandlerMockAddRoomSubscriptionsResults struct {
	pp2 *connect.Response[v1.AddRoomSubscriptionsResponse]
	err error
}

// ChatServiceHandlerMockAddRoomSubscriptionsOrigins contains origins of expectations of the ChatServiceHandler.AddRoomSubscriptions
type ChatServiceHandlerMockAddRoomSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Optional() *mChatServiceHandlerMockAddRoomSubscriptions {
	mmAddRoomSubscriptions.optional = true
	return mmAddRoomSubscriptions
}

// Expect sets up expected params for ChatServiceHandler.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) *mChatServiceHandlerMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockAddRoomSubscriptionsExpectation{}
	}

	if mmAddRoomSubscriptions.defaultExpectation.paramPtrs != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by ExpectParams functions")
	}

	mmAddRoomSubscriptions.defaultExpectation.params = &ChatServiceHandlerMockAddRoomSubscriptionsParams{ctx, pp1}
	mmAddRoomSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddRoomSubscriptions.expectations {
		if minimock.Equal(e.params, mmAddRoomSubscriptions.defaultExpectation.params) {
			mmAddRoomSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRoomSubscriptions.defaultExpectation.params)
		}
	}

	return mmAddRoomSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockAddRoomSubscriptionsExpectation{}
	}

	if mmAddRoomSubscriptions.defaultExpectation.params != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Expect")
	}

	if mmAddRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmAddRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceHandlerMockAddRoomSubscriptionsParamPtrs{}
	}
	mmAddRoomSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddRoomSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddRoomSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) *mChatServiceHandlerMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockAddRoomSubscriptionsExpectation{}
	}

	if mmAddRoomSubscriptions.defaultExpectation.params != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Expect")
	}

	if mmAddRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmAddRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceHandlerMockAddRoomSubscriptionsParamPtrs{}
	}
	mmAddRoomSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddRoomSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddRoomSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest])) *mChatServiceHandlerMockAddRoomSubscriptions {
	if mmAddRoomSubscriptions.mock.inspectFuncAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.AddRoomSubscriptions")
	}

	mmAddRoomSubscriptions.mock.inspectFuncAddRoomSubscriptions = f

	return mmAddRoomSubscriptions
}

// Return sets up results that will be returned by ChatServiceHandler.AddRoomSubscriptions
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Return(pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error) *ChatServiceHandlerMock {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Set")
	}

	if mmAddRoomSubscriptions.defaultExpectation == nil {
		mmAddRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockAddRoomSubscriptionsExpectation{mock: mmAddRoomSubscriptions.mock}
	}
	mmAddRoomSubscriptions.defaultExpectation.results = &ChatServiceHandlerMockAddRoomSubscriptionsResults{pp2, err}
	mmAddRoomSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddRoomSubscriptions.mock
}

// Set uses given function f to mock the ChatServiceHandler.AddRoomSubscriptions method
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error)) *ChatServiceHandlerMock {
	if mmAddRoomSubscriptions.defaultExpectation != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.AddRoomSubscriptions method")
	}

	if len(mmAddRoomSubscriptions.expectations) > 0 {
		mmAddRoomSubscriptions.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.AddRoomSubscriptions method")
	}

	mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions = f
	mmAddRoomSubscriptions.mock.funcAddRoomSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmAddRoomSubscriptions.mock
}

// When sets expectation for the ChatServiceHandler.AddRoomSubscriptions which will trigger the result defined by the following
// Then helper
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) *ChatServiceHandlerMockAddRoomSubscriptionsExpectation {
	if mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.AddRoomSubscriptions mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockAddRoomSubscriptionsExpectation{
		mock:               mmAddRoomSubscriptions.mock,
		params:             &ChatServiceHandlerMockAddRoomSubscriptionsParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockAddRoomSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddRoomSubscriptions.expectations = append(mmAddRoomSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.AddRoomSubscriptions return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockAddRoomSubscriptionsExpectation) Then(pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockAddRoomSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.AddRoomSubscriptions should be invoked
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Times(n uint64) *mChatServiceHandlerMockAddRoomSubscriptions {
	if n == 0 {
		mmAddRoomSubscriptions.mock.t.Fatalf("Times of ChatServiceHandlerMock.AddRoomSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddRoomSubscriptions.expectedInvocations, n)
	mmAddRoomSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddRoomSubscriptions
}

func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) invocationsDone() bool {
	if len(mmAddRoomSubscriptions.expectations) == 0 && mmAddRoomSubscriptions.defaultExpectation == nil && mmAddRoomSubscriptions.mock.funcAddRoomSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddRoomSubscriptions.mock.afterAddRoomSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddRoomSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddRoomSubscriptions implements mm_chatv1connect.ChatServiceHandler
func (mmAddRoomSubscriptions *ChatServiceHandlerMock) AddRoomSubscriptions(ctx context.Context, pp1 *connect.Request[v1.AddRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.AddRoomSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmAddRoomSubscriptions.beforeAddRoomSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRoomSubscriptions.afterAddRoomSubscriptionsCounter, 1)

	mmAddRoomSubscriptions.t.Helper()

	if mmAddRoomSubscriptions.inspectFuncAddRoomSubscriptions != nil {
		mmAddRoomSubscriptions.inspectFuncAddRoomSubscriptions(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockAddRoomSubscriptionsParams{ctx, pp1}

	// Record call args
	mmAddRoomSubscriptions.AddRoomSubscriptionsMock.mutex.Lock()
	mmAddRoomSubscriptions.AddRoomSubscriptionsMock.callArgs = append(mmAddRoomSubscriptions.AddRoomSubscriptionsMock.callArgs, &mm_params)
	mmAddRoomSubscriptions.AddRoomSubscriptionsMock.mutex.Unlock()

	for _, e := range mmAddRoomSubscriptions.AddRoomSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockAddRoomSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.AddRoomSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.AddRoomSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.AddRoomSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddRoomSubscriptions.AddRoomSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmAddRoomSubscriptions.t.Fatal("No results are set for the ChatServiceHandlerMock.AddRoomSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddRoomSubscriptions.funcAddRoomSubscriptions != nil {
		return mmAddRoomSubscriptions.funcAddRoomSubscriptions(ctx, pp1)
	}
	mmAddRoomSubscriptions.t.Fatalf("Unexpected call to ChatServiceHandlerMock.AddRoomSubscriptions. %v %v", ctx, pp1)
	return
}

// AddRoomSubscriptionsAfterCounter returns a count of finished ChatServiceHandlerMock.AddRoomSubscriptions invocations
func (mmAddRoomSubscriptions *ChatServiceHandlerMock) AddRoomSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRoomSubscriptions.afterAddRoomSubscriptionsCounter)
}

// AddRoomSubscriptionsBeforeCounter returns a count of ChatServiceHandlerMock.AddRoomSubscriptions invocations
func (mmAddRoomSubscriptions *ChatServiceHandlerMock) AddRoomSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRoomSubscriptions.beforeAddRoomSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.AddRoomSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRoomSubscriptions *mChatServiceHandlerMockAddRoomSubscriptions) Calls() []*ChatServiceHandlerMockAddRoomSubscriptionsParams {
	mmAddRoomSubscriptions.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockAddRoomSubscriptionsParams, len(mmAddRoomSubscriptions.callArgs))
	copy(argCopy, mmAddRoomSubscriptions.callArgs)

	mmAddRoomSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockAddRoomSubscriptionsDone returns true if the count of the AddRoomSubscriptions invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockAddRoomSubscriptionsDone() bool {
	if m.AddRoomSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddRoomSubscriptionsMock.invocationsDone()
}

// MinimockAddRoomSubscriptionsInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockAddRoomSubscriptionsInspect() {
	for _, e := range m.AddRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.AddRoomSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddRoomSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterAddRoomSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddRoomSubscriptionsMock.defaultExpectation != nil && afterAddRoomSubscriptionsCounter < 1 {
		if m.AddRoomSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.AddRoomSubscriptions at\n%s", m.AddRoomSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.AddRoomSubscriptions at\n%s with params: %#v", m.AddRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.AddRoomSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRoomSubscriptions != nil && afterAddRoomSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.AddRoomSubscriptions at\n%s", m.funcAddRoomSubscriptionsOrigin)
	}

	if !m.AddRoomSubscriptionsMock.invocationsDone() && afterAddRoomSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.AddRoomSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddRoomSubscriptionsMock.expectedInvocations), m.AddRoomSubscriptionsMock.expectedInvocationsOrigin, afterAddRoomSubscriptionsCounter)
	}
}

type mChatServiceHandlerMockCreateRoom struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockCreateRoomExpectation
	expectations       []*ChatServiceHandlerMockCreateRoomExpectation

	callArgs []*ChatServiceHandlerMockCreateRoomParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockCreateRoomExpectation specifies expectation struct of the ChatServiceHandler.CreateRoom
type ChatServiceHandlerMockCreateRoomExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockCreateRoomParams
	paramPtrs          *ChatServiceHandlerMockCreateRoomParamPtrs
	expectationOrigins ChatServiceHandlerMockCreateRoomExpectationOrigins
	results            *ChatServiceHandlerMockCreateRoomResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockCreateRoomParams contains parameters of the ChatServiceHandler.CreateRoom
type ChatServiceHandlerMockCreateRoomParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateRoomRequest]
}

// ChatServiceHandlerMockCreateRoomParamPtrs contains pointers to parameters of the ChatServiceHandler.CreateRoom
type ChatServiceHandlerMockCreateRoomParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateRoomRequest]
}

// ChatServiceHandlerMockCreateRoomResults contains results of the ChatServiceHandler.CreateRoom
type ChatServiceHandlerMockCreateRoomResults struct {
	pp2 *connect.Response[v1.CreateRoomResponse]
	err error
}

// ChatServiceHandlerMockCreateRoomOrigins contains origins of expectations of the ChatServiceHandler.CreateRoom
type ChatServiceHandlerMockCreateRoomExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Optional() *mChatServiceHandlerMockCreateRoom {
	mmCreateRoom.optional = true
	return mmCreateRoom
}

// Expect sets up expected params for ChatServiceHandler.CreateRoom
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) *mChatServiceHandlerMockCreateRoom {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceHandlerMockCreateRoomExpectation{}
	}

	if mmCreateRoom.defaultExpectation.paramPtrs != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by ExpectParams functions")
	}

	mmCreateRoom.defaultExpectation.params = &ChatServiceHandlerMockCreateRoomParams{ctx, pp1}
	mmCreateRoom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRoom.expectations {
		if minimock.Equal(e.params, mmCreateRoom.defaultExpectation.params) {
			mmCreateRoom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRoom.defaultExpectation.params)
		}
	}

	return mmCreateRoom
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.CreateRoom
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockCreateRoom {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceHandlerMockCreateRoomExpectation{}
	}

	if mmCreateRoom.defaultExpectation.params != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Expect")
	}

	if mmCreateRoom.defaultExpectation.paramPtrs == nil {
		mmCreateRoom.defaultExpectation.paramPtrs = &ChatServiceHandlerMockCreateRoomParamPtrs{}
	}
	mmCreateRoom.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRoom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRoom
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.CreateRoom
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) ExpectPp1Param2(pp1 *connect.Request[v1.CreateRoomRequest]) *mChatServiceHandlerMockCreateRoom {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceHandlerMockCreateRoomExpectation{}
	}

	if mmCreateRoom.defaultExpectation.params != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Expect")
	}

	if mmCreateRoom.defaultExpectation.paramPtrs == nil {
		mmCreateRoom.defaultExpectation.paramPtrs = &ChatServiceHandlerMockCreateRoomParamPtrs{}
	}
	mmCreateRoom.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateRoom.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateRoom
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.CreateRoom
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest])) *mChatServiceHandlerMockCreateRoom {
	if mmCreateRoom.mock.inspectFuncCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.CreateRoom")
	}

	mmCreateRoom.mock.inspectFuncCreateRoom = f

	return mmCreateRoom
}

// Return sets up results that will be returned by ChatServiceHandler.CreateRoom
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Return(pp2 *connect.Response[v1.CreateRoomResponse], err error) *ChatServiceHandlerMock {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Set")
	}

	if mmCreateRoom.defaultExpectation == nil {
		mmCreateRoom.defaultExpectation = &ChatServiceHandlerMockCreateRoomExpectation{mock: mmCreateRoom.mock}
	}
	mmCreateRoom.defaultExpectation.results = &ChatServiceHandlerMockCreateRoomResults{pp2, err}
	mmCreateRoom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRoom.mock
}

// Set uses given function f to mock the ChatServiceHandler.CreateRoom method
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) (pp2 *connect.Response[v1.CreateRoomResponse], err error)) *ChatServiceHandlerMock {
	if mmCreateRoom.defaultExpectation != nil {
		mmCreateRoom.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.CreateRoom method")
	}

	if len(mmCreateRoom.expectations) > 0 {
		mmCreateRoom.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.CreateRoom method")
	}

	mmCreateRoom.mock.funcCreateRoom = f
	mmCreateRoom.mock.funcCreateRoomOrigin = minimock.CallerInfo(1)
	return mmCreateRoom.mock
}

// When sets expectation for the ChatServiceHandler.CreateRoom which will trigger the result defined by the following
// Then helper
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) When(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) *ChatServiceHandlerMockCreateRoomExpectation {
	if mmCreateRoom.mock.funcCreateRoom != nil {
		mmCreateRoom.mock.t.Fatalf("ChatServiceHandlerMock.CreateRoom mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockCreateRoomExpectation{
		mock:               mmCreateRoom.mock,
		params:             &ChatServiceHandlerMockCreateRoomParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockCreateRoomExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRoom.expectations = append(mmCreateRoom.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.CreateRoom return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockCreateRoomExpectation) Then(pp2 *connect.Response[v1.CreateRoomResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockCreateRoomResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.CreateRoom should be invoked
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Times(n uint64) *mChatServiceHandlerMockCreateRoom {
	if n == 0 {
		mmCreateRoom.mock.t.Fatalf("Times of ChatServiceHandlerMock.CreateRoom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRoom.expectedInvocations, n)
	mmCreateRoom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRoom
}

func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) invocationsDone() bool {
	if len(mmCreateRoom.expectations) == 0 && mmCreateRoom.defaultExpectation == nil && mmCreateRoom.mock.funcCreateRoom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRoom.mock.afterCreateRoomCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRoom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRoom implements mm_chatv1connect.ChatServiceHandler
func (mmCreateRoom *ChatServiceHandlerMock) CreateRoom(ctx context.Context, pp1 *connect.Request[v1.CreateRoomRequest]) (pp2 *connect.Response[v1.CreateRoomResponse], err error) {
	mm_atomic.AddUint64(&mmCreateRoom.beforeCreateRoomCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRoom.afterCreateRoomCounter, 1)

	mmCreateRoom.t.Helper()

	if mmCreateRoom.inspectFuncCreateRoom != nil {
		mmCreateRoom.inspectFuncCreateRoom(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockCreateRoomParams{ctx, pp1}

	// Record call args
	mmCreateRoom.CreateRoomMock.mutex.Lock()
	mmCreateRoom.CreateRoomMock.callArgs = append(mmCreateRoom.CreateRoomMock.callArgs, &mm_params)
	mmCreateRoom.CreateRoomMock.mutex.Unlock()

	for _, e := range mmCreateRoom.CreateRoomMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateRoom.CreateRoomMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRoom.CreateRoomMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRoom.CreateRoomMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRoom.CreateRoomMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockCreateRoomParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRoom.t.Errorf("ChatServiceHandlerMock.CreateRoom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRoom.CreateRoomMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateRoom.t.Errorf("ChatServiceHandlerMock.CreateRoom got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRoom.CreateRoomMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRoom.t.Errorf("ChatServiceHandlerMock.CreateRoom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRoom.CreateRoomMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRoom.CreateRoomMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRoom.t.Fatal("No results are set for the ChatServiceHandlerMock.CreateRoom")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateRoom.funcCreateRoom != nil {
		return mmCreateRoom.funcCreateRoom(ctx, pp1)
	}
	mmCreateRoom.t.Fatalf("Unexpected call to ChatServiceHandlerMock.CreateRoom. %v %v", ctx, pp1)
	return
}

// CreateRoomAfterCounter returns a count of finished ChatServiceHandlerMock.CreateRoom invocations
func (mmCreateRoom *ChatServiceHandlerMock) CreateRoomAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRoom.afterCreateRoomCounter)
}

// CreateRoomBeforeCounter returns a count of ChatServiceHandlerMock.CreateRoom invocations
func (mmCreateRoom *ChatServiceHandlerMock) CreateRoomBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRoom.beforeCreateRoomCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.CreateRoom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRoom *mChatServiceHandlerMockCreateRoom) Calls() []*ChatServiceHandlerMockCreateRoomParams {
	mmCreateRoom.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockCreateRoomParams, len(mmCreateRoom.callArgs))
	copy(argCopy, mmCreateRoom.callArgs)

	mmCreateRoom.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRoomDone returns true if the count of the CreateRoom invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockCreateRoomDone() bool {
	if m.CreateRoomMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRoomMock.invocationsDone()
}

// MinimockCreateRoomInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockCreateRoomInspect() {
	for _, e := range m.CreateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.CreateRoom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRoomCounter := mm_atomic.LoadUint64(&m.afterCreateRoomCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRoomMock.defaultExpectation != nil && afterCreateRoomCounter < 1 {
		if m.CreateRoomMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.CreateRoom at\n%s", m.CreateRoomMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.CreateRoom at\n%s with params: %#v", m.CreateRoomMock.defaultExpectation.expectationOrigins.origin, *m.CreateRoomMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRoom != nil && afterCreateRoomCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.CreateRoom at\n%s", m.funcCreateRoomOrigin)
	}

	if !m.CreateRoomMock.invocationsDone() && afterCreateRoomCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.CreateRoom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRoomMock.expectedInvocations), m.CreateRoomMock.expectedInvocationsOrigin, afterCreateRoomCounter)
	}
}

type mChatServiceHandlerMockDeleteRoom struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockDeleteRoomExpectation
	expectations       []*ChatServiceHandlerMockDeleteRoomExpectation

	callArgs []*ChatServiceHandlerMockDeleteRoomParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockDeleteRoomExpectation specifies expectation struct of the ChatServiceHandler.DeleteRoom
type ChatServiceHandlerMockDeleteRoomExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockDeleteRoomParams
	paramPtrs          *ChatServiceHandlerMockDeleteRoomParamPtrs
	expectationOrigins ChatServiceHandlerMockDeleteRoomExpectationOrigins
	results            *ChatServiceHandlerMockDeleteRoomResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockDeleteRoomParams contains parameters of the ChatServiceHandler.DeleteRoom
type ChatServiceHandlerMockDeleteRoomParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeleteRoomRequest]
}

// ChatServiceHandlerMockDeleteRoomParamPtrs contains pointers to parameters of the ChatServiceHandler.DeleteRoom
type ChatServiceHandlerMockDeleteRoomParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeleteRoomRequest]
}

// ChatServiceHandlerMockDeleteRoomResults contains results of the ChatServiceHandler.DeleteRoom
type ChatServiceHandlerMockDeleteRoomResults struct {
	pp2 *connect.Response[v1.DeleteRoomResponse]
	err error
}

// ChatServiceHandlerMockDeleteRoomOrigins contains origins of expectations of the ChatServiceHandler.DeleteRoom
type ChatServiceHandlerMockDeleteRoomExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Optional() *mChatServiceHandlerMockDeleteRoom {
	mmDeleteRoom.optional = true
	return mmDeleteRoom
}

// Expect sets up expected params for ChatServiceHandler.DeleteRoom
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Expect(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) *mChatServiceHandlerMockDeleteRoom {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceHandlerMockDeleteRoomExpectation{}
	}

	if mmDeleteRoom.defaultExpectation.paramPtrs != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by ExpectParams functions")
	}

	mmDeleteRoom.defaultExpectation.params = &ChatServiceHandlerMockDeleteRoomParams{ctx, pp1}
	mmDeleteRoom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRoom.expectations {
		if minimock.Equal(e.params, mmDeleteRoom.defaultExpectation.params) {
			mmDeleteRoom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRoom.defaultExpectation.params)
		}
	}

	return mmDeleteRoom
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.DeleteRoom
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockDeleteRoom {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceHandlerMockDeleteRoomExpectation{}
	}

	if mmDeleteRoom.defaultExpectation.params != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Expect")
	}

	if mmDeleteRoom.defaultExpectation.paramPtrs == nil {
		mmDeleteRoom.defaultExpectation.paramPtrs = &ChatServiceHandlerMockDeleteRoomParamPtrs{}
	}
	mmDeleteRoom.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRoom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRoom
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.DeleteRoom
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) ExpectPp1Param2(pp1 *connect.Request[v1.DeleteRoomRequest]) *mChatServiceHandlerMockDeleteRoom {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceHandlerMockDeleteRoomExpectation{}
	}

	if mmDeleteRoom.defaultExpectation.params != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Expect")
	}

	if mmDeleteRoom.defaultExpectation.paramPtrs == nil {
		mmDeleteRoom.defaultExpectation.paramPtrs = &ChatServiceHandlerMockDeleteRoomParamPtrs{}
	}
	mmDeleteRoom.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteRoom.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteRoom
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.DeleteRoom
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest])) *mChatServiceHandlerMockDeleteRoom {
	if mmDeleteRoom.mock.inspectFuncDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.DeleteRoom")
	}

	mmDeleteRoom.mock.inspectFuncDeleteRoom = f

	return mmDeleteRoom
}

// Return sets up results that will be returned by ChatServiceHandler.DeleteRoom
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Return(pp2 *connect.Response[v1.DeleteRoomResponse], err error) *ChatServiceHandlerMock {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Set")
	}

	if mmDeleteRoom.defaultExpectation == nil {
		mmDeleteRoom.defaultExpectation = &ChatServiceHandlerMockDeleteRoomExpectation{mock: mmDeleteRoom.mock}
	}
	mmDeleteRoom.defaultExpectation.results = &ChatServiceHandlerMockDeleteRoomResults{pp2, err}
	mmDeleteRoom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRoom.mock
}

// Set uses given function f to mock the ChatServiceHandler.DeleteRoom method
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) (pp2 *connect.Response[v1.DeleteRoomResponse], err error)) *ChatServiceHandlerMock {
	if mmDeleteRoom.defaultExpectation != nil {
		mmDeleteRoom.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.DeleteRoom method")
	}

	if len(mmDeleteRoom.expectations) > 0 {
		mmDeleteRoom.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.DeleteRoom method")
	}

	mmDeleteRoom.mock.funcDeleteRoom = f
	mmDeleteRoom.mock.funcDeleteRoomOrigin = minimock.CallerInfo(1)
	return mmDeleteRoom.mock
}

// When sets expectation for the ChatServiceHandler.DeleteRoom which will trigger the result defined by the following
// Then helper
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) When(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) *ChatServiceHandlerMockDeleteRoomExpectation {
	if mmDeleteRoom.mock.funcDeleteRoom != nil {
		mmDeleteRoom.mock.t.Fatalf("ChatServiceHandlerMock.DeleteRoom mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockDeleteRoomExpectation{
		mock:               mmDeleteRoom.mock,
		params:             &ChatServiceHandlerMockDeleteRoomParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockDeleteRoomExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRoom.expectations = append(mmDeleteRoom.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.DeleteRoom return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockDeleteRoomExpectation) Then(pp2 *connect.Response[v1.DeleteRoomResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockDeleteRoomResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.DeleteRoom should be invoked
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Times(n uint64) *mChatServiceHandlerMockDeleteRoom {
	if n == 0 {
		mmDeleteRoom.mock.t.Fatalf("Times of ChatServiceHandlerMock.DeleteRoom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRoom.expectedInvocations, n)
	mmDeleteRoom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRoom
}

func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) invocationsDone() bool {
	if len(mmDeleteRoom.expectations) == 0 && mmDeleteRoom.defaultExpectation == nil && mmDeleteRoom.mock.funcDeleteRoom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRoom.mock.afterDeleteRoomCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRoom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRoom implements mm_chatv1connect.ChatServiceHandler
func (mmDeleteRoom *ChatServiceHandlerMock) DeleteRoom(ctx context.Context, pp1 *connect.Request[v1.DeleteRoomRequest]) (pp2 *connect.Response[v1.DeleteRoomResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteRoom.beforeDeleteRoomCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRoom.afterDeleteRoomCounter, 1)

	mmDeleteRoom.t.Helper()

	if mmDeleteRoom.inspectFuncDeleteRoom != nil {
		mmDeleteRoom.inspectFuncDeleteRoom(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockDeleteRoomParams{ctx, pp1}

	// Record call args
	mmDeleteRoom.DeleteRoomMock.mutex.Lock()
	mmDeleteRoom.DeleteRoomMock.callArgs = append(mmDeleteRoom.DeleteRoomMock.callArgs, &mm_params)
	mmDeleteRoom.DeleteRoomMock.mutex.Unlock()

	for _, e := range mmDeleteRoom.DeleteRoomMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteRoom.DeleteRoomMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRoom.DeleteRoomMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRoom.DeleteRoomMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRoom.DeleteRoomMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockDeleteRoomParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRoom.t.Errorf("ChatServiceHandlerMock.DeleteRoom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRoom.DeleteRoomMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteRoom.t.Errorf("ChatServiceHandlerMock.DeleteRoom got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRoom.DeleteRoomMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRoom.t.Errorf("ChatServiceHandlerMock.DeleteRoom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRoom.DeleteRoomMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRoom.DeleteRoomMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRoom.t.Fatal("No results are set for the ChatServiceHandlerMock.DeleteRoom")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteRoom.funcDeleteRoom != nil {
		return mmDeleteRoom.funcDeleteRoom(ctx, pp1)
	}
	mmDeleteRoom.t.Fatalf("Unexpected call to ChatServiceHandlerMock.DeleteRoom. %v %v", ctx, pp1)
	return
}

// DeleteRoomAfterCounter returns a count of finished ChatServiceHandlerMock.DeleteRoom invocations
func (mmDeleteRoom *ChatServiceHandlerMock) DeleteRoomAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRoom.afterDeleteRoomCounter)
}

// DeleteRoomBeforeCounter returns a count of ChatServiceHandlerMock.DeleteRoom invocations
func (mmDeleteRoom *ChatServiceHandlerMock) DeleteRoomBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRoom.beforeDeleteRoomCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.DeleteRoom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRoom *mChatServiceHandlerMockDeleteRoom) Calls() []*ChatServiceHandlerMockDeleteRoomParams {
	mmDeleteRoom.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockDeleteRoomParams, len(mmDeleteRoom.callArgs))
	copy(argCopy, mmDeleteRoom.callArgs)

	mmDeleteRoom.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRoomDone returns true if the count of the DeleteRoom invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockDeleteRoomDone() bool {
	if m.DeleteRoomMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRoomMock.invocationsDone()
}

// MinimockDeleteRoomInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockDeleteRoomInspect() {
	for _, e := range m.DeleteRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.DeleteRoom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRoomCounter := mm_atomic.LoadUint64(&m.afterDeleteRoomCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRoomMock.defaultExpectation != nil && afterDeleteRoomCounter < 1 {
		if m.DeleteRoomMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.DeleteRoom at\n%s", m.DeleteRoomMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.DeleteRoom at\n%s with params: %#v", m.DeleteRoomMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRoomMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRoom != nil && afterDeleteRoomCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.DeleteRoom at\n%s", m.funcDeleteRoomOrigin)
	}

	if !m.DeleteRoomMock.invocationsDone() && afterDeleteRoomCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.DeleteRoom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRoomMock.expectedInvocations), m.DeleteRoomMock.expectedInvocationsOrigin, afterDeleteRoomCounter)
	}
}

type mChatServiceHandlerMockGetClientState struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockGetClientStateExpectation
	expectations       []*ChatServiceHandlerMockGetClientStateExpectation

	callArgs []*ChatServiceHandlerMockGetClientStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockGetClientStateExpectation specifies expectation struct of the ChatServiceHandler.GetClientState
type ChatServiceHandlerMockGetClientStateExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockGetClientStateParams
	paramPtrs          *ChatServiceHandlerMockGetClientStateParamPtrs
	expectationOrigins ChatServiceHandlerMockGetClientStateExpectationOrigins
	results            *ChatServiceHandlerMockGetClientStateResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockGetClientStateParams contains parameters of the ChatServiceHandler.GetClientState
type ChatServiceHandlerMockGetClientStateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetClientStateRequest]
}

// ChatServiceHandlerMockGetClientStateParamPtrs contains pointers to parameters of the ChatServiceHandler.GetClientState
type ChatServiceHandlerMockGetClientStateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetClientStateRequest]
}

// ChatServiceHandlerMockGetClientStateResults contains results of the ChatServiceHandler.GetClientState
type ChatServiceHandlerMockGetClientStateResults struct {
	pp2 *connect.Response[v1.GetClientStateResponse]
	err error
}

// ChatServiceHandlerMockGetClientStateOrigins contains origins of expectations of the ChatServiceHandler.GetClientState
type ChatServiceHandlerMockGetClientStateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Optional() *mChatServiceHandlerMockGetClientState {
	mmGetClientState.optional = true
	return mmGetClientState
}

// Expect sets up expected params for ChatServiceHandler.GetClientState
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Expect(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) *mChatServiceHandlerMockGetClientState {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceHandlerMockGetClientStateExpectation{}
	}

	if mmGetClientState.defaultExpectation.paramPtrs != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by ExpectParams functions")
	}

	mmGetClientState.defaultExpectation.params = &ChatServiceHandlerMockGetClientStateParams{ctx, pp1}
	mmGetClientState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClientState.expectations {
		if minimock.Equal(e.params, mmGetClientState.defaultExpectation.params) {
			mmGetClientState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClientState.defaultExpectation.params)
		}
	}

	return mmGetClientState
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.GetClientState
func (mmGetClientState *mChatServiceHandlerMockGetClientState) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockGetClientState {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceHandlerMockGetClientStateExpectation{}
	}

	if mmGetClientState.defaultExpectation.params != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Expect")
	}

	if mmGetClientState.defaultExpectation.paramPtrs == nil {
		mmGetClientState.defaultExpectation.paramPtrs = &ChatServiceHandlerMockGetClientStateParamPtrs{}
	}
	mmGetClientState.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetClientState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetClientState
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.GetClientState
func (mmGetClientState *mChatServiceHandlerMockGetClientState) ExpectPp1Param2(pp1 *connect.Request[v1.GetClientStateRequest]) *mChatServiceHandlerMockGetClientState {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceHandlerMockGetClientStateExpectation{}
	}

	if mmGetClientState.defaultExpectation.params != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Expect")
	}

	if mmGetClientState.defaultExpectation.paramPtrs == nil {
		mmGetClientState.defaultExpectation.paramPtrs = &ChatServiceHandlerMockGetClientStateParamPtrs{}
	}
	mmGetClientState.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetClientState.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetClientState
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.GetClientState
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest])) *mChatServiceHandlerMockGetClientState {
	if mmGetClientState.mock.inspectFuncGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.GetClientState")
	}

	mmGetClientState.mock.inspectFuncGetClientState = f

	return mmGetClientState
}

// Return sets up results that will be returned by ChatServiceHandler.GetClientState
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Return(pp2 *connect.Response[v1.GetClientStateResponse], err error) *ChatServiceHandlerMock {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Set")
	}

	if mmGetClientState.defaultExpectation == nil {
		mmGetClientState.defaultExpectation = &ChatServiceHandlerMockGetClientStateExpectation{mock: mmGetClientState.mock}
	}
	mmGetClientState.defaultExpectation.results = &ChatServiceHandlerMockGetClientStateResults{pp2, err}
	mmGetClientState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClientState.mock
}

// Set uses given function f to mock the ChatServiceHandler.GetClientState method
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) (pp2 *connect.Response[v1.GetClientStateResponse], err error)) *ChatServiceHandlerMock {
	if mmGetClientState.defaultExpectation != nil {
		mmGetClientState.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.GetClientState method")
	}

	if len(mmGetClientState.expectations) > 0 {
		mmGetClientState.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.GetClientState method")
	}

	mmGetClientState.mock.funcGetClientState = f
	mmGetClientState.mock.funcGetClientStateOrigin = minimock.CallerInfo(1)
	return mmGetClientState.mock
}

// When sets expectation for the ChatServiceHandler.GetClientState which will trigger the result defined by the following
// Then helper
func (mmGetClientState *mChatServiceHandlerMockGetClientState) When(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) *ChatServiceHandlerMockGetClientStateExpectation {
	if mmGetClientState.mock.funcGetClientState != nil {
		mmGetClientState.mock.t.Fatalf("ChatServiceHandlerMock.GetClientState mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockGetClientStateExpectation{
		mock:               mmGetClientState.mock,
		params:             &ChatServiceHandlerMockGetClientStateParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockGetClientStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClientState.expectations = append(mmGetClientState.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.GetClientState return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockGetClientStateExpectation) Then(pp2 *connect.Response[v1.GetClientStateResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockGetClientStateResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.GetClientState should be invoked
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Times(n uint64) *mChatServiceHandlerMockGetClientState {
	if n == 0 {
		mmGetClientState.mock.t.Fatalf("Times of ChatServiceHandlerMock.GetClientState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClientState.expectedInvocations, n)
	mmGetClientState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClientState
}

func (mmGetClientState *mChatServiceHandlerMockGetClientState) invocationsDone() bool {
	if len(mmGetClientState.expectations) == 0 && mmGetClientState.defaultExpectation == nil && mmGetClientState.mock.funcGetClientState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClientState.mock.afterGetClientStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClientState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClientState implements mm_chatv1connect.ChatServiceHandler
func (mmGetClientState *ChatServiceHandlerMock) GetClientState(ctx context.Context, pp1 *connect.Request[v1.GetClientStateRequest]) (pp2 *connect.Response[v1.GetClientStateResponse], err error) {
	mm_atomic.AddUint64(&mmGetClientState.beforeGetClientStateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClientState.afterGetClientStateCounter, 1)

	mmGetClientState.t.Helper()

	if mmGetClientState.inspectFuncGetClientState != nil {
		mmGetClientState.inspectFuncGetClientState(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockGetClientStateParams{ctx, pp1}

	// Record call args
	mmGetClientState.GetClientStateMock.mutex.Lock()
	mmGetClientState.GetClientStateMock.callArgs = append(mmGetClientState.GetClientStateMock.callArgs, &mm_params)
	mmGetClientState.GetClientStateMock.mutex.Unlock()

	for _, e := range mmGetClientState.GetClientStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetClientState.GetClientStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClientState.GetClientStateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClientState.GetClientStateMock.defaultExpectation.params
		mm_want_ptrs := mmGetClientState.GetClientStateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockGetClientStateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClientState.t.Errorf("ChatServiceHandlerMock.GetClientState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientState.GetClientStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetClientState.t.Errorf("ChatServiceHandlerMock.GetClientState got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientState.GetClientStateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClientState.t.Errorf("ChatServiceHandlerMock.GetClientState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClientState.GetClientStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClientState.GetClientStateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClientState.t.Fatal("No results are set for the ChatServiceHandlerMock.GetClientState")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetClientState.funcGetClientState != nil {
		return mmGetClientState.funcGetClientState(ctx, pp1)
	}
	mmGetClientState.t.Fatalf("Unexpected call to ChatServiceHandlerMock.GetClientState. %v %v", ctx, pp1)
	return
}

// GetClientStateAfterCounter returns a count of finished ChatServiceHandlerMock.GetClientState invocations
func (mmGetClientState *ChatServiceHandlerMock) GetClientStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientState.afterGetClientStateCounter)
}

// GetClientStateBeforeCounter returns a count of ChatServiceHandlerMock.GetClientState invocations
func (mmGetClientState *ChatServiceHandlerMock) GetClientStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientState.beforeGetClientStateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.GetClientState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClientState *mChatServiceHandlerMockGetClientState) Calls() []*ChatServiceHandlerMockGetClientStateParams {
	mmGetClientState.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockGetClientStateParams, len(mmGetClientState.callArgs))
	copy(argCopy, mmGetClientState.callArgs)

	mmGetClientState.mutex.RUnlock()

	return argCopy
}

// MinimockGetClientStateDone returns true if the count of the GetClientState invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockGetClientStateDone() bool {
	if m.GetClientStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClientStateMock.invocationsDone()
}

// MinimockGetClientStateInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockGetClientStateInspect() {
	for _, e := range m.GetClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.GetClientState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClientStateCounter := mm_atomic.LoadUint64(&m.afterGetClientStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientStateMock.defaultExpectation != nil && afterGetClientStateCounter < 1 {
		if m.GetClientStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.GetClientState at\n%s", m.GetClientStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.GetClientState at\n%s with params: %#v", m.GetClientStateMock.defaultExpectation.expectationOrigins.origin, *m.GetClientStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClientState != nil && afterGetClientStateCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.GetClientState at\n%s", m.funcGetClientStateOrigin)
	}

	if !m.GetClientStateMock.invocationsDone() && afterGetClientStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.GetClientState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClientStateMock.expectedInvocations), m.GetClientStateMock.expectedInvocationsOrigin, afterGetClientStateCounter)
	}
}

type mChatServiceHandlerMockGetHistory struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockGetHistoryExpectation
	expectations       []*ChatServiceHandlerMockGetHistoryExpectation

	callArgs []*ChatServiceHandlerMockGetHistoryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockGetHistoryExpectation specifies expectation struct of the ChatServiceHandler.GetHistory
type ChatServiceHandlerMockGetHistoryExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockGetHistoryParams
	paramPtrs          *ChatServiceHandlerMockGetHistoryParamPtrs
	expectationOrigins ChatServiceHandlerMockGetHistoryExpectationOrigins
	results            *ChatServiceHandlerMockGetHistoryResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockGetHistoryParams contains parameters of the ChatServiceHandler.GetHistory
type ChatServiceHandlerMockGetHistoryParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetHistoryRequest]
}

// ChatServiceHandlerMockGetHistoryParamPtrs contains pointers to parameters of the ChatServiceHandler.GetHistory
type ChatServiceHandlerMockGetHistoryParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetHistoryRequest]
}

// ChatServiceHandlerMockGetHistoryResults contains results of the ChatServiceHandler.GetHistory
type ChatServiceHandlerMockGetHistoryResults struct {
	pp2 *connect.Response[v1.GetHistoryResponse]
	err error
}

// ChatServiceHandlerMockGetHistoryOrigins contains origins of expectations of the ChatServiceHandler.GetHistory
type ChatServiceHandlerMockGetHistoryExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Optional() *mChatServiceHandlerMockGetHistory {
	mmGetHistory.optional = true
	return mmGetHistory
}

// Expect sets up expected params for ChatServiceHandler.GetHistory
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Expect(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) *mChatServiceHandlerMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceHandlerMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.paramPtrs != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by ExpectParams functions")
	}

	mmGetHistory.defaultExpectation.params = &ChatServiceHandlerMockGetHistoryParams{ctx, pp1}
	mmGetHistory.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetHistory.expectations {
		if minimock.Equal(e.params, mmGetHistory.defaultExpectation.params) {
			mmGetHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetHistory.defaultExpectation.params)
		}
	}

	return mmGetHistory
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.GetHistory
func (mmGetHistory *mChatServiceHandlerMockGetHistory) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceHandlerMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &ChatServiceHandlerMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetHistory.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetHistory
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.GetHistory
func (mmGetHistory *mChatServiceHandlerMockGetHistory) ExpectPp1Param2(pp1 *connect.Request[v1.GetHistoryRequest]) *mChatServiceHandlerMockGetHistory {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceHandlerMockGetHistoryExpectation{}
	}

	if mmGetHistory.defaultExpectation.params != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Expect")
	}

	if mmGetHistory.defaultExpectation.paramPtrs == nil {
		mmGetHistory.defaultExpectation.paramPtrs = &ChatServiceHandlerMockGetHistoryParamPtrs{}
	}
	mmGetHistory.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetHistory.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetHistory
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.GetHistory
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest])) *mChatServiceHandlerMockGetHistory {
	if mmGetHistory.mock.inspectFuncGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.GetHistory")
	}

	mmGetHistory.mock.inspectFuncGetHistory = f

	return mmGetHistory
}

// Return sets up results that will be returned by ChatServiceHandler.GetHistory
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Return(pp2 *connect.Response[v1.GetHistoryResponse], err error) *ChatServiceHandlerMock {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Set")
	}

	if mmGetHistory.defaultExpectation == nil {
		mmGetHistory.defaultExpectation = &ChatServiceHandlerMockGetHistoryExpectation{mock: mmGetHistory.mock}
	}
	mmGetHistory.defaultExpectation.results = &ChatServiceHandlerMockGetHistoryResults{pp2, err}
	mmGetHistory.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetHistory.mock
}

// Set uses given function f to mock the ChatServiceHandler.GetHistory method
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) (pp2 *connect.Response[v1.GetHistoryResponse], err error)) *ChatServiceHandlerMock {
	if mmGetHistory.defaultExpectation != nil {
		mmGetHistory.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.GetHistory method")
	}

	if len(mmGetHistory.expectations) > 0 {
		mmGetHistory.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.GetHistory method")
	}

	mmGetHistory.mock.funcGetHistory = f
	mmGetHistory.mock.funcGetHistoryOrigin = minimock.CallerInfo(1)
	return mmGetHistory.mock
}

// When sets expectation for the ChatServiceHandler.GetHistory which will trigger the result defined by the following
// Then helper
func (mmGetHistory *mChatServiceHandlerMockGetHistory) When(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) *ChatServiceHandlerMockGetHistoryExpectation {
	if mmGetHistory.mock.funcGetHistory != nil {
		mmGetHistory.mock.t.Fatalf("ChatServiceHandlerMock.GetHistory mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockGetHistoryExpectation{
		mock:               mmGetHistory.mock,
		params:             &ChatServiceHandlerMockGetHistoryParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockGetHistoryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetHistory.expectations = append(mmGetHistory.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.GetHistory return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockGetHistoryExpectation) Then(pp2 *connect.Response[v1.GetHistoryResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockGetHistoryResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.GetHistory should be invoked
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Times(n uint64) *mChatServiceHandlerMockGetHistory {
	if n == 0 {
		mmGetHistory.mock.t.Fatalf("Times of ChatServiceHandlerMock.GetHistory mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetHistory.expectedInvocations, n)
	mmGetHistory.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetHistory
}

func (mmGetHistory *mChatServiceHandlerMockGetHistory) invocationsDone() bool {
	if len(mmGetHistory.expectations) == 0 && mmGetHistory.defaultExpectation == nil && mmGetHistory.mock.funcGetHistory == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetHistory.mock.afterGetHistoryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetHistory.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetHistory implements mm_chatv1connect.ChatServiceHandler
func (mmGetHistory *ChatServiceHandlerMock) GetHistory(ctx context.Context, pp1 *connect.Request[v1.GetHistoryRequest]) (pp2 *connect.Response[v1.GetHistoryResponse], err error) {
	mm_atomic.AddUint64(&mmGetHistory.beforeGetHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetHistory.afterGetHistoryCounter, 1)

	mmGetHistory.t.Helper()

	if mmGetHistory.inspectFuncGetHistory != nil {
		mmGetHistory.inspectFuncGetHistory(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockGetHistoryParams{ctx, pp1}

	// Record call args
	mmGetHistory.GetHistoryMock.mutex.Lock()
	mmGetHistory.GetHistoryMock.callArgs = append(mmGetHistory.GetHistoryMock.callArgs, &mm_params)
	mmGetHistory.GetHistoryMock.mutex.Unlock()

	for _, e := range mmGetHistory.GetHistoryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetHistory.GetHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetHistory.GetHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetHistory.GetHistoryMock.defaultExpectation.params
		mm_want_ptrs := mmGetHistory.GetHistoryMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockGetHistoryParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetHistory.t.Errorf("ChatServiceHandlerMock.GetHistory got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetHistory.t.Errorf("ChatServiceHandlerMock.GetHistory got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetHistory.t.Errorf("ChatServiceHandlerMock.GetHistory got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetHistory.GetHistoryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetHistory.GetHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetHistory.t.Fatal("No results are set for the ChatServiceHandlerMock.GetHistory")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetHistory.funcGetHistory != nil {
		return mmGetHistory.funcGetHistory(ctx, pp1)
	}
	mmGetHistory.t.Fatalf("Unexpected call to ChatServiceHandlerMock.GetHistory. %v %v", ctx, pp1)
	return
}

// GetHistoryAfterCounter returns a count of finished ChatServiceHandlerMock.GetHistory invocations
func (mmGetHistory *ChatServiceHandlerMock) GetHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.afterGetHistoryCounter)
}

// GetHistoryBeforeCounter returns a count of ChatServiceHandlerMock.GetHistory invocations
func (mmGetHistory *ChatServiceHandlerMock) GetHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetHistory.beforeGetHistoryCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.GetHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetHistory *mChatServiceHandlerMockGetHistory) Calls() []*ChatServiceHandlerMockGetHistoryParams {
	mmGetHistory.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockGetHistoryParams, len(mmGetHistory.callArgs))
	copy(argCopy, mmGetHistory.callArgs)

	mmGetHistory.mutex.RUnlock()

	return argCopy
}

// MinimockGetHistoryDone returns true if the count of the GetHistory invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockGetHistoryDone() bool {
	if m.GetHistoryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetHistoryMock.invocationsDone()
}

// MinimockGetHistoryInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockGetHistoryInspect() {
	for _, e := range m.GetHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.GetHistory at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetHistoryCounter := mm_atomic.LoadUint64(&m.afterGetHistoryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetHistoryMock.defaultExpectation != nil && afterGetHistoryCounter < 1 {
		if m.GetHistoryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.GetHistory at\n%s", m.GetHistoryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.GetHistory at\n%s with params: %#v", m.GetHistoryMock.defaultExpectation.expectationOrigins.origin, *m.GetHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetHistory != nil && afterGetHistoryCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.GetHistory at\n%s", m.funcGetHistoryOrigin)
	}

	if !m.GetHistoryMock.invocationsDone() && afterGetHistoryCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.GetHistory at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetHistoryMock.expectedInvocations), m.GetHistoryMock.expectedInvocationsOrigin, afterGetHistoryCounter)
	}
}

type mChatServiceHandlerMockRemoveRoomSubscriptions struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation
	expectations       []*ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation

	callArgs []*ChatServiceHandlerMockRemoveRoomSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation specifies expectation struct of the ChatServiceHandler.RemoveRoomSubscriptions
type ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockRemoveRoomSubscriptionsParams
	paramPtrs          *ChatServiceHandlerMockRemoveRoomSubscriptionsParamPtrs
	expectationOrigins ChatServiceHandlerMockRemoveRoomSubscriptionsExpectationOrigins
	results            *ChatServiceHandlerMockRemoveRoomSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockRemoveRoomSubscriptionsParams contains parameters of the ChatServiceHandler.RemoveRoomSubscriptions
type ChatServiceHandlerMockRemoveRoomSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]
}

// ChatServiceHandlerMockRemoveRoomSubscriptionsParamPtrs contains pointers to parameters of the ChatServiceHandler.RemoveRoomSubscriptions
type ChatServiceHandlerMockRemoveRoomSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveRoomSubscriptionsRequest]
}

// ChatServiceHandlerMockRemoveRoomSubscriptionsResults contains results of the ChatServiceHandler.RemoveRoomSubscriptions
type ChatServiceHandlerMockRemoveRoomSubscriptionsResults struct {
	pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse]
	err error
}

// ChatServiceHandlerMockRemoveRoomSubscriptionsOrigins contains origins of expectations of the ChatServiceHandler.RemoveRoomSubscriptions
type ChatServiceHandlerMockRemoveRoomSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Optional() *mChatServiceHandlerMockRemoveRoomSubscriptions {
	mmRemoveRoomSubscriptions.optional = true
	return mmRemoveRoomSubscriptions
}

// Expect sets up expected params for ChatServiceHandler.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) *mChatServiceHandlerMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation{}
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by ExpectParams functions")
	}

	mmRemoveRoomSubscriptions.defaultExpectation.params = &ChatServiceHandlerMockRemoveRoomSubscriptionsParams{ctx, pp1}
	mmRemoveRoomSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveRoomSubscriptions.expectations {
		if minimock.Equal(e.params, mmRemoveRoomSubscriptions.defaultExpectation.params) {
			mmRemoveRoomSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveRoomSubscriptions.defaultExpectation.params)
		}
	}

	return mmRemoveRoomSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation{}
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.params != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Expect")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceHandlerMockRemoveRoomSubscriptionsParamPtrs{}
	}
	mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveRoomSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveRoomSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) *mChatServiceHandlerMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation{}
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.params != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Expect")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceHandlerMockRemoveRoomSubscriptionsParamPtrs{}
	}
	mmRemoveRoomSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveRoomSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveRoomSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest])) *mChatServiceHandlerMockRemoveRoomSubscriptions {
	if mmRemoveRoomSubscriptions.mock.inspectFuncRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.RemoveRoomSubscriptions")
	}

	mmRemoveRoomSubscriptions.mock.inspectFuncRemoveRoomSubscriptions = f

	return mmRemoveRoomSubscriptions
}

// Return sets up results that will be returned by ChatServiceHandler.RemoveRoomSubscriptions
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Return(pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error) *ChatServiceHandlerMock {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	if mmRemoveRoomSubscriptions.defaultExpectation == nil {
		mmRemoveRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation{mock: mmRemoveRoomSubscriptions.mock}
	}
	mmRemoveRoomSubscriptions.defaultExpectation.results = &ChatServiceHandlerMockRemoveRoomSubscriptionsResults{pp2, err}
	mmRemoveRoomSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveRoomSubscriptions.mock
}

// Set uses given function f to mock the ChatServiceHandler.RemoveRoomSubscriptions method
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error)) *ChatServiceHandlerMock {
	if mmRemoveRoomSubscriptions.defaultExpectation != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.RemoveRoomSubscriptions method")
	}

	if len(mmRemoveRoomSubscriptions.expectations) > 0 {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.RemoveRoomSubscriptions method")
	}

	mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions = f
	mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmRemoveRoomSubscriptions.mock
}

// When sets expectation for the ChatServiceHandler.RemoveRoomSubscriptions which will trigger the result defined by the following
// Then helper
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) *ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation {
	if mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.RemoveRoomSubscriptions mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation{
		mock:               mmRemoveRoomSubscriptions.mock,
		params:             &ChatServiceHandlerMockRemoveRoomSubscriptionsParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockRemoveRoomSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveRoomSubscriptions.expectations = append(mmRemoveRoomSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.RemoveRoomSubscriptions return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockRemoveRoomSubscriptionsExpectation) Then(pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockRemoveRoomSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.RemoveRoomSubscriptions should be invoked
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Times(n uint64) *mChatServiceHandlerMockRemoveRoomSubscriptions {
	if n == 0 {
		mmRemoveRoomSubscriptions.mock.t.Fatalf("Times of ChatServiceHandlerMock.RemoveRoomSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveRoomSubscriptions.expectedInvocations, n)
	mmRemoveRoomSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveRoomSubscriptions
}

func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) invocationsDone() bool {
	if len(mmRemoveRoomSubscriptions.expectations) == 0 && mmRemoveRoomSubscriptions.defaultExpectation == nil && mmRemoveRoomSubscriptions.mock.funcRemoveRoomSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.mock.afterRemoveRoomSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveRoomSubscriptions implements mm_chatv1connect.ChatServiceHandler
func (mmRemoveRoomSubscriptions *ChatServiceHandlerMock) RemoveRoomSubscriptions(ctx context.Context, pp1 *connect.Request[v1.RemoveRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.RemoveRoomSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveRoomSubscriptions.beforeRemoveRoomSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveRoomSubscriptions.afterRemoveRoomSubscriptionsCounter, 1)

	mmRemoveRoomSubscriptions.t.Helper()

	if mmRemoveRoomSubscriptions.inspectFuncRemoveRoomSubscriptions != nil {
		mmRemoveRoomSubscriptions.inspectFuncRemoveRoomSubscriptions(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockRemoveRoomSubscriptionsParams{ctx, pp1}

	// Record call args
	mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.mutex.Lock()
	mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.callArgs = append(mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.callArgs, &mm_params)
	mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.mutex.Unlock()

	for _, e := range mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockRemoveRoomSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.RemoveRoomSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.RemoveRoomSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.RemoveRoomSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveRoomSubscriptions.RemoveRoomSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveRoomSubscriptions.t.Fatal("No results are set for the ChatServiceHandlerMock.RemoveRoomSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveRoomSubscriptions.funcRemoveRoomSubscriptions != nil {
		return mmRemoveRoomSubscriptions.funcRemoveRoomSubscriptions(ctx, pp1)
	}
	mmRemoveRoomSubscriptions.t.Fatalf("Unexpected call to ChatServiceHandlerMock.RemoveRoomSubscriptions. %v %v", ctx, pp1)
	return
}

// RemoveRoomSubscriptionsAfterCounter returns a count of finished ChatServiceHandlerMock.RemoveRoomSubscriptions invocations
func (mmRemoveRoomSubscriptions *ChatServiceHandlerMock) RemoveRoomSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.afterRemoveRoomSubscriptionsCounter)
}

// RemoveRoomSubscriptionsBeforeCounter returns a count of ChatServiceHandlerMock.RemoveRoomSubscriptions invocations
func (mmRemoveRoomSubscriptions *ChatServiceHandlerMock) RemoveRoomSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveRoomSubscriptions.beforeRemoveRoomSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.RemoveRoomSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveRoomSubscriptions *mChatServiceHandlerMockRemoveRoomSubscriptions) Calls() []*ChatServiceHandlerMockRemoveRoomSubscriptionsParams {
	mmRemoveRoomSubscriptions.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockRemoveRoomSubscriptionsParams, len(mmRemoveRoomSubscriptions.callArgs))
	copy(argCopy, mmRemoveRoomSubscriptions.callArgs)

	mmRemoveRoomSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveRoomSubscriptionsDone returns true if the count of the RemoveRoomSubscriptions invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockRemoveRoomSubscriptionsDone() bool {
	if m.RemoveRoomSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveRoomSubscriptionsMock.invocationsDone()
}

// MinimockRemoveRoomSubscriptionsInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockRemoveRoomSubscriptionsInspect() {
	for _, e := range m.RemoveRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.RemoveRoomSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveRoomSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterRemoveRoomSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveRoomSubscriptionsMock.defaultExpectation != nil && afterRemoveRoomSubscriptionsCounter < 1 {
		if m.RemoveRoomSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.RemoveRoomSubscriptions at\n%s", m.RemoveRoomSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.RemoveRoomSubscriptions at\n%s with params: %#v", m.RemoveRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.RemoveRoomSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveRoomSubscriptions != nil && afterRemoveRoomSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.RemoveRoomSubscriptions at\n%s", m.funcRemoveRoomSubscriptionsOrigin)
	}

	if !m.RemoveRoomSubscriptionsMock.invocationsDone() && afterRemoveRoomSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.RemoveRoomSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveRoomSubscriptionsMock.expectedInvocations), m.RemoveRoomSubscriptionsMock.expectedInvocationsOrigin, afterRemoveRoomSubscriptionsCounter)
	}
}

type mChatServiceHandlerMockSearchRoomSubscriptions struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockSearchRoomSubscriptionsExpectation
	expectations       []*ChatServiceHandlerMockSearchRoomSubscriptionsExpectation

	callArgs []*ChatServiceHandlerMockSearchRoomSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockSearchRoomSubscriptionsExpectation specifies expectation struct of the ChatServiceHandler.SearchRoomSubscriptions
type ChatServiceHandlerMockSearchRoomSubscriptionsExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockSearchRoomSubscriptionsParams
	paramPtrs          *ChatServiceHandlerMockSearchRoomSubscriptionsParamPtrs
	expectationOrigins ChatServiceHandlerMockSearchRoomSubscriptionsExpectationOrigins
	results            *ChatServiceHandlerMockSearchRoomSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockSearchRoomSubscriptionsParams contains parameters of the ChatServiceHandler.SearchRoomSubscriptions
type ChatServiceHandlerMockSearchRoomSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]
}

// ChatServiceHandlerMockSearchRoomSubscriptionsParamPtrs contains pointers to parameters of the ChatServiceHandler.SearchRoomSubscriptions
type ChatServiceHandlerMockSearchRoomSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRoomSubscriptionsRequest]
}

// ChatServiceHandlerMockSearchRoomSubscriptionsResults contains results of the ChatServiceHandler.SearchRoomSubscriptions
type ChatServiceHandlerMockSearchRoomSubscriptionsResults struct {
	pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse]
	err error
}

// ChatServiceHandlerMockSearchRoomSubscriptionsOrigins contains origins of expectations of the ChatServiceHandler.SearchRoomSubscriptions
type ChatServiceHandlerMockSearchRoomSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Optional() *mChatServiceHandlerMockSearchRoomSubscriptions {
	mmSearchRoomSubscriptions.optional = true
	return mmSearchRoomSubscriptions
}

// Expect sets up expected params for ChatServiceHandler.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) *mChatServiceHandlerMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockSearchRoomSubscriptionsExpectation{}
	}

	if mmSearchRoomSubscriptions.defaultExpectation.paramPtrs != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by ExpectParams functions")
	}

	mmSearchRoomSubscriptions.defaultExpectation.params = &ChatServiceHandlerMockSearchRoomSubscriptionsParams{ctx, pp1}
	mmSearchRoomSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchRoomSubscriptions.expectations {
		if minimock.Equal(e.params, mmSearchRoomSubscriptions.defaultExpectation.params) {
			mmSearchRoomSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchRoomSubscriptions.defaultExpectation.params)
		}
	}

	return mmSearchRoomSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockSearchRoomSubscriptionsExpectation{}
	}

	if mmSearchRoomSubscriptions.defaultExpectation.params != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Expect")
	}

	if mmSearchRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmSearchRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSearchRoomSubscriptionsParamPtrs{}
	}
	mmSearchRoomSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchRoomSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchRoomSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) *mChatServiceHandlerMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockSearchRoomSubscriptionsExpectation{}
	}

	if mmSearchRoomSubscriptions.defaultExpectation.params != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Expect")
	}

	if mmSearchRoomSubscriptions.defaultExpectation.paramPtrs == nil {
		mmSearchRoomSubscriptions.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSearchRoomSubscriptionsParamPtrs{}
	}
	mmSearchRoomSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchRoomSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchRoomSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest])) *mChatServiceHandlerMockSearchRoomSubscriptions {
	if mmSearchRoomSubscriptions.mock.inspectFuncSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.SearchRoomSubscriptions")
	}

	mmSearchRoomSubscriptions.mock.inspectFuncSearchRoomSubscriptions = f

	return mmSearchRoomSubscriptions
}

// Return sets up results that will be returned by ChatServiceHandler.SearchRoomSubscriptions
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Return(pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error) *ChatServiceHandlerMock {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Set")
	}

	if mmSearchRoomSubscriptions.defaultExpectation == nil {
		mmSearchRoomSubscriptions.defaultExpectation = &ChatServiceHandlerMockSearchRoomSubscriptionsExpectation{mock: mmSearchRoomSubscriptions.mock}
	}
	mmSearchRoomSubscriptions.defaultExpectation.results = &ChatServiceHandlerMockSearchRoomSubscriptionsResults{pp2, err}
	mmSearchRoomSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchRoomSubscriptions.mock
}

// Set uses given function f to mock the ChatServiceHandler.SearchRoomSubscriptions method
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error)) *ChatServiceHandlerMock {
	if mmSearchRoomSubscriptions.defaultExpectation != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.SearchRoomSubscriptions method")
	}

	if len(mmSearchRoomSubscriptions.expectations) > 0 {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.SearchRoomSubscriptions method")
	}

	mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions = f
	mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmSearchRoomSubscriptions.mock
}

// When sets expectation for the ChatServiceHandler.SearchRoomSubscriptions which will trigger the result defined by the following
// Then helper
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) *ChatServiceHandlerMockSearchRoomSubscriptionsExpectation {
	if mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.mock.t.Fatalf("ChatServiceHandlerMock.SearchRoomSubscriptions mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockSearchRoomSubscriptionsExpectation{
		mock:               mmSearchRoomSubscriptions.mock,
		params:             &ChatServiceHandlerMockSearchRoomSubscriptionsParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockSearchRoomSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchRoomSubscriptions.expectations = append(mmSearchRoomSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.SearchRoomSubscriptions return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockSearchRoomSubscriptionsExpectation) Then(pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockSearchRoomSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.SearchRoomSubscriptions should be invoked
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Times(n uint64) *mChatServiceHandlerMockSearchRoomSubscriptions {
	if n == 0 {
		mmSearchRoomSubscriptions.mock.t.Fatalf("Times of ChatServiceHandlerMock.SearchRoomSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchRoomSubscriptions.expectedInvocations, n)
	mmSearchRoomSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchRoomSubscriptions
}

func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) invocationsDone() bool {
	if len(mmSearchRoomSubscriptions.expectations) == 0 && mmSearchRoomSubscriptions.defaultExpectation == nil && mmSearchRoomSubscriptions.mock.funcSearchRoomSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.mock.afterSearchRoomSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchRoomSubscriptions implements mm_chatv1connect.ChatServiceHandler
func (mmSearchRoomSubscriptions *ChatServiceHandlerMock) SearchRoomSubscriptions(ctx context.Context, pp1 *connect.Request[v1.SearchRoomSubscriptionsRequest]) (pp2 *connect.Response[v1.SearchRoomSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchRoomSubscriptions.beforeSearchRoomSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchRoomSubscriptions.afterSearchRoomSubscriptionsCounter, 1)

	mmSearchRoomSubscriptions.t.Helper()

	if mmSearchRoomSubscriptions.inspectFuncSearchRoomSubscriptions != nil {
		mmSearchRoomSubscriptions.inspectFuncSearchRoomSubscriptions(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockSearchRoomSubscriptionsParams{ctx, pp1}

	// Record call args
	mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.mutex.Lock()
	mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.callArgs = append(mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.callArgs, &mm_params)
	mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.mutex.Unlock()

	for _, e := range mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockSearchRoomSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.SearchRoomSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.SearchRoomSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchRoomSubscriptions.t.Errorf("ChatServiceHandlerMock.SearchRoomSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchRoomSubscriptions.SearchRoomSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchRoomSubscriptions.t.Fatal("No results are set for the ChatServiceHandlerMock.SearchRoomSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchRoomSubscriptions.funcSearchRoomSubscriptions != nil {
		return mmSearchRoomSubscriptions.funcSearchRoomSubscriptions(ctx, pp1)
	}
	mmSearchRoomSubscriptions.t.Fatalf("Unexpected call to ChatServiceHandlerMock.SearchRoomSubscriptions. %v %v", ctx, pp1)
	return
}

// SearchRoomSubscriptionsAfterCounter returns a count of finished ChatServiceHandlerMock.SearchRoomSubscriptions invocations
func (mmSearchRoomSubscriptions *ChatServiceHandlerMock) SearchRoomSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.afterSearchRoomSubscriptionsCounter)
}

// SearchRoomSubscriptionsBeforeCounter returns a count of ChatServiceHandlerMock.SearchRoomSubscriptions invocations
func (mmSearchRoomSubscriptions *ChatServiceHandlerMock) SearchRoomSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRoomSubscriptions.beforeSearchRoomSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.SearchRoomSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchRoomSubscriptions *mChatServiceHandlerMockSearchRoomSubscriptions) Calls() []*ChatServiceHandlerMockSearchRoomSubscriptionsParams {
	mmSearchRoomSubscriptions.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockSearchRoomSubscriptionsParams, len(mmSearchRoomSubscriptions.callArgs))
	copy(argCopy, mmSearchRoomSubscriptions.callArgs)

	mmSearchRoomSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockSearchRoomSubscriptionsDone returns true if the count of the SearchRoomSubscriptions invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockSearchRoomSubscriptionsDone() bool {
	if m.SearchRoomSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchRoomSubscriptionsMock.invocationsDone()
}

// MinimockSearchRoomSubscriptionsInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockSearchRoomSubscriptionsInspect() {
	for _, e := range m.SearchRoomSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRoomSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchRoomSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterSearchRoomSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchRoomSubscriptionsMock.defaultExpectation != nil && afterSearchRoomSubscriptionsCounter < 1 {
		if m.SearchRoomSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRoomSubscriptions at\n%s", m.SearchRoomSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRoomSubscriptions at\n%s with params: %#v", m.SearchRoomSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.SearchRoomSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchRoomSubscriptions != nil && afterSearchRoomSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRoomSubscriptions at\n%s", m.funcSearchRoomSubscriptionsOrigin)
	}

	if !m.SearchRoomSubscriptionsMock.invocationsDone() && afterSearchRoomSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.SearchRoomSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchRoomSubscriptionsMock.expectedInvocations), m.SearchRoomSubscriptionsMock.expectedInvocationsOrigin, afterSearchRoomSubscriptionsCounter)
	}
}

type mChatServiceHandlerMockSearchRooms struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockSearchRoomsExpectation
	expectations       []*ChatServiceHandlerMockSearchRoomsExpectation

	callArgs []*ChatServiceHandlerMockSearchRoomsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockSearchRoomsExpectation specifies expectation struct of the ChatServiceHandler.SearchRooms
type ChatServiceHandlerMockSearchRoomsExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockSearchRoomsParams
	paramPtrs          *ChatServiceHandlerMockSearchRoomsParamPtrs
	expectationOrigins ChatServiceHandlerMockSearchRoomsExpectationOrigins
	results            *ChatServiceHandlerMockSearchRoomsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockSearchRoomsParams contains parameters of the ChatServiceHandler.SearchRooms
type ChatServiceHandlerMockSearchRoomsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRoomsRequest]
	pp2 *connect.ServerStream[v1.SearchRoomsResponse]
}

// ChatServiceHandlerMockSearchRoomsParamPtrs contains pointers to parameters of the ChatServiceHandler.SearchRooms
type ChatServiceHandlerMockSearchRoomsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRoomsRequest]
	pp2 **connect.ServerStream[v1.SearchRoomsResponse]
}

// ChatServiceHandlerMockSearchRoomsResults contains results of the ChatServiceHandler.SearchRooms
type ChatServiceHandlerMockSearchRoomsResults struct {
	err error
}

// ChatServiceHandlerMockSearchRoomsOrigins contains origins of expectations of the ChatServiceHandler.SearchRooms
type ChatServiceHandlerMockSearchRoomsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Optional() *mChatServiceHandlerMockSearchRooms {
	mmSearchRooms.optional = true
	return mmSearchRooms
}

// Expect sets up expected params for ChatServiceHandler.SearchRooms
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse]) *mChatServiceHandlerMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceHandlerMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.paramPtrs != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by ExpectParams functions")
	}

	mmSearchRooms.defaultExpectation.params = &ChatServiceHandlerMockSearchRoomsParams{ctx, pp1, pp2}
	mmSearchRooms.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchRooms.expectations {
		if minimock.Equal(e.params, mmSearchRooms.defaultExpectation.params) {
			mmSearchRooms.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchRooms.defaultExpectation.params)
		}
	}

	return mmSearchRooms
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.SearchRooms
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceHandlerMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.params != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Expect")
	}

	if mmSearchRooms.defaultExpectation.paramPtrs == nil {
		mmSearchRooms.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSearchRoomsParamPtrs{}
	}
	mmSearchRooms.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchRooms.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchRooms
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.SearchRooms
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRoomsRequest]) *mChatServiceHandlerMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceHandlerMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.params != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Expect")
	}

	if mmSearchRooms.defaultExpectation.paramPtrs == nil {
		mmSearchRooms.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSearchRoomsParamPtrs{}
	}
	mmSearchRooms.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchRooms.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchRooms
}

// ExpectPp2Param3 sets up expected param pp2 for ChatServiceHandler.SearchRooms
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) ExpectPp2Param3(pp2 *connect.ServerStream[v1.SearchRoomsResponse]) *mChatServiceHandlerMockSearchRooms {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceHandlerMockSearchRoomsExpectation{}
	}

	if mmSearchRooms.defaultExpectation.params != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Expect")
	}

	if mmSearchRooms.defaultExpectation.paramPtrs == nil {
		mmSearchRooms.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSearchRoomsParamPtrs{}
	}
	mmSearchRooms.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearchRooms.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearchRooms
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.SearchRooms
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse])) *mChatServiceHandlerMockSearchRooms {
	if mmSearchRooms.mock.inspectFuncSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.SearchRooms")
	}

	mmSearchRooms.mock.inspectFuncSearchRooms = f

	return mmSearchRooms
}

// Return sets up results that will be returned by ChatServiceHandler.SearchRooms
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Return(err error) *ChatServiceHandlerMock {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Set")
	}

	if mmSearchRooms.defaultExpectation == nil {
		mmSearchRooms.defaultExpectation = &ChatServiceHandlerMockSearchRoomsExpectation{mock: mmSearchRooms.mock}
	}
	mmSearchRooms.defaultExpectation.results = &ChatServiceHandlerMockSearchRoomsResults{err}
	mmSearchRooms.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchRooms.mock
}

// Set uses given function f to mock the ChatServiceHandler.SearchRooms method
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse]) (err error)) *ChatServiceHandlerMock {
	if mmSearchRooms.defaultExpectation != nil {
		mmSearchRooms.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.SearchRooms method")
	}

	if len(mmSearchRooms.expectations) > 0 {
		mmSearchRooms.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.SearchRooms method")
	}

	mmSearchRooms.mock.funcSearchRooms = f
	mmSearchRooms.mock.funcSearchRoomsOrigin = minimock.CallerInfo(1)
	return mmSearchRooms.mock
}

// When sets expectation for the ChatServiceHandler.SearchRooms which will trigger the result defined by the following
// Then helper
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) When(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse]) *ChatServiceHandlerMockSearchRoomsExpectation {
	if mmSearchRooms.mock.funcSearchRooms != nil {
		mmSearchRooms.mock.t.Fatalf("ChatServiceHandlerMock.SearchRooms mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockSearchRoomsExpectation{
		mock:               mmSearchRooms.mock,
		params:             &ChatServiceHandlerMockSearchRoomsParams{ctx, pp1, pp2},
		expectationOrigins: ChatServiceHandlerMockSearchRoomsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchRooms.expectations = append(mmSearchRooms.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.SearchRooms return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockSearchRoomsExpectation) Then(err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockSearchRoomsResults{err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.SearchRooms should be invoked
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Times(n uint64) *mChatServiceHandlerMockSearchRooms {
	if n == 0 {
		mmSearchRooms.mock.t.Fatalf("Times of ChatServiceHandlerMock.SearchRooms mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchRooms.expectedInvocations, n)
	mmSearchRooms.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchRooms
}

func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) invocationsDone() bool {
	if len(mmSearchRooms.expectations) == 0 && mmSearchRooms.defaultExpectation == nil && mmSearchRooms.mock.funcSearchRooms == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchRooms.mock.afterSearchRoomsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchRooms.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchRooms implements mm_chatv1connect.ChatServiceHandler
func (mmSearchRooms *ChatServiceHandlerMock) SearchRooms(ctx context.Context, pp1 *connect.Request[v1.SearchRoomsRequest], pp2 *connect.ServerStream[v1.SearchRoomsResponse]) (err error) {
	mm_atomic.AddUint64(&mmSearchRooms.beforeSearchRoomsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchRooms.afterSearchRoomsCounter, 1)

	mmSearchRooms.t.Helper()

	if mmSearchRooms.inspectFuncSearchRooms != nil {
		mmSearchRooms.inspectFuncSearchRooms(ctx, pp1, pp2)
	}

	mm_params := ChatServiceHandlerMockSearchRoomsParams{ctx, pp1, pp2}

	// Record call args
	mmSearchRooms.SearchRoomsMock.mutex.Lock()
	mmSearchRooms.SearchRoomsMock.callArgs = append(mmSearchRooms.SearchRoomsMock.callArgs, &mm_params)
	mmSearchRooms.SearchRoomsMock.mutex.Unlock()

	for _, e := range mmSearchRooms.SearchRoomsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearchRooms.SearchRoomsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchRooms.SearchRoomsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchRooms.SearchRoomsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchRooms.SearchRoomsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockSearchRoomsParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchRooms.t.Errorf("ChatServiceHandlerMock.SearchRooms got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchRooms.t.Errorf("ChatServiceHandlerMock.SearchRooms got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearchRooms.t.Errorf("ChatServiceHandlerMock.SearchRooms got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchRooms.t.Errorf("ChatServiceHandlerMock.SearchRooms got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchRooms.SearchRoomsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchRooms.SearchRoomsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchRooms.t.Fatal("No results are set for the ChatServiceHandlerMock.SearchRooms")
		}
		return (*mm_results).err
	}
	if mmSearchRooms.funcSearchRooms != nil {
		return mmSearchRooms.funcSearchRooms(ctx, pp1, pp2)
	}
	mmSearchRooms.t.Fatalf("Unexpected call to ChatServiceHandlerMock.SearchRooms. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchRoomsAfterCounter returns a count of finished ChatServiceHandlerMock.SearchRooms invocations
func (mmSearchRooms *ChatServiceHandlerMock) SearchRoomsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRooms.afterSearchRoomsCounter)
}

// SearchRoomsBeforeCounter returns a count of ChatServiceHandlerMock.SearchRooms invocations
func (mmSearchRooms *ChatServiceHandlerMock) SearchRoomsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchRooms.beforeSearchRoomsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.SearchRooms.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchRooms *mChatServiceHandlerMockSearchRooms) Calls() []*ChatServiceHandlerMockSearchRoomsParams {
	mmSearchRooms.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockSearchRoomsParams, len(mmSearchRooms.callArgs))
	copy(argCopy, mmSearchRooms.callArgs)

	mmSearchRooms.mutex.RUnlock()

	return argCopy
}

// MinimockSearchRoomsDone returns true if the count of the SearchRooms invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockSearchRoomsDone() bool {
	if m.SearchRoomsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchRoomsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchRoomsMock.invocationsDone()
}

// MinimockSearchRoomsInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockSearchRoomsInspect() {
	for _, e := range m.SearchRoomsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRooms at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchRoomsCounter := mm_atomic.LoadUint64(&m.afterSearchRoomsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchRoomsMock.defaultExpectation != nil && afterSearchRoomsCounter < 1 {
		if m.SearchRoomsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRooms at\n%s", m.SearchRoomsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRooms at\n%s with params: %#v", m.SearchRoomsMock.defaultExpectation.expectationOrigins.origin, *m.SearchRoomsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchRooms != nil && afterSearchRoomsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.SearchRooms at\n%s", m.funcSearchRoomsOrigin)
	}

	if !m.SearchRoomsMock.invocationsDone() && afterSearchRoomsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.SearchRooms at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchRoomsMock.expectedInvocations), m.SearchRoomsMock.expectedInvocationsOrigin, afterSearchRoomsCounter)
	}
}

type mChatServiceHandlerMockSendEvent struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockSendEventExpectation
	expectations       []*ChatServiceHandlerMockSendEventExpectation

	callArgs []*ChatServiceHandlerMockSendEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockSendEventExpectation specifies expectation struct of the ChatServiceHandler.SendEvent
type ChatServiceHandlerMockSendEventExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockSendEventParams
	paramPtrs          *ChatServiceHandlerMockSendEventParamPtrs
	expectationOrigins ChatServiceHandlerMockSendEventExpectationOrigins
	results            *ChatServiceHandlerMockSendEventResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockSendEventParams contains parameters of the ChatServiceHandler.SendEvent
type ChatServiceHandlerMockSendEventParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SendEventRequest]
}

// ChatServiceHandlerMockSendEventParamPtrs contains pointers to parameters of the ChatServiceHandler.SendEvent
type ChatServiceHandlerMockSendEventParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SendEventRequest]
}

// ChatServiceHandlerMockSendEventResults contains results of the ChatServiceHandler.SendEvent
type ChatServiceHandlerMockSendEventResults struct {
	pp2 *connect.Response[v1.SendEventResponse]
	err error
}

// ChatServiceHandlerMockSendEventOrigins contains origins of expectations of the ChatServiceHandler.SendEvent
type ChatServiceHandlerMockSendEventExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Optional() *mChatServiceHandlerMockSendEvent {
	mmSendEvent.optional = true
	return mmSendEvent
}

// Expect sets up expected params for ChatServiceHandler.SendEvent
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Expect(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) *mChatServiceHandlerMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceHandlerMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.paramPtrs != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by ExpectParams functions")
	}

	mmSendEvent.defaultExpectation.params = &ChatServiceHandlerMockSendEventParams{ctx, pp1}
	mmSendEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendEvent.expectations {
		if minimock.Equal(e.params, mmSendEvent.defaultExpectation.params) {
			mmSendEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendEvent.defaultExpectation.params)
		}
	}

	return mmSendEvent
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.SendEvent
func (mmSendEvent *mChatServiceHandlerMockSendEvent) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceHandlerMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.params != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Expect")
	}

	if mmSendEvent.defaultExpectation.paramPtrs == nil {
		mmSendEvent.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSendEventParamPtrs{}
	}
	mmSendEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendEvent
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.SendEvent
func (mmSendEvent *mChatServiceHandlerMockSendEvent) ExpectPp1Param2(pp1 *connect.Request[v1.SendEventRequest]) *mChatServiceHandlerMockSendEvent {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceHandlerMockSendEventExpectation{}
	}

	if mmSendEvent.defaultExpectation.params != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Expect")
	}

	if mmSendEvent.defaultExpectation.paramPtrs == nil {
		mmSendEvent.defaultExpectation.paramPtrs = &ChatServiceHandlerMockSendEventParamPtrs{}
	}
	mmSendEvent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSendEvent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSendEvent
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.SendEvent
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest])) *mChatServiceHandlerMockSendEvent {
	if mmSendEvent.mock.inspectFuncSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.SendEvent")
	}

	mmSendEvent.mock.inspectFuncSendEvent = f

	return mmSendEvent
}

// Return sets up results that will be returned by ChatServiceHandler.SendEvent
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Return(pp2 *connect.Response[v1.SendEventResponse], err error) *ChatServiceHandlerMock {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Set")
	}

	if mmSendEvent.defaultExpectation == nil {
		mmSendEvent.defaultExpectation = &ChatServiceHandlerMockSendEventExpectation{mock: mmSendEvent.mock}
	}
	mmSendEvent.defaultExpectation.results = &ChatServiceHandlerMockSendEventResults{pp2, err}
	mmSendEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendEvent.mock
}

// Set uses given function f to mock the ChatServiceHandler.SendEvent method
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) (pp2 *connect.Response[v1.SendEventResponse], err error)) *ChatServiceHandlerMock {
	if mmSendEvent.defaultExpectation != nil {
		mmSendEvent.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.SendEvent method")
	}

	if len(mmSendEvent.expectations) > 0 {
		mmSendEvent.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.SendEvent method")
	}

	mmSendEvent.mock.funcSendEvent = f
	mmSendEvent.mock.funcSendEventOrigin = minimock.CallerInfo(1)
	return mmSendEvent.mock
}

// When sets expectation for the ChatServiceHandler.SendEvent which will trigger the result defined by the following
// Then helper
func (mmSendEvent *mChatServiceHandlerMockSendEvent) When(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) *ChatServiceHandlerMockSendEventExpectation {
	if mmSendEvent.mock.funcSendEvent != nil {
		mmSendEvent.mock.t.Fatalf("ChatServiceHandlerMock.SendEvent mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockSendEventExpectation{
		mock:               mmSendEvent.mock,
		params:             &ChatServiceHandlerMockSendEventParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockSendEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendEvent.expectations = append(mmSendEvent.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.SendEvent return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockSendEventExpectation) Then(pp2 *connect.Response[v1.SendEventResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockSendEventResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.SendEvent should be invoked
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Times(n uint64) *mChatServiceHandlerMockSendEvent {
	if n == 0 {
		mmSendEvent.mock.t.Fatalf("Times of ChatServiceHandlerMock.SendEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendEvent.expectedInvocations, n)
	mmSendEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendEvent
}

func (mmSendEvent *mChatServiceHandlerMockSendEvent) invocationsDone() bool {
	if len(mmSendEvent.expectations) == 0 && mmSendEvent.defaultExpectation == nil && mmSendEvent.mock.funcSendEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendEvent.mock.afterSendEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendEvent implements mm_chatv1connect.ChatServiceHandler
func (mmSendEvent *ChatServiceHandlerMock) SendEvent(ctx context.Context, pp1 *connect.Request[v1.SendEventRequest]) (pp2 *connect.Response[v1.SendEventResponse], err error) {
	mm_atomic.AddUint64(&mmSendEvent.beforeSendEventCounter, 1)
	defer mm_atomic.AddUint64(&mmSendEvent.afterSendEventCounter, 1)

	mmSendEvent.t.Helper()

	if mmSendEvent.inspectFuncSendEvent != nil {
		mmSendEvent.inspectFuncSendEvent(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockSendEventParams{ctx, pp1}

	// Record call args
	mmSendEvent.SendEventMock.mutex.Lock()
	mmSendEvent.SendEventMock.callArgs = append(mmSendEvent.SendEventMock.callArgs, &mm_params)
	mmSendEvent.SendEventMock.mutex.Unlock()

	for _, e := range mmSendEvent.SendEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSendEvent.SendEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendEvent.SendEventMock.defaultExpectation.Counter, 1)
		mm_want := mmSendEvent.SendEventMock.defaultExpectation.params
		mm_want_ptrs := mmSendEvent.SendEventMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockSendEventParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendEvent.t.Errorf("ChatServiceHandlerMock.SendEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSendEvent.t.Errorf("ChatServiceHandlerMock.SendEvent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendEvent.t.Errorf("ChatServiceHandlerMock.SendEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendEvent.SendEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendEvent.SendEventMock.defaultExpectation.results
		if mm_results == nil {
			mmSendEvent.t.Fatal("No results are set for the ChatServiceHandlerMock.SendEvent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSendEvent.funcSendEvent != nil {
		return mmSendEvent.funcSendEvent(ctx, pp1)
	}
	mmSendEvent.t.Fatalf("Unexpected call to ChatServiceHandlerMock.SendEvent. %v %v", ctx, pp1)
	return
}

// SendEventAfterCounter returns a count of finished ChatServiceHandlerMock.SendEvent invocations
func (mmSendEvent *ChatServiceHandlerMock) SendEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendEvent.afterSendEventCounter)
}

// SendEventBeforeCounter returns a count of ChatServiceHandlerMock.SendEvent invocations
func (mmSendEvent *ChatServiceHandlerMock) SendEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendEvent.beforeSendEventCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.SendEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendEvent *mChatServiceHandlerMockSendEvent) Calls() []*ChatServiceHandlerMockSendEventParams {
	mmSendEvent.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockSendEventParams, len(mmSendEvent.callArgs))
	copy(argCopy, mmSendEvent.callArgs)

	mmSendEvent.mutex.RUnlock()

	return argCopy
}

// MinimockSendEventDone returns true if the count of the SendEvent invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockSendEventDone() bool {
	if m.SendEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendEventMock.invocationsDone()
}

// MinimockSendEventInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockSendEventInspect() {
	for _, e := range m.SendEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SendEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendEventCounter := mm_atomic.LoadUint64(&m.afterSendEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendEventMock.defaultExpectation != nil && afterSendEventCounter < 1 {
		if m.SendEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SendEvent at\n%s", m.SendEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.SendEvent at\n%s with params: %#v", m.SendEventMock.defaultExpectation.expectationOrigins.origin, *m.SendEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendEvent != nil && afterSendEventCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.SendEvent at\n%s", m.funcSendEventOrigin)
	}

	if !m.SendEventMock.invocationsDone() && afterSendEventCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.SendEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendEventMock.expectedInvocations), m.SendEventMock.expectedInvocationsOrigin, afterSendEventCounter)
	}
}

type mChatServiceHandlerMockUpdateClientState struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockUpdateClientStateExpectation
	expectations       []*ChatServiceHandlerMockUpdateClientStateExpectation

	callArgs []*ChatServiceHandlerMockUpdateClientStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockUpdateClientStateExpectation specifies expectation struct of the ChatServiceHandler.UpdateClientState
type ChatServiceHandlerMockUpdateClientStateExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockUpdateClientStateParams
	paramPtrs          *ChatServiceHandlerMockUpdateClientStateParamPtrs
	expectationOrigins ChatServiceHandlerMockUpdateClientStateExpectationOrigins
	results            *ChatServiceHandlerMockUpdateClientStateResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockUpdateClientStateParams contains parameters of the ChatServiceHandler.UpdateClientState
type ChatServiceHandlerMockUpdateClientStateParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateClientStateRequest]
}

// ChatServiceHandlerMockUpdateClientStateParamPtrs contains pointers to parameters of the ChatServiceHandler.UpdateClientState
type ChatServiceHandlerMockUpdateClientStateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateClientStateRequest]
}

// ChatServiceHandlerMockUpdateClientStateResults contains results of the ChatServiceHandler.UpdateClientState
type ChatServiceHandlerMockUpdateClientStateResults struct {
	pp2 *connect.Response[v1.UpdateClientStateResponse]
	err error
}

// ChatServiceHandlerMockUpdateClientStateOrigins contains origins of expectations of the ChatServiceHandler.UpdateClientState
type ChatServiceHandlerMockUpdateClientStateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Optional() *mChatServiceHandlerMockUpdateClientState {
	mmUpdateClientState.optional = true
	return mmUpdateClientState
}

// Expect sets up expected params for ChatServiceHandler.UpdateClientState
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) *mChatServiceHandlerMockUpdateClientState {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceHandlerMockUpdateClientStateExpectation{}
	}

	if mmUpdateClientState.defaultExpectation.paramPtrs != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by ExpectParams functions")
	}

	mmUpdateClientState.defaultExpectation.params = &ChatServiceHandlerMockUpdateClientStateParams{ctx, pp1}
	mmUpdateClientState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateClientState.expectations {
		if minimock.Equal(e.params, mmUpdateClientState.defaultExpectation.params) {
			mmUpdateClientState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateClientState.defaultExpectation.params)
		}
	}

	return mmUpdateClientState
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.UpdateClientState
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockUpdateClientState {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceHandlerMockUpdateClientStateExpectation{}
	}

	if mmUpdateClientState.defaultExpectation.params != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Expect")
	}

	if mmUpdateClientState.defaultExpectation.paramPtrs == nil {
		mmUpdateClientState.defaultExpectation.paramPtrs = &ChatServiceHandlerMockUpdateClientStateParamPtrs{}
	}
	mmUpdateClientState.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateClientState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateClientState
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.UpdateClientState
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateClientStateRequest]) *mChatServiceHandlerMockUpdateClientState {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceHandlerMockUpdateClientStateExpectation{}
	}

	if mmUpdateClientState.defaultExpectation.params != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Expect")
	}

	if mmUpdateClientState.defaultExpectation.paramPtrs == nil {
		mmUpdateClientState.defaultExpectation.paramPtrs = &ChatServiceHandlerMockUpdateClientStateParamPtrs{}
	}
	mmUpdateClientState.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateClientState.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateClientState
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.UpdateClientState
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest])) *mChatServiceHandlerMockUpdateClientState {
	if mmUpdateClientState.mock.inspectFuncUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.UpdateClientState")
	}

	mmUpdateClientState.mock.inspectFuncUpdateClientState = f

	return mmUpdateClientState
}

// Return sets up results that will be returned by ChatServiceHandler.UpdateClientState
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Return(pp2 *connect.Response[v1.UpdateClientStateResponse], err error) *ChatServiceHandlerMock {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Set")
	}

	if mmUpdateClientState.defaultExpectation == nil {
		mmUpdateClientState.defaultExpectation = &ChatServiceHandlerMockUpdateClientStateExpectation{mock: mmUpdateClientState.mock}
	}
	mmUpdateClientState.defaultExpectation.results = &ChatServiceHandlerMockUpdateClientStateResults{pp2, err}
	mmUpdateClientState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateClientState.mock
}

// Set uses given function f to mock the ChatServiceHandler.UpdateClientState method
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) (pp2 *connect.Response[v1.UpdateClientStateResponse], err error)) *ChatServiceHandlerMock {
	if mmUpdateClientState.defaultExpectation != nil {
		mmUpdateClientState.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.UpdateClientState method")
	}

	if len(mmUpdateClientState.expectations) > 0 {
		mmUpdateClientState.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.UpdateClientState method")
	}

	mmUpdateClientState.mock.funcUpdateClientState = f
	mmUpdateClientState.mock.funcUpdateClientStateOrigin = minimock.CallerInfo(1)
	return mmUpdateClientState.mock
}

// When sets expectation for the ChatServiceHandler.UpdateClientState which will trigger the result defined by the following
// Then helper
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) When(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) *ChatServiceHandlerMockUpdateClientStateExpectation {
	if mmUpdateClientState.mock.funcUpdateClientState != nil {
		mmUpdateClientState.mock.t.Fatalf("ChatServiceHandlerMock.UpdateClientState mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockUpdateClientStateExpectation{
		mock:               mmUpdateClientState.mock,
		params:             &ChatServiceHandlerMockUpdateClientStateParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockUpdateClientStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateClientState.expectations = append(mmUpdateClientState.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.UpdateClientState return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockUpdateClientStateExpectation) Then(pp2 *connect.Response[v1.UpdateClientStateResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockUpdateClientStateResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.UpdateClientState should be invoked
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Times(n uint64) *mChatServiceHandlerMockUpdateClientState {
	if n == 0 {
		mmUpdateClientState.mock.t.Fatalf("Times of ChatServiceHandlerMock.UpdateClientState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateClientState.expectedInvocations, n)
	mmUpdateClientState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateClientState
}

func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) invocationsDone() bool {
	if len(mmUpdateClientState.expectations) == 0 && mmUpdateClientState.defaultExpectation == nil && mmUpdateClientState.mock.funcUpdateClientState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateClientState.mock.afterUpdateClientStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateClientState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateClientState implements mm_chatv1connect.ChatServiceHandler
func (mmUpdateClientState *ChatServiceHandlerMock) UpdateClientState(ctx context.Context, pp1 *connect.Request[v1.UpdateClientStateRequest]) (pp2 *connect.Response[v1.UpdateClientStateResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateClientState.beforeUpdateClientStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateClientState.afterUpdateClientStateCounter, 1)

	mmUpdateClientState.t.Helper()

	if mmUpdateClientState.inspectFuncUpdateClientState != nil {
		mmUpdateClientState.inspectFuncUpdateClientState(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockUpdateClientStateParams{ctx, pp1}

	// Record call args
	mmUpdateClientState.UpdateClientStateMock.mutex.Lock()
	mmUpdateClientState.UpdateClientStateMock.callArgs = append(mmUpdateClientState.UpdateClientStateMock.callArgs, &mm_params)
	mmUpdateClientState.UpdateClientStateMock.mutex.Unlock()

	for _, e := range mmUpdateClientState.UpdateClientStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateClientState.UpdateClientStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateClientState.UpdateClientStateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateClientState.UpdateClientStateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateClientState.UpdateClientStateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockUpdateClientStateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateClientState.t.Errorf("ChatServiceHandlerMock.UpdateClientState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClientState.UpdateClientStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateClientState.t.Errorf("ChatServiceHandlerMock.UpdateClientState got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateClientState.UpdateClientStateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateClientState.t.Errorf("ChatServiceHandlerMock.UpdateClientState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateClientState.UpdateClientStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateClientState.UpdateClientStateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateClientState.t.Fatal("No results are set for the ChatServiceHandlerMock.UpdateClientState")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateClientState.funcUpdateClientState != nil {
		return mmUpdateClientState.funcUpdateClientState(ctx, pp1)
	}
	mmUpdateClientState.t.Fatalf("Unexpected call to ChatServiceHandlerMock.UpdateClientState. %v %v", ctx, pp1)
	return
}

// UpdateClientStateAfterCounter returns a count of finished ChatServiceHandlerMock.UpdateClientState invocations
func (mmUpdateClientState *ChatServiceHandlerMock) UpdateClientStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClientState.afterUpdateClientStateCounter)
}

// UpdateClientStateBeforeCounter returns a count of ChatServiceHandlerMock.UpdateClientState invocations
func (mmUpdateClientState *ChatServiceHandlerMock) UpdateClientStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateClientState.beforeUpdateClientStateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.UpdateClientState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateClientState *mChatServiceHandlerMockUpdateClientState) Calls() []*ChatServiceHandlerMockUpdateClientStateParams {
	mmUpdateClientState.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockUpdateClientStateParams, len(mmUpdateClientState.callArgs))
	copy(argCopy, mmUpdateClientState.callArgs)

	mmUpdateClientState.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateClientStateDone returns true if the count of the UpdateClientState invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockUpdateClientStateDone() bool {
	if m.UpdateClientStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateClientStateMock.invocationsDone()
}

// MinimockUpdateClientStateInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockUpdateClientStateInspect() {
	for _, e := range m.UpdateClientStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateClientState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateClientStateCounter := mm_atomic.LoadUint64(&m.afterUpdateClientStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateClientStateMock.defaultExpectation != nil && afterUpdateClientStateCounter < 1 {
		if m.UpdateClientStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateClientState at\n%s", m.UpdateClientStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateClientState at\n%s with params: %#v", m.UpdateClientStateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateClientStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateClientState != nil && afterUpdateClientStateCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateClientState at\n%s", m.funcUpdateClientStateOrigin)
	}

	if !m.UpdateClientStateMock.invocationsDone() && afterUpdateClientStateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.UpdateClientState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateClientStateMock.expectedInvocations), m.UpdateClientStateMock.expectedInvocationsOrigin, afterUpdateClientStateCounter)
	}
}

type mChatServiceHandlerMockUpdateRoom struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockUpdateRoomExpectation
	expectations       []*ChatServiceHandlerMockUpdateRoomExpectation

	callArgs []*ChatServiceHandlerMockUpdateRoomParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockUpdateRoomExpectation specifies expectation struct of the ChatServiceHandler.UpdateRoom
type ChatServiceHandlerMockUpdateRoomExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockUpdateRoomParams
	paramPtrs          *ChatServiceHandlerMockUpdateRoomParamPtrs
	expectationOrigins ChatServiceHandlerMockUpdateRoomExpectationOrigins
	results            *ChatServiceHandlerMockUpdateRoomResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockUpdateRoomParams contains parameters of the ChatServiceHandler.UpdateRoom
type ChatServiceHandlerMockUpdateRoomParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateRoomRequest]
}

// ChatServiceHandlerMockUpdateRoomParamPtrs contains pointers to parameters of the ChatServiceHandler.UpdateRoom
type ChatServiceHandlerMockUpdateRoomParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateRoomRequest]
}

// ChatServiceHandlerMockUpdateRoomResults contains results of the ChatServiceHandler.UpdateRoom
type ChatServiceHandlerMockUpdateRoomResults struct {
	pp2 *connect.Response[v1.UpdateRoomResponse]
	err error
}

// ChatServiceHandlerMockUpdateRoomOrigins contains origins of expectations of the ChatServiceHandler.UpdateRoom
type ChatServiceHandlerMockUpdateRoomExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Optional() *mChatServiceHandlerMockUpdateRoom {
	mmUpdateRoom.optional = true
	return mmUpdateRoom
}

// Expect sets up expected params for ChatServiceHandler.UpdateRoom
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) *mChatServiceHandlerMockUpdateRoom {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceHandlerMockUpdateRoomExpectation{}
	}

	if mmUpdateRoom.defaultExpectation.paramPtrs != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by ExpectParams functions")
	}

	mmUpdateRoom.defaultExpectation.params = &ChatServiceHandlerMockUpdateRoomParams{ctx, pp1}
	mmUpdateRoom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateRoom.expectations {
		if minimock.Equal(e.params, mmUpdateRoom.defaultExpectation.params) {
			mmUpdateRoom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateRoom.defaultExpectation.params)
		}
	}

	return mmUpdateRoom
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.UpdateRoom
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockUpdateRoom {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceHandlerMockUpdateRoomExpectation{}
	}

	if mmUpdateRoom.defaultExpectation.params != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Expect")
	}

	if mmUpdateRoom.defaultExpectation.paramPtrs == nil {
		mmUpdateRoom.defaultExpectation.paramPtrs = &ChatServiceHandlerMockUpdateRoomParamPtrs{}
	}
	mmUpdateRoom.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateRoom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateRoom
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.UpdateRoom
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateRoomRequest]) *mChatServiceHandlerMockUpdateRoom {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceHandlerMockUpdateRoomExpectation{}
	}

	if mmUpdateRoom.defaultExpectation.params != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Expect")
	}

	if mmUpdateRoom.defaultExpectation.paramPtrs == nil {
		mmUpdateRoom.defaultExpectation.paramPtrs = &ChatServiceHandlerMockUpdateRoomParamPtrs{}
	}
	mmUpdateRoom.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateRoom.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateRoom
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.UpdateRoom
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest])) *mChatServiceHandlerMockUpdateRoom {
	if mmUpdateRoom.mock.inspectFuncUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.UpdateRoom")
	}

	mmUpdateRoom.mock.inspectFuncUpdateRoom = f

	return mmUpdateRoom
}

// Return sets up results that will be returned by ChatServiceHandler.UpdateRoom
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Return(pp2 *connect.Response[v1.UpdateRoomResponse], err error) *ChatServiceHandlerMock {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Set")
	}

	if mmUpdateRoom.defaultExpectation == nil {
		mmUpdateRoom.defaultExpectation = &ChatServiceHandlerMockUpdateRoomExpectation{mock: mmUpdateRoom.mock}
	}
	mmUpdateRoom.defaultExpectation.results = &ChatServiceHandlerMockUpdateRoomResults{pp2, err}
	mmUpdateRoom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateRoom.mock
}

// Set uses given function f to mock the ChatServiceHandler.UpdateRoom method
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) (pp2 *connect.Response[v1.UpdateRoomResponse], err error)) *ChatServiceHandlerMock {
	if mmUpdateRoom.defaultExpectation != nil {
		mmUpdateRoom.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.UpdateRoom method")
	}

	if len(mmUpdateRoom.expectations) > 0 {
		mmUpdateRoom.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.UpdateRoom method")
	}

	mmUpdateRoom.mock.funcUpdateRoom = f
	mmUpdateRoom.mock.funcUpdateRoomOrigin = minimock.CallerInfo(1)
	return mmUpdateRoom.mock
}

// When sets expectation for the ChatServiceHandler.UpdateRoom which will trigger the result defined by the following
// Then helper
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) When(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) *ChatServiceHandlerMockUpdateRoomExpectation {
	if mmUpdateRoom.mock.funcUpdateRoom != nil {
		mmUpdateRoom.mock.t.Fatalf("ChatServiceHandlerMock.UpdateRoom mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockUpdateRoomExpectation{
		mock:               mmUpdateRoom.mock,
		params:             &ChatServiceHandlerMockUpdateRoomParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockUpdateRoomExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateRoom.expectations = append(mmUpdateRoom.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.UpdateRoom return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockUpdateRoomExpectation) Then(pp2 *connect.Response[v1.UpdateRoomResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockUpdateRoomResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.UpdateRoom should be invoked
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Times(n uint64) *mChatServiceHandlerMockUpdateRoom {
	if n == 0 {
		mmUpdateRoom.mock.t.Fatalf("Times of ChatServiceHandlerMock.UpdateRoom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateRoom.expectedInvocations, n)
	mmUpdateRoom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateRoom
}

func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) invocationsDone() bool {
	if len(mmUpdateRoom.expectations) == 0 && mmUpdateRoom.defaultExpectation == nil && mmUpdateRoom.mock.funcUpdateRoom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateRoom.mock.afterUpdateRoomCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateRoom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateRoom implements mm_chatv1connect.ChatServiceHandler
func (mmUpdateRoom *ChatServiceHandlerMock) UpdateRoom(ctx context.Context, pp1 *connect.Request[v1.UpdateRoomRequest]) (pp2 *connect.Response[v1.UpdateRoomResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateRoom.beforeUpdateRoomCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateRoom.afterUpdateRoomCounter, 1)

	mmUpdateRoom.t.Helper()

	if mmUpdateRoom.inspectFuncUpdateRoom != nil {
		mmUpdateRoom.inspectFuncUpdateRoom(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockUpdateRoomParams{ctx, pp1}

	// Record call args
	mmUpdateRoom.UpdateRoomMock.mutex.Lock()
	mmUpdateRoom.UpdateRoomMock.callArgs = append(mmUpdateRoom.UpdateRoomMock.callArgs, &mm_params)
	mmUpdateRoom.UpdateRoomMock.mutex.Unlock()

	for _, e := range mmUpdateRoom.UpdateRoomMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateRoom.UpdateRoomMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateRoom.UpdateRoomMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateRoom.UpdateRoomMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateRoom.UpdateRoomMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockUpdateRoomParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateRoom.t.Errorf("ChatServiceHandlerMock.UpdateRoom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateRoom.UpdateRoomMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateRoom.t.Errorf("ChatServiceHandlerMock.UpdateRoom got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateRoom.UpdateRoomMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateRoom.t.Errorf("ChatServiceHandlerMock.UpdateRoom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateRoom.UpdateRoomMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateRoom.UpdateRoomMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateRoom.t.Fatal("No results are set for the ChatServiceHandlerMock.UpdateRoom")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateRoom.funcUpdateRoom != nil {
		return mmUpdateRoom.funcUpdateRoom(ctx, pp1)
	}
	mmUpdateRoom.t.Fatalf("Unexpected call to ChatServiceHandlerMock.UpdateRoom. %v %v", ctx, pp1)
	return
}

// UpdateRoomAfterCounter returns a count of finished ChatServiceHandlerMock.UpdateRoom invocations
func (mmUpdateRoom *ChatServiceHandlerMock) UpdateRoomAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRoom.afterUpdateRoomCounter)
}

// UpdateRoomBeforeCounter returns a count of ChatServiceHandlerMock.UpdateRoom invocations
func (mmUpdateRoom *ChatServiceHandlerMock) UpdateRoomBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateRoom.beforeUpdateRoomCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.UpdateRoom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateRoom *mChatServiceHandlerMockUpdateRoom) Calls() []*ChatServiceHandlerMockUpdateRoomParams {
	mmUpdateRoom.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockUpdateRoomParams, len(mmUpdateRoom.callArgs))
	copy(argCopy, mmUpdateRoom.callArgs)

	mmUpdateRoom.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateRoomDone returns true if the count of the UpdateRoom invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockUpdateRoomDone() bool {
	if m.UpdateRoomMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateRoomMock.invocationsDone()
}

// MinimockUpdateRoomInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockUpdateRoomInspect() {
	for _, e := range m.UpdateRoomMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateRoom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateRoomCounter := mm_atomic.LoadUint64(&m.afterUpdateRoomCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateRoomMock.defaultExpectation != nil && afterUpdateRoomCounter < 1 {
		if m.UpdateRoomMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateRoom at\n%s", m.UpdateRoomMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateRoom at\n%s with params: %#v", m.UpdateRoomMock.defaultExpectation.expectationOrigins.origin, *m.UpdateRoomMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateRoom != nil && afterUpdateRoomCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateRoom at\n%s", m.funcUpdateRoomOrigin)
	}

	if !m.UpdateRoomMock.invocationsDone() && afterUpdateRoomCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.UpdateRoom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateRoomMock.expectedInvocations), m.UpdateRoomMock.expectedInvocationsOrigin, afterUpdateRoomCounter)
	}
}

type mChatServiceHandlerMockUpdateSubscriptionRole struct {
	optional           bool
	mock               *ChatServiceHandlerMock
	defaultExpectation *ChatServiceHandlerMockUpdateSubscriptionRoleExpectation
	expectations       []*ChatServiceHandlerMockUpdateSubscriptionRoleExpectation

	callArgs []*ChatServiceHandlerMockUpdateSubscriptionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceHandlerMockUpdateSubscriptionRoleExpectation specifies expectation struct of the ChatServiceHandler.UpdateSubscriptionRole
type ChatServiceHandlerMockUpdateSubscriptionRoleExpectation struct {
	mock               *ChatServiceHandlerMock
	params             *ChatServiceHandlerMockUpdateSubscriptionRoleParams
	paramPtrs          *ChatServiceHandlerMockUpdateSubscriptionRoleParamPtrs
	expectationOrigins ChatServiceHandlerMockUpdateSubscriptionRoleExpectationOrigins
	results            *ChatServiceHandlerMockUpdateSubscriptionRoleResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceHandlerMockUpdateSubscriptionRoleParams contains parameters of the ChatServiceHandler.UpdateSubscriptionRole
type ChatServiceHandlerMockUpdateSubscriptionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]
}

// ChatServiceHandlerMockUpdateSubscriptionRoleParamPtrs contains pointers to parameters of the ChatServiceHandler.UpdateSubscriptionRole
type ChatServiceHandlerMockUpdateSubscriptionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateSubscriptionRoleRequest]
}

// ChatServiceHandlerMockUpdateSubscriptionRoleResults contains results of the ChatServiceHandler.UpdateSubscriptionRole
type ChatServiceHandlerMockUpdateSubscriptionRoleResults struct {
	pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse]
	err error
}

// ChatServiceHandlerMockUpdateSubscriptionRoleOrigins contains origins of expectations of the ChatServiceHandler.UpdateSubscriptionRole
type ChatServiceHandlerMockUpdateSubscriptionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Optional() *mChatServiceHandlerMockUpdateSubscriptionRole {
	mmUpdateSubscriptionRole.optional = true
	return mmUpdateSubscriptionRole
}

// Expect sets up expected params for ChatServiceHandler.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) *mChatServiceHandlerMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceHandlerMockUpdateSubscriptionRoleExpectation{}
	}

	if mmUpdateSubscriptionRole.defaultExpectation.paramPtrs != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by ExpectParams functions")
	}

	mmUpdateSubscriptionRole.defaultExpectation.params = &ChatServiceHandlerMockUpdateSubscriptionRoleParams{ctx, pp1}
	mmUpdateSubscriptionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateSubscriptionRole.expectations {
		if minimock.Equal(e.params, mmUpdateSubscriptionRole.defaultExpectation.params) {
			mmUpdateSubscriptionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscriptionRole.defaultExpectation.params)
		}
	}

	return mmUpdateSubscriptionRole
}

// ExpectCtxParam1 sets up expected param ctx for ChatServiceHandler.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) ExpectCtxParam1(ctx context.Context) *mChatServiceHandlerMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceHandlerMockUpdateSubscriptionRoleExpectation{}
	}

	if mmUpdateSubscriptionRole.defaultExpectation.params != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Expect")
	}

	if mmUpdateSubscriptionRole.defaultExpectation.paramPtrs == nil {
		mmUpdateSubscriptionRole.defaultExpectation.paramPtrs = &ChatServiceHandlerMockUpdateSubscriptionRoleParamPtrs{}
	}
	mmUpdateSubscriptionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateSubscriptionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateSubscriptionRole
}

// ExpectPp1Param2 sets up expected param pp1 for ChatServiceHandler.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) *mChatServiceHandlerMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceHandlerMockUpdateSubscriptionRoleExpectation{}
	}

	if mmUpdateSubscriptionRole.defaultExpectation.params != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Expect")
	}

	if mmUpdateSubscriptionRole.defaultExpectation.paramPtrs == nil {
		mmUpdateSubscriptionRole.defaultExpectation.paramPtrs = &ChatServiceHandlerMockUpdateSubscriptionRoleParamPtrs{}
	}
	mmUpdateSubscriptionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateSubscriptionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateSubscriptionRole
}

// Inspect accepts an inspector function that has same arguments as the ChatServiceHandler.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest])) *mChatServiceHandlerMockUpdateSubscriptionRole {
	if mmUpdateSubscriptionRole.mock.inspectFuncUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Inspect function is already set for ChatServiceHandlerMock.UpdateSubscriptionRole")
	}

	mmUpdateSubscriptionRole.mock.inspectFuncUpdateSubscriptionRole = f

	return mmUpdateSubscriptionRole
}

// Return sets up results that will be returned by ChatServiceHandler.UpdateSubscriptionRole
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Return(pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error) *ChatServiceHandlerMock {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Set")
	}

	if mmUpdateSubscriptionRole.defaultExpectation == nil {
		mmUpdateSubscriptionRole.defaultExpectation = &ChatServiceHandlerMockUpdateSubscriptionRoleExpectation{mock: mmUpdateSubscriptionRole.mock}
	}
	mmUpdateSubscriptionRole.defaultExpectation.results = &ChatServiceHandlerMockUpdateSubscriptionRoleResults{pp2, err}
	mmUpdateSubscriptionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateSubscriptionRole.mock
}

// Set uses given function f to mock the ChatServiceHandler.UpdateSubscriptionRole method
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) (pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error)) *ChatServiceHandlerMock {
	if mmUpdateSubscriptionRole.defaultExpectation != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Default expectation is already set for the ChatServiceHandler.UpdateSubscriptionRole method")
	}

	if len(mmUpdateSubscriptionRole.expectations) > 0 {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Some expectations are already set for the ChatServiceHandler.UpdateSubscriptionRole method")
	}

	mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole = f
	mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRoleOrigin = minimock.CallerInfo(1)
	return mmUpdateSubscriptionRole.mock
}

// When sets expectation for the ChatServiceHandler.UpdateSubscriptionRole which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) When(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) *ChatServiceHandlerMockUpdateSubscriptionRoleExpectation {
	if mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.mock.t.Fatalf("ChatServiceHandlerMock.UpdateSubscriptionRole mock is already set by Set")
	}

	expectation := &ChatServiceHandlerMockUpdateSubscriptionRoleExpectation{
		mock:               mmUpdateSubscriptionRole.mock,
		params:             &ChatServiceHandlerMockUpdateSubscriptionRoleParams{ctx, pp1},
		expectationOrigins: ChatServiceHandlerMockUpdateSubscriptionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateSubscriptionRole.expectations = append(mmUpdateSubscriptionRole.expectations, expectation)
	return expectation
}

// Then sets up ChatServiceHandler.UpdateSubscriptionRole return parameters for the expectation previously defined by the When method
func (e *ChatServiceHandlerMockUpdateSubscriptionRoleExpectation) Then(pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error) *ChatServiceHandlerMock {
	e.results = &ChatServiceHandlerMockUpdateSubscriptionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times ChatServiceHandler.UpdateSubscriptionRole should be invoked
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Times(n uint64) *mChatServiceHandlerMockUpdateSubscriptionRole {
	if n == 0 {
		mmUpdateSubscriptionRole.mock.t.Fatalf("Times of ChatServiceHandlerMock.UpdateSubscriptionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateSubscriptionRole.expectedInvocations, n)
	mmUpdateSubscriptionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateSubscriptionRole
}

func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) invocationsDone() bool {
	if len(mmUpdateSubscriptionRole.expectations) == 0 && mmUpdateSubscriptionRole.defaultExpectation == nil && mmUpdateSubscriptionRole.mock.funcUpdateSubscriptionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.mock.afterUpdateSubscriptionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateSubscriptionRole implements mm_chatv1connect.ChatServiceHandler
func (mmUpdateSubscriptionRole *ChatServiceHandlerMock) UpdateSubscriptionRole(ctx context.Context, pp1 *connect.Request[v1.UpdateSubscriptionRoleRequest]) (pp2 *connect.Response[v1.UpdateSubscriptionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateSubscriptionRole.beforeUpdateSubscriptionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscriptionRole.afterUpdateSubscriptionRoleCounter, 1)

	mmUpdateSubscriptionRole.t.Helper()

	if mmUpdateSubscriptionRole.inspectFuncUpdateSubscriptionRole != nil {
		mmUpdateSubscriptionRole.inspectFuncUpdateSubscriptionRole(ctx, pp1)
	}

	mm_params := ChatServiceHandlerMockUpdateSubscriptionRoleParams{ctx, pp1}

	// Record call args
	mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.mutex.Lock()
	mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.callArgs = append(mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.callArgs, &mm_params)
	mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.mutex.Unlock()

	for _, e := range mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceHandlerMockUpdateSubscriptionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateSubscriptionRole.t.Errorf("ChatServiceHandlerMock.UpdateSubscriptionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateSubscriptionRole.t.Errorf("ChatServiceHandlerMock.UpdateSubscriptionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscriptionRole.t.Errorf("ChatServiceHandlerMock.UpdateSubscriptionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscriptionRole.UpdateSubscriptionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscriptionRole.t.Fatal("No results are set for the ChatServiceHandlerMock.UpdateSubscriptionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateSubscriptionRole.funcUpdateSubscriptionRole != nil {
		return mmUpdateSubscriptionRole.funcUpdateSubscriptionRole(ctx, pp1)
	}
	mmUpdateSubscriptionRole.t.Fatalf("Unexpected call to ChatServiceHandlerMock.UpdateSubscriptionRole. %v %v", ctx, pp1)
	return
}

// UpdateSubscriptionRoleAfterCounter returns a count of finished ChatServiceHandlerMock.UpdateSubscriptionRole invocations
func (mmUpdateSubscriptionRole *ChatServiceHandlerMock) UpdateSubscriptionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.afterUpdateSubscriptionRoleCounter)
}

// UpdateSubscriptionRoleBeforeCounter returns a count of ChatServiceHandlerMock.UpdateSubscriptionRole invocations
func (mmUpdateSubscriptionRole *ChatServiceHandlerMock) UpdateSubscriptionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriptionRole.beforeUpdateSubscriptionRoleCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceHandlerMock.UpdateSubscriptionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscriptionRole *mChatServiceHandlerMockUpdateSubscriptionRole) Calls() []*ChatServiceHandlerMockUpdateSubscriptionRoleParams {
	mmUpdateSubscriptionRole.mutex.RLock()

	argCopy := make([]*ChatServiceHandlerMockUpdateSubscriptionRoleParams, len(mmUpdateSubscriptionRole.callArgs))
	copy(argCopy, mmUpdateSubscriptionRole.callArgs)

	mmUpdateSubscriptionRole.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriptionRoleDone returns true if the count of the UpdateSubscriptionRole invocations corresponds
// the number of defined expectations
func (m *ChatServiceHandlerMock) MinimockUpdateSubscriptionRoleDone() bool {
	if m.UpdateSubscriptionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateSubscriptionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateSubscriptionRoleMock.invocationsDone()
}

// MinimockUpdateSubscriptionRoleInspect logs each unmet expectation
func (m *ChatServiceHandlerMock) MinimockUpdateSubscriptionRoleInspect() {
	for _, e := range m.UpdateSubscriptionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateSubscriptionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateSubscriptionRoleCounter := mm_atomic.LoadUint64(&m.afterUpdateSubscriptionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionRoleMock.defaultExpectation != nil && afterUpdateSubscriptionRoleCounter < 1 {
		if m.UpdateSubscriptionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateSubscriptionRole at\n%s", m.UpdateSubscriptionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateSubscriptionRole at\n%s with params: %#v", m.UpdateSubscriptionRoleMock.defaultExpectation.expectationOrigins.origin, *m.UpdateSubscriptionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriptionRole != nil && afterUpdateSubscriptionRoleCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceHandlerMock.UpdateSubscriptionRole at\n%s", m.funcUpdateSubscriptionRoleOrigin)
	}

	if !m.UpdateSubscriptionRoleMock.invocationsDone() && afterUpdateSubscriptionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceHandlerMock.UpdateSubscriptionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateSubscriptionRoleMock.expectedInvocations), m.UpdateSubscriptionRoleMock.expectedInvocationsOrigin, afterUpdateSubscriptionRoleCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddRoomSubscriptionsInspect()

			m.MinimockCreateRoomInspect()

			m.MinimockDeleteRoomInspect()

			m.MinimockGetClientStateInspect()

			m.MinimockGetHistoryInspect()

			m.MinimockRemoveRoomSubscriptionsInspect()

			m.MinimockSearchRoomSubscriptionsInspect()

			m.MinimockSearchRoomsInspect()

			m.MinimockSendEventInspect()

			m.MinimockUpdateClientStateInspect()

			m.MinimockUpdateRoomInspect()

			m.MinimockUpdateSubscriptionRoleInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddRoomSubscriptionsDone() &&
		m.MinimockCreateRoomDone() &&
		m.MinimockDeleteRoomDone() &&
		m.MinimockGetClientStateDone() &&
		m.MinimockGetHistoryDone() &&
		m.MinimockRemoveRoomSubscriptionsDone() &&
		m.MinimockSearchRoomSubscriptionsDone() &&
		m.MinimockSearchRoomsDone() &&
		m.MinimockSendEventDone() &&
		m.MinimockUpdateClientStateDone() &&
		m.MinimockUpdateRoomDone() &&
		m.MinimockUpdateSubscriptionRoleDone()
}
