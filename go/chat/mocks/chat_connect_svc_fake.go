// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"buf.build/gen/go/antinvestor/chat/connectrpc/go/chat/v1/chatv1connect"
	chatv1 "buf.build/gen/go/antinvestor/chat/protocolbuffers/go/chat/v1"
	"connectrpc.com/connect"
)

type FakeChatServiceHandler struct {
	AddRoomSubscriptionsStub        func(context.Context, *connect.Request[chatv1.AddRoomSubscriptionsRequest]) (*connect.Response[chatv1.AddRoomSubscriptionsResponse], error)
	addRoomSubscriptionsMutex       sync.RWMutex
	addRoomSubscriptionsArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.AddRoomSubscriptionsRequest]
	}
	addRoomSubscriptionsReturns struct {
		result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse]
		result2 error
	}
	addRoomSubscriptionsReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse]
		result2 error
	}
	CreateRoomStub        func(context.Context, *connect.Request[chatv1.CreateRoomRequest]) (*connect.Response[chatv1.CreateRoomResponse], error)
	createRoomMutex       sync.RWMutex
	createRoomArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.CreateRoomRequest]
	}
	createRoomReturns struct {
		result1 *connect.Response[chatv1.CreateRoomResponse]
		result2 error
	}
	createRoomReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.CreateRoomResponse]
		result2 error
	}
	DeleteRoomStub        func(context.Context, *connect.Request[chatv1.DeleteRoomRequest]) (*connect.Response[chatv1.DeleteRoomResponse], error)
	deleteRoomMutex       sync.RWMutex
	deleteRoomArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.DeleteRoomRequest]
	}
	deleteRoomReturns struct {
		result1 *connect.Response[chatv1.DeleteRoomResponse]
		result2 error
	}
	deleteRoomReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.DeleteRoomResponse]
		result2 error
	}
	GetClientStateStub        func(context.Context, *connect.Request[chatv1.GetClientStateRequest]) (*connect.Response[chatv1.GetClientStateResponse], error)
	getClientStateMutex       sync.RWMutex
	getClientStateArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.GetClientStateRequest]
	}
	getClientStateReturns struct {
		result1 *connect.Response[chatv1.GetClientStateResponse]
		result2 error
	}
	getClientStateReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.GetClientStateResponse]
		result2 error
	}
	GetHistoryStub        func(context.Context, *connect.Request[chatv1.GetHistoryRequest]) (*connect.Response[chatv1.GetHistoryResponse], error)
	getHistoryMutex       sync.RWMutex
	getHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.GetHistoryRequest]
	}
	getHistoryReturns struct {
		result1 *connect.Response[chatv1.GetHistoryResponse]
		result2 error
	}
	getHistoryReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.GetHistoryResponse]
		result2 error
	}
	RemoveRoomSubscriptionsStub        func(context.Context, *connect.Request[chatv1.RemoveRoomSubscriptionsRequest]) (*connect.Response[chatv1.RemoveRoomSubscriptionsResponse], error)
	removeRoomSubscriptionsMutex       sync.RWMutex
	removeRoomSubscriptionsArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.RemoveRoomSubscriptionsRequest]
	}
	removeRoomSubscriptionsReturns struct {
		result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse]
		result2 error
	}
	removeRoomSubscriptionsReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse]
		result2 error
	}
	SearchRoomSubscriptionsStub        func(context.Context, *connect.Request[chatv1.SearchRoomSubscriptionsRequest]) (*connect.Response[chatv1.SearchRoomSubscriptionsResponse], error)
	searchRoomSubscriptionsMutex       sync.RWMutex
	searchRoomSubscriptionsArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.SearchRoomSubscriptionsRequest]
	}
	searchRoomSubscriptionsReturns struct {
		result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse]
		result2 error
	}
	searchRoomSubscriptionsReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse]
		result2 error
	}
	SearchRoomsStub        func(context.Context, *connect.Request[chatv1.SearchRoomsRequest], *connect.ServerStream[chatv1.SearchRoomsResponse]) error
	searchRoomsMutex       sync.RWMutex
	searchRoomsArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.SearchRoomsRequest]
		arg3 *connect.ServerStream[chatv1.SearchRoomsResponse]
	}
	searchRoomsReturns struct {
		result1 error
	}
	searchRoomsReturnsOnCall map[int]struct {
		result1 error
	}
	SendEventStub        func(context.Context, *connect.Request[chatv1.SendEventRequest]) (*connect.Response[chatv1.SendEventResponse], error)
	sendEventMutex       sync.RWMutex
	sendEventArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.SendEventRequest]
	}
	sendEventReturns struct {
		result1 *connect.Response[chatv1.SendEventResponse]
		result2 error
	}
	sendEventReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.SendEventResponse]
		result2 error
	}
	UpdateClientStateStub        func(context.Context, *connect.Request[chatv1.UpdateClientStateRequest]) (*connect.Response[chatv1.UpdateClientStateResponse], error)
	updateClientStateMutex       sync.RWMutex
	updateClientStateArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.UpdateClientStateRequest]
	}
	updateClientStateReturns struct {
		result1 *connect.Response[chatv1.UpdateClientStateResponse]
		result2 error
	}
	updateClientStateReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.UpdateClientStateResponse]
		result2 error
	}
	UpdateRoomStub        func(context.Context, *connect.Request[chatv1.UpdateRoomRequest]) (*connect.Response[chatv1.UpdateRoomResponse], error)
	updateRoomMutex       sync.RWMutex
	updateRoomArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.UpdateRoomRequest]
	}
	updateRoomReturns struct {
		result1 *connect.Response[chatv1.UpdateRoomResponse]
		result2 error
	}
	updateRoomReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.UpdateRoomResponse]
		result2 error
	}
	UpdateSubscriptionRoleStub        func(context.Context, *connect.Request[chatv1.UpdateSubscriptionRoleRequest]) (*connect.Response[chatv1.UpdateSubscriptionRoleResponse], error)
	updateSubscriptionRoleMutex       sync.RWMutex
	updateSubscriptionRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.UpdateSubscriptionRoleRequest]
	}
	updateSubscriptionRoleReturns struct {
		result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse]
		result2 error
	}
	updateSubscriptionRoleReturnsOnCall map[int]struct {
		result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse]
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeChatServiceHandler) AddRoomSubscriptions(arg1 context.Context, arg2 *connect.Request[chatv1.AddRoomSubscriptionsRequest]) (*connect.Response[chatv1.AddRoomSubscriptionsResponse], error) {
	fake.addRoomSubscriptionsMutex.Lock()
	ret, specificReturn := fake.addRoomSubscriptionsReturnsOnCall[len(fake.addRoomSubscriptionsArgsForCall)]
	fake.addRoomSubscriptionsArgsForCall = append(fake.addRoomSubscriptionsArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.AddRoomSubscriptionsRequest]
	}{arg1, arg2})
	stub := fake.AddRoomSubscriptionsStub
	fakeReturns := fake.addRoomSubscriptionsReturns
	fake.recordInvocation("AddRoomSubscriptions", []interface{}{arg1, arg2})
	fake.addRoomSubscriptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) AddRoomSubscriptionsCallCount() int {
	fake.addRoomSubscriptionsMutex.RLock()
	defer fake.addRoomSubscriptionsMutex.RUnlock()
	return len(fake.addRoomSubscriptionsArgsForCall)
}

func (fake *FakeChatServiceHandler) AddRoomSubscriptionsCalls(stub func(context.Context, *connect.Request[chatv1.AddRoomSubscriptionsRequest]) (*connect.Response[chatv1.AddRoomSubscriptionsResponse], error)) {
	fake.addRoomSubscriptionsMutex.Lock()
	defer fake.addRoomSubscriptionsMutex.Unlock()
	fake.AddRoomSubscriptionsStub = stub
}

func (fake *FakeChatServiceHandler) AddRoomSubscriptionsArgsForCall(i int) (context.Context, *connect.Request[chatv1.AddRoomSubscriptionsRequest]) {
	fake.addRoomSubscriptionsMutex.RLock()
	defer fake.addRoomSubscriptionsMutex.RUnlock()
	argsForCall := fake.addRoomSubscriptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) AddRoomSubscriptionsReturns(result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse], result2 error) {
	fake.addRoomSubscriptionsMutex.Lock()
	defer fake.addRoomSubscriptionsMutex.Unlock()
	fake.AddRoomSubscriptionsStub = nil
	fake.addRoomSubscriptionsReturns = struct {
		result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) AddRoomSubscriptionsReturnsOnCall(i int, result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse], result2 error) {
	fake.addRoomSubscriptionsMutex.Lock()
	defer fake.addRoomSubscriptionsMutex.Unlock()
	fake.AddRoomSubscriptionsStub = nil
	if fake.addRoomSubscriptionsReturnsOnCall == nil {
		fake.addRoomSubscriptionsReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse]
			result2 error
		})
	}
	fake.addRoomSubscriptionsReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.AddRoomSubscriptionsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) CreateRoom(arg1 context.Context, arg2 *connect.Request[chatv1.CreateRoomRequest]) (*connect.Response[chatv1.CreateRoomResponse], error) {
	fake.createRoomMutex.Lock()
	ret, specificReturn := fake.createRoomReturnsOnCall[len(fake.createRoomArgsForCall)]
	fake.createRoomArgsForCall = append(fake.createRoomArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.CreateRoomRequest]
	}{arg1, arg2})
	stub := fake.CreateRoomStub
	fakeReturns := fake.createRoomReturns
	fake.recordInvocation("CreateRoom", []interface{}{arg1, arg2})
	fake.createRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) CreateRoomCallCount() int {
	fake.createRoomMutex.RLock()
	defer fake.createRoomMutex.RUnlock()
	return len(fake.createRoomArgsForCall)
}

func (fake *FakeChatServiceHandler) CreateRoomCalls(stub func(context.Context, *connect.Request[chatv1.CreateRoomRequest]) (*connect.Response[chatv1.CreateRoomResponse], error)) {
	fake.createRoomMutex.Lock()
	defer fake.createRoomMutex.Unlock()
	fake.CreateRoomStub = stub
}

func (fake *FakeChatServiceHandler) CreateRoomArgsForCall(i int) (context.Context, *connect.Request[chatv1.CreateRoomRequest]) {
	fake.createRoomMutex.RLock()
	defer fake.createRoomMutex.RUnlock()
	argsForCall := fake.createRoomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) CreateRoomReturns(result1 *connect.Response[chatv1.CreateRoomResponse], result2 error) {
	fake.createRoomMutex.Lock()
	defer fake.createRoomMutex.Unlock()
	fake.CreateRoomStub = nil
	fake.createRoomReturns = struct {
		result1 *connect.Response[chatv1.CreateRoomResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) CreateRoomReturnsOnCall(i int, result1 *connect.Response[chatv1.CreateRoomResponse], result2 error) {
	fake.createRoomMutex.Lock()
	defer fake.createRoomMutex.Unlock()
	fake.CreateRoomStub = nil
	if fake.createRoomReturnsOnCall == nil {
		fake.createRoomReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.CreateRoomResponse]
			result2 error
		})
	}
	fake.createRoomReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.CreateRoomResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) DeleteRoom(arg1 context.Context, arg2 *connect.Request[chatv1.DeleteRoomRequest]) (*connect.Response[chatv1.DeleteRoomResponse], error) {
	fake.deleteRoomMutex.Lock()
	ret, specificReturn := fake.deleteRoomReturnsOnCall[len(fake.deleteRoomArgsForCall)]
	fake.deleteRoomArgsForCall = append(fake.deleteRoomArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.DeleteRoomRequest]
	}{arg1, arg2})
	stub := fake.DeleteRoomStub
	fakeReturns := fake.deleteRoomReturns
	fake.recordInvocation("DeleteRoom", []interface{}{arg1, arg2})
	fake.deleteRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) DeleteRoomCallCount() int {
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	return len(fake.deleteRoomArgsForCall)
}

func (fake *FakeChatServiceHandler) DeleteRoomCalls(stub func(context.Context, *connect.Request[chatv1.DeleteRoomRequest]) (*connect.Response[chatv1.DeleteRoomResponse], error)) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = stub
}

func (fake *FakeChatServiceHandler) DeleteRoomArgsForCall(i int) (context.Context, *connect.Request[chatv1.DeleteRoomRequest]) {
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	argsForCall := fake.deleteRoomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) DeleteRoomReturns(result1 *connect.Response[chatv1.DeleteRoomResponse], result2 error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = nil
	fake.deleteRoomReturns = struct {
		result1 *connect.Response[chatv1.DeleteRoomResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) DeleteRoomReturnsOnCall(i int, result1 *connect.Response[chatv1.DeleteRoomResponse], result2 error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = nil
	if fake.deleteRoomReturnsOnCall == nil {
		fake.deleteRoomReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.DeleteRoomResponse]
			result2 error
		})
	}
	fake.deleteRoomReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.DeleteRoomResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) GetClientState(arg1 context.Context, arg2 *connect.Request[chatv1.GetClientStateRequest]) (*connect.Response[chatv1.GetClientStateResponse], error) {
	fake.getClientStateMutex.Lock()
	ret, specificReturn := fake.getClientStateReturnsOnCall[len(fake.getClientStateArgsForCall)]
	fake.getClientStateArgsForCall = append(fake.getClientStateArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.GetClientStateRequest]
	}{arg1, arg2})
	stub := fake.GetClientStateStub
	fakeReturns := fake.getClientStateReturns
	fake.recordInvocation("GetClientState", []interface{}{arg1, arg2})
	fake.getClientStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) GetClientStateCallCount() int {
	fake.getClientStateMutex.RLock()
	defer fake.getClientStateMutex.RUnlock()
	return len(fake.getClientStateArgsForCall)
}

func (fake *FakeChatServiceHandler) GetClientStateCalls(stub func(context.Context, *connect.Request[chatv1.GetClientStateRequest]) (*connect.Response[chatv1.GetClientStateResponse], error)) {
	fake.getClientStateMutex.Lock()
	defer fake.getClientStateMutex.Unlock()
	fake.GetClientStateStub = stub
}

func (fake *FakeChatServiceHandler) GetClientStateArgsForCall(i int) (context.Context, *connect.Request[chatv1.GetClientStateRequest]) {
	fake.getClientStateMutex.RLock()
	defer fake.getClientStateMutex.RUnlock()
	argsForCall := fake.getClientStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) GetClientStateReturns(result1 *connect.Response[chatv1.GetClientStateResponse], result2 error) {
	fake.getClientStateMutex.Lock()
	defer fake.getClientStateMutex.Unlock()
	fake.GetClientStateStub = nil
	fake.getClientStateReturns = struct {
		result1 *connect.Response[chatv1.GetClientStateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) GetClientStateReturnsOnCall(i int, result1 *connect.Response[chatv1.GetClientStateResponse], result2 error) {
	fake.getClientStateMutex.Lock()
	defer fake.getClientStateMutex.Unlock()
	fake.GetClientStateStub = nil
	if fake.getClientStateReturnsOnCall == nil {
		fake.getClientStateReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.GetClientStateResponse]
			result2 error
		})
	}
	fake.getClientStateReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.GetClientStateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) GetHistory(arg1 context.Context, arg2 *connect.Request[chatv1.GetHistoryRequest]) (*connect.Response[chatv1.GetHistoryResponse], error) {
	fake.getHistoryMutex.Lock()
	ret, specificReturn := fake.getHistoryReturnsOnCall[len(fake.getHistoryArgsForCall)]
	fake.getHistoryArgsForCall = append(fake.getHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.GetHistoryRequest]
	}{arg1, arg2})
	stub := fake.GetHistoryStub
	fakeReturns := fake.getHistoryReturns
	fake.recordInvocation("GetHistory", []interface{}{arg1, arg2})
	fake.getHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) GetHistoryCallCount() int {
	fake.getHistoryMutex.RLock()
	defer fake.getHistoryMutex.RUnlock()
	return len(fake.getHistoryArgsForCall)
}

func (fake *FakeChatServiceHandler) GetHistoryCalls(stub func(context.Context, *connect.Request[chatv1.GetHistoryRequest]) (*connect.Response[chatv1.GetHistoryResponse], error)) {
	fake.getHistoryMutex.Lock()
	defer fake.getHistoryMutex.Unlock()
	fake.GetHistoryStub = stub
}

func (fake *FakeChatServiceHandler) GetHistoryArgsForCall(i int) (context.Context, *connect.Request[chatv1.GetHistoryRequest]) {
	fake.getHistoryMutex.RLock()
	defer fake.getHistoryMutex.RUnlock()
	argsForCall := fake.getHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) GetHistoryReturns(result1 *connect.Response[chatv1.GetHistoryResponse], result2 error) {
	fake.getHistoryMutex.Lock()
	defer fake.getHistoryMutex.Unlock()
	fake.GetHistoryStub = nil
	fake.getHistoryReturns = struct {
		result1 *connect.Response[chatv1.GetHistoryResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) GetHistoryReturnsOnCall(i int, result1 *connect.Response[chatv1.GetHistoryResponse], result2 error) {
	fake.getHistoryMutex.Lock()
	defer fake.getHistoryMutex.Unlock()
	fake.GetHistoryStub = nil
	if fake.getHistoryReturnsOnCall == nil {
		fake.getHistoryReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.GetHistoryResponse]
			result2 error
		})
	}
	fake.getHistoryReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.GetHistoryResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) RemoveRoomSubscriptions(arg1 context.Context, arg2 *connect.Request[chatv1.RemoveRoomSubscriptionsRequest]) (*connect.Response[chatv1.RemoveRoomSubscriptionsResponse], error) {
	fake.removeRoomSubscriptionsMutex.Lock()
	ret, specificReturn := fake.removeRoomSubscriptionsReturnsOnCall[len(fake.removeRoomSubscriptionsArgsForCall)]
	fake.removeRoomSubscriptionsArgsForCall = append(fake.removeRoomSubscriptionsArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.RemoveRoomSubscriptionsRequest]
	}{arg1, arg2})
	stub := fake.RemoveRoomSubscriptionsStub
	fakeReturns := fake.removeRoomSubscriptionsReturns
	fake.recordInvocation("RemoveRoomSubscriptions", []interface{}{arg1, arg2})
	fake.removeRoomSubscriptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) RemoveRoomSubscriptionsCallCount() int {
	fake.removeRoomSubscriptionsMutex.RLock()
	defer fake.removeRoomSubscriptionsMutex.RUnlock()
	return len(fake.removeRoomSubscriptionsArgsForCall)
}

func (fake *FakeChatServiceHandler) RemoveRoomSubscriptionsCalls(stub func(context.Context, *connect.Request[chatv1.RemoveRoomSubscriptionsRequest]) (*connect.Response[chatv1.RemoveRoomSubscriptionsResponse], error)) {
	fake.removeRoomSubscriptionsMutex.Lock()
	defer fake.removeRoomSubscriptionsMutex.Unlock()
	fake.RemoveRoomSubscriptionsStub = stub
}

func (fake *FakeChatServiceHandler) RemoveRoomSubscriptionsArgsForCall(i int) (context.Context, *connect.Request[chatv1.RemoveRoomSubscriptionsRequest]) {
	fake.removeRoomSubscriptionsMutex.RLock()
	defer fake.removeRoomSubscriptionsMutex.RUnlock()
	argsForCall := fake.removeRoomSubscriptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) RemoveRoomSubscriptionsReturns(result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse], result2 error) {
	fake.removeRoomSubscriptionsMutex.Lock()
	defer fake.removeRoomSubscriptionsMutex.Unlock()
	fake.RemoveRoomSubscriptionsStub = nil
	fake.removeRoomSubscriptionsReturns = struct {
		result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) RemoveRoomSubscriptionsReturnsOnCall(i int, result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse], result2 error) {
	fake.removeRoomSubscriptionsMutex.Lock()
	defer fake.removeRoomSubscriptionsMutex.Unlock()
	fake.RemoveRoomSubscriptionsStub = nil
	if fake.removeRoomSubscriptionsReturnsOnCall == nil {
		fake.removeRoomSubscriptionsReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse]
			result2 error
		})
	}
	fake.removeRoomSubscriptionsReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.RemoveRoomSubscriptionsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) SearchRoomSubscriptions(arg1 context.Context, arg2 *connect.Request[chatv1.SearchRoomSubscriptionsRequest]) (*connect.Response[chatv1.SearchRoomSubscriptionsResponse], error) {
	fake.searchRoomSubscriptionsMutex.Lock()
	ret, specificReturn := fake.searchRoomSubscriptionsReturnsOnCall[len(fake.searchRoomSubscriptionsArgsForCall)]
	fake.searchRoomSubscriptionsArgsForCall = append(fake.searchRoomSubscriptionsArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.SearchRoomSubscriptionsRequest]
	}{arg1, arg2})
	stub := fake.SearchRoomSubscriptionsStub
	fakeReturns := fake.searchRoomSubscriptionsReturns
	fake.recordInvocation("SearchRoomSubscriptions", []interface{}{arg1, arg2})
	fake.searchRoomSubscriptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) SearchRoomSubscriptionsCallCount() int {
	fake.searchRoomSubscriptionsMutex.RLock()
	defer fake.searchRoomSubscriptionsMutex.RUnlock()
	return len(fake.searchRoomSubscriptionsArgsForCall)
}

func (fake *FakeChatServiceHandler) SearchRoomSubscriptionsCalls(stub func(context.Context, *connect.Request[chatv1.SearchRoomSubscriptionsRequest]) (*connect.Response[chatv1.SearchRoomSubscriptionsResponse], error)) {
	fake.searchRoomSubscriptionsMutex.Lock()
	defer fake.searchRoomSubscriptionsMutex.Unlock()
	fake.SearchRoomSubscriptionsStub = stub
}

func (fake *FakeChatServiceHandler) SearchRoomSubscriptionsArgsForCall(i int) (context.Context, *connect.Request[chatv1.SearchRoomSubscriptionsRequest]) {
	fake.searchRoomSubscriptionsMutex.RLock()
	defer fake.searchRoomSubscriptionsMutex.RUnlock()
	argsForCall := fake.searchRoomSubscriptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) SearchRoomSubscriptionsReturns(result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse], result2 error) {
	fake.searchRoomSubscriptionsMutex.Lock()
	defer fake.searchRoomSubscriptionsMutex.Unlock()
	fake.SearchRoomSubscriptionsStub = nil
	fake.searchRoomSubscriptionsReturns = struct {
		result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) SearchRoomSubscriptionsReturnsOnCall(i int, result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse], result2 error) {
	fake.searchRoomSubscriptionsMutex.Lock()
	defer fake.searchRoomSubscriptionsMutex.Unlock()
	fake.SearchRoomSubscriptionsStub = nil
	if fake.searchRoomSubscriptionsReturnsOnCall == nil {
		fake.searchRoomSubscriptionsReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse]
			result2 error
		})
	}
	fake.searchRoomSubscriptionsReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.SearchRoomSubscriptionsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) SearchRooms(arg1 context.Context, arg2 *connect.Request[chatv1.SearchRoomsRequest], arg3 *connect.ServerStream[chatv1.SearchRoomsResponse]) error {
	fake.searchRoomsMutex.Lock()
	ret, specificReturn := fake.searchRoomsReturnsOnCall[len(fake.searchRoomsArgsForCall)]
	fake.searchRoomsArgsForCall = append(fake.searchRoomsArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.SearchRoomsRequest]
		arg3 *connect.ServerStream[chatv1.SearchRoomsResponse]
	}{arg1, arg2, arg3})
	stub := fake.SearchRoomsStub
	fakeReturns := fake.searchRoomsReturns
	fake.recordInvocation("SearchRooms", []interface{}{arg1, arg2, arg3})
	fake.searchRoomsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeChatServiceHandler) SearchRoomsCallCount() int {
	fake.searchRoomsMutex.RLock()
	defer fake.searchRoomsMutex.RUnlock()
	return len(fake.searchRoomsArgsForCall)
}

func (fake *FakeChatServiceHandler) SearchRoomsCalls(stub func(context.Context, *connect.Request[chatv1.SearchRoomsRequest], *connect.ServerStream[chatv1.SearchRoomsResponse]) error) {
	fake.searchRoomsMutex.Lock()
	defer fake.searchRoomsMutex.Unlock()
	fake.SearchRoomsStub = stub
}

func (fake *FakeChatServiceHandler) SearchRoomsArgsForCall(i int) (context.Context, *connect.Request[chatv1.SearchRoomsRequest], *connect.ServerStream[chatv1.SearchRoomsResponse]) {
	fake.searchRoomsMutex.RLock()
	defer fake.searchRoomsMutex.RUnlock()
	argsForCall := fake.searchRoomsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeChatServiceHandler) SearchRoomsReturns(result1 error) {
	fake.searchRoomsMutex.Lock()
	defer fake.searchRoomsMutex.Unlock()
	fake.SearchRoomsStub = nil
	fake.searchRoomsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeChatServiceHandler) SearchRoomsReturnsOnCall(i int, result1 error) {
	fake.searchRoomsMutex.Lock()
	defer fake.searchRoomsMutex.Unlock()
	fake.SearchRoomsStub = nil
	if fake.searchRoomsReturnsOnCall == nil {
		fake.searchRoomsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.searchRoomsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeChatServiceHandler) SendEvent(arg1 context.Context, arg2 *connect.Request[chatv1.SendEventRequest]) (*connect.Response[chatv1.SendEventResponse], error) {
	fake.sendEventMutex.Lock()
	ret, specificReturn := fake.sendEventReturnsOnCall[len(fake.sendEventArgsForCall)]
	fake.sendEventArgsForCall = append(fake.sendEventArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.SendEventRequest]
	}{arg1, arg2})
	stub := fake.SendEventStub
	fakeReturns := fake.sendEventReturns
	fake.recordInvocation("SendEvent", []interface{}{arg1, arg2})
	fake.sendEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) SendEventCallCount() int {
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	return len(fake.sendEventArgsForCall)
}

func (fake *FakeChatServiceHandler) SendEventCalls(stub func(context.Context, *connect.Request[chatv1.SendEventRequest]) (*connect.Response[chatv1.SendEventResponse], error)) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = stub
}

func (fake *FakeChatServiceHandler) SendEventArgsForCall(i int) (context.Context, *connect.Request[chatv1.SendEventRequest]) {
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	argsForCall := fake.sendEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) SendEventReturns(result1 *connect.Response[chatv1.SendEventResponse], result2 error) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = nil
	fake.sendEventReturns = struct {
		result1 *connect.Response[chatv1.SendEventResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) SendEventReturnsOnCall(i int, result1 *connect.Response[chatv1.SendEventResponse], result2 error) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = nil
	if fake.sendEventReturnsOnCall == nil {
		fake.sendEventReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.SendEventResponse]
			result2 error
		})
	}
	fake.sendEventReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.SendEventResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) UpdateClientState(arg1 context.Context, arg2 *connect.Request[chatv1.UpdateClientStateRequest]) (*connect.Response[chatv1.UpdateClientStateResponse], error) {
	fake.updateClientStateMutex.Lock()
	ret, specificReturn := fake.updateClientStateReturnsOnCall[len(fake.updateClientStateArgsForCall)]
	fake.updateClientStateArgsForCall = append(fake.updateClientStateArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.UpdateClientStateRequest]
	}{arg1, arg2})
	stub := fake.UpdateClientStateStub
	fakeReturns := fake.updateClientStateReturns
	fake.recordInvocation("UpdateClientState", []interface{}{arg1, arg2})
	fake.updateClientStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) UpdateClientStateCallCount() int {
	fake.updateClientStateMutex.RLock()
	defer fake.updateClientStateMutex.RUnlock()
	return len(fake.updateClientStateArgsForCall)
}

func (fake *FakeChatServiceHandler) UpdateClientStateCalls(stub func(context.Context, *connect.Request[chatv1.UpdateClientStateRequest]) (*connect.Response[chatv1.UpdateClientStateResponse], error)) {
	fake.updateClientStateMutex.Lock()
	defer fake.updateClientStateMutex.Unlock()
	fake.UpdateClientStateStub = stub
}

func (fake *FakeChatServiceHandler) UpdateClientStateArgsForCall(i int) (context.Context, *connect.Request[chatv1.UpdateClientStateRequest]) {
	fake.updateClientStateMutex.RLock()
	defer fake.updateClientStateMutex.RUnlock()
	argsForCall := fake.updateClientStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) UpdateClientStateReturns(result1 *connect.Response[chatv1.UpdateClientStateResponse], result2 error) {
	fake.updateClientStateMutex.Lock()
	defer fake.updateClientStateMutex.Unlock()
	fake.UpdateClientStateStub = nil
	fake.updateClientStateReturns = struct {
		result1 *connect.Response[chatv1.UpdateClientStateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) UpdateClientStateReturnsOnCall(i int, result1 *connect.Response[chatv1.UpdateClientStateResponse], result2 error) {
	fake.updateClientStateMutex.Lock()
	defer fake.updateClientStateMutex.Unlock()
	fake.UpdateClientStateStub = nil
	if fake.updateClientStateReturnsOnCall == nil {
		fake.updateClientStateReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.UpdateClientStateResponse]
			result2 error
		})
	}
	fake.updateClientStateReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.UpdateClientStateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) UpdateRoom(arg1 context.Context, arg2 *connect.Request[chatv1.UpdateRoomRequest]) (*connect.Response[chatv1.UpdateRoomResponse], error) {
	fake.updateRoomMutex.Lock()
	ret, specificReturn := fake.updateRoomReturnsOnCall[len(fake.updateRoomArgsForCall)]
	fake.updateRoomArgsForCall = append(fake.updateRoomArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.UpdateRoomRequest]
	}{arg1, arg2})
	stub := fake.UpdateRoomStub
	fakeReturns := fake.updateRoomReturns
	fake.recordInvocation("UpdateRoom", []interface{}{arg1, arg2})
	fake.updateRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) UpdateRoomCallCount() int {
	fake.updateRoomMutex.RLock()
	defer fake.updateRoomMutex.RUnlock()
	return len(fake.updateRoomArgsForCall)
}

func (fake *FakeChatServiceHandler) UpdateRoomCalls(stub func(context.Context, *connect.Request[chatv1.UpdateRoomRequest]) (*connect.Response[chatv1.UpdateRoomResponse], error)) {
	fake.updateRoomMutex.Lock()
	defer fake.updateRoomMutex.Unlock()
	fake.UpdateRoomStub = stub
}

func (fake *FakeChatServiceHandler) UpdateRoomArgsForCall(i int) (context.Context, *connect.Request[chatv1.UpdateRoomRequest]) {
	fake.updateRoomMutex.RLock()
	defer fake.updateRoomMutex.RUnlock()
	argsForCall := fake.updateRoomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) UpdateRoomReturns(result1 *connect.Response[chatv1.UpdateRoomResponse], result2 error) {
	fake.updateRoomMutex.Lock()
	defer fake.updateRoomMutex.Unlock()
	fake.UpdateRoomStub = nil
	fake.updateRoomReturns = struct {
		result1 *connect.Response[chatv1.UpdateRoomResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) UpdateRoomReturnsOnCall(i int, result1 *connect.Response[chatv1.UpdateRoomResponse], result2 error) {
	fake.updateRoomMutex.Lock()
	defer fake.updateRoomMutex.Unlock()
	fake.UpdateRoomStub = nil
	if fake.updateRoomReturnsOnCall == nil {
		fake.updateRoomReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.UpdateRoomResponse]
			result2 error
		})
	}
	fake.updateRoomReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.UpdateRoomResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) UpdateSubscriptionRole(arg1 context.Context, arg2 *connect.Request[chatv1.UpdateSubscriptionRoleRequest]) (*connect.Response[chatv1.UpdateSubscriptionRoleResponse], error) {
	fake.updateSubscriptionRoleMutex.Lock()
	ret, specificReturn := fake.updateSubscriptionRoleReturnsOnCall[len(fake.updateSubscriptionRoleArgsForCall)]
	fake.updateSubscriptionRoleArgsForCall = append(fake.updateSubscriptionRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[chatv1.UpdateSubscriptionRoleRequest]
	}{arg1, arg2})
	stub := fake.UpdateSubscriptionRoleStub
	fakeReturns := fake.updateSubscriptionRoleReturns
	fake.recordInvocation("UpdateSubscriptionRole", []interface{}{arg1, arg2})
	fake.updateSubscriptionRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeChatServiceHandler) UpdateSubscriptionRoleCallCount() int {
	fake.updateSubscriptionRoleMutex.RLock()
	defer fake.updateSubscriptionRoleMutex.RUnlock()
	return len(fake.updateSubscriptionRoleArgsForCall)
}

func (fake *FakeChatServiceHandler) UpdateSubscriptionRoleCalls(stub func(context.Context, *connect.Request[chatv1.UpdateSubscriptionRoleRequest]) (*connect.Response[chatv1.UpdateSubscriptionRoleResponse], error)) {
	fake.updateSubscriptionRoleMutex.Lock()
	defer fake.updateSubscriptionRoleMutex.Unlock()
	fake.UpdateSubscriptionRoleStub = stub
}

func (fake *FakeChatServiceHandler) UpdateSubscriptionRoleArgsForCall(i int) (context.Context, *connect.Request[chatv1.UpdateSubscriptionRoleRequest]) {
	fake.updateSubscriptionRoleMutex.RLock()
	defer fake.updateSubscriptionRoleMutex.RUnlock()
	argsForCall := fake.updateSubscriptionRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeChatServiceHandler) UpdateSubscriptionRoleReturns(result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse], result2 error) {
	fake.updateSubscriptionRoleMutex.Lock()
	defer fake.updateSubscriptionRoleMutex.Unlock()
	fake.UpdateSubscriptionRoleStub = nil
	fake.updateSubscriptionRoleReturns = struct {
		result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) UpdateSubscriptionRoleReturnsOnCall(i int, result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse], result2 error) {
	fake.updateSubscriptionRoleMutex.Lock()
	defer fake.updateSubscriptionRoleMutex.Unlock()
	fake.UpdateSubscriptionRoleStub = nil
	if fake.updateSubscriptionRoleReturnsOnCall == nil {
		fake.updateSubscriptionRoleReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse]
			result2 error
		})
	}
	fake.updateSubscriptionRoleReturnsOnCall[i] = struct {
		result1 *connect.Response[chatv1.UpdateSubscriptionRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeChatServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeChatServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ chatv1connect.ChatServiceHandler = new(FakeChatServiceHandler)
