// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/files/connectrpc/go/files/v1/filesv1connect.FilesServiceClient -o files_handler.gen.go -n FilesServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/files/protocolbuffers/go/files/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// FilesServiceClientMock implements mm_filesv1connect.FilesServiceClient
type FilesServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateContent          func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) (pp2 *connect.Response[v1.CreateContentResponse], err error)
	funcCreateContentOrigin    string
	inspectFuncCreateContent   func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest])
	afterCreateContentCounter  uint64
	beforeCreateContentCounter uint64
	CreateContentMock          mFilesServiceClientMockCreateContent

	funcGetConfig          func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) (pp2 *connect.Response[v1.GetConfigResponse], err error)
	funcGetConfigOrigin    string
	inspectFuncGetConfig   func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest])
	afterGetConfigCounter  uint64
	beforeGetConfigCounter uint64
	GetConfigMock          mFilesServiceClientMockGetConfig

	funcGetContent          func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) (pp2 *connect.Response[v1.GetContentResponse], err error)
	funcGetContentOrigin    string
	inspectFuncGetContent   func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest])
	afterGetContentCounter  uint64
	beforeGetContentCounter uint64
	GetContentMock          mFilesServiceClientMockGetContent

	funcGetContentOverrideName          func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) (pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error)
	funcGetContentOverrideNameOrigin    string
	inspectFuncGetContentOverrideName   func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest])
	afterGetContentOverrideNameCounter  uint64
	beforeGetContentOverrideNameCounter uint64
	GetContentOverrideNameMock          mFilesServiceClientMockGetContentOverrideName

	funcGetContentThumbnail          func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) (pp2 *connect.Response[v1.GetContentThumbnailResponse], err error)
	funcGetContentThumbnailOrigin    string
	inspectFuncGetContentThumbnail   func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest])
	afterGetContentThumbnailCounter  uint64
	beforeGetContentThumbnailCounter uint64
	GetContentThumbnailMock          mFilesServiceClientMockGetContentThumbnail

	funcGetUrlPreview          func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) (pp2 *connect.Response[v1.GetUrlPreviewResponse], err error)
	funcGetUrlPreviewOrigin    string
	inspectFuncGetUrlPreview   func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest])
	afterGetUrlPreviewCounter  uint64
	beforeGetUrlPreviewCounter uint64
	GetUrlPreviewMock          mFilesServiceClientMockGetUrlPreview

	funcSearchMedia          func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) (pp2 *connect.Response[v1.SearchMediaResponse], err error)
	funcSearchMediaOrigin    string
	inspectFuncSearchMedia   func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest])
	afterSearchMediaCounter  uint64
	beforeSearchMediaCounter uint64
	SearchMediaMock          mFilesServiceClientMockSearchMedia

	funcUploadContent          func(ctx context.Context) (pp1 *connect.ClientStreamForClient[v1.UploadContentRequest, v1.UploadContentResponse])
	funcUploadContentOrigin    string
	inspectFuncUploadContent   func(ctx context.Context)
	afterUploadContentCounter  uint64
	beforeUploadContentCounter uint64
	UploadContentMock          mFilesServiceClientMockUploadContent
}

// NewFilesServiceClientMock returns a mock for mm_filesv1connect.FilesServiceClient
func NewFilesServiceClientMock(t minimock.Tester) *FilesServiceClientMock {
	m := &FilesServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateContentMock = mFilesServiceClientMockCreateContent{mock: m}
	m.CreateContentMock.callArgs = []*FilesServiceClientMockCreateContentParams{}

	m.GetConfigMock = mFilesServiceClientMockGetConfig{mock: m}
	m.GetConfigMock.callArgs = []*FilesServiceClientMockGetConfigParams{}

	m.GetContentMock = mFilesServiceClientMockGetContent{mock: m}
	m.GetContentMock.callArgs = []*FilesServiceClientMockGetContentParams{}

	m.GetContentOverrideNameMock = mFilesServiceClientMockGetContentOverrideName{mock: m}
	m.GetContentOverrideNameMock.callArgs = []*FilesServiceClientMockGetContentOverrideNameParams{}

	m.GetContentThumbnailMock = mFilesServiceClientMockGetContentThumbnail{mock: m}
	m.GetContentThumbnailMock.callArgs = []*FilesServiceClientMockGetContentThumbnailParams{}

	m.GetUrlPreviewMock = mFilesServiceClientMockGetUrlPreview{mock: m}
	m.GetUrlPreviewMock.callArgs = []*FilesServiceClientMockGetUrlPreviewParams{}

	m.SearchMediaMock = mFilesServiceClientMockSearchMedia{mock: m}
	m.SearchMediaMock.callArgs = []*FilesServiceClientMockSearchMediaParams{}

	m.UploadContentMock = mFilesServiceClientMockUploadContent{mock: m}
	m.UploadContentMock.callArgs = []*FilesServiceClientMockUploadContentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFilesServiceClientMockCreateContent struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockCreateContentExpectation
	expectations       []*FilesServiceClientMockCreateContentExpectation

	callArgs []*FilesServiceClientMockCreateContentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockCreateContentExpectation specifies expectation struct of the FilesServiceClient.CreateContent
type FilesServiceClientMockCreateContentExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockCreateContentParams
	paramPtrs          *FilesServiceClientMockCreateContentParamPtrs
	expectationOrigins FilesServiceClientMockCreateContentExpectationOrigins
	results            *FilesServiceClientMockCreateContentResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockCreateContentParams contains parameters of the FilesServiceClient.CreateContent
type FilesServiceClientMockCreateContentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateContentRequest]
}

// FilesServiceClientMockCreateContentParamPtrs contains pointers to parameters of the FilesServiceClient.CreateContent
type FilesServiceClientMockCreateContentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateContentRequest]
}

// FilesServiceClientMockCreateContentResults contains results of the FilesServiceClient.CreateContent
type FilesServiceClientMockCreateContentResults struct {
	pp2 *connect.Response[v1.CreateContentResponse]
	err error
}

// FilesServiceClientMockCreateContentOrigins contains origins of expectations of the FilesServiceClient.CreateContent
type FilesServiceClientMockCreateContentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateContent *mFilesServiceClientMockCreateContent) Optional() *mFilesServiceClientMockCreateContent {
	mmCreateContent.optional = true
	return mmCreateContent
}

// Expect sets up expected params for FilesServiceClient.CreateContent
func (mmCreateContent *mFilesServiceClientMockCreateContent) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) *mFilesServiceClientMockCreateContent {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceClientMockCreateContentExpectation{}
	}

	if mmCreateContent.defaultExpectation.paramPtrs != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by ExpectParams functions")
	}

	mmCreateContent.defaultExpectation.params = &FilesServiceClientMockCreateContentParams{ctx, pp1}
	mmCreateContent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateContent.expectations {
		if minimock.Equal(e.params, mmCreateContent.defaultExpectation.params) {
			mmCreateContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateContent.defaultExpectation.params)
		}
	}

	return mmCreateContent
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.CreateContent
func (mmCreateContent *mFilesServiceClientMockCreateContent) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockCreateContent {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceClientMockCreateContentExpectation{}
	}

	if mmCreateContent.defaultExpectation.params != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Expect")
	}

	if mmCreateContent.defaultExpectation.paramPtrs == nil {
		mmCreateContent.defaultExpectation.paramPtrs = &FilesServiceClientMockCreateContentParamPtrs{}
	}
	mmCreateContent.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateContent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateContent
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.CreateContent
func (mmCreateContent *mFilesServiceClientMockCreateContent) ExpectPp1Param2(pp1 *connect.Request[v1.CreateContentRequest]) *mFilesServiceClientMockCreateContent {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceClientMockCreateContentExpectation{}
	}

	if mmCreateContent.defaultExpectation.params != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Expect")
	}

	if mmCreateContent.defaultExpectation.paramPtrs == nil {
		mmCreateContent.defaultExpectation.paramPtrs = &FilesServiceClientMockCreateContentParamPtrs{}
	}
	mmCreateContent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateContent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateContent
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.CreateContent
func (mmCreateContent *mFilesServiceClientMockCreateContent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest])) *mFilesServiceClientMockCreateContent {
	if mmCreateContent.mock.inspectFuncCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.CreateContent")
	}

	mmCreateContent.mock.inspectFuncCreateContent = f

	return mmCreateContent
}

// Return sets up results that will be returned by FilesServiceClient.CreateContent
func (mmCreateContent *mFilesServiceClientMockCreateContent) Return(pp2 *connect.Response[v1.CreateContentResponse], err error) *FilesServiceClientMock {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceClientMockCreateContentExpectation{mock: mmCreateContent.mock}
	}
	mmCreateContent.defaultExpectation.results = &FilesServiceClientMockCreateContentResults{pp2, err}
	mmCreateContent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateContent.mock
}

// Set uses given function f to mock the FilesServiceClient.CreateContent method
func (mmCreateContent *mFilesServiceClientMockCreateContent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) (pp2 *connect.Response[v1.CreateContentResponse], err error)) *FilesServiceClientMock {
	if mmCreateContent.defaultExpectation != nil {
		mmCreateContent.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.CreateContent method")
	}

	if len(mmCreateContent.expectations) > 0 {
		mmCreateContent.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.CreateContent method")
	}

	mmCreateContent.mock.funcCreateContent = f
	mmCreateContent.mock.funcCreateContentOrigin = minimock.CallerInfo(1)
	return mmCreateContent.mock
}

// When sets expectation for the FilesServiceClient.CreateContent which will trigger the result defined by the following
// Then helper
func (mmCreateContent *mFilesServiceClientMockCreateContent) When(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) *FilesServiceClientMockCreateContentExpectation {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceClientMock.CreateContent mock is already set by Set")
	}

	expectation := &FilesServiceClientMockCreateContentExpectation{
		mock:               mmCreateContent.mock,
		params:             &FilesServiceClientMockCreateContentParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockCreateContentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateContent.expectations = append(mmCreateContent.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.CreateContent return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockCreateContentExpectation) Then(pp2 *connect.Response[v1.CreateContentResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockCreateContentResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.CreateContent should be invoked
func (mmCreateContent *mFilesServiceClientMockCreateContent) Times(n uint64) *mFilesServiceClientMockCreateContent {
	if n == 0 {
		mmCreateContent.mock.t.Fatalf("Times of FilesServiceClientMock.CreateContent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateContent.expectedInvocations, n)
	mmCreateContent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateContent
}

func (mmCreateContent *mFilesServiceClientMockCreateContent) invocationsDone() bool {
	if len(mmCreateContent.expectations) == 0 && mmCreateContent.defaultExpectation == nil && mmCreateContent.mock.funcCreateContent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateContent.mock.afterCreateContentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateContent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateContent implements mm_filesv1connect.FilesServiceClient
func (mmCreateContent *FilesServiceClientMock) CreateContent(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) (pp2 *connect.Response[v1.CreateContentResponse], err error) {
	mm_atomic.AddUint64(&mmCreateContent.beforeCreateContentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateContent.afterCreateContentCounter, 1)

	mmCreateContent.t.Helper()

	if mmCreateContent.inspectFuncCreateContent != nil {
		mmCreateContent.inspectFuncCreateContent(ctx, pp1)
	}

	mm_params := FilesServiceClientMockCreateContentParams{ctx, pp1}

	// Record call args
	mmCreateContent.CreateContentMock.mutex.Lock()
	mmCreateContent.CreateContentMock.callArgs = append(mmCreateContent.CreateContentMock.callArgs, &mm_params)
	mmCreateContent.CreateContentMock.mutex.Unlock()

	for _, e := range mmCreateContent.CreateContentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateContent.CreateContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateContent.CreateContentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateContent.CreateContentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateContent.CreateContentMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockCreateContentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateContent.t.Errorf("FilesServiceClientMock.CreateContent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateContent.CreateContentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateContent.t.Errorf("FilesServiceClientMock.CreateContent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateContent.CreateContentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateContent.t.Errorf("FilesServiceClientMock.CreateContent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateContent.CreateContentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateContent.CreateContentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateContent.t.Fatal("No results are set for the FilesServiceClientMock.CreateContent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateContent.funcCreateContent != nil {
		return mmCreateContent.funcCreateContent(ctx, pp1)
	}
	mmCreateContent.t.Fatalf("Unexpected call to FilesServiceClientMock.CreateContent. %v %v", ctx, pp1)
	return
}

// CreateContentAfterCounter returns a count of finished FilesServiceClientMock.CreateContent invocations
func (mmCreateContent *FilesServiceClientMock) CreateContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateContent.afterCreateContentCounter)
}

// CreateContentBeforeCounter returns a count of FilesServiceClientMock.CreateContent invocations
func (mmCreateContent *FilesServiceClientMock) CreateContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateContent.beforeCreateContentCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.CreateContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateContent *mFilesServiceClientMockCreateContent) Calls() []*FilesServiceClientMockCreateContentParams {
	mmCreateContent.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockCreateContentParams, len(mmCreateContent.callArgs))
	copy(argCopy, mmCreateContent.callArgs)

	mmCreateContent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateContentDone returns true if the count of the CreateContent invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockCreateContentDone() bool {
	if m.CreateContentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateContentMock.invocationsDone()
}

// MinimockCreateContentInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockCreateContentInspect() {
	for _, e := range m.CreateContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.CreateContent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateContentCounter := mm_atomic.LoadUint64(&m.afterCreateContentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateContentMock.defaultExpectation != nil && afterCreateContentCounter < 1 {
		if m.CreateContentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.CreateContent at\n%s", m.CreateContentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.CreateContent at\n%s with params: %#v", m.CreateContentMock.defaultExpectation.expectationOrigins.origin, *m.CreateContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateContent != nil && afterCreateContentCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.CreateContent at\n%s", m.funcCreateContentOrigin)
	}

	if !m.CreateContentMock.invocationsDone() && afterCreateContentCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.CreateContent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateContentMock.expectedInvocations), m.CreateContentMock.expectedInvocationsOrigin, afterCreateContentCounter)
	}
}

type mFilesServiceClientMockGetConfig struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockGetConfigExpectation
	expectations       []*FilesServiceClientMockGetConfigExpectation

	callArgs []*FilesServiceClientMockGetConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockGetConfigExpectation specifies expectation struct of the FilesServiceClient.GetConfig
type FilesServiceClientMockGetConfigExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockGetConfigParams
	paramPtrs          *FilesServiceClientMockGetConfigParamPtrs
	expectationOrigins FilesServiceClientMockGetConfigExpectationOrigins
	results            *FilesServiceClientMockGetConfigResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockGetConfigParams contains parameters of the FilesServiceClient.GetConfig
type FilesServiceClientMockGetConfigParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetConfigRequest]
}

// FilesServiceClientMockGetConfigParamPtrs contains pointers to parameters of the FilesServiceClient.GetConfig
type FilesServiceClientMockGetConfigParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetConfigRequest]
}

// FilesServiceClientMockGetConfigResults contains results of the FilesServiceClient.GetConfig
type FilesServiceClientMockGetConfigResults struct {
	pp2 *connect.Response[v1.GetConfigResponse]
	err error
}

// FilesServiceClientMockGetConfigOrigins contains origins of expectations of the FilesServiceClient.GetConfig
type FilesServiceClientMockGetConfigExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConfig *mFilesServiceClientMockGetConfig) Optional() *mFilesServiceClientMockGetConfig {
	mmGetConfig.optional = true
	return mmGetConfig
}

// Expect sets up expected params for FilesServiceClient.GetConfig
func (mmGetConfig *mFilesServiceClientMockGetConfig) Expect(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) *mFilesServiceClientMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceClientMockGetConfigExpectation{}
	}

	if mmGetConfig.defaultExpectation.paramPtrs != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by ExpectParams functions")
	}

	mmGetConfig.defaultExpectation.params = &FilesServiceClientMockGetConfigParams{ctx, pp1}
	mmGetConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConfig.expectations {
		if minimock.Equal(e.params, mmGetConfig.defaultExpectation.params) {
			mmGetConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConfig.defaultExpectation.params)
		}
	}

	return mmGetConfig
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.GetConfig
func (mmGetConfig *mFilesServiceClientMockGetConfig) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceClientMockGetConfigExpectation{}
	}

	if mmGetConfig.defaultExpectation.params != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Expect")
	}

	if mmGetConfig.defaultExpectation.paramPtrs == nil {
		mmGetConfig.defaultExpectation.paramPtrs = &FilesServiceClientMockGetConfigParamPtrs{}
	}
	mmGetConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConfig
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.GetConfig
func (mmGetConfig *mFilesServiceClientMockGetConfig) ExpectPp1Param2(pp1 *connect.Request[v1.GetConfigRequest]) *mFilesServiceClientMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceClientMockGetConfigExpectation{}
	}

	if mmGetConfig.defaultExpectation.params != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Expect")
	}

	if mmGetConfig.defaultExpectation.paramPtrs == nil {
		mmGetConfig.defaultExpectation.paramPtrs = &FilesServiceClientMockGetConfigParamPtrs{}
	}
	mmGetConfig.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetConfig.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetConfig
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.GetConfig
func (mmGetConfig *mFilesServiceClientMockGetConfig) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest])) *mFilesServiceClientMockGetConfig {
	if mmGetConfig.mock.inspectFuncGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.GetConfig")
	}

	mmGetConfig.mock.inspectFuncGetConfig = f

	return mmGetConfig
}

// Return sets up results that will be returned by FilesServiceClient.GetConfig
func (mmGetConfig *mFilesServiceClientMockGetConfig) Return(pp2 *connect.Response[v1.GetConfigResponse], err error) *FilesServiceClientMock {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceClientMockGetConfigExpectation{mock: mmGetConfig.mock}
	}
	mmGetConfig.defaultExpectation.results = &FilesServiceClientMockGetConfigResults{pp2, err}
	mmGetConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConfig.mock
}

// Set uses given function f to mock the FilesServiceClient.GetConfig method
func (mmGetConfig *mFilesServiceClientMockGetConfig) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) (pp2 *connect.Response[v1.GetConfigResponse], err error)) *FilesServiceClientMock {
	if mmGetConfig.defaultExpectation != nil {
		mmGetConfig.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.GetConfig method")
	}

	if len(mmGetConfig.expectations) > 0 {
		mmGetConfig.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.GetConfig method")
	}

	mmGetConfig.mock.funcGetConfig = f
	mmGetConfig.mock.funcGetConfigOrigin = minimock.CallerInfo(1)
	return mmGetConfig.mock
}

// When sets expectation for the FilesServiceClient.GetConfig which will trigger the result defined by the following
// Then helper
func (mmGetConfig *mFilesServiceClientMockGetConfig) When(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) *FilesServiceClientMockGetConfigExpectation {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceClientMock.GetConfig mock is already set by Set")
	}

	expectation := &FilesServiceClientMockGetConfigExpectation{
		mock:               mmGetConfig.mock,
		params:             &FilesServiceClientMockGetConfigParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockGetConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConfig.expectations = append(mmGetConfig.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.GetConfig return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockGetConfigExpectation) Then(pp2 *connect.Response[v1.GetConfigResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockGetConfigResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.GetConfig should be invoked
func (mmGetConfig *mFilesServiceClientMockGetConfig) Times(n uint64) *mFilesServiceClientMockGetConfig {
	if n == 0 {
		mmGetConfig.mock.t.Fatalf("Times of FilesServiceClientMock.GetConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConfig.expectedInvocations, n)
	mmGetConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConfig
}

func (mmGetConfig *mFilesServiceClientMockGetConfig) invocationsDone() bool {
	if len(mmGetConfig.expectations) == 0 && mmGetConfig.defaultExpectation == nil && mmGetConfig.mock.funcGetConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConfig.mock.afterGetConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConfig implements mm_filesv1connect.FilesServiceClient
func (mmGetConfig *FilesServiceClientMock) GetConfig(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) (pp2 *connect.Response[v1.GetConfigResponse], err error) {
	mm_atomic.AddUint64(&mmGetConfig.beforeGetConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConfig.afterGetConfigCounter, 1)

	mmGetConfig.t.Helper()

	if mmGetConfig.inspectFuncGetConfig != nil {
		mmGetConfig.inspectFuncGetConfig(ctx, pp1)
	}

	mm_params := FilesServiceClientMockGetConfigParams{ctx, pp1}

	// Record call args
	mmGetConfig.GetConfigMock.mutex.Lock()
	mmGetConfig.GetConfigMock.callArgs = append(mmGetConfig.GetConfigMock.callArgs, &mm_params)
	mmGetConfig.GetConfigMock.mutex.Unlock()

	for _, e := range mmGetConfig.GetConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetConfig.GetConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConfig.GetConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConfig.GetConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetConfig.GetConfigMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockGetConfigParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConfig.t.Errorf("FilesServiceClientMock.GetConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConfig.GetConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetConfig.t.Errorf("FilesServiceClientMock.GetConfig got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConfig.GetConfigMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConfig.t.Errorf("FilesServiceClientMock.GetConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConfig.GetConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConfig.GetConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConfig.t.Fatal("No results are set for the FilesServiceClientMock.GetConfig")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetConfig.funcGetConfig != nil {
		return mmGetConfig.funcGetConfig(ctx, pp1)
	}
	mmGetConfig.t.Fatalf("Unexpected call to FilesServiceClientMock.GetConfig. %v %v", ctx, pp1)
	return
}

// GetConfigAfterCounter returns a count of finished FilesServiceClientMock.GetConfig invocations
func (mmGetConfig *FilesServiceClientMock) GetConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.afterGetConfigCounter)
}

// GetConfigBeforeCounter returns a count of FilesServiceClientMock.GetConfig invocations
func (mmGetConfig *FilesServiceClientMock) GetConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.beforeGetConfigCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.GetConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConfig *mFilesServiceClientMockGetConfig) Calls() []*FilesServiceClientMockGetConfigParams {
	mmGetConfig.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockGetConfigParams, len(mmGetConfig.callArgs))
	copy(argCopy, mmGetConfig.callArgs)

	mmGetConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetConfigDone returns true if the count of the GetConfig invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockGetConfigDone() bool {
	if m.GetConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConfigMock.invocationsDone()
}

// MinimockGetConfigInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockGetConfigInspect() {
	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConfigCounter := mm_atomic.LoadUint64(&m.afterGetConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigMock.defaultExpectation != nil && afterGetConfigCounter < 1 {
		if m.GetConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetConfig at\n%s", m.GetConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetConfig at\n%s with params: %#v", m.GetConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfig != nil && afterGetConfigCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.GetConfig at\n%s", m.funcGetConfigOrigin)
	}

	if !m.GetConfigMock.invocationsDone() && afterGetConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.GetConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConfigMock.expectedInvocations), m.GetConfigMock.expectedInvocationsOrigin, afterGetConfigCounter)
	}
}

type mFilesServiceClientMockGetContent struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockGetContentExpectation
	expectations       []*FilesServiceClientMockGetContentExpectation

	callArgs []*FilesServiceClientMockGetContentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockGetContentExpectation specifies expectation struct of the FilesServiceClient.GetContent
type FilesServiceClientMockGetContentExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockGetContentParams
	paramPtrs          *FilesServiceClientMockGetContentParamPtrs
	expectationOrigins FilesServiceClientMockGetContentExpectationOrigins
	results            *FilesServiceClientMockGetContentResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockGetContentParams contains parameters of the FilesServiceClient.GetContent
type FilesServiceClientMockGetContentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetContentRequest]
}

// FilesServiceClientMockGetContentParamPtrs contains pointers to parameters of the FilesServiceClient.GetContent
type FilesServiceClientMockGetContentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetContentRequest]
}

// FilesServiceClientMockGetContentResults contains results of the FilesServiceClient.GetContent
type FilesServiceClientMockGetContentResults struct {
	pp2 *connect.Response[v1.GetContentResponse]
	err error
}

// FilesServiceClientMockGetContentOrigins contains origins of expectations of the FilesServiceClient.GetContent
type FilesServiceClientMockGetContentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContent *mFilesServiceClientMockGetContent) Optional() *mFilesServiceClientMockGetContent {
	mmGetContent.optional = true
	return mmGetContent
}

// Expect sets up expected params for FilesServiceClient.GetContent
func (mmGetContent *mFilesServiceClientMockGetContent) Expect(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) *mFilesServiceClientMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceClientMockGetContentExpectation{}
	}

	if mmGetContent.defaultExpectation.paramPtrs != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by ExpectParams functions")
	}

	mmGetContent.defaultExpectation.params = &FilesServiceClientMockGetContentParams{ctx, pp1}
	mmGetContent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContent.expectations {
		if minimock.Equal(e.params, mmGetContent.defaultExpectation.params) {
			mmGetContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContent.defaultExpectation.params)
		}
	}

	return mmGetContent
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.GetContent
func (mmGetContent *mFilesServiceClientMockGetContent) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceClientMockGetContentExpectation{}
	}

	if mmGetContent.defaultExpectation.params != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Expect")
	}

	if mmGetContent.defaultExpectation.paramPtrs == nil {
		mmGetContent.defaultExpectation.paramPtrs = &FilesServiceClientMockGetContentParamPtrs{}
	}
	mmGetContent.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContent
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.GetContent
func (mmGetContent *mFilesServiceClientMockGetContent) ExpectPp1Param2(pp1 *connect.Request[v1.GetContentRequest]) *mFilesServiceClientMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceClientMockGetContentExpectation{}
	}

	if mmGetContent.defaultExpectation.params != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Expect")
	}

	if mmGetContent.defaultExpectation.paramPtrs == nil {
		mmGetContent.defaultExpectation.paramPtrs = &FilesServiceClientMockGetContentParamPtrs{}
	}
	mmGetContent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetContent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetContent
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.GetContent
func (mmGetContent *mFilesServiceClientMockGetContent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest])) *mFilesServiceClientMockGetContent {
	if mmGetContent.mock.inspectFuncGetContent != nil {
		mmGetContent.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.GetContent")
	}

	mmGetContent.mock.inspectFuncGetContent = f

	return mmGetContent
}

// Return sets up results that will be returned by FilesServiceClient.GetContent
func (mmGetContent *mFilesServiceClientMockGetContent) Return(pp2 *connect.Response[v1.GetContentResponse], err error) *FilesServiceClientMock {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceClientMockGetContentExpectation{mock: mmGetContent.mock}
	}
	mmGetContent.defaultExpectation.results = &FilesServiceClientMockGetContentResults{pp2, err}
	mmGetContent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContent.mock
}

// Set uses given function f to mock the FilesServiceClient.GetContent method
func (mmGetContent *mFilesServiceClientMockGetContent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) (pp2 *connect.Response[v1.GetContentResponse], err error)) *FilesServiceClientMock {
	if mmGetContent.defaultExpectation != nil {
		mmGetContent.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.GetContent method")
	}

	if len(mmGetContent.expectations) > 0 {
		mmGetContent.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.GetContent method")
	}

	mmGetContent.mock.funcGetContent = f
	mmGetContent.mock.funcGetContentOrigin = minimock.CallerInfo(1)
	return mmGetContent.mock
}

// When sets expectation for the FilesServiceClient.GetContent which will trigger the result defined by the following
// Then helper
func (mmGetContent *mFilesServiceClientMockGetContent) When(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) *FilesServiceClientMockGetContentExpectation {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceClientMock.GetContent mock is already set by Set")
	}

	expectation := &FilesServiceClientMockGetContentExpectation{
		mock:               mmGetContent.mock,
		params:             &FilesServiceClientMockGetContentParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockGetContentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContent.expectations = append(mmGetContent.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.GetContent return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockGetContentExpectation) Then(pp2 *connect.Response[v1.GetContentResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockGetContentResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.GetContent should be invoked
func (mmGetContent *mFilesServiceClientMockGetContent) Times(n uint64) *mFilesServiceClientMockGetContent {
	if n == 0 {
		mmGetContent.mock.t.Fatalf("Times of FilesServiceClientMock.GetContent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContent.expectedInvocations, n)
	mmGetContent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContent
}

func (mmGetContent *mFilesServiceClientMockGetContent) invocationsDone() bool {
	if len(mmGetContent.expectations) == 0 && mmGetContent.defaultExpectation == nil && mmGetContent.mock.funcGetContent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContent.mock.afterGetContentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContent implements mm_filesv1connect.FilesServiceClient
func (mmGetContent *FilesServiceClientMock) GetContent(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) (pp2 *connect.Response[v1.GetContentResponse], err error) {
	mm_atomic.AddUint64(&mmGetContent.beforeGetContentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContent.afterGetContentCounter, 1)

	mmGetContent.t.Helper()

	if mmGetContent.inspectFuncGetContent != nil {
		mmGetContent.inspectFuncGetContent(ctx, pp1)
	}

	mm_params := FilesServiceClientMockGetContentParams{ctx, pp1}

	// Record call args
	mmGetContent.GetContentMock.mutex.Lock()
	mmGetContent.GetContentMock.callArgs = append(mmGetContent.GetContentMock.callArgs, &mm_params)
	mmGetContent.GetContentMock.mutex.Unlock()

	for _, e := range mmGetContent.GetContentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetContent.GetContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContent.GetContentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContent.GetContentMock.defaultExpectation.params
		mm_want_ptrs := mmGetContent.GetContentMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockGetContentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContent.t.Errorf("FilesServiceClientMock.GetContent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContent.GetContentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetContent.t.Errorf("FilesServiceClientMock.GetContent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContent.GetContentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContent.t.Errorf("FilesServiceClientMock.GetContent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContent.GetContentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContent.GetContentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContent.t.Fatal("No results are set for the FilesServiceClientMock.GetContent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetContent.funcGetContent != nil {
		return mmGetContent.funcGetContent(ctx, pp1)
	}
	mmGetContent.t.Fatalf("Unexpected call to FilesServiceClientMock.GetContent. %v %v", ctx, pp1)
	return
}

// GetContentAfterCounter returns a count of finished FilesServiceClientMock.GetContent invocations
func (mmGetContent *FilesServiceClientMock) GetContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContent.afterGetContentCounter)
}

// GetContentBeforeCounter returns a count of FilesServiceClientMock.GetContent invocations
func (mmGetContent *FilesServiceClientMock) GetContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContent.beforeGetContentCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.GetContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContent *mFilesServiceClientMockGetContent) Calls() []*FilesServiceClientMockGetContentParams {
	mmGetContent.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockGetContentParams, len(mmGetContent.callArgs))
	copy(argCopy, mmGetContent.callArgs)

	mmGetContent.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentDone returns true if the count of the GetContent invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockGetContentDone() bool {
	if m.GetContentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentMock.invocationsDone()
}

// MinimockGetContentInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockGetContentInspect() {
	for _, e := range m.GetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentCounter := mm_atomic.LoadUint64(&m.afterGetContentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentMock.defaultExpectation != nil && afterGetContentCounter < 1 {
		if m.GetContentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContent at\n%s", m.GetContentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContent at\n%s with params: %#v", m.GetContentMock.defaultExpectation.expectationOrigins.origin, *m.GetContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContent != nil && afterGetContentCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.GetContent at\n%s", m.funcGetContentOrigin)
	}

	if !m.GetContentMock.invocationsDone() && afterGetContentCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.GetContent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentMock.expectedInvocations), m.GetContentMock.expectedInvocationsOrigin, afterGetContentCounter)
	}
}

type mFilesServiceClientMockGetContentOverrideName struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockGetContentOverrideNameExpectation
	expectations       []*FilesServiceClientMockGetContentOverrideNameExpectation

	callArgs []*FilesServiceClientMockGetContentOverrideNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockGetContentOverrideNameExpectation specifies expectation struct of the FilesServiceClient.GetContentOverrideName
type FilesServiceClientMockGetContentOverrideNameExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockGetContentOverrideNameParams
	paramPtrs          *FilesServiceClientMockGetContentOverrideNameParamPtrs
	expectationOrigins FilesServiceClientMockGetContentOverrideNameExpectationOrigins
	results            *FilesServiceClientMockGetContentOverrideNameResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockGetContentOverrideNameParams contains parameters of the FilesServiceClient.GetContentOverrideName
type FilesServiceClientMockGetContentOverrideNameParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetContentOverrideNameRequest]
}

// FilesServiceClientMockGetContentOverrideNameParamPtrs contains pointers to parameters of the FilesServiceClient.GetContentOverrideName
type FilesServiceClientMockGetContentOverrideNameParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetContentOverrideNameRequest]
}

// FilesServiceClientMockGetContentOverrideNameResults contains results of the FilesServiceClient.GetContentOverrideName
type FilesServiceClientMockGetContentOverrideNameResults struct {
	pp2 *connect.Response[v1.GetContentOverrideNameResponse]
	err error
}

// FilesServiceClientMockGetContentOverrideNameOrigins contains origins of expectations of the FilesServiceClient.GetContentOverrideName
type FilesServiceClientMockGetContentOverrideNameExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Optional() *mFilesServiceClientMockGetContentOverrideName {
	mmGetContentOverrideName.optional = true
	return mmGetContentOverrideName
}

// Expect sets up expected params for FilesServiceClient.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Expect(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) *mFilesServiceClientMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceClientMockGetContentOverrideNameExpectation{}
	}

	if mmGetContentOverrideName.defaultExpectation.paramPtrs != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by ExpectParams functions")
	}

	mmGetContentOverrideName.defaultExpectation.params = &FilesServiceClientMockGetContentOverrideNameParams{ctx, pp1}
	mmGetContentOverrideName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContentOverrideName.expectations {
		if minimock.Equal(e.params, mmGetContentOverrideName.defaultExpectation.params) {
			mmGetContentOverrideName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContentOverrideName.defaultExpectation.params)
		}
	}

	return mmGetContentOverrideName
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceClientMockGetContentOverrideNameExpectation{}
	}

	if mmGetContentOverrideName.defaultExpectation.params != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Expect")
	}

	if mmGetContentOverrideName.defaultExpectation.paramPtrs == nil {
		mmGetContentOverrideName.defaultExpectation.paramPtrs = &FilesServiceClientMockGetContentOverrideNameParamPtrs{}
	}
	mmGetContentOverrideName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContentOverrideName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContentOverrideName
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) ExpectPp1Param2(pp1 *connect.Request[v1.GetContentOverrideNameRequest]) *mFilesServiceClientMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceClientMockGetContentOverrideNameExpectation{}
	}

	if mmGetContentOverrideName.defaultExpectation.params != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Expect")
	}

	if mmGetContentOverrideName.defaultExpectation.paramPtrs == nil {
		mmGetContentOverrideName.defaultExpectation.paramPtrs = &FilesServiceClientMockGetContentOverrideNameParamPtrs{}
	}
	mmGetContentOverrideName.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetContentOverrideName.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetContentOverrideName
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest])) *mFilesServiceClientMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.inspectFuncGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.GetContentOverrideName")
	}

	mmGetContentOverrideName.mock.inspectFuncGetContentOverrideName = f

	return mmGetContentOverrideName
}

// Return sets up results that will be returned by FilesServiceClient.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Return(pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error) *FilesServiceClientMock {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceClientMockGetContentOverrideNameExpectation{mock: mmGetContentOverrideName.mock}
	}
	mmGetContentOverrideName.defaultExpectation.results = &FilesServiceClientMockGetContentOverrideNameResults{pp2, err}
	mmGetContentOverrideName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContentOverrideName.mock
}

// Set uses given function f to mock the FilesServiceClient.GetContentOverrideName method
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) (pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error)) *FilesServiceClientMock {
	if mmGetContentOverrideName.defaultExpectation != nil {
		mmGetContentOverrideName.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.GetContentOverrideName method")
	}

	if len(mmGetContentOverrideName.expectations) > 0 {
		mmGetContentOverrideName.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.GetContentOverrideName method")
	}

	mmGetContentOverrideName.mock.funcGetContentOverrideName = f
	mmGetContentOverrideName.mock.funcGetContentOverrideNameOrigin = minimock.CallerInfo(1)
	return mmGetContentOverrideName.mock
}

// When sets expectation for the FilesServiceClient.GetContentOverrideName which will trigger the result defined by the following
// Then helper
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) When(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) *FilesServiceClientMockGetContentOverrideNameExpectation {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceClientMock.GetContentOverrideName mock is already set by Set")
	}

	expectation := &FilesServiceClientMockGetContentOverrideNameExpectation{
		mock:               mmGetContentOverrideName.mock,
		params:             &FilesServiceClientMockGetContentOverrideNameParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockGetContentOverrideNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContentOverrideName.expectations = append(mmGetContentOverrideName.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.GetContentOverrideName return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockGetContentOverrideNameExpectation) Then(pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockGetContentOverrideNameResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.GetContentOverrideName should be invoked
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Times(n uint64) *mFilesServiceClientMockGetContentOverrideName {
	if n == 0 {
		mmGetContentOverrideName.mock.t.Fatalf("Times of FilesServiceClientMock.GetContentOverrideName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContentOverrideName.expectedInvocations, n)
	mmGetContentOverrideName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContentOverrideName
}

func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) invocationsDone() bool {
	if len(mmGetContentOverrideName.expectations) == 0 && mmGetContentOverrideName.defaultExpectation == nil && mmGetContentOverrideName.mock.funcGetContentOverrideName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContentOverrideName.mock.afterGetContentOverrideNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContentOverrideName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContentOverrideName implements mm_filesv1connect.FilesServiceClient
func (mmGetContentOverrideName *FilesServiceClientMock) GetContentOverrideName(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) (pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error) {
	mm_atomic.AddUint64(&mmGetContentOverrideName.beforeGetContentOverrideNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContentOverrideName.afterGetContentOverrideNameCounter, 1)

	mmGetContentOverrideName.t.Helper()

	if mmGetContentOverrideName.inspectFuncGetContentOverrideName != nil {
		mmGetContentOverrideName.inspectFuncGetContentOverrideName(ctx, pp1)
	}

	mm_params := FilesServiceClientMockGetContentOverrideNameParams{ctx, pp1}

	// Record call args
	mmGetContentOverrideName.GetContentOverrideNameMock.mutex.Lock()
	mmGetContentOverrideName.GetContentOverrideNameMock.callArgs = append(mmGetContentOverrideName.GetContentOverrideNameMock.callArgs, &mm_params)
	mmGetContentOverrideName.GetContentOverrideNameMock.mutex.Unlock()

	for _, e := range mmGetContentOverrideName.GetContentOverrideNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockGetContentOverrideNameParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContentOverrideName.t.Errorf("FilesServiceClientMock.GetContentOverrideName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetContentOverrideName.t.Errorf("FilesServiceClientMock.GetContentOverrideName got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContentOverrideName.t.Errorf("FilesServiceClientMock.GetContentOverrideName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContentOverrideName.t.Fatal("No results are set for the FilesServiceClientMock.GetContentOverrideName")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetContentOverrideName.funcGetContentOverrideName != nil {
		return mmGetContentOverrideName.funcGetContentOverrideName(ctx, pp1)
	}
	mmGetContentOverrideName.t.Fatalf("Unexpected call to FilesServiceClientMock.GetContentOverrideName. %v %v", ctx, pp1)
	return
}

// GetContentOverrideNameAfterCounter returns a count of finished FilesServiceClientMock.GetContentOverrideName invocations
func (mmGetContentOverrideName *FilesServiceClientMock) GetContentOverrideNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentOverrideName.afterGetContentOverrideNameCounter)
}

// GetContentOverrideNameBeforeCounter returns a count of FilesServiceClientMock.GetContentOverrideName invocations
func (mmGetContentOverrideName *FilesServiceClientMock) GetContentOverrideNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentOverrideName.beforeGetContentOverrideNameCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.GetContentOverrideName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContentOverrideName *mFilesServiceClientMockGetContentOverrideName) Calls() []*FilesServiceClientMockGetContentOverrideNameParams {
	mmGetContentOverrideName.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockGetContentOverrideNameParams, len(mmGetContentOverrideName.callArgs))
	copy(argCopy, mmGetContentOverrideName.callArgs)

	mmGetContentOverrideName.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentOverrideNameDone returns true if the count of the GetContentOverrideName invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockGetContentOverrideNameDone() bool {
	if m.GetContentOverrideNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentOverrideNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentOverrideNameMock.invocationsDone()
}

// MinimockGetContentOverrideNameInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockGetContentOverrideNameInspect() {
	for _, e := range m.GetContentOverrideNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContentOverrideName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentOverrideNameCounter := mm_atomic.LoadUint64(&m.afterGetContentOverrideNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentOverrideNameMock.defaultExpectation != nil && afterGetContentOverrideNameCounter < 1 {
		if m.GetContentOverrideNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContentOverrideName at\n%s", m.GetContentOverrideNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContentOverrideName at\n%s with params: %#v", m.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.origin, *m.GetContentOverrideNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContentOverrideName != nil && afterGetContentOverrideNameCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.GetContentOverrideName at\n%s", m.funcGetContentOverrideNameOrigin)
	}

	if !m.GetContentOverrideNameMock.invocationsDone() && afterGetContentOverrideNameCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.GetContentOverrideName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentOverrideNameMock.expectedInvocations), m.GetContentOverrideNameMock.expectedInvocationsOrigin, afterGetContentOverrideNameCounter)
	}
}

type mFilesServiceClientMockGetContentThumbnail struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockGetContentThumbnailExpectation
	expectations       []*FilesServiceClientMockGetContentThumbnailExpectation

	callArgs []*FilesServiceClientMockGetContentThumbnailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockGetContentThumbnailExpectation specifies expectation struct of the FilesServiceClient.GetContentThumbnail
type FilesServiceClientMockGetContentThumbnailExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockGetContentThumbnailParams
	paramPtrs          *FilesServiceClientMockGetContentThumbnailParamPtrs
	expectationOrigins FilesServiceClientMockGetContentThumbnailExpectationOrigins
	results            *FilesServiceClientMockGetContentThumbnailResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockGetContentThumbnailParams contains parameters of the FilesServiceClient.GetContentThumbnail
type FilesServiceClientMockGetContentThumbnailParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetContentThumbnailRequest]
}

// FilesServiceClientMockGetContentThumbnailParamPtrs contains pointers to parameters of the FilesServiceClient.GetContentThumbnail
type FilesServiceClientMockGetContentThumbnailParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetContentThumbnailRequest]
}

// FilesServiceClientMockGetContentThumbnailResults contains results of the FilesServiceClient.GetContentThumbnail
type FilesServiceClientMockGetContentThumbnailResults struct {
	pp2 *connect.Response[v1.GetContentThumbnailResponse]
	err error
}

// FilesServiceClientMockGetContentThumbnailOrigins contains origins of expectations of the FilesServiceClient.GetContentThumbnail
type FilesServiceClientMockGetContentThumbnailExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Optional() *mFilesServiceClientMockGetContentThumbnail {
	mmGetContentThumbnail.optional = true
	return mmGetContentThumbnail
}

// Expect sets up expected params for FilesServiceClient.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Expect(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) *mFilesServiceClientMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceClientMockGetContentThumbnailExpectation{}
	}

	if mmGetContentThumbnail.defaultExpectation.paramPtrs != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by ExpectParams functions")
	}

	mmGetContentThumbnail.defaultExpectation.params = &FilesServiceClientMockGetContentThumbnailParams{ctx, pp1}
	mmGetContentThumbnail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContentThumbnail.expectations {
		if minimock.Equal(e.params, mmGetContentThumbnail.defaultExpectation.params) {
			mmGetContentThumbnail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContentThumbnail.defaultExpectation.params)
		}
	}

	return mmGetContentThumbnail
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceClientMockGetContentThumbnailExpectation{}
	}

	if mmGetContentThumbnail.defaultExpectation.params != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Expect")
	}

	if mmGetContentThumbnail.defaultExpectation.paramPtrs == nil {
		mmGetContentThumbnail.defaultExpectation.paramPtrs = &FilesServiceClientMockGetContentThumbnailParamPtrs{}
	}
	mmGetContentThumbnail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContentThumbnail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContentThumbnail
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) ExpectPp1Param2(pp1 *connect.Request[v1.GetContentThumbnailRequest]) *mFilesServiceClientMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceClientMockGetContentThumbnailExpectation{}
	}

	if mmGetContentThumbnail.defaultExpectation.params != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Expect")
	}

	if mmGetContentThumbnail.defaultExpectation.paramPtrs == nil {
		mmGetContentThumbnail.defaultExpectation.paramPtrs = &FilesServiceClientMockGetContentThumbnailParamPtrs{}
	}
	mmGetContentThumbnail.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetContentThumbnail.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetContentThumbnail
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest])) *mFilesServiceClientMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.inspectFuncGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.GetContentThumbnail")
	}

	mmGetContentThumbnail.mock.inspectFuncGetContentThumbnail = f

	return mmGetContentThumbnail
}

// Return sets up results that will be returned by FilesServiceClient.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Return(pp2 *connect.Response[v1.GetContentThumbnailResponse], err error) *FilesServiceClientMock {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceClientMockGetContentThumbnailExpectation{mock: mmGetContentThumbnail.mock}
	}
	mmGetContentThumbnail.defaultExpectation.results = &FilesServiceClientMockGetContentThumbnailResults{pp2, err}
	mmGetContentThumbnail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContentThumbnail.mock
}

// Set uses given function f to mock the FilesServiceClient.GetContentThumbnail method
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) (pp2 *connect.Response[v1.GetContentThumbnailResponse], err error)) *FilesServiceClientMock {
	if mmGetContentThumbnail.defaultExpectation != nil {
		mmGetContentThumbnail.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.GetContentThumbnail method")
	}

	if len(mmGetContentThumbnail.expectations) > 0 {
		mmGetContentThumbnail.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.GetContentThumbnail method")
	}

	mmGetContentThumbnail.mock.funcGetContentThumbnail = f
	mmGetContentThumbnail.mock.funcGetContentThumbnailOrigin = minimock.CallerInfo(1)
	return mmGetContentThumbnail.mock
}

// When sets expectation for the FilesServiceClient.GetContentThumbnail which will trigger the result defined by the following
// Then helper
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) When(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) *FilesServiceClientMockGetContentThumbnailExpectation {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceClientMock.GetContentThumbnail mock is already set by Set")
	}

	expectation := &FilesServiceClientMockGetContentThumbnailExpectation{
		mock:               mmGetContentThumbnail.mock,
		params:             &FilesServiceClientMockGetContentThumbnailParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockGetContentThumbnailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContentThumbnail.expectations = append(mmGetContentThumbnail.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.GetContentThumbnail return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockGetContentThumbnailExpectation) Then(pp2 *connect.Response[v1.GetContentThumbnailResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockGetContentThumbnailResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.GetContentThumbnail should be invoked
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Times(n uint64) *mFilesServiceClientMockGetContentThumbnail {
	if n == 0 {
		mmGetContentThumbnail.mock.t.Fatalf("Times of FilesServiceClientMock.GetContentThumbnail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContentThumbnail.expectedInvocations, n)
	mmGetContentThumbnail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContentThumbnail
}

func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) invocationsDone() bool {
	if len(mmGetContentThumbnail.expectations) == 0 && mmGetContentThumbnail.defaultExpectation == nil && mmGetContentThumbnail.mock.funcGetContentThumbnail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContentThumbnail.mock.afterGetContentThumbnailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContentThumbnail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContentThumbnail implements mm_filesv1connect.FilesServiceClient
func (mmGetContentThumbnail *FilesServiceClientMock) GetContentThumbnail(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) (pp2 *connect.Response[v1.GetContentThumbnailResponse], err error) {
	mm_atomic.AddUint64(&mmGetContentThumbnail.beforeGetContentThumbnailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContentThumbnail.afterGetContentThumbnailCounter, 1)

	mmGetContentThumbnail.t.Helper()

	if mmGetContentThumbnail.inspectFuncGetContentThumbnail != nil {
		mmGetContentThumbnail.inspectFuncGetContentThumbnail(ctx, pp1)
	}

	mm_params := FilesServiceClientMockGetContentThumbnailParams{ctx, pp1}

	// Record call args
	mmGetContentThumbnail.GetContentThumbnailMock.mutex.Lock()
	mmGetContentThumbnail.GetContentThumbnailMock.callArgs = append(mmGetContentThumbnail.GetContentThumbnailMock.callArgs, &mm_params)
	mmGetContentThumbnail.GetContentThumbnailMock.mutex.Unlock()

	for _, e := range mmGetContentThumbnail.GetContentThumbnailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.params
		mm_want_ptrs := mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockGetContentThumbnailParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContentThumbnail.t.Errorf("FilesServiceClientMock.GetContentThumbnail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetContentThumbnail.t.Errorf("FilesServiceClientMock.GetContentThumbnail got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContentThumbnail.t.Errorf("FilesServiceClientMock.GetContentThumbnail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContentThumbnail.t.Fatal("No results are set for the FilesServiceClientMock.GetContentThumbnail")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetContentThumbnail.funcGetContentThumbnail != nil {
		return mmGetContentThumbnail.funcGetContentThumbnail(ctx, pp1)
	}
	mmGetContentThumbnail.t.Fatalf("Unexpected call to FilesServiceClientMock.GetContentThumbnail. %v %v", ctx, pp1)
	return
}

// GetContentThumbnailAfterCounter returns a count of finished FilesServiceClientMock.GetContentThumbnail invocations
func (mmGetContentThumbnail *FilesServiceClientMock) GetContentThumbnailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentThumbnail.afterGetContentThumbnailCounter)
}

// GetContentThumbnailBeforeCounter returns a count of FilesServiceClientMock.GetContentThumbnail invocations
func (mmGetContentThumbnail *FilesServiceClientMock) GetContentThumbnailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentThumbnail.beforeGetContentThumbnailCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.GetContentThumbnail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContentThumbnail *mFilesServiceClientMockGetContentThumbnail) Calls() []*FilesServiceClientMockGetContentThumbnailParams {
	mmGetContentThumbnail.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockGetContentThumbnailParams, len(mmGetContentThumbnail.callArgs))
	copy(argCopy, mmGetContentThumbnail.callArgs)

	mmGetContentThumbnail.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentThumbnailDone returns true if the count of the GetContentThumbnail invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockGetContentThumbnailDone() bool {
	if m.GetContentThumbnailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentThumbnailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentThumbnailMock.invocationsDone()
}

// MinimockGetContentThumbnailInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockGetContentThumbnailInspect() {
	for _, e := range m.GetContentThumbnailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContentThumbnail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentThumbnailCounter := mm_atomic.LoadUint64(&m.afterGetContentThumbnailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentThumbnailMock.defaultExpectation != nil && afterGetContentThumbnailCounter < 1 {
		if m.GetContentThumbnailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContentThumbnail at\n%s", m.GetContentThumbnailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetContentThumbnail at\n%s with params: %#v", m.GetContentThumbnailMock.defaultExpectation.expectationOrigins.origin, *m.GetContentThumbnailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContentThumbnail != nil && afterGetContentThumbnailCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.GetContentThumbnail at\n%s", m.funcGetContentThumbnailOrigin)
	}

	if !m.GetContentThumbnailMock.invocationsDone() && afterGetContentThumbnailCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.GetContentThumbnail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentThumbnailMock.expectedInvocations), m.GetContentThumbnailMock.expectedInvocationsOrigin, afterGetContentThumbnailCounter)
	}
}

type mFilesServiceClientMockGetUrlPreview struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockGetUrlPreviewExpectation
	expectations       []*FilesServiceClientMockGetUrlPreviewExpectation

	callArgs []*FilesServiceClientMockGetUrlPreviewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockGetUrlPreviewExpectation specifies expectation struct of the FilesServiceClient.GetUrlPreview
type FilesServiceClientMockGetUrlPreviewExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockGetUrlPreviewParams
	paramPtrs          *FilesServiceClientMockGetUrlPreviewParamPtrs
	expectationOrigins FilesServiceClientMockGetUrlPreviewExpectationOrigins
	results            *FilesServiceClientMockGetUrlPreviewResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockGetUrlPreviewParams contains parameters of the FilesServiceClient.GetUrlPreview
type FilesServiceClientMockGetUrlPreviewParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetUrlPreviewRequest]
}

// FilesServiceClientMockGetUrlPreviewParamPtrs contains pointers to parameters of the FilesServiceClient.GetUrlPreview
type FilesServiceClientMockGetUrlPreviewParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetUrlPreviewRequest]
}

// FilesServiceClientMockGetUrlPreviewResults contains results of the FilesServiceClient.GetUrlPreview
type FilesServiceClientMockGetUrlPreviewResults struct {
	pp2 *connect.Response[v1.GetUrlPreviewResponse]
	err error
}

// FilesServiceClientMockGetUrlPreviewOrigins contains origins of expectations of the FilesServiceClient.GetUrlPreview
type FilesServiceClientMockGetUrlPreviewExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Optional() *mFilesServiceClientMockGetUrlPreview {
	mmGetUrlPreview.optional = true
	return mmGetUrlPreview
}

// Expect sets up expected params for FilesServiceClient.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Expect(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) *mFilesServiceClientMockGetUrlPreview {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceClientMockGetUrlPreviewExpectation{}
	}

	if mmGetUrlPreview.defaultExpectation.paramPtrs != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by ExpectParams functions")
	}

	mmGetUrlPreview.defaultExpectation.params = &FilesServiceClientMockGetUrlPreviewParams{ctx, pp1}
	mmGetUrlPreview.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUrlPreview.expectations {
		if minimock.Equal(e.params, mmGetUrlPreview.defaultExpectation.params) {
			mmGetUrlPreview.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUrlPreview.defaultExpectation.params)
		}
	}

	return mmGetUrlPreview
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockGetUrlPreview {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceClientMockGetUrlPreviewExpectation{}
	}

	if mmGetUrlPreview.defaultExpectation.params != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Expect")
	}

	if mmGetUrlPreview.defaultExpectation.paramPtrs == nil {
		mmGetUrlPreview.defaultExpectation.paramPtrs = &FilesServiceClientMockGetUrlPreviewParamPtrs{}
	}
	mmGetUrlPreview.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUrlPreview.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUrlPreview
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) ExpectPp1Param2(pp1 *connect.Request[v1.GetUrlPreviewRequest]) *mFilesServiceClientMockGetUrlPreview {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceClientMockGetUrlPreviewExpectation{}
	}

	if mmGetUrlPreview.defaultExpectation.params != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Expect")
	}

	if mmGetUrlPreview.defaultExpectation.paramPtrs == nil {
		mmGetUrlPreview.defaultExpectation.paramPtrs = &FilesServiceClientMockGetUrlPreviewParamPtrs{}
	}
	mmGetUrlPreview.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetUrlPreview.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetUrlPreview
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest])) *mFilesServiceClientMockGetUrlPreview {
	if mmGetUrlPreview.mock.inspectFuncGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.GetUrlPreview")
	}

	mmGetUrlPreview.mock.inspectFuncGetUrlPreview = f

	return mmGetUrlPreview
}

// Return sets up results that will be returned by FilesServiceClient.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Return(pp2 *connect.Response[v1.GetUrlPreviewResponse], err error) *FilesServiceClientMock {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceClientMockGetUrlPreviewExpectation{mock: mmGetUrlPreview.mock}
	}
	mmGetUrlPreview.defaultExpectation.results = &FilesServiceClientMockGetUrlPreviewResults{pp2, err}
	mmGetUrlPreview.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUrlPreview.mock
}

// Set uses given function f to mock the FilesServiceClient.GetUrlPreview method
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) (pp2 *connect.Response[v1.GetUrlPreviewResponse], err error)) *FilesServiceClientMock {
	if mmGetUrlPreview.defaultExpectation != nil {
		mmGetUrlPreview.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.GetUrlPreview method")
	}

	if len(mmGetUrlPreview.expectations) > 0 {
		mmGetUrlPreview.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.GetUrlPreview method")
	}

	mmGetUrlPreview.mock.funcGetUrlPreview = f
	mmGetUrlPreview.mock.funcGetUrlPreviewOrigin = minimock.CallerInfo(1)
	return mmGetUrlPreview.mock
}

// When sets expectation for the FilesServiceClient.GetUrlPreview which will trigger the result defined by the following
// Then helper
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) When(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) *FilesServiceClientMockGetUrlPreviewExpectation {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceClientMock.GetUrlPreview mock is already set by Set")
	}

	expectation := &FilesServiceClientMockGetUrlPreviewExpectation{
		mock:               mmGetUrlPreview.mock,
		params:             &FilesServiceClientMockGetUrlPreviewParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockGetUrlPreviewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUrlPreview.expectations = append(mmGetUrlPreview.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.GetUrlPreview return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockGetUrlPreviewExpectation) Then(pp2 *connect.Response[v1.GetUrlPreviewResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockGetUrlPreviewResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.GetUrlPreview should be invoked
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Times(n uint64) *mFilesServiceClientMockGetUrlPreview {
	if n == 0 {
		mmGetUrlPreview.mock.t.Fatalf("Times of FilesServiceClientMock.GetUrlPreview mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUrlPreview.expectedInvocations, n)
	mmGetUrlPreview.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUrlPreview
}

func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) invocationsDone() bool {
	if len(mmGetUrlPreview.expectations) == 0 && mmGetUrlPreview.defaultExpectation == nil && mmGetUrlPreview.mock.funcGetUrlPreview == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUrlPreview.mock.afterGetUrlPreviewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUrlPreview.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUrlPreview implements mm_filesv1connect.FilesServiceClient
func (mmGetUrlPreview *FilesServiceClientMock) GetUrlPreview(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) (pp2 *connect.Response[v1.GetUrlPreviewResponse], err error) {
	mm_atomic.AddUint64(&mmGetUrlPreview.beforeGetUrlPreviewCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUrlPreview.afterGetUrlPreviewCounter, 1)

	mmGetUrlPreview.t.Helper()

	if mmGetUrlPreview.inspectFuncGetUrlPreview != nil {
		mmGetUrlPreview.inspectFuncGetUrlPreview(ctx, pp1)
	}

	mm_params := FilesServiceClientMockGetUrlPreviewParams{ctx, pp1}

	// Record call args
	mmGetUrlPreview.GetUrlPreviewMock.mutex.Lock()
	mmGetUrlPreview.GetUrlPreviewMock.callArgs = append(mmGetUrlPreview.GetUrlPreviewMock.callArgs, &mm_params)
	mmGetUrlPreview.GetUrlPreviewMock.mutex.Unlock()

	for _, e := range mmGetUrlPreview.GetUrlPreviewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.params
		mm_want_ptrs := mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockGetUrlPreviewParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUrlPreview.t.Errorf("FilesServiceClientMock.GetUrlPreview got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetUrlPreview.t.Errorf("FilesServiceClientMock.GetUrlPreview got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUrlPreview.t.Errorf("FilesServiceClientMock.GetUrlPreview got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUrlPreview.t.Fatal("No results are set for the FilesServiceClientMock.GetUrlPreview")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetUrlPreview.funcGetUrlPreview != nil {
		return mmGetUrlPreview.funcGetUrlPreview(ctx, pp1)
	}
	mmGetUrlPreview.t.Fatalf("Unexpected call to FilesServiceClientMock.GetUrlPreview. %v %v", ctx, pp1)
	return
}

// GetUrlPreviewAfterCounter returns a count of finished FilesServiceClientMock.GetUrlPreview invocations
func (mmGetUrlPreview *FilesServiceClientMock) GetUrlPreviewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUrlPreview.afterGetUrlPreviewCounter)
}

// GetUrlPreviewBeforeCounter returns a count of FilesServiceClientMock.GetUrlPreview invocations
func (mmGetUrlPreview *FilesServiceClientMock) GetUrlPreviewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUrlPreview.beforeGetUrlPreviewCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.GetUrlPreview.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUrlPreview *mFilesServiceClientMockGetUrlPreview) Calls() []*FilesServiceClientMockGetUrlPreviewParams {
	mmGetUrlPreview.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockGetUrlPreviewParams, len(mmGetUrlPreview.callArgs))
	copy(argCopy, mmGetUrlPreview.callArgs)

	mmGetUrlPreview.mutex.RUnlock()

	return argCopy
}

// MinimockGetUrlPreviewDone returns true if the count of the GetUrlPreview invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockGetUrlPreviewDone() bool {
	if m.GetUrlPreviewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUrlPreviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUrlPreviewMock.invocationsDone()
}

// MinimockGetUrlPreviewInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockGetUrlPreviewInspect() {
	for _, e := range m.GetUrlPreviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetUrlPreview at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUrlPreviewCounter := mm_atomic.LoadUint64(&m.afterGetUrlPreviewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUrlPreviewMock.defaultExpectation != nil && afterGetUrlPreviewCounter < 1 {
		if m.GetUrlPreviewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetUrlPreview at\n%s", m.GetUrlPreviewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.GetUrlPreview at\n%s with params: %#v", m.GetUrlPreviewMock.defaultExpectation.expectationOrigins.origin, *m.GetUrlPreviewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUrlPreview != nil && afterGetUrlPreviewCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.GetUrlPreview at\n%s", m.funcGetUrlPreviewOrigin)
	}

	if !m.GetUrlPreviewMock.invocationsDone() && afterGetUrlPreviewCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.GetUrlPreview at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUrlPreviewMock.expectedInvocations), m.GetUrlPreviewMock.expectedInvocationsOrigin, afterGetUrlPreviewCounter)
	}
}

type mFilesServiceClientMockSearchMedia struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockSearchMediaExpectation
	expectations       []*FilesServiceClientMockSearchMediaExpectation

	callArgs []*FilesServiceClientMockSearchMediaParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockSearchMediaExpectation specifies expectation struct of the FilesServiceClient.SearchMedia
type FilesServiceClientMockSearchMediaExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockSearchMediaParams
	paramPtrs          *FilesServiceClientMockSearchMediaParamPtrs
	expectationOrigins FilesServiceClientMockSearchMediaExpectationOrigins
	results            *FilesServiceClientMockSearchMediaResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockSearchMediaParams contains parameters of the FilesServiceClient.SearchMedia
type FilesServiceClientMockSearchMediaParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchMediaRequest]
}

// FilesServiceClientMockSearchMediaParamPtrs contains pointers to parameters of the FilesServiceClient.SearchMedia
type FilesServiceClientMockSearchMediaParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchMediaRequest]
}

// FilesServiceClientMockSearchMediaResults contains results of the FilesServiceClient.SearchMedia
type FilesServiceClientMockSearchMediaResults struct {
	pp2 *connect.Response[v1.SearchMediaResponse]
	err error
}

// FilesServiceClientMockSearchMediaOrigins contains origins of expectations of the FilesServiceClient.SearchMedia
type FilesServiceClientMockSearchMediaExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Optional() *mFilesServiceClientMockSearchMedia {
	mmSearchMedia.optional = true
	return mmSearchMedia
}

// Expect sets up expected params for FilesServiceClient.SearchMedia
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) *mFilesServiceClientMockSearchMedia {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceClientMockSearchMediaExpectation{}
	}

	if mmSearchMedia.defaultExpectation.paramPtrs != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by ExpectParams functions")
	}

	mmSearchMedia.defaultExpectation.params = &FilesServiceClientMockSearchMediaParams{ctx, pp1}
	mmSearchMedia.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchMedia.expectations {
		if minimock.Equal(e.params, mmSearchMedia.defaultExpectation.params) {
			mmSearchMedia.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchMedia.defaultExpectation.params)
		}
	}

	return mmSearchMedia
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.SearchMedia
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockSearchMedia {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceClientMockSearchMediaExpectation{}
	}

	if mmSearchMedia.defaultExpectation.params != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Expect")
	}

	if mmSearchMedia.defaultExpectation.paramPtrs == nil {
		mmSearchMedia.defaultExpectation.paramPtrs = &FilesServiceClientMockSearchMediaParamPtrs{}
	}
	mmSearchMedia.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchMedia.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchMedia
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceClient.SearchMedia
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) ExpectPp1Param2(pp1 *connect.Request[v1.SearchMediaRequest]) *mFilesServiceClientMockSearchMedia {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceClientMockSearchMediaExpectation{}
	}

	if mmSearchMedia.defaultExpectation.params != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Expect")
	}

	if mmSearchMedia.defaultExpectation.paramPtrs == nil {
		mmSearchMedia.defaultExpectation.paramPtrs = &FilesServiceClientMockSearchMediaParamPtrs{}
	}
	mmSearchMedia.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchMedia.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchMedia
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.SearchMedia
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest])) *mFilesServiceClientMockSearchMedia {
	if mmSearchMedia.mock.inspectFuncSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.SearchMedia")
	}

	mmSearchMedia.mock.inspectFuncSearchMedia = f

	return mmSearchMedia
}

// Return sets up results that will be returned by FilesServiceClient.SearchMedia
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Return(pp2 *connect.Response[v1.SearchMediaResponse], err error) *FilesServiceClientMock {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceClientMockSearchMediaExpectation{mock: mmSearchMedia.mock}
	}
	mmSearchMedia.defaultExpectation.results = &FilesServiceClientMockSearchMediaResults{pp2, err}
	mmSearchMedia.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchMedia.mock
}

// Set uses given function f to mock the FilesServiceClient.SearchMedia method
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) (pp2 *connect.Response[v1.SearchMediaResponse], err error)) *FilesServiceClientMock {
	if mmSearchMedia.defaultExpectation != nil {
		mmSearchMedia.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.SearchMedia method")
	}

	if len(mmSearchMedia.expectations) > 0 {
		mmSearchMedia.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.SearchMedia method")
	}

	mmSearchMedia.mock.funcSearchMedia = f
	mmSearchMedia.mock.funcSearchMediaOrigin = minimock.CallerInfo(1)
	return mmSearchMedia.mock
}

// When sets expectation for the FilesServiceClient.SearchMedia which will trigger the result defined by the following
// Then helper
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) When(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) *FilesServiceClientMockSearchMediaExpectation {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceClientMock.SearchMedia mock is already set by Set")
	}

	expectation := &FilesServiceClientMockSearchMediaExpectation{
		mock:               mmSearchMedia.mock,
		params:             &FilesServiceClientMockSearchMediaParams{ctx, pp1},
		expectationOrigins: FilesServiceClientMockSearchMediaExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchMedia.expectations = append(mmSearchMedia.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.SearchMedia return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockSearchMediaExpectation) Then(pp2 *connect.Response[v1.SearchMediaResponse], err error) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockSearchMediaResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceClient.SearchMedia should be invoked
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Times(n uint64) *mFilesServiceClientMockSearchMedia {
	if n == 0 {
		mmSearchMedia.mock.t.Fatalf("Times of FilesServiceClientMock.SearchMedia mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchMedia.expectedInvocations, n)
	mmSearchMedia.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchMedia
}

func (mmSearchMedia *mFilesServiceClientMockSearchMedia) invocationsDone() bool {
	if len(mmSearchMedia.expectations) == 0 && mmSearchMedia.defaultExpectation == nil && mmSearchMedia.mock.funcSearchMedia == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchMedia.mock.afterSearchMediaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchMedia.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchMedia implements mm_filesv1connect.FilesServiceClient
func (mmSearchMedia *FilesServiceClientMock) SearchMedia(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) (pp2 *connect.Response[v1.SearchMediaResponse], err error) {
	mm_atomic.AddUint64(&mmSearchMedia.beforeSearchMediaCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchMedia.afterSearchMediaCounter, 1)

	mmSearchMedia.t.Helper()

	if mmSearchMedia.inspectFuncSearchMedia != nil {
		mmSearchMedia.inspectFuncSearchMedia(ctx, pp1)
	}

	mm_params := FilesServiceClientMockSearchMediaParams{ctx, pp1}

	// Record call args
	mmSearchMedia.SearchMediaMock.mutex.Lock()
	mmSearchMedia.SearchMediaMock.callArgs = append(mmSearchMedia.SearchMediaMock.callArgs, &mm_params)
	mmSearchMedia.SearchMediaMock.mutex.Unlock()

	for _, e := range mmSearchMedia.SearchMediaMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchMedia.SearchMediaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchMedia.SearchMediaMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchMedia.SearchMediaMock.defaultExpectation.params
		mm_want_ptrs := mmSearchMedia.SearchMediaMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockSearchMediaParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchMedia.t.Errorf("FilesServiceClientMock.SearchMedia got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchMedia.SearchMediaMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchMedia.t.Errorf("FilesServiceClientMock.SearchMedia got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchMedia.SearchMediaMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchMedia.t.Errorf("FilesServiceClientMock.SearchMedia got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchMedia.SearchMediaMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchMedia.SearchMediaMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchMedia.t.Fatal("No results are set for the FilesServiceClientMock.SearchMedia")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchMedia.funcSearchMedia != nil {
		return mmSearchMedia.funcSearchMedia(ctx, pp1)
	}
	mmSearchMedia.t.Fatalf("Unexpected call to FilesServiceClientMock.SearchMedia. %v %v", ctx, pp1)
	return
}

// SearchMediaAfterCounter returns a count of finished FilesServiceClientMock.SearchMedia invocations
func (mmSearchMedia *FilesServiceClientMock) SearchMediaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchMedia.afterSearchMediaCounter)
}

// SearchMediaBeforeCounter returns a count of FilesServiceClientMock.SearchMedia invocations
func (mmSearchMedia *FilesServiceClientMock) SearchMediaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchMedia.beforeSearchMediaCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.SearchMedia.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchMedia *mFilesServiceClientMockSearchMedia) Calls() []*FilesServiceClientMockSearchMediaParams {
	mmSearchMedia.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockSearchMediaParams, len(mmSearchMedia.callArgs))
	copy(argCopy, mmSearchMedia.callArgs)

	mmSearchMedia.mutex.RUnlock()

	return argCopy
}

// MinimockSearchMediaDone returns true if the count of the SearchMedia invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockSearchMediaDone() bool {
	if m.SearchMediaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMediaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMediaMock.invocationsDone()
}

// MinimockSearchMediaInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockSearchMediaInspect() {
	for _, e := range m.SearchMediaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.SearchMedia at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchMediaCounter := mm_atomic.LoadUint64(&m.afterSearchMediaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMediaMock.defaultExpectation != nil && afterSearchMediaCounter < 1 {
		if m.SearchMediaMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.SearchMedia at\n%s", m.SearchMediaMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.SearchMedia at\n%s with params: %#v", m.SearchMediaMock.defaultExpectation.expectationOrigins.origin, *m.SearchMediaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchMedia != nil && afterSearchMediaCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.SearchMedia at\n%s", m.funcSearchMediaOrigin)
	}

	if !m.SearchMediaMock.invocationsDone() && afterSearchMediaCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.SearchMedia at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMediaMock.expectedInvocations), m.SearchMediaMock.expectedInvocationsOrigin, afterSearchMediaCounter)
	}
}

type mFilesServiceClientMockUploadContent struct {
	optional           bool
	mock               *FilesServiceClientMock
	defaultExpectation *FilesServiceClientMockUploadContentExpectation
	expectations       []*FilesServiceClientMockUploadContentExpectation

	callArgs []*FilesServiceClientMockUploadContentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceClientMockUploadContentExpectation specifies expectation struct of the FilesServiceClient.UploadContent
type FilesServiceClientMockUploadContentExpectation struct {
	mock               *FilesServiceClientMock
	params             *FilesServiceClientMockUploadContentParams
	paramPtrs          *FilesServiceClientMockUploadContentParamPtrs
	expectationOrigins FilesServiceClientMockUploadContentExpectationOrigins
	results            *FilesServiceClientMockUploadContentResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceClientMockUploadContentParams contains parameters of the FilesServiceClient.UploadContent
type FilesServiceClientMockUploadContentParams struct {
	ctx context.Context
}

// FilesServiceClientMockUploadContentParamPtrs contains pointers to parameters of the FilesServiceClient.UploadContent
type FilesServiceClientMockUploadContentParamPtrs struct {
	ctx *context.Context
}

// FilesServiceClientMockUploadContentResults contains results of the FilesServiceClient.UploadContent
type FilesServiceClientMockUploadContentResults struct {
	pp1 *connect.ClientStreamForClient[v1.UploadContentRequest, v1.UploadContentResponse]
}

// FilesServiceClientMockUploadContentOrigins contains origins of expectations of the FilesServiceClient.UploadContent
type FilesServiceClientMockUploadContentExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadContent *mFilesServiceClientMockUploadContent) Optional() *mFilesServiceClientMockUploadContent {
	mmUploadContent.optional = true
	return mmUploadContent
}

// Expect sets up expected params for FilesServiceClient.UploadContent
func (mmUploadContent *mFilesServiceClientMockUploadContent) Expect(ctx context.Context) *mFilesServiceClientMockUploadContent {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceClientMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceClientMockUploadContentExpectation{}
	}

	if mmUploadContent.defaultExpectation.paramPtrs != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceClientMock.UploadContent mock is already set by ExpectParams functions")
	}

	mmUploadContent.defaultExpectation.params = &FilesServiceClientMockUploadContentParams{ctx}
	mmUploadContent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadContent.expectations {
		if minimock.Equal(e.params, mmUploadContent.defaultExpectation.params) {
			mmUploadContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadContent.defaultExpectation.params)
		}
	}

	return mmUploadContent
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceClient.UploadContent
func (mmUploadContent *mFilesServiceClientMockUploadContent) ExpectCtxParam1(ctx context.Context) *mFilesServiceClientMockUploadContent {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceClientMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceClientMockUploadContentExpectation{}
	}

	if mmUploadContent.defaultExpectation.params != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceClientMock.UploadContent mock is already set by Expect")
	}

	if mmUploadContent.defaultExpectation.paramPtrs == nil {
		mmUploadContent.defaultExpectation.paramPtrs = &FilesServiceClientMockUploadContentParamPtrs{}
	}
	mmUploadContent.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadContent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadContent
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceClient.UploadContent
func (mmUploadContent *mFilesServiceClientMockUploadContent) Inspect(f func(ctx context.Context)) *mFilesServiceClientMockUploadContent {
	if mmUploadContent.mock.inspectFuncUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("Inspect function is already set for FilesServiceClientMock.UploadContent")
	}

	mmUploadContent.mock.inspectFuncUploadContent = f

	return mmUploadContent
}

// Return sets up results that will be returned by FilesServiceClient.UploadContent
func (mmUploadContent *mFilesServiceClientMockUploadContent) Return(pp1 *connect.ClientStreamForClient[v1.UploadContentRequest, v1.UploadContentResponse]) *FilesServiceClientMock {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceClientMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceClientMockUploadContentExpectation{mock: mmUploadContent.mock}
	}
	mmUploadContent.defaultExpectation.results = &FilesServiceClientMockUploadContentResults{pp1}
	mmUploadContent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadContent.mock
}

// Set uses given function f to mock the FilesServiceClient.UploadContent method
func (mmUploadContent *mFilesServiceClientMockUploadContent) Set(f func(ctx context.Context) (pp1 *connect.ClientStreamForClient[v1.UploadContentRequest, v1.UploadContentResponse])) *FilesServiceClientMock {
	if mmUploadContent.defaultExpectation != nil {
		mmUploadContent.mock.t.Fatalf("Default expectation is already set for the FilesServiceClient.UploadContent method")
	}

	if len(mmUploadContent.expectations) > 0 {
		mmUploadContent.mock.t.Fatalf("Some expectations are already set for the FilesServiceClient.UploadContent method")
	}

	mmUploadContent.mock.funcUploadContent = f
	mmUploadContent.mock.funcUploadContentOrigin = minimock.CallerInfo(1)
	return mmUploadContent.mock
}

// When sets expectation for the FilesServiceClient.UploadContent which will trigger the result defined by the following
// Then helper
func (mmUploadContent *mFilesServiceClientMockUploadContent) When(ctx context.Context) *FilesServiceClientMockUploadContentExpectation {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceClientMock.UploadContent mock is already set by Set")
	}

	expectation := &FilesServiceClientMockUploadContentExpectation{
		mock:               mmUploadContent.mock,
		params:             &FilesServiceClientMockUploadContentParams{ctx},
		expectationOrigins: FilesServiceClientMockUploadContentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadContent.expectations = append(mmUploadContent.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceClient.UploadContent return parameters for the expectation previously defined by the When method
func (e *FilesServiceClientMockUploadContentExpectation) Then(pp1 *connect.ClientStreamForClient[v1.UploadContentRequest, v1.UploadContentResponse]) *FilesServiceClientMock {
	e.results = &FilesServiceClientMockUploadContentResults{pp1}
	return e.mock
}

// Times sets number of times FilesServiceClient.UploadContent should be invoked
func (mmUploadContent *mFilesServiceClientMockUploadContent) Times(n uint64) *mFilesServiceClientMockUploadContent {
	if n == 0 {
		mmUploadContent.mock.t.Fatalf("Times of FilesServiceClientMock.UploadContent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadContent.expectedInvocations, n)
	mmUploadContent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadContent
}

func (mmUploadContent *mFilesServiceClientMockUploadContent) invocationsDone() bool {
	if len(mmUploadContent.expectations) == 0 && mmUploadContent.defaultExpectation == nil && mmUploadContent.mock.funcUploadContent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadContent.mock.afterUploadContentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadContent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadContent implements mm_filesv1connect.FilesServiceClient
func (mmUploadContent *FilesServiceClientMock) UploadContent(ctx context.Context) (pp1 *connect.ClientStreamForClient[v1.UploadContentRequest, v1.UploadContentResponse]) {
	mm_atomic.AddUint64(&mmUploadContent.beforeUploadContentCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadContent.afterUploadContentCounter, 1)

	mmUploadContent.t.Helper()

	if mmUploadContent.inspectFuncUploadContent != nil {
		mmUploadContent.inspectFuncUploadContent(ctx)
	}

	mm_params := FilesServiceClientMockUploadContentParams{ctx}

	// Record call args
	mmUploadContent.UploadContentMock.mutex.Lock()
	mmUploadContent.UploadContentMock.callArgs = append(mmUploadContent.UploadContentMock.callArgs, &mm_params)
	mmUploadContent.UploadContentMock.mutex.Unlock()

	for _, e := range mmUploadContent.UploadContentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1
		}
	}

	if mmUploadContent.UploadContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadContent.UploadContentMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadContent.UploadContentMock.defaultExpectation.params
		mm_want_ptrs := mmUploadContent.UploadContentMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceClientMockUploadContentParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadContent.t.Errorf("FilesServiceClientMock.UploadContent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadContent.UploadContentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadContent.t.Errorf("FilesServiceClientMock.UploadContent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadContent.UploadContentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadContent.UploadContentMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadContent.t.Fatal("No results are set for the FilesServiceClientMock.UploadContent")
		}
		return (*mm_results).pp1
	}
	if mmUploadContent.funcUploadContent != nil {
		return mmUploadContent.funcUploadContent(ctx)
	}
	mmUploadContent.t.Fatalf("Unexpected call to FilesServiceClientMock.UploadContent. %v", ctx)
	return
}

// UploadContentAfterCounter returns a count of finished FilesServiceClientMock.UploadContent invocations
func (mmUploadContent *FilesServiceClientMock) UploadContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadContent.afterUploadContentCounter)
}

// UploadContentBeforeCounter returns a count of FilesServiceClientMock.UploadContent invocations
func (mmUploadContent *FilesServiceClientMock) UploadContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadContent.beforeUploadContentCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceClientMock.UploadContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadContent *mFilesServiceClientMockUploadContent) Calls() []*FilesServiceClientMockUploadContentParams {
	mmUploadContent.mutex.RLock()

	argCopy := make([]*FilesServiceClientMockUploadContentParams, len(mmUploadContent.callArgs))
	copy(argCopy, mmUploadContent.callArgs)

	mmUploadContent.mutex.RUnlock()

	return argCopy
}

// MinimockUploadContentDone returns true if the count of the UploadContent invocations corresponds
// the number of defined expectations
func (m *FilesServiceClientMock) MinimockUploadContentDone() bool {
	if m.UploadContentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadContentMock.invocationsDone()
}

// MinimockUploadContentInspect logs each unmet expectation
func (m *FilesServiceClientMock) MinimockUploadContentInspect() {
	for _, e := range m.UploadContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceClientMock.UploadContent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadContentCounter := mm_atomic.LoadUint64(&m.afterUploadContentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadContentMock.defaultExpectation != nil && afterUploadContentCounter < 1 {
		if m.UploadContentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceClientMock.UploadContent at\n%s", m.UploadContentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceClientMock.UploadContent at\n%s with params: %#v", m.UploadContentMock.defaultExpectation.expectationOrigins.origin, *m.UploadContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadContent != nil && afterUploadContentCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceClientMock.UploadContent at\n%s", m.funcUploadContentOrigin)
	}

	if !m.UploadContentMock.invocationsDone() && afterUploadContentCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceClientMock.UploadContent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadContentMock.expectedInvocations), m.UploadContentMock.expectedInvocationsOrigin, afterUploadContentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FilesServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateContentInspect()

			m.MinimockGetConfigInspect()

			m.MinimockGetContentInspect()

			m.MinimockGetContentOverrideNameInspect()

			m.MinimockGetContentThumbnailInspect()

			m.MinimockGetUrlPreviewInspect()

			m.MinimockSearchMediaInspect()

			m.MinimockUploadContentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FilesServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FilesServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateContentDone() &&
		m.MinimockGetConfigDone() &&
		m.MinimockGetContentDone() &&
		m.MinimockGetContentOverrideNameDone() &&
		m.MinimockGetContentThumbnailDone() &&
		m.MinimockGetUrlPreviewDone() &&
		m.MinimockSearchMediaDone() &&
		m.MinimockUploadContentDone()
}
