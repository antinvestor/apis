// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/files/connectrpc/go/files/v1/filesv1connect.FilesServiceHandler -o files_handler.gen.go -n FilesServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/files/protocolbuffers/go/files/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// FilesServiceHandlerMock implements mm_filesv1connect.FilesServiceHandler
type FilesServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateContent          func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) (pp2 *connect.Response[v1.CreateContentResponse], err error)
	funcCreateContentOrigin    string
	inspectFuncCreateContent   func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest])
	afterCreateContentCounter  uint64
	beforeCreateContentCounter uint64
	CreateContentMock          mFilesServiceHandlerMockCreateContent

	funcGetConfig          func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) (pp2 *connect.Response[v1.GetConfigResponse], err error)
	funcGetConfigOrigin    string
	inspectFuncGetConfig   func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest])
	afterGetConfigCounter  uint64
	beforeGetConfigCounter uint64
	GetConfigMock          mFilesServiceHandlerMockGetConfig

	funcGetContent          func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) (pp2 *connect.Response[v1.GetContentResponse], err error)
	funcGetContentOrigin    string
	inspectFuncGetContent   func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest])
	afterGetContentCounter  uint64
	beforeGetContentCounter uint64
	GetContentMock          mFilesServiceHandlerMockGetContent

	funcGetContentOverrideName          func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) (pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error)
	funcGetContentOverrideNameOrigin    string
	inspectFuncGetContentOverrideName   func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest])
	afterGetContentOverrideNameCounter  uint64
	beforeGetContentOverrideNameCounter uint64
	GetContentOverrideNameMock          mFilesServiceHandlerMockGetContentOverrideName

	funcGetContentThumbnail          func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) (pp2 *connect.Response[v1.GetContentThumbnailResponse], err error)
	funcGetContentThumbnailOrigin    string
	inspectFuncGetContentThumbnail   func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest])
	afterGetContentThumbnailCounter  uint64
	beforeGetContentThumbnailCounter uint64
	GetContentThumbnailMock          mFilesServiceHandlerMockGetContentThumbnail

	funcGetUrlPreview          func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) (pp2 *connect.Response[v1.GetUrlPreviewResponse], err error)
	funcGetUrlPreviewOrigin    string
	inspectFuncGetUrlPreview   func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest])
	afterGetUrlPreviewCounter  uint64
	beforeGetUrlPreviewCounter uint64
	GetUrlPreviewMock          mFilesServiceHandlerMockGetUrlPreview

	funcSearchMedia          func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) (pp2 *connect.Response[v1.SearchMediaResponse], err error)
	funcSearchMediaOrigin    string
	inspectFuncSearchMedia   func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest])
	afterSearchMediaCounter  uint64
	beforeSearchMediaCounter uint64
	SearchMediaMock          mFilesServiceHandlerMockSearchMedia

	funcUploadContent          func(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest]) (pp2 *connect.Response[v1.UploadContentResponse], err error)
	funcUploadContentOrigin    string
	inspectFuncUploadContent   func(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest])
	afterUploadContentCounter  uint64
	beforeUploadContentCounter uint64
	UploadContentMock          mFilesServiceHandlerMockUploadContent
}

// NewFilesServiceHandlerMock returns a mock for mm_filesv1connect.FilesServiceHandler
func NewFilesServiceHandlerMock(t minimock.Tester) *FilesServiceHandlerMock {
	m := &FilesServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateContentMock = mFilesServiceHandlerMockCreateContent{mock: m}
	m.CreateContentMock.callArgs = []*FilesServiceHandlerMockCreateContentParams{}

	m.GetConfigMock = mFilesServiceHandlerMockGetConfig{mock: m}
	m.GetConfigMock.callArgs = []*FilesServiceHandlerMockGetConfigParams{}

	m.GetContentMock = mFilesServiceHandlerMockGetContent{mock: m}
	m.GetContentMock.callArgs = []*FilesServiceHandlerMockGetContentParams{}

	m.GetContentOverrideNameMock = mFilesServiceHandlerMockGetContentOverrideName{mock: m}
	m.GetContentOverrideNameMock.callArgs = []*FilesServiceHandlerMockGetContentOverrideNameParams{}

	m.GetContentThumbnailMock = mFilesServiceHandlerMockGetContentThumbnail{mock: m}
	m.GetContentThumbnailMock.callArgs = []*FilesServiceHandlerMockGetContentThumbnailParams{}

	m.GetUrlPreviewMock = mFilesServiceHandlerMockGetUrlPreview{mock: m}
	m.GetUrlPreviewMock.callArgs = []*FilesServiceHandlerMockGetUrlPreviewParams{}

	m.SearchMediaMock = mFilesServiceHandlerMockSearchMedia{mock: m}
	m.SearchMediaMock.callArgs = []*FilesServiceHandlerMockSearchMediaParams{}

	m.UploadContentMock = mFilesServiceHandlerMockUploadContent{mock: m}
	m.UploadContentMock.callArgs = []*FilesServiceHandlerMockUploadContentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFilesServiceHandlerMockCreateContent struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockCreateContentExpectation
	expectations       []*FilesServiceHandlerMockCreateContentExpectation

	callArgs []*FilesServiceHandlerMockCreateContentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockCreateContentExpectation specifies expectation struct of the FilesServiceHandler.CreateContent
type FilesServiceHandlerMockCreateContentExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockCreateContentParams
	paramPtrs          *FilesServiceHandlerMockCreateContentParamPtrs
	expectationOrigins FilesServiceHandlerMockCreateContentExpectationOrigins
	results            *FilesServiceHandlerMockCreateContentResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockCreateContentParams contains parameters of the FilesServiceHandler.CreateContent
type FilesServiceHandlerMockCreateContentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateContentRequest]
}

// FilesServiceHandlerMockCreateContentParamPtrs contains pointers to parameters of the FilesServiceHandler.CreateContent
type FilesServiceHandlerMockCreateContentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateContentRequest]
}

// FilesServiceHandlerMockCreateContentResults contains results of the FilesServiceHandler.CreateContent
type FilesServiceHandlerMockCreateContentResults struct {
	pp2 *connect.Response[v1.CreateContentResponse]
	err error
}

// FilesServiceHandlerMockCreateContentOrigins contains origins of expectations of the FilesServiceHandler.CreateContent
type FilesServiceHandlerMockCreateContentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Optional() *mFilesServiceHandlerMockCreateContent {
	mmCreateContent.optional = true
	return mmCreateContent
}

// Expect sets up expected params for FilesServiceHandler.CreateContent
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) *mFilesServiceHandlerMockCreateContent {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceHandlerMockCreateContentExpectation{}
	}

	if mmCreateContent.defaultExpectation.paramPtrs != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by ExpectParams functions")
	}

	mmCreateContent.defaultExpectation.params = &FilesServiceHandlerMockCreateContentParams{ctx, pp1}
	mmCreateContent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateContent.expectations {
		if minimock.Equal(e.params, mmCreateContent.defaultExpectation.params) {
			mmCreateContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateContent.defaultExpectation.params)
		}
	}

	return mmCreateContent
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.CreateContent
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockCreateContent {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceHandlerMockCreateContentExpectation{}
	}

	if mmCreateContent.defaultExpectation.params != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Expect")
	}

	if mmCreateContent.defaultExpectation.paramPtrs == nil {
		mmCreateContent.defaultExpectation.paramPtrs = &FilesServiceHandlerMockCreateContentParamPtrs{}
	}
	mmCreateContent.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateContent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateContent
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.CreateContent
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) ExpectPp1Param2(pp1 *connect.Request[v1.CreateContentRequest]) *mFilesServiceHandlerMockCreateContent {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceHandlerMockCreateContentExpectation{}
	}

	if mmCreateContent.defaultExpectation.params != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Expect")
	}

	if mmCreateContent.defaultExpectation.paramPtrs == nil {
		mmCreateContent.defaultExpectation.paramPtrs = &FilesServiceHandlerMockCreateContentParamPtrs{}
	}
	mmCreateContent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateContent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateContent
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.CreateContent
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest])) *mFilesServiceHandlerMockCreateContent {
	if mmCreateContent.mock.inspectFuncCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.CreateContent")
	}

	mmCreateContent.mock.inspectFuncCreateContent = f

	return mmCreateContent
}

// Return sets up results that will be returned by FilesServiceHandler.CreateContent
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Return(pp2 *connect.Response[v1.CreateContentResponse], err error) *FilesServiceHandlerMock {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Set")
	}

	if mmCreateContent.defaultExpectation == nil {
		mmCreateContent.defaultExpectation = &FilesServiceHandlerMockCreateContentExpectation{mock: mmCreateContent.mock}
	}
	mmCreateContent.defaultExpectation.results = &FilesServiceHandlerMockCreateContentResults{pp2, err}
	mmCreateContent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateContent.mock
}

// Set uses given function f to mock the FilesServiceHandler.CreateContent method
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) (pp2 *connect.Response[v1.CreateContentResponse], err error)) *FilesServiceHandlerMock {
	if mmCreateContent.defaultExpectation != nil {
		mmCreateContent.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.CreateContent method")
	}

	if len(mmCreateContent.expectations) > 0 {
		mmCreateContent.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.CreateContent method")
	}

	mmCreateContent.mock.funcCreateContent = f
	mmCreateContent.mock.funcCreateContentOrigin = minimock.CallerInfo(1)
	return mmCreateContent.mock
}

// When sets expectation for the FilesServiceHandler.CreateContent which will trigger the result defined by the following
// Then helper
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) When(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) *FilesServiceHandlerMockCreateContentExpectation {
	if mmCreateContent.mock.funcCreateContent != nil {
		mmCreateContent.mock.t.Fatalf("FilesServiceHandlerMock.CreateContent mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockCreateContentExpectation{
		mock:               mmCreateContent.mock,
		params:             &FilesServiceHandlerMockCreateContentParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockCreateContentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateContent.expectations = append(mmCreateContent.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.CreateContent return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockCreateContentExpectation) Then(pp2 *connect.Response[v1.CreateContentResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockCreateContentResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.CreateContent should be invoked
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Times(n uint64) *mFilesServiceHandlerMockCreateContent {
	if n == 0 {
		mmCreateContent.mock.t.Fatalf("Times of FilesServiceHandlerMock.CreateContent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateContent.expectedInvocations, n)
	mmCreateContent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateContent
}

func (mmCreateContent *mFilesServiceHandlerMockCreateContent) invocationsDone() bool {
	if len(mmCreateContent.expectations) == 0 && mmCreateContent.defaultExpectation == nil && mmCreateContent.mock.funcCreateContent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateContent.mock.afterCreateContentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateContent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateContent implements mm_filesv1connect.FilesServiceHandler
func (mmCreateContent *FilesServiceHandlerMock) CreateContent(ctx context.Context, pp1 *connect.Request[v1.CreateContentRequest]) (pp2 *connect.Response[v1.CreateContentResponse], err error) {
	mm_atomic.AddUint64(&mmCreateContent.beforeCreateContentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateContent.afterCreateContentCounter, 1)

	mmCreateContent.t.Helper()

	if mmCreateContent.inspectFuncCreateContent != nil {
		mmCreateContent.inspectFuncCreateContent(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockCreateContentParams{ctx, pp1}

	// Record call args
	mmCreateContent.CreateContentMock.mutex.Lock()
	mmCreateContent.CreateContentMock.callArgs = append(mmCreateContent.CreateContentMock.callArgs, &mm_params)
	mmCreateContent.CreateContentMock.mutex.Unlock()

	for _, e := range mmCreateContent.CreateContentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateContent.CreateContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateContent.CreateContentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateContent.CreateContentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateContent.CreateContentMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockCreateContentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateContent.t.Errorf("FilesServiceHandlerMock.CreateContent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateContent.CreateContentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateContent.t.Errorf("FilesServiceHandlerMock.CreateContent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateContent.CreateContentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateContent.t.Errorf("FilesServiceHandlerMock.CreateContent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateContent.CreateContentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateContent.CreateContentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateContent.t.Fatal("No results are set for the FilesServiceHandlerMock.CreateContent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateContent.funcCreateContent != nil {
		return mmCreateContent.funcCreateContent(ctx, pp1)
	}
	mmCreateContent.t.Fatalf("Unexpected call to FilesServiceHandlerMock.CreateContent. %v %v", ctx, pp1)
	return
}

// CreateContentAfterCounter returns a count of finished FilesServiceHandlerMock.CreateContent invocations
func (mmCreateContent *FilesServiceHandlerMock) CreateContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateContent.afterCreateContentCounter)
}

// CreateContentBeforeCounter returns a count of FilesServiceHandlerMock.CreateContent invocations
func (mmCreateContent *FilesServiceHandlerMock) CreateContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateContent.beforeCreateContentCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.CreateContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateContent *mFilesServiceHandlerMockCreateContent) Calls() []*FilesServiceHandlerMockCreateContentParams {
	mmCreateContent.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockCreateContentParams, len(mmCreateContent.callArgs))
	copy(argCopy, mmCreateContent.callArgs)

	mmCreateContent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateContentDone returns true if the count of the CreateContent invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockCreateContentDone() bool {
	if m.CreateContentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateContentMock.invocationsDone()
}

// MinimockCreateContentInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockCreateContentInspect() {
	for _, e := range m.CreateContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.CreateContent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateContentCounter := mm_atomic.LoadUint64(&m.afterCreateContentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateContentMock.defaultExpectation != nil && afterCreateContentCounter < 1 {
		if m.CreateContentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.CreateContent at\n%s", m.CreateContentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.CreateContent at\n%s with params: %#v", m.CreateContentMock.defaultExpectation.expectationOrigins.origin, *m.CreateContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateContent != nil && afterCreateContentCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.CreateContent at\n%s", m.funcCreateContentOrigin)
	}

	if !m.CreateContentMock.invocationsDone() && afterCreateContentCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.CreateContent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateContentMock.expectedInvocations), m.CreateContentMock.expectedInvocationsOrigin, afterCreateContentCounter)
	}
}

type mFilesServiceHandlerMockGetConfig struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockGetConfigExpectation
	expectations       []*FilesServiceHandlerMockGetConfigExpectation

	callArgs []*FilesServiceHandlerMockGetConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockGetConfigExpectation specifies expectation struct of the FilesServiceHandler.GetConfig
type FilesServiceHandlerMockGetConfigExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockGetConfigParams
	paramPtrs          *FilesServiceHandlerMockGetConfigParamPtrs
	expectationOrigins FilesServiceHandlerMockGetConfigExpectationOrigins
	results            *FilesServiceHandlerMockGetConfigResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockGetConfigParams contains parameters of the FilesServiceHandler.GetConfig
type FilesServiceHandlerMockGetConfigParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetConfigRequest]
}

// FilesServiceHandlerMockGetConfigParamPtrs contains pointers to parameters of the FilesServiceHandler.GetConfig
type FilesServiceHandlerMockGetConfigParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetConfigRequest]
}

// FilesServiceHandlerMockGetConfigResults contains results of the FilesServiceHandler.GetConfig
type FilesServiceHandlerMockGetConfigResults struct {
	pp2 *connect.Response[v1.GetConfigResponse]
	err error
}

// FilesServiceHandlerMockGetConfigOrigins contains origins of expectations of the FilesServiceHandler.GetConfig
type FilesServiceHandlerMockGetConfigExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Optional() *mFilesServiceHandlerMockGetConfig {
	mmGetConfig.optional = true
	return mmGetConfig
}

// Expect sets up expected params for FilesServiceHandler.GetConfig
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Expect(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) *mFilesServiceHandlerMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceHandlerMockGetConfigExpectation{}
	}

	if mmGetConfig.defaultExpectation.paramPtrs != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by ExpectParams functions")
	}

	mmGetConfig.defaultExpectation.params = &FilesServiceHandlerMockGetConfigParams{ctx, pp1}
	mmGetConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetConfig.expectations {
		if minimock.Equal(e.params, mmGetConfig.defaultExpectation.params) {
			mmGetConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetConfig.defaultExpectation.params)
		}
	}

	return mmGetConfig
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.GetConfig
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceHandlerMockGetConfigExpectation{}
	}

	if mmGetConfig.defaultExpectation.params != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Expect")
	}

	if mmGetConfig.defaultExpectation.paramPtrs == nil {
		mmGetConfig.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetConfigParamPtrs{}
	}
	mmGetConfig.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetConfig.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetConfig
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.GetConfig
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) ExpectPp1Param2(pp1 *connect.Request[v1.GetConfigRequest]) *mFilesServiceHandlerMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceHandlerMockGetConfigExpectation{}
	}

	if mmGetConfig.defaultExpectation.params != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Expect")
	}

	if mmGetConfig.defaultExpectation.paramPtrs == nil {
		mmGetConfig.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetConfigParamPtrs{}
	}
	mmGetConfig.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetConfig.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetConfig
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.GetConfig
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest])) *mFilesServiceHandlerMockGetConfig {
	if mmGetConfig.mock.inspectFuncGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.GetConfig")
	}

	mmGetConfig.mock.inspectFuncGetConfig = f

	return mmGetConfig
}

// Return sets up results that will be returned by FilesServiceHandler.GetConfig
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Return(pp2 *connect.Response[v1.GetConfigResponse], err error) *FilesServiceHandlerMock {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &FilesServiceHandlerMockGetConfigExpectation{mock: mmGetConfig.mock}
	}
	mmGetConfig.defaultExpectation.results = &FilesServiceHandlerMockGetConfigResults{pp2, err}
	mmGetConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetConfig.mock
}

// Set uses given function f to mock the FilesServiceHandler.GetConfig method
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) (pp2 *connect.Response[v1.GetConfigResponse], err error)) *FilesServiceHandlerMock {
	if mmGetConfig.defaultExpectation != nil {
		mmGetConfig.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.GetConfig method")
	}

	if len(mmGetConfig.expectations) > 0 {
		mmGetConfig.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.GetConfig method")
	}

	mmGetConfig.mock.funcGetConfig = f
	mmGetConfig.mock.funcGetConfigOrigin = minimock.CallerInfo(1)
	return mmGetConfig.mock
}

// When sets expectation for the FilesServiceHandler.GetConfig which will trigger the result defined by the following
// Then helper
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) When(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) *FilesServiceHandlerMockGetConfigExpectation {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("FilesServiceHandlerMock.GetConfig mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockGetConfigExpectation{
		mock:               mmGetConfig.mock,
		params:             &FilesServiceHandlerMockGetConfigParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockGetConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetConfig.expectations = append(mmGetConfig.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.GetConfig return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockGetConfigExpectation) Then(pp2 *connect.Response[v1.GetConfigResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockGetConfigResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.GetConfig should be invoked
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Times(n uint64) *mFilesServiceHandlerMockGetConfig {
	if n == 0 {
		mmGetConfig.mock.t.Fatalf("Times of FilesServiceHandlerMock.GetConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetConfig.expectedInvocations, n)
	mmGetConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetConfig
}

func (mmGetConfig *mFilesServiceHandlerMockGetConfig) invocationsDone() bool {
	if len(mmGetConfig.expectations) == 0 && mmGetConfig.defaultExpectation == nil && mmGetConfig.mock.funcGetConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetConfig.mock.afterGetConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetConfig implements mm_filesv1connect.FilesServiceHandler
func (mmGetConfig *FilesServiceHandlerMock) GetConfig(ctx context.Context, pp1 *connect.Request[v1.GetConfigRequest]) (pp2 *connect.Response[v1.GetConfigResponse], err error) {
	mm_atomic.AddUint64(&mmGetConfig.beforeGetConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConfig.afterGetConfigCounter, 1)

	mmGetConfig.t.Helper()

	if mmGetConfig.inspectFuncGetConfig != nil {
		mmGetConfig.inspectFuncGetConfig(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockGetConfigParams{ctx, pp1}

	// Record call args
	mmGetConfig.GetConfigMock.mutex.Lock()
	mmGetConfig.GetConfigMock.callArgs = append(mmGetConfig.GetConfigMock.callArgs, &mm_params)
	mmGetConfig.GetConfigMock.mutex.Unlock()

	for _, e := range mmGetConfig.GetConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetConfig.GetConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConfig.GetConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmGetConfig.GetConfigMock.defaultExpectation.params
		mm_want_ptrs := mmGetConfig.GetConfigMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockGetConfigParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetConfig.t.Errorf("FilesServiceHandlerMock.GetConfig got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConfig.GetConfigMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetConfig.t.Errorf("FilesServiceHandlerMock.GetConfig got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetConfig.GetConfigMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetConfig.t.Errorf("FilesServiceHandlerMock.GetConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetConfig.GetConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetConfig.GetConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConfig.t.Fatal("No results are set for the FilesServiceHandlerMock.GetConfig")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetConfig.funcGetConfig != nil {
		return mmGetConfig.funcGetConfig(ctx, pp1)
	}
	mmGetConfig.t.Fatalf("Unexpected call to FilesServiceHandlerMock.GetConfig. %v %v", ctx, pp1)
	return
}

// GetConfigAfterCounter returns a count of finished FilesServiceHandlerMock.GetConfig invocations
func (mmGetConfig *FilesServiceHandlerMock) GetConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.afterGetConfigCounter)
}

// GetConfigBeforeCounter returns a count of FilesServiceHandlerMock.GetConfig invocations
func (mmGetConfig *FilesServiceHandlerMock) GetConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.beforeGetConfigCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.GetConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetConfig *mFilesServiceHandlerMockGetConfig) Calls() []*FilesServiceHandlerMockGetConfigParams {
	mmGetConfig.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockGetConfigParams, len(mmGetConfig.callArgs))
	copy(argCopy, mmGetConfig.callArgs)

	mmGetConfig.mutex.RUnlock()

	return argCopy
}

// MinimockGetConfigDone returns true if the count of the GetConfig invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockGetConfigDone() bool {
	if m.GetConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetConfigMock.invocationsDone()
}

// MinimockGetConfigInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockGetConfigInspect() {
	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetConfigCounter := mm_atomic.LoadUint64(&m.afterGetConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigMock.defaultExpectation != nil && afterGetConfigCounter < 1 {
		if m.GetConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetConfig at\n%s", m.GetConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetConfig at\n%s with params: %#v", m.GetConfigMock.defaultExpectation.expectationOrigins.origin, *m.GetConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfig != nil && afterGetConfigCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.GetConfig at\n%s", m.funcGetConfigOrigin)
	}

	if !m.GetConfigMock.invocationsDone() && afterGetConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.GetConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetConfigMock.expectedInvocations), m.GetConfigMock.expectedInvocationsOrigin, afterGetConfigCounter)
	}
}

type mFilesServiceHandlerMockGetContent struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockGetContentExpectation
	expectations       []*FilesServiceHandlerMockGetContentExpectation

	callArgs []*FilesServiceHandlerMockGetContentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockGetContentExpectation specifies expectation struct of the FilesServiceHandler.GetContent
type FilesServiceHandlerMockGetContentExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockGetContentParams
	paramPtrs          *FilesServiceHandlerMockGetContentParamPtrs
	expectationOrigins FilesServiceHandlerMockGetContentExpectationOrigins
	results            *FilesServiceHandlerMockGetContentResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockGetContentParams contains parameters of the FilesServiceHandler.GetContent
type FilesServiceHandlerMockGetContentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetContentRequest]
}

// FilesServiceHandlerMockGetContentParamPtrs contains pointers to parameters of the FilesServiceHandler.GetContent
type FilesServiceHandlerMockGetContentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetContentRequest]
}

// FilesServiceHandlerMockGetContentResults contains results of the FilesServiceHandler.GetContent
type FilesServiceHandlerMockGetContentResults struct {
	pp2 *connect.Response[v1.GetContentResponse]
	err error
}

// FilesServiceHandlerMockGetContentOrigins contains origins of expectations of the FilesServiceHandler.GetContent
type FilesServiceHandlerMockGetContentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContent *mFilesServiceHandlerMockGetContent) Optional() *mFilesServiceHandlerMockGetContent {
	mmGetContent.optional = true
	return mmGetContent
}

// Expect sets up expected params for FilesServiceHandler.GetContent
func (mmGetContent *mFilesServiceHandlerMockGetContent) Expect(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) *mFilesServiceHandlerMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceHandlerMockGetContentExpectation{}
	}

	if mmGetContent.defaultExpectation.paramPtrs != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by ExpectParams functions")
	}

	mmGetContent.defaultExpectation.params = &FilesServiceHandlerMockGetContentParams{ctx, pp1}
	mmGetContent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContent.expectations {
		if minimock.Equal(e.params, mmGetContent.defaultExpectation.params) {
			mmGetContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContent.defaultExpectation.params)
		}
	}

	return mmGetContent
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.GetContent
func (mmGetContent *mFilesServiceHandlerMockGetContent) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceHandlerMockGetContentExpectation{}
	}

	if mmGetContent.defaultExpectation.params != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Expect")
	}

	if mmGetContent.defaultExpectation.paramPtrs == nil {
		mmGetContent.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetContentParamPtrs{}
	}
	mmGetContent.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContent
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.GetContent
func (mmGetContent *mFilesServiceHandlerMockGetContent) ExpectPp1Param2(pp1 *connect.Request[v1.GetContentRequest]) *mFilesServiceHandlerMockGetContent {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceHandlerMockGetContentExpectation{}
	}

	if mmGetContent.defaultExpectation.params != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Expect")
	}

	if mmGetContent.defaultExpectation.paramPtrs == nil {
		mmGetContent.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetContentParamPtrs{}
	}
	mmGetContent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetContent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetContent
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.GetContent
func (mmGetContent *mFilesServiceHandlerMockGetContent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest])) *mFilesServiceHandlerMockGetContent {
	if mmGetContent.mock.inspectFuncGetContent != nil {
		mmGetContent.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.GetContent")
	}

	mmGetContent.mock.inspectFuncGetContent = f

	return mmGetContent
}

// Return sets up results that will be returned by FilesServiceHandler.GetContent
func (mmGetContent *mFilesServiceHandlerMockGetContent) Return(pp2 *connect.Response[v1.GetContentResponse], err error) *FilesServiceHandlerMock {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Set")
	}

	if mmGetContent.defaultExpectation == nil {
		mmGetContent.defaultExpectation = &FilesServiceHandlerMockGetContentExpectation{mock: mmGetContent.mock}
	}
	mmGetContent.defaultExpectation.results = &FilesServiceHandlerMockGetContentResults{pp2, err}
	mmGetContent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContent.mock
}

// Set uses given function f to mock the FilesServiceHandler.GetContent method
func (mmGetContent *mFilesServiceHandlerMockGetContent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) (pp2 *connect.Response[v1.GetContentResponse], err error)) *FilesServiceHandlerMock {
	if mmGetContent.defaultExpectation != nil {
		mmGetContent.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.GetContent method")
	}

	if len(mmGetContent.expectations) > 0 {
		mmGetContent.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.GetContent method")
	}

	mmGetContent.mock.funcGetContent = f
	mmGetContent.mock.funcGetContentOrigin = minimock.CallerInfo(1)
	return mmGetContent.mock
}

// When sets expectation for the FilesServiceHandler.GetContent which will trigger the result defined by the following
// Then helper
func (mmGetContent *mFilesServiceHandlerMockGetContent) When(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) *FilesServiceHandlerMockGetContentExpectation {
	if mmGetContent.mock.funcGetContent != nil {
		mmGetContent.mock.t.Fatalf("FilesServiceHandlerMock.GetContent mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockGetContentExpectation{
		mock:               mmGetContent.mock,
		params:             &FilesServiceHandlerMockGetContentParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockGetContentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContent.expectations = append(mmGetContent.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.GetContent return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockGetContentExpectation) Then(pp2 *connect.Response[v1.GetContentResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockGetContentResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.GetContent should be invoked
func (mmGetContent *mFilesServiceHandlerMockGetContent) Times(n uint64) *mFilesServiceHandlerMockGetContent {
	if n == 0 {
		mmGetContent.mock.t.Fatalf("Times of FilesServiceHandlerMock.GetContent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContent.expectedInvocations, n)
	mmGetContent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContent
}

func (mmGetContent *mFilesServiceHandlerMockGetContent) invocationsDone() bool {
	if len(mmGetContent.expectations) == 0 && mmGetContent.defaultExpectation == nil && mmGetContent.mock.funcGetContent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContent.mock.afterGetContentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContent implements mm_filesv1connect.FilesServiceHandler
func (mmGetContent *FilesServiceHandlerMock) GetContent(ctx context.Context, pp1 *connect.Request[v1.GetContentRequest]) (pp2 *connect.Response[v1.GetContentResponse], err error) {
	mm_atomic.AddUint64(&mmGetContent.beforeGetContentCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContent.afterGetContentCounter, 1)

	mmGetContent.t.Helper()

	if mmGetContent.inspectFuncGetContent != nil {
		mmGetContent.inspectFuncGetContent(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockGetContentParams{ctx, pp1}

	// Record call args
	mmGetContent.GetContentMock.mutex.Lock()
	mmGetContent.GetContentMock.callArgs = append(mmGetContent.GetContentMock.callArgs, &mm_params)
	mmGetContent.GetContentMock.mutex.Unlock()

	for _, e := range mmGetContent.GetContentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetContent.GetContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContent.GetContentMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContent.GetContentMock.defaultExpectation.params
		mm_want_ptrs := mmGetContent.GetContentMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockGetContentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContent.t.Errorf("FilesServiceHandlerMock.GetContent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContent.GetContentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetContent.t.Errorf("FilesServiceHandlerMock.GetContent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContent.GetContentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContent.t.Errorf("FilesServiceHandlerMock.GetContent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContent.GetContentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContent.GetContentMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContent.t.Fatal("No results are set for the FilesServiceHandlerMock.GetContent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetContent.funcGetContent != nil {
		return mmGetContent.funcGetContent(ctx, pp1)
	}
	mmGetContent.t.Fatalf("Unexpected call to FilesServiceHandlerMock.GetContent. %v %v", ctx, pp1)
	return
}

// GetContentAfterCounter returns a count of finished FilesServiceHandlerMock.GetContent invocations
func (mmGetContent *FilesServiceHandlerMock) GetContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContent.afterGetContentCounter)
}

// GetContentBeforeCounter returns a count of FilesServiceHandlerMock.GetContent invocations
func (mmGetContent *FilesServiceHandlerMock) GetContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContent.beforeGetContentCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.GetContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContent *mFilesServiceHandlerMockGetContent) Calls() []*FilesServiceHandlerMockGetContentParams {
	mmGetContent.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockGetContentParams, len(mmGetContent.callArgs))
	copy(argCopy, mmGetContent.callArgs)

	mmGetContent.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentDone returns true if the count of the GetContent invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockGetContentDone() bool {
	if m.GetContentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentMock.invocationsDone()
}

// MinimockGetContentInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockGetContentInspect() {
	for _, e := range m.GetContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentCounter := mm_atomic.LoadUint64(&m.afterGetContentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentMock.defaultExpectation != nil && afterGetContentCounter < 1 {
		if m.GetContentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContent at\n%s", m.GetContentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContent at\n%s with params: %#v", m.GetContentMock.defaultExpectation.expectationOrigins.origin, *m.GetContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContent != nil && afterGetContentCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContent at\n%s", m.funcGetContentOrigin)
	}

	if !m.GetContentMock.invocationsDone() && afterGetContentCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.GetContent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentMock.expectedInvocations), m.GetContentMock.expectedInvocationsOrigin, afterGetContentCounter)
	}
}

type mFilesServiceHandlerMockGetContentOverrideName struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockGetContentOverrideNameExpectation
	expectations       []*FilesServiceHandlerMockGetContentOverrideNameExpectation

	callArgs []*FilesServiceHandlerMockGetContentOverrideNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockGetContentOverrideNameExpectation specifies expectation struct of the FilesServiceHandler.GetContentOverrideName
type FilesServiceHandlerMockGetContentOverrideNameExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockGetContentOverrideNameParams
	paramPtrs          *FilesServiceHandlerMockGetContentOverrideNameParamPtrs
	expectationOrigins FilesServiceHandlerMockGetContentOverrideNameExpectationOrigins
	results            *FilesServiceHandlerMockGetContentOverrideNameResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockGetContentOverrideNameParams contains parameters of the FilesServiceHandler.GetContentOverrideName
type FilesServiceHandlerMockGetContentOverrideNameParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetContentOverrideNameRequest]
}

// FilesServiceHandlerMockGetContentOverrideNameParamPtrs contains pointers to parameters of the FilesServiceHandler.GetContentOverrideName
type FilesServiceHandlerMockGetContentOverrideNameParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetContentOverrideNameRequest]
}

// FilesServiceHandlerMockGetContentOverrideNameResults contains results of the FilesServiceHandler.GetContentOverrideName
type FilesServiceHandlerMockGetContentOverrideNameResults struct {
	pp2 *connect.Response[v1.GetContentOverrideNameResponse]
	err error
}

// FilesServiceHandlerMockGetContentOverrideNameOrigins contains origins of expectations of the FilesServiceHandler.GetContentOverrideName
type FilesServiceHandlerMockGetContentOverrideNameExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Optional() *mFilesServiceHandlerMockGetContentOverrideName {
	mmGetContentOverrideName.optional = true
	return mmGetContentOverrideName
}

// Expect sets up expected params for FilesServiceHandler.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Expect(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) *mFilesServiceHandlerMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceHandlerMockGetContentOverrideNameExpectation{}
	}

	if mmGetContentOverrideName.defaultExpectation.paramPtrs != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by ExpectParams functions")
	}

	mmGetContentOverrideName.defaultExpectation.params = &FilesServiceHandlerMockGetContentOverrideNameParams{ctx, pp1}
	mmGetContentOverrideName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContentOverrideName.expectations {
		if minimock.Equal(e.params, mmGetContentOverrideName.defaultExpectation.params) {
			mmGetContentOverrideName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContentOverrideName.defaultExpectation.params)
		}
	}

	return mmGetContentOverrideName
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceHandlerMockGetContentOverrideNameExpectation{}
	}

	if mmGetContentOverrideName.defaultExpectation.params != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Expect")
	}

	if mmGetContentOverrideName.defaultExpectation.paramPtrs == nil {
		mmGetContentOverrideName.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetContentOverrideNameParamPtrs{}
	}
	mmGetContentOverrideName.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContentOverrideName.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContentOverrideName
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) ExpectPp1Param2(pp1 *connect.Request[v1.GetContentOverrideNameRequest]) *mFilesServiceHandlerMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceHandlerMockGetContentOverrideNameExpectation{}
	}

	if mmGetContentOverrideName.defaultExpectation.params != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Expect")
	}

	if mmGetContentOverrideName.defaultExpectation.paramPtrs == nil {
		mmGetContentOverrideName.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetContentOverrideNameParamPtrs{}
	}
	mmGetContentOverrideName.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetContentOverrideName.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetContentOverrideName
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest])) *mFilesServiceHandlerMockGetContentOverrideName {
	if mmGetContentOverrideName.mock.inspectFuncGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.GetContentOverrideName")
	}

	mmGetContentOverrideName.mock.inspectFuncGetContentOverrideName = f

	return mmGetContentOverrideName
}

// Return sets up results that will be returned by FilesServiceHandler.GetContentOverrideName
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Return(pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error) *FilesServiceHandlerMock {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Set")
	}

	if mmGetContentOverrideName.defaultExpectation == nil {
		mmGetContentOverrideName.defaultExpectation = &FilesServiceHandlerMockGetContentOverrideNameExpectation{mock: mmGetContentOverrideName.mock}
	}
	mmGetContentOverrideName.defaultExpectation.results = &FilesServiceHandlerMockGetContentOverrideNameResults{pp2, err}
	mmGetContentOverrideName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContentOverrideName.mock
}

// Set uses given function f to mock the FilesServiceHandler.GetContentOverrideName method
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) (pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error)) *FilesServiceHandlerMock {
	if mmGetContentOverrideName.defaultExpectation != nil {
		mmGetContentOverrideName.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.GetContentOverrideName method")
	}

	if len(mmGetContentOverrideName.expectations) > 0 {
		mmGetContentOverrideName.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.GetContentOverrideName method")
	}

	mmGetContentOverrideName.mock.funcGetContentOverrideName = f
	mmGetContentOverrideName.mock.funcGetContentOverrideNameOrigin = minimock.CallerInfo(1)
	return mmGetContentOverrideName.mock
}

// When sets expectation for the FilesServiceHandler.GetContentOverrideName which will trigger the result defined by the following
// Then helper
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) When(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) *FilesServiceHandlerMockGetContentOverrideNameExpectation {
	if mmGetContentOverrideName.mock.funcGetContentOverrideName != nil {
		mmGetContentOverrideName.mock.t.Fatalf("FilesServiceHandlerMock.GetContentOverrideName mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockGetContentOverrideNameExpectation{
		mock:               mmGetContentOverrideName.mock,
		params:             &FilesServiceHandlerMockGetContentOverrideNameParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockGetContentOverrideNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContentOverrideName.expectations = append(mmGetContentOverrideName.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.GetContentOverrideName return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockGetContentOverrideNameExpectation) Then(pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockGetContentOverrideNameResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.GetContentOverrideName should be invoked
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Times(n uint64) *mFilesServiceHandlerMockGetContentOverrideName {
	if n == 0 {
		mmGetContentOverrideName.mock.t.Fatalf("Times of FilesServiceHandlerMock.GetContentOverrideName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContentOverrideName.expectedInvocations, n)
	mmGetContentOverrideName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContentOverrideName
}

func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) invocationsDone() bool {
	if len(mmGetContentOverrideName.expectations) == 0 && mmGetContentOverrideName.defaultExpectation == nil && mmGetContentOverrideName.mock.funcGetContentOverrideName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContentOverrideName.mock.afterGetContentOverrideNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContentOverrideName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContentOverrideName implements mm_filesv1connect.FilesServiceHandler
func (mmGetContentOverrideName *FilesServiceHandlerMock) GetContentOverrideName(ctx context.Context, pp1 *connect.Request[v1.GetContentOverrideNameRequest]) (pp2 *connect.Response[v1.GetContentOverrideNameResponse], err error) {
	mm_atomic.AddUint64(&mmGetContentOverrideName.beforeGetContentOverrideNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContentOverrideName.afterGetContentOverrideNameCounter, 1)

	mmGetContentOverrideName.t.Helper()

	if mmGetContentOverrideName.inspectFuncGetContentOverrideName != nil {
		mmGetContentOverrideName.inspectFuncGetContentOverrideName(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockGetContentOverrideNameParams{ctx, pp1}

	// Record call args
	mmGetContentOverrideName.GetContentOverrideNameMock.mutex.Lock()
	mmGetContentOverrideName.GetContentOverrideNameMock.callArgs = append(mmGetContentOverrideName.GetContentOverrideNameMock.callArgs, &mm_params)
	mmGetContentOverrideName.GetContentOverrideNameMock.mutex.Unlock()

	for _, e := range mmGetContentOverrideName.GetContentOverrideNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.params
		mm_want_ptrs := mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockGetContentOverrideNameParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContentOverrideName.t.Errorf("FilesServiceHandlerMock.GetContentOverrideName got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetContentOverrideName.t.Errorf("FilesServiceHandlerMock.GetContentOverrideName got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContentOverrideName.t.Errorf("FilesServiceHandlerMock.GetContentOverrideName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContentOverrideName.GetContentOverrideNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContentOverrideName.t.Fatal("No results are set for the FilesServiceHandlerMock.GetContentOverrideName")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetContentOverrideName.funcGetContentOverrideName != nil {
		return mmGetContentOverrideName.funcGetContentOverrideName(ctx, pp1)
	}
	mmGetContentOverrideName.t.Fatalf("Unexpected call to FilesServiceHandlerMock.GetContentOverrideName. %v %v", ctx, pp1)
	return
}

// GetContentOverrideNameAfterCounter returns a count of finished FilesServiceHandlerMock.GetContentOverrideName invocations
func (mmGetContentOverrideName *FilesServiceHandlerMock) GetContentOverrideNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentOverrideName.afterGetContentOverrideNameCounter)
}

// GetContentOverrideNameBeforeCounter returns a count of FilesServiceHandlerMock.GetContentOverrideName invocations
func (mmGetContentOverrideName *FilesServiceHandlerMock) GetContentOverrideNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentOverrideName.beforeGetContentOverrideNameCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.GetContentOverrideName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContentOverrideName *mFilesServiceHandlerMockGetContentOverrideName) Calls() []*FilesServiceHandlerMockGetContentOverrideNameParams {
	mmGetContentOverrideName.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockGetContentOverrideNameParams, len(mmGetContentOverrideName.callArgs))
	copy(argCopy, mmGetContentOverrideName.callArgs)

	mmGetContentOverrideName.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentOverrideNameDone returns true if the count of the GetContentOverrideName invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockGetContentOverrideNameDone() bool {
	if m.GetContentOverrideNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentOverrideNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentOverrideNameMock.invocationsDone()
}

// MinimockGetContentOverrideNameInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockGetContentOverrideNameInspect() {
	for _, e := range m.GetContentOverrideNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentOverrideName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentOverrideNameCounter := mm_atomic.LoadUint64(&m.afterGetContentOverrideNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentOverrideNameMock.defaultExpectation != nil && afterGetContentOverrideNameCounter < 1 {
		if m.GetContentOverrideNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentOverrideName at\n%s", m.GetContentOverrideNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentOverrideName at\n%s with params: %#v", m.GetContentOverrideNameMock.defaultExpectation.expectationOrigins.origin, *m.GetContentOverrideNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContentOverrideName != nil && afterGetContentOverrideNameCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentOverrideName at\n%s", m.funcGetContentOverrideNameOrigin)
	}

	if !m.GetContentOverrideNameMock.invocationsDone() && afterGetContentOverrideNameCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.GetContentOverrideName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentOverrideNameMock.expectedInvocations), m.GetContentOverrideNameMock.expectedInvocationsOrigin, afterGetContentOverrideNameCounter)
	}
}

type mFilesServiceHandlerMockGetContentThumbnail struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockGetContentThumbnailExpectation
	expectations       []*FilesServiceHandlerMockGetContentThumbnailExpectation

	callArgs []*FilesServiceHandlerMockGetContentThumbnailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockGetContentThumbnailExpectation specifies expectation struct of the FilesServiceHandler.GetContentThumbnail
type FilesServiceHandlerMockGetContentThumbnailExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockGetContentThumbnailParams
	paramPtrs          *FilesServiceHandlerMockGetContentThumbnailParamPtrs
	expectationOrigins FilesServiceHandlerMockGetContentThumbnailExpectationOrigins
	results            *FilesServiceHandlerMockGetContentThumbnailResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockGetContentThumbnailParams contains parameters of the FilesServiceHandler.GetContentThumbnail
type FilesServiceHandlerMockGetContentThumbnailParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetContentThumbnailRequest]
}

// FilesServiceHandlerMockGetContentThumbnailParamPtrs contains pointers to parameters of the FilesServiceHandler.GetContentThumbnail
type FilesServiceHandlerMockGetContentThumbnailParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetContentThumbnailRequest]
}

// FilesServiceHandlerMockGetContentThumbnailResults contains results of the FilesServiceHandler.GetContentThumbnail
type FilesServiceHandlerMockGetContentThumbnailResults struct {
	pp2 *connect.Response[v1.GetContentThumbnailResponse]
	err error
}

// FilesServiceHandlerMockGetContentThumbnailOrigins contains origins of expectations of the FilesServiceHandler.GetContentThumbnail
type FilesServiceHandlerMockGetContentThumbnailExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Optional() *mFilesServiceHandlerMockGetContentThumbnail {
	mmGetContentThumbnail.optional = true
	return mmGetContentThumbnail
}

// Expect sets up expected params for FilesServiceHandler.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Expect(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) *mFilesServiceHandlerMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceHandlerMockGetContentThumbnailExpectation{}
	}

	if mmGetContentThumbnail.defaultExpectation.paramPtrs != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by ExpectParams functions")
	}

	mmGetContentThumbnail.defaultExpectation.params = &FilesServiceHandlerMockGetContentThumbnailParams{ctx, pp1}
	mmGetContentThumbnail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetContentThumbnail.expectations {
		if minimock.Equal(e.params, mmGetContentThumbnail.defaultExpectation.params) {
			mmGetContentThumbnail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetContentThumbnail.defaultExpectation.params)
		}
	}

	return mmGetContentThumbnail
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceHandlerMockGetContentThumbnailExpectation{}
	}

	if mmGetContentThumbnail.defaultExpectation.params != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Expect")
	}

	if mmGetContentThumbnail.defaultExpectation.paramPtrs == nil {
		mmGetContentThumbnail.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetContentThumbnailParamPtrs{}
	}
	mmGetContentThumbnail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetContentThumbnail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetContentThumbnail
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) ExpectPp1Param2(pp1 *connect.Request[v1.GetContentThumbnailRequest]) *mFilesServiceHandlerMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceHandlerMockGetContentThumbnailExpectation{}
	}

	if mmGetContentThumbnail.defaultExpectation.params != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Expect")
	}

	if mmGetContentThumbnail.defaultExpectation.paramPtrs == nil {
		mmGetContentThumbnail.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetContentThumbnailParamPtrs{}
	}
	mmGetContentThumbnail.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetContentThumbnail.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetContentThumbnail
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest])) *mFilesServiceHandlerMockGetContentThumbnail {
	if mmGetContentThumbnail.mock.inspectFuncGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.GetContentThumbnail")
	}

	mmGetContentThumbnail.mock.inspectFuncGetContentThumbnail = f

	return mmGetContentThumbnail
}

// Return sets up results that will be returned by FilesServiceHandler.GetContentThumbnail
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Return(pp2 *connect.Response[v1.GetContentThumbnailResponse], err error) *FilesServiceHandlerMock {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Set")
	}

	if mmGetContentThumbnail.defaultExpectation == nil {
		mmGetContentThumbnail.defaultExpectation = &FilesServiceHandlerMockGetContentThumbnailExpectation{mock: mmGetContentThumbnail.mock}
	}
	mmGetContentThumbnail.defaultExpectation.results = &FilesServiceHandlerMockGetContentThumbnailResults{pp2, err}
	mmGetContentThumbnail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetContentThumbnail.mock
}

// Set uses given function f to mock the FilesServiceHandler.GetContentThumbnail method
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) (pp2 *connect.Response[v1.GetContentThumbnailResponse], err error)) *FilesServiceHandlerMock {
	if mmGetContentThumbnail.defaultExpectation != nil {
		mmGetContentThumbnail.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.GetContentThumbnail method")
	}

	if len(mmGetContentThumbnail.expectations) > 0 {
		mmGetContentThumbnail.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.GetContentThumbnail method")
	}

	mmGetContentThumbnail.mock.funcGetContentThumbnail = f
	mmGetContentThumbnail.mock.funcGetContentThumbnailOrigin = minimock.CallerInfo(1)
	return mmGetContentThumbnail.mock
}

// When sets expectation for the FilesServiceHandler.GetContentThumbnail which will trigger the result defined by the following
// Then helper
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) When(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) *FilesServiceHandlerMockGetContentThumbnailExpectation {
	if mmGetContentThumbnail.mock.funcGetContentThumbnail != nil {
		mmGetContentThumbnail.mock.t.Fatalf("FilesServiceHandlerMock.GetContentThumbnail mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockGetContentThumbnailExpectation{
		mock:               mmGetContentThumbnail.mock,
		params:             &FilesServiceHandlerMockGetContentThumbnailParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockGetContentThumbnailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetContentThumbnail.expectations = append(mmGetContentThumbnail.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.GetContentThumbnail return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockGetContentThumbnailExpectation) Then(pp2 *connect.Response[v1.GetContentThumbnailResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockGetContentThumbnailResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.GetContentThumbnail should be invoked
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Times(n uint64) *mFilesServiceHandlerMockGetContentThumbnail {
	if n == 0 {
		mmGetContentThumbnail.mock.t.Fatalf("Times of FilesServiceHandlerMock.GetContentThumbnail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetContentThumbnail.expectedInvocations, n)
	mmGetContentThumbnail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetContentThumbnail
}

func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) invocationsDone() bool {
	if len(mmGetContentThumbnail.expectations) == 0 && mmGetContentThumbnail.defaultExpectation == nil && mmGetContentThumbnail.mock.funcGetContentThumbnail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetContentThumbnail.mock.afterGetContentThumbnailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetContentThumbnail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetContentThumbnail implements mm_filesv1connect.FilesServiceHandler
func (mmGetContentThumbnail *FilesServiceHandlerMock) GetContentThumbnail(ctx context.Context, pp1 *connect.Request[v1.GetContentThumbnailRequest]) (pp2 *connect.Response[v1.GetContentThumbnailResponse], err error) {
	mm_atomic.AddUint64(&mmGetContentThumbnail.beforeGetContentThumbnailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetContentThumbnail.afterGetContentThumbnailCounter, 1)

	mmGetContentThumbnail.t.Helper()

	if mmGetContentThumbnail.inspectFuncGetContentThumbnail != nil {
		mmGetContentThumbnail.inspectFuncGetContentThumbnail(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockGetContentThumbnailParams{ctx, pp1}

	// Record call args
	mmGetContentThumbnail.GetContentThumbnailMock.mutex.Lock()
	mmGetContentThumbnail.GetContentThumbnailMock.callArgs = append(mmGetContentThumbnail.GetContentThumbnailMock.callArgs, &mm_params)
	mmGetContentThumbnail.GetContentThumbnailMock.mutex.Unlock()

	for _, e := range mmGetContentThumbnail.GetContentThumbnailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.params
		mm_want_ptrs := mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockGetContentThumbnailParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetContentThumbnail.t.Errorf("FilesServiceHandlerMock.GetContentThumbnail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetContentThumbnail.t.Errorf("FilesServiceHandlerMock.GetContentThumbnail got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetContentThumbnail.t.Errorf("FilesServiceHandlerMock.GetContentThumbnail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetContentThumbnail.GetContentThumbnailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetContentThumbnail.t.Fatal("No results are set for the FilesServiceHandlerMock.GetContentThumbnail")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetContentThumbnail.funcGetContentThumbnail != nil {
		return mmGetContentThumbnail.funcGetContentThumbnail(ctx, pp1)
	}
	mmGetContentThumbnail.t.Fatalf("Unexpected call to FilesServiceHandlerMock.GetContentThumbnail. %v %v", ctx, pp1)
	return
}

// GetContentThumbnailAfterCounter returns a count of finished FilesServiceHandlerMock.GetContentThumbnail invocations
func (mmGetContentThumbnail *FilesServiceHandlerMock) GetContentThumbnailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentThumbnail.afterGetContentThumbnailCounter)
}

// GetContentThumbnailBeforeCounter returns a count of FilesServiceHandlerMock.GetContentThumbnail invocations
func (mmGetContentThumbnail *FilesServiceHandlerMock) GetContentThumbnailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetContentThumbnail.beforeGetContentThumbnailCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.GetContentThumbnail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetContentThumbnail *mFilesServiceHandlerMockGetContentThumbnail) Calls() []*FilesServiceHandlerMockGetContentThumbnailParams {
	mmGetContentThumbnail.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockGetContentThumbnailParams, len(mmGetContentThumbnail.callArgs))
	copy(argCopy, mmGetContentThumbnail.callArgs)

	mmGetContentThumbnail.mutex.RUnlock()

	return argCopy
}

// MinimockGetContentThumbnailDone returns true if the count of the GetContentThumbnail invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockGetContentThumbnailDone() bool {
	if m.GetContentThumbnailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetContentThumbnailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetContentThumbnailMock.invocationsDone()
}

// MinimockGetContentThumbnailInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockGetContentThumbnailInspect() {
	for _, e := range m.GetContentThumbnailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentThumbnail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetContentThumbnailCounter := mm_atomic.LoadUint64(&m.afterGetContentThumbnailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetContentThumbnailMock.defaultExpectation != nil && afterGetContentThumbnailCounter < 1 {
		if m.GetContentThumbnailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentThumbnail at\n%s", m.GetContentThumbnailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentThumbnail at\n%s with params: %#v", m.GetContentThumbnailMock.defaultExpectation.expectationOrigins.origin, *m.GetContentThumbnailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetContentThumbnail != nil && afterGetContentThumbnailCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.GetContentThumbnail at\n%s", m.funcGetContentThumbnailOrigin)
	}

	if !m.GetContentThumbnailMock.invocationsDone() && afterGetContentThumbnailCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.GetContentThumbnail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetContentThumbnailMock.expectedInvocations), m.GetContentThumbnailMock.expectedInvocationsOrigin, afterGetContentThumbnailCounter)
	}
}

type mFilesServiceHandlerMockGetUrlPreview struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockGetUrlPreviewExpectation
	expectations       []*FilesServiceHandlerMockGetUrlPreviewExpectation

	callArgs []*FilesServiceHandlerMockGetUrlPreviewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockGetUrlPreviewExpectation specifies expectation struct of the FilesServiceHandler.GetUrlPreview
type FilesServiceHandlerMockGetUrlPreviewExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockGetUrlPreviewParams
	paramPtrs          *FilesServiceHandlerMockGetUrlPreviewParamPtrs
	expectationOrigins FilesServiceHandlerMockGetUrlPreviewExpectationOrigins
	results            *FilesServiceHandlerMockGetUrlPreviewResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockGetUrlPreviewParams contains parameters of the FilesServiceHandler.GetUrlPreview
type FilesServiceHandlerMockGetUrlPreviewParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetUrlPreviewRequest]
}

// FilesServiceHandlerMockGetUrlPreviewParamPtrs contains pointers to parameters of the FilesServiceHandler.GetUrlPreview
type FilesServiceHandlerMockGetUrlPreviewParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetUrlPreviewRequest]
}

// FilesServiceHandlerMockGetUrlPreviewResults contains results of the FilesServiceHandler.GetUrlPreview
type FilesServiceHandlerMockGetUrlPreviewResults struct {
	pp2 *connect.Response[v1.GetUrlPreviewResponse]
	err error
}

// FilesServiceHandlerMockGetUrlPreviewOrigins contains origins of expectations of the FilesServiceHandler.GetUrlPreview
type FilesServiceHandlerMockGetUrlPreviewExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Optional() *mFilesServiceHandlerMockGetUrlPreview {
	mmGetUrlPreview.optional = true
	return mmGetUrlPreview
}

// Expect sets up expected params for FilesServiceHandler.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Expect(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) *mFilesServiceHandlerMockGetUrlPreview {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceHandlerMockGetUrlPreviewExpectation{}
	}

	if mmGetUrlPreview.defaultExpectation.paramPtrs != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by ExpectParams functions")
	}

	mmGetUrlPreview.defaultExpectation.params = &FilesServiceHandlerMockGetUrlPreviewParams{ctx, pp1}
	mmGetUrlPreview.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUrlPreview.expectations {
		if minimock.Equal(e.params, mmGetUrlPreview.defaultExpectation.params) {
			mmGetUrlPreview.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUrlPreview.defaultExpectation.params)
		}
	}

	return mmGetUrlPreview
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockGetUrlPreview {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceHandlerMockGetUrlPreviewExpectation{}
	}

	if mmGetUrlPreview.defaultExpectation.params != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Expect")
	}

	if mmGetUrlPreview.defaultExpectation.paramPtrs == nil {
		mmGetUrlPreview.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetUrlPreviewParamPtrs{}
	}
	mmGetUrlPreview.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUrlPreview.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUrlPreview
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) ExpectPp1Param2(pp1 *connect.Request[v1.GetUrlPreviewRequest]) *mFilesServiceHandlerMockGetUrlPreview {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceHandlerMockGetUrlPreviewExpectation{}
	}

	if mmGetUrlPreview.defaultExpectation.params != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Expect")
	}

	if mmGetUrlPreview.defaultExpectation.paramPtrs == nil {
		mmGetUrlPreview.defaultExpectation.paramPtrs = &FilesServiceHandlerMockGetUrlPreviewParamPtrs{}
	}
	mmGetUrlPreview.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetUrlPreview.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetUrlPreview
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest])) *mFilesServiceHandlerMockGetUrlPreview {
	if mmGetUrlPreview.mock.inspectFuncGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.GetUrlPreview")
	}

	mmGetUrlPreview.mock.inspectFuncGetUrlPreview = f

	return mmGetUrlPreview
}

// Return sets up results that will be returned by FilesServiceHandler.GetUrlPreview
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Return(pp2 *connect.Response[v1.GetUrlPreviewResponse], err error) *FilesServiceHandlerMock {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Set")
	}

	if mmGetUrlPreview.defaultExpectation == nil {
		mmGetUrlPreview.defaultExpectation = &FilesServiceHandlerMockGetUrlPreviewExpectation{mock: mmGetUrlPreview.mock}
	}
	mmGetUrlPreview.defaultExpectation.results = &FilesServiceHandlerMockGetUrlPreviewResults{pp2, err}
	mmGetUrlPreview.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUrlPreview.mock
}

// Set uses given function f to mock the FilesServiceHandler.GetUrlPreview method
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) (pp2 *connect.Response[v1.GetUrlPreviewResponse], err error)) *FilesServiceHandlerMock {
	if mmGetUrlPreview.defaultExpectation != nil {
		mmGetUrlPreview.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.GetUrlPreview method")
	}

	if len(mmGetUrlPreview.expectations) > 0 {
		mmGetUrlPreview.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.GetUrlPreview method")
	}

	mmGetUrlPreview.mock.funcGetUrlPreview = f
	mmGetUrlPreview.mock.funcGetUrlPreviewOrigin = minimock.CallerInfo(1)
	return mmGetUrlPreview.mock
}

// When sets expectation for the FilesServiceHandler.GetUrlPreview which will trigger the result defined by the following
// Then helper
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) When(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) *FilesServiceHandlerMockGetUrlPreviewExpectation {
	if mmGetUrlPreview.mock.funcGetUrlPreview != nil {
		mmGetUrlPreview.mock.t.Fatalf("FilesServiceHandlerMock.GetUrlPreview mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockGetUrlPreviewExpectation{
		mock:               mmGetUrlPreview.mock,
		params:             &FilesServiceHandlerMockGetUrlPreviewParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockGetUrlPreviewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUrlPreview.expectations = append(mmGetUrlPreview.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.GetUrlPreview return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockGetUrlPreviewExpectation) Then(pp2 *connect.Response[v1.GetUrlPreviewResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockGetUrlPreviewResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.GetUrlPreview should be invoked
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Times(n uint64) *mFilesServiceHandlerMockGetUrlPreview {
	if n == 0 {
		mmGetUrlPreview.mock.t.Fatalf("Times of FilesServiceHandlerMock.GetUrlPreview mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUrlPreview.expectedInvocations, n)
	mmGetUrlPreview.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUrlPreview
}

func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) invocationsDone() bool {
	if len(mmGetUrlPreview.expectations) == 0 && mmGetUrlPreview.defaultExpectation == nil && mmGetUrlPreview.mock.funcGetUrlPreview == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUrlPreview.mock.afterGetUrlPreviewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUrlPreview.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUrlPreview implements mm_filesv1connect.FilesServiceHandler
func (mmGetUrlPreview *FilesServiceHandlerMock) GetUrlPreview(ctx context.Context, pp1 *connect.Request[v1.GetUrlPreviewRequest]) (pp2 *connect.Response[v1.GetUrlPreviewResponse], err error) {
	mm_atomic.AddUint64(&mmGetUrlPreview.beforeGetUrlPreviewCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUrlPreview.afterGetUrlPreviewCounter, 1)

	mmGetUrlPreview.t.Helper()

	if mmGetUrlPreview.inspectFuncGetUrlPreview != nil {
		mmGetUrlPreview.inspectFuncGetUrlPreview(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockGetUrlPreviewParams{ctx, pp1}

	// Record call args
	mmGetUrlPreview.GetUrlPreviewMock.mutex.Lock()
	mmGetUrlPreview.GetUrlPreviewMock.callArgs = append(mmGetUrlPreview.GetUrlPreviewMock.callArgs, &mm_params)
	mmGetUrlPreview.GetUrlPreviewMock.mutex.Unlock()

	for _, e := range mmGetUrlPreview.GetUrlPreviewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.params
		mm_want_ptrs := mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockGetUrlPreviewParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUrlPreview.t.Errorf("FilesServiceHandlerMock.GetUrlPreview got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetUrlPreview.t.Errorf("FilesServiceHandlerMock.GetUrlPreview got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUrlPreview.t.Errorf("FilesServiceHandlerMock.GetUrlPreview got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUrlPreview.GetUrlPreviewMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUrlPreview.t.Fatal("No results are set for the FilesServiceHandlerMock.GetUrlPreview")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetUrlPreview.funcGetUrlPreview != nil {
		return mmGetUrlPreview.funcGetUrlPreview(ctx, pp1)
	}
	mmGetUrlPreview.t.Fatalf("Unexpected call to FilesServiceHandlerMock.GetUrlPreview. %v %v", ctx, pp1)
	return
}

// GetUrlPreviewAfterCounter returns a count of finished FilesServiceHandlerMock.GetUrlPreview invocations
func (mmGetUrlPreview *FilesServiceHandlerMock) GetUrlPreviewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUrlPreview.afterGetUrlPreviewCounter)
}

// GetUrlPreviewBeforeCounter returns a count of FilesServiceHandlerMock.GetUrlPreview invocations
func (mmGetUrlPreview *FilesServiceHandlerMock) GetUrlPreviewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUrlPreview.beforeGetUrlPreviewCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.GetUrlPreview.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUrlPreview *mFilesServiceHandlerMockGetUrlPreview) Calls() []*FilesServiceHandlerMockGetUrlPreviewParams {
	mmGetUrlPreview.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockGetUrlPreviewParams, len(mmGetUrlPreview.callArgs))
	copy(argCopy, mmGetUrlPreview.callArgs)

	mmGetUrlPreview.mutex.RUnlock()

	return argCopy
}

// MinimockGetUrlPreviewDone returns true if the count of the GetUrlPreview invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockGetUrlPreviewDone() bool {
	if m.GetUrlPreviewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUrlPreviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUrlPreviewMock.invocationsDone()
}

// MinimockGetUrlPreviewInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockGetUrlPreviewInspect() {
	for _, e := range m.GetUrlPreviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetUrlPreview at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUrlPreviewCounter := mm_atomic.LoadUint64(&m.afterGetUrlPreviewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUrlPreviewMock.defaultExpectation != nil && afterGetUrlPreviewCounter < 1 {
		if m.GetUrlPreviewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetUrlPreview at\n%s", m.GetUrlPreviewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.GetUrlPreview at\n%s with params: %#v", m.GetUrlPreviewMock.defaultExpectation.expectationOrigins.origin, *m.GetUrlPreviewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUrlPreview != nil && afterGetUrlPreviewCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.GetUrlPreview at\n%s", m.funcGetUrlPreviewOrigin)
	}

	if !m.GetUrlPreviewMock.invocationsDone() && afterGetUrlPreviewCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.GetUrlPreview at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUrlPreviewMock.expectedInvocations), m.GetUrlPreviewMock.expectedInvocationsOrigin, afterGetUrlPreviewCounter)
	}
}

type mFilesServiceHandlerMockSearchMedia struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockSearchMediaExpectation
	expectations       []*FilesServiceHandlerMockSearchMediaExpectation

	callArgs []*FilesServiceHandlerMockSearchMediaParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockSearchMediaExpectation specifies expectation struct of the FilesServiceHandler.SearchMedia
type FilesServiceHandlerMockSearchMediaExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockSearchMediaParams
	paramPtrs          *FilesServiceHandlerMockSearchMediaParamPtrs
	expectationOrigins FilesServiceHandlerMockSearchMediaExpectationOrigins
	results            *FilesServiceHandlerMockSearchMediaResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockSearchMediaParams contains parameters of the FilesServiceHandler.SearchMedia
type FilesServiceHandlerMockSearchMediaParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchMediaRequest]
}

// FilesServiceHandlerMockSearchMediaParamPtrs contains pointers to parameters of the FilesServiceHandler.SearchMedia
type FilesServiceHandlerMockSearchMediaParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchMediaRequest]
}

// FilesServiceHandlerMockSearchMediaResults contains results of the FilesServiceHandler.SearchMedia
type FilesServiceHandlerMockSearchMediaResults struct {
	pp2 *connect.Response[v1.SearchMediaResponse]
	err error
}

// FilesServiceHandlerMockSearchMediaOrigins contains origins of expectations of the FilesServiceHandler.SearchMedia
type FilesServiceHandlerMockSearchMediaExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Optional() *mFilesServiceHandlerMockSearchMedia {
	mmSearchMedia.optional = true
	return mmSearchMedia
}

// Expect sets up expected params for FilesServiceHandler.SearchMedia
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) *mFilesServiceHandlerMockSearchMedia {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceHandlerMockSearchMediaExpectation{}
	}

	if mmSearchMedia.defaultExpectation.paramPtrs != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by ExpectParams functions")
	}

	mmSearchMedia.defaultExpectation.params = &FilesServiceHandlerMockSearchMediaParams{ctx, pp1}
	mmSearchMedia.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchMedia.expectations {
		if minimock.Equal(e.params, mmSearchMedia.defaultExpectation.params) {
			mmSearchMedia.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchMedia.defaultExpectation.params)
		}
	}

	return mmSearchMedia
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.SearchMedia
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockSearchMedia {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceHandlerMockSearchMediaExpectation{}
	}

	if mmSearchMedia.defaultExpectation.params != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Expect")
	}

	if mmSearchMedia.defaultExpectation.paramPtrs == nil {
		mmSearchMedia.defaultExpectation.paramPtrs = &FilesServiceHandlerMockSearchMediaParamPtrs{}
	}
	mmSearchMedia.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchMedia.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchMedia
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.SearchMedia
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) ExpectPp1Param2(pp1 *connect.Request[v1.SearchMediaRequest]) *mFilesServiceHandlerMockSearchMedia {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceHandlerMockSearchMediaExpectation{}
	}

	if mmSearchMedia.defaultExpectation.params != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Expect")
	}

	if mmSearchMedia.defaultExpectation.paramPtrs == nil {
		mmSearchMedia.defaultExpectation.paramPtrs = &FilesServiceHandlerMockSearchMediaParamPtrs{}
	}
	mmSearchMedia.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchMedia.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchMedia
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.SearchMedia
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest])) *mFilesServiceHandlerMockSearchMedia {
	if mmSearchMedia.mock.inspectFuncSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.SearchMedia")
	}

	mmSearchMedia.mock.inspectFuncSearchMedia = f

	return mmSearchMedia
}

// Return sets up results that will be returned by FilesServiceHandler.SearchMedia
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Return(pp2 *connect.Response[v1.SearchMediaResponse], err error) *FilesServiceHandlerMock {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Set")
	}

	if mmSearchMedia.defaultExpectation == nil {
		mmSearchMedia.defaultExpectation = &FilesServiceHandlerMockSearchMediaExpectation{mock: mmSearchMedia.mock}
	}
	mmSearchMedia.defaultExpectation.results = &FilesServiceHandlerMockSearchMediaResults{pp2, err}
	mmSearchMedia.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchMedia.mock
}

// Set uses given function f to mock the FilesServiceHandler.SearchMedia method
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) (pp2 *connect.Response[v1.SearchMediaResponse], err error)) *FilesServiceHandlerMock {
	if mmSearchMedia.defaultExpectation != nil {
		mmSearchMedia.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.SearchMedia method")
	}

	if len(mmSearchMedia.expectations) > 0 {
		mmSearchMedia.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.SearchMedia method")
	}

	mmSearchMedia.mock.funcSearchMedia = f
	mmSearchMedia.mock.funcSearchMediaOrigin = minimock.CallerInfo(1)
	return mmSearchMedia.mock
}

// When sets expectation for the FilesServiceHandler.SearchMedia which will trigger the result defined by the following
// Then helper
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) When(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) *FilesServiceHandlerMockSearchMediaExpectation {
	if mmSearchMedia.mock.funcSearchMedia != nil {
		mmSearchMedia.mock.t.Fatalf("FilesServiceHandlerMock.SearchMedia mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockSearchMediaExpectation{
		mock:               mmSearchMedia.mock,
		params:             &FilesServiceHandlerMockSearchMediaParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockSearchMediaExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchMedia.expectations = append(mmSearchMedia.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.SearchMedia return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockSearchMediaExpectation) Then(pp2 *connect.Response[v1.SearchMediaResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockSearchMediaResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.SearchMedia should be invoked
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Times(n uint64) *mFilesServiceHandlerMockSearchMedia {
	if n == 0 {
		mmSearchMedia.mock.t.Fatalf("Times of FilesServiceHandlerMock.SearchMedia mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchMedia.expectedInvocations, n)
	mmSearchMedia.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchMedia
}

func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) invocationsDone() bool {
	if len(mmSearchMedia.expectations) == 0 && mmSearchMedia.defaultExpectation == nil && mmSearchMedia.mock.funcSearchMedia == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchMedia.mock.afterSearchMediaCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchMedia.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchMedia implements mm_filesv1connect.FilesServiceHandler
func (mmSearchMedia *FilesServiceHandlerMock) SearchMedia(ctx context.Context, pp1 *connect.Request[v1.SearchMediaRequest]) (pp2 *connect.Response[v1.SearchMediaResponse], err error) {
	mm_atomic.AddUint64(&mmSearchMedia.beforeSearchMediaCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchMedia.afterSearchMediaCounter, 1)

	mmSearchMedia.t.Helper()

	if mmSearchMedia.inspectFuncSearchMedia != nil {
		mmSearchMedia.inspectFuncSearchMedia(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockSearchMediaParams{ctx, pp1}

	// Record call args
	mmSearchMedia.SearchMediaMock.mutex.Lock()
	mmSearchMedia.SearchMediaMock.callArgs = append(mmSearchMedia.SearchMediaMock.callArgs, &mm_params)
	mmSearchMedia.SearchMediaMock.mutex.Unlock()

	for _, e := range mmSearchMedia.SearchMediaMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchMedia.SearchMediaMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchMedia.SearchMediaMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchMedia.SearchMediaMock.defaultExpectation.params
		mm_want_ptrs := mmSearchMedia.SearchMediaMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockSearchMediaParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchMedia.t.Errorf("FilesServiceHandlerMock.SearchMedia got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchMedia.SearchMediaMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchMedia.t.Errorf("FilesServiceHandlerMock.SearchMedia got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchMedia.SearchMediaMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchMedia.t.Errorf("FilesServiceHandlerMock.SearchMedia got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchMedia.SearchMediaMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchMedia.SearchMediaMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchMedia.t.Fatal("No results are set for the FilesServiceHandlerMock.SearchMedia")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchMedia.funcSearchMedia != nil {
		return mmSearchMedia.funcSearchMedia(ctx, pp1)
	}
	mmSearchMedia.t.Fatalf("Unexpected call to FilesServiceHandlerMock.SearchMedia. %v %v", ctx, pp1)
	return
}

// SearchMediaAfterCounter returns a count of finished FilesServiceHandlerMock.SearchMedia invocations
func (mmSearchMedia *FilesServiceHandlerMock) SearchMediaAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchMedia.afterSearchMediaCounter)
}

// SearchMediaBeforeCounter returns a count of FilesServiceHandlerMock.SearchMedia invocations
func (mmSearchMedia *FilesServiceHandlerMock) SearchMediaBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchMedia.beforeSearchMediaCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.SearchMedia.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchMedia *mFilesServiceHandlerMockSearchMedia) Calls() []*FilesServiceHandlerMockSearchMediaParams {
	mmSearchMedia.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockSearchMediaParams, len(mmSearchMedia.callArgs))
	copy(argCopy, mmSearchMedia.callArgs)

	mmSearchMedia.mutex.RUnlock()

	return argCopy
}

// MinimockSearchMediaDone returns true if the count of the SearchMedia invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockSearchMediaDone() bool {
	if m.SearchMediaMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMediaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMediaMock.invocationsDone()
}

// MinimockSearchMediaInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockSearchMediaInspect() {
	for _, e := range m.SearchMediaMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.SearchMedia at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchMediaCounter := mm_atomic.LoadUint64(&m.afterSearchMediaCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMediaMock.defaultExpectation != nil && afterSearchMediaCounter < 1 {
		if m.SearchMediaMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.SearchMedia at\n%s", m.SearchMediaMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.SearchMedia at\n%s with params: %#v", m.SearchMediaMock.defaultExpectation.expectationOrigins.origin, *m.SearchMediaMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchMedia != nil && afterSearchMediaCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.SearchMedia at\n%s", m.funcSearchMediaOrigin)
	}

	if !m.SearchMediaMock.invocationsDone() && afterSearchMediaCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.SearchMedia at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMediaMock.expectedInvocations), m.SearchMediaMock.expectedInvocationsOrigin, afterSearchMediaCounter)
	}
}

type mFilesServiceHandlerMockUploadContent struct {
	optional           bool
	mock               *FilesServiceHandlerMock
	defaultExpectation *FilesServiceHandlerMockUploadContentExpectation
	expectations       []*FilesServiceHandlerMockUploadContentExpectation

	callArgs []*FilesServiceHandlerMockUploadContentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FilesServiceHandlerMockUploadContentExpectation specifies expectation struct of the FilesServiceHandler.UploadContent
type FilesServiceHandlerMockUploadContentExpectation struct {
	mock               *FilesServiceHandlerMock
	params             *FilesServiceHandlerMockUploadContentParams
	paramPtrs          *FilesServiceHandlerMockUploadContentParamPtrs
	expectationOrigins FilesServiceHandlerMockUploadContentExpectationOrigins
	results            *FilesServiceHandlerMockUploadContentResults
	returnOrigin       string
	Counter            uint64
}

// FilesServiceHandlerMockUploadContentParams contains parameters of the FilesServiceHandler.UploadContent
type FilesServiceHandlerMockUploadContentParams struct {
	ctx context.Context
	pp1 *connect.ClientStream[v1.UploadContentRequest]
}

// FilesServiceHandlerMockUploadContentParamPtrs contains pointers to parameters of the FilesServiceHandler.UploadContent
type FilesServiceHandlerMockUploadContentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.ClientStream[v1.UploadContentRequest]
}

// FilesServiceHandlerMockUploadContentResults contains results of the FilesServiceHandler.UploadContent
type FilesServiceHandlerMockUploadContentResults struct {
	pp2 *connect.Response[v1.UploadContentResponse]
	err error
}

// FilesServiceHandlerMockUploadContentOrigins contains origins of expectations of the FilesServiceHandler.UploadContent
type FilesServiceHandlerMockUploadContentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Optional() *mFilesServiceHandlerMockUploadContent {
	mmUploadContent.optional = true
	return mmUploadContent
}

// Expect sets up expected params for FilesServiceHandler.UploadContent
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Expect(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest]) *mFilesServiceHandlerMockUploadContent {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceHandlerMockUploadContentExpectation{}
	}

	if mmUploadContent.defaultExpectation.paramPtrs != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by ExpectParams functions")
	}

	mmUploadContent.defaultExpectation.params = &FilesServiceHandlerMockUploadContentParams{ctx, pp1}
	mmUploadContent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUploadContent.expectations {
		if minimock.Equal(e.params, mmUploadContent.defaultExpectation.params) {
			mmUploadContent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadContent.defaultExpectation.params)
		}
	}

	return mmUploadContent
}

// ExpectCtxParam1 sets up expected param ctx for FilesServiceHandler.UploadContent
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) ExpectCtxParam1(ctx context.Context) *mFilesServiceHandlerMockUploadContent {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceHandlerMockUploadContentExpectation{}
	}

	if mmUploadContent.defaultExpectation.params != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Expect")
	}

	if mmUploadContent.defaultExpectation.paramPtrs == nil {
		mmUploadContent.defaultExpectation.paramPtrs = &FilesServiceHandlerMockUploadContentParamPtrs{}
	}
	mmUploadContent.defaultExpectation.paramPtrs.ctx = &ctx
	mmUploadContent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUploadContent
}

// ExpectPp1Param2 sets up expected param pp1 for FilesServiceHandler.UploadContent
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) ExpectPp1Param2(pp1 *connect.ClientStream[v1.UploadContentRequest]) *mFilesServiceHandlerMockUploadContent {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceHandlerMockUploadContentExpectation{}
	}

	if mmUploadContent.defaultExpectation.params != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Expect")
	}

	if mmUploadContent.defaultExpectation.paramPtrs == nil {
		mmUploadContent.defaultExpectation.paramPtrs = &FilesServiceHandlerMockUploadContentParamPtrs{}
	}
	mmUploadContent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUploadContent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUploadContent
}

// Inspect accepts an inspector function that has same arguments as the FilesServiceHandler.UploadContent
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Inspect(f func(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest])) *mFilesServiceHandlerMockUploadContent {
	if mmUploadContent.mock.inspectFuncUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("Inspect function is already set for FilesServiceHandlerMock.UploadContent")
	}

	mmUploadContent.mock.inspectFuncUploadContent = f

	return mmUploadContent
}

// Return sets up results that will be returned by FilesServiceHandler.UploadContent
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Return(pp2 *connect.Response[v1.UploadContentResponse], err error) *FilesServiceHandlerMock {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Set")
	}

	if mmUploadContent.defaultExpectation == nil {
		mmUploadContent.defaultExpectation = &FilesServiceHandlerMockUploadContentExpectation{mock: mmUploadContent.mock}
	}
	mmUploadContent.defaultExpectation.results = &FilesServiceHandlerMockUploadContentResults{pp2, err}
	mmUploadContent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUploadContent.mock
}

// Set uses given function f to mock the FilesServiceHandler.UploadContent method
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Set(f func(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest]) (pp2 *connect.Response[v1.UploadContentResponse], err error)) *FilesServiceHandlerMock {
	if mmUploadContent.defaultExpectation != nil {
		mmUploadContent.mock.t.Fatalf("Default expectation is already set for the FilesServiceHandler.UploadContent method")
	}

	if len(mmUploadContent.expectations) > 0 {
		mmUploadContent.mock.t.Fatalf("Some expectations are already set for the FilesServiceHandler.UploadContent method")
	}

	mmUploadContent.mock.funcUploadContent = f
	mmUploadContent.mock.funcUploadContentOrigin = minimock.CallerInfo(1)
	return mmUploadContent.mock
}

// When sets expectation for the FilesServiceHandler.UploadContent which will trigger the result defined by the following
// Then helper
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) When(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest]) *FilesServiceHandlerMockUploadContentExpectation {
	if mmUploadContent.mock.funcUploadContent != nil {
		mmUploadContent.mock.t.Fatalf("FilesServiceHandlerMock.UploadContent mock is already set by Set")
	}

	expectation := &FilesServiceHandlerMockUploadContentExpectation{
		mock:               mmUploadContent.mock,
		params:             &FilesServiceHandlerMockUploadContentParams{ctx, pp1},
		expectationOrigins: FilesServiceHandlerMockUploadContentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUploadContent.expectations = append(mmUploadContent.expectations, expectation)
	return expectation
}

// Then sets up FilesServiceHandler.UploadContent return parameters for the expectation previously defined by the When method
func (e *FilesServiceHandlerMockUploadContentExpectation) Then(pp2 *connect.Response[v1.UploadContentResponse], err error) *FilesServiceHandlerMock {
	e.results = &FilesServiceHandlerMockUploadContentResults{pp2, err}
	return e.mock
}

// Times sets number of times FilesServiceHandler.UploadContent should be invoked
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Times(n uint64) *mFilesServiceHandlerMockUploadContent {
	if n == 0 {
		mmUploadContent.mock.t.Fatalf("Times of FilesServiceHandlerMock.UploadContent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadContent.expectedInvocations, n)
	mmUploadContent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUploadContent
}

func (mmUploadContent *mFilesServiceHandlerMockUploadContent) invocationsDone() bool {
	if len(mmUploadContent.expectations) == 0 && mmUploadContent.defaultExpectation == nil && mmUploadContent.mock.funcUploadContent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadContent.mock.afterUploadContentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadContent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadContent implements mm_filesv1connect.FilesServiceHandler
func (mmUploadContent *FilesServiceHandlerMock) UploadContent(ctx context.Context, pp1 *connect.ClientStream[v1.UploadContentRequest]) (pp2 *connect.Response[v1.UploadContentResponse], err error) {
	mm_atomic.AddUint64(&mmUploadContent.beforeUploadContentCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadContent.afterUploadContentCounter, 1)

	mmUploadContent.t.Helper()

	if mmUploadContent.inspectFuncUploadContent != nil {
		mmUploadContent.inspectFuncUploadContent(ctx, pp1)
	}

	mm_params := FilesServiceHandlerMockUploadContentParams{ctx, pp1}

	// Record call args
	mmUploadContent.UploadContentMock.mutex.Lock()
	mmUploadContent.UploadContentMock.callArgs = append(mmUploadContent.UploadContentMock.callArgs, &mm_params)
	mmUploadContent.UploadContentMock.mutex.Unlock()

	for _, e := range mmUploadContent.UploadContentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUploadContent.UploadContentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadContent.UploadContentMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadContent.UploadContentMock.defaultExpectation.params
		mm_want_ptrs := mmUploadContent.UploadContentMock.defaultExpectation.paramPtrs

		mm_got := FilesServiceHandlerMockUploadContentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadContent.t.Errorf("FilesServiceHandlerMock.UploadContent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadContent.UploadContentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUploadContent.t.Errorf("FilesServiceHandlerMock.UploadContent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUploadContent.UploadContentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadContent.t.Errorf("FilesServiceHandlerMock.UploadContent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUploadContent.UploadContentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadContent.UploadContentMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadContent.t.Fatal("No results are set for the FilesServiceHandlerMock.UploadContent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUploadContent.funcUploadContent != nil {
		return mmUploadContent.funcUploadContent(ctx, pp1)
	}
	mmUploadContent.t.Fatalf("Unexpected call to FilesServiceHandlerMock.UploadContent. %v %v", ctx, pp1)
	return
}

// UploadContentAfterCounter returns a count of finished FilesServiceHandlerMock.UploadContent invocations
func (mmUploadContent *FilesServiceHandlerMock) UploadContentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadContent.afterUploadContentCounter)
}

// UploadContentBeforeCounter returns a count of FilesServiceHandlerMock.UploadContent invocations
func (mmUploadContent *FilesServiceHandlerMock) UploadContentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadContent.beforeUploadContentCounter)
}

// Calls returns a list of arguments used in each call to FilesServiceHandlerMock.UploadContent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadContent *mFilesServiceHandlerMockUploadContent) Calls() []*FilesServiceHandlerMockUploadContentParams {
	mmUploadContent.mutex.RLock()

	argCopy := make([]*FilesServiceHandlerMockUploadContentParams, len(mmUploadContent.callArgs))
	copy(argCopy, mmUploadContent.callArgs)

	mmUploadContent.mutex.RUnlock()

	return argCopy
}

// MinimockUploadContentDone returns true if the count of the UploadContent invocations corresponds
// the number of defined expectations
func (m *FilesServiceHandlerMock) MinimockUploadContentDone() bool {
	if m.UploadContentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadContentMock.invocationsDone()
}

// MinimockUploadContentInspect logs each unmet expectation
func (m *FilesServiceHandlerMock) MinimockUploadContentInspect() {
	for _, e := range m.UploadContentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.UploadContent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUploadContentCounter := mm_atomic.LoadUint64(&m.afterUploadContentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadContentMock.defaultExpectation != nil && afterUploadContentCounter < 1 {
		if m.UploadContentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.UploadContent at\n%s", m.UploadContentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FilesServiceHandlerMock.UploadContent at\n%s with params: %#v", m.UploadContentMock.defaultExpectation.expectationOrigins.origin, *m.UploadContentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadContent != nil && afterUploadContentCounter < 1 {
		m.t.Errorf("Expected call to FilesServiceHandlerMock.UploadContent at\n%s", m.funcUploadContentOrigin)
	}

	if !m.UploadContentMock.invocationsDone() && afterUploadContentCounter > 0 {
		m.t.Errorf("Expected %d calls to FilesServiceHandlerMock.UploadContent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UploadContentMock.expectedInvocations), m.UploadContentMock.expectedInvocationsOrigin, afterUploadContentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FilesServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateContentInspect()

			m.MinimockGetConfigInspect()

			m.MinimockGetContentInspect()

			m.MinimockGetContentOverrideNameInspect()

			m.MinimockGetContentThumbnailInspect()

			m.MinimockGetUrlPreviewInspect()

			m.MinimockSearchMediaInspect()

			m.MinimockUploadContentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FilesServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FilesServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateContentDone() &&
		m.MinimockGetConfigDone() &&
		m.MinimockGetContentDone() &&
		m.MinimockGetContentOverrideNameDone() &&
		m.MinimockGetContentThumbnailDone() &&
		m.MinimockGetUrlPreviewDone() &&
		m.MinimockSearchMediaDone() &&
		m.MinimockUploadContentDone()
}
