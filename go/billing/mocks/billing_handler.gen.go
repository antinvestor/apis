// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/billing/connectrpc/go/billing/v1/billingv1connect.BillingServiceClient -o billing_handler.gen.go -n BillingServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/billing/protocolbuffers/go/billing/v1"
	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// BillingServiceClientMock implements mm_billingv1connect.BillingServiceClient
type BillingServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelSubscription          func(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest]) (pp2 *connect.Response[v1.CancelSubscriptionResponse], err error)
	funcCancelSubscriptionOrigin    string
	inspectFuncCancelSubscription   func(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest])
	afterCancelSubscriptionCounter  uint64
	beforeCancelSubscriptionCounter uint64
	CancelSubscriptionMock          mBillingServiceClientMockCancelSubscription

	funcCreateCatalogVersion          func(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest]) (pp2 *connect.Response[v1.CreateCatalogVersionResponse], err error)
	funcCreateCatalogVersionOrigin    string
	inspectFuncCreateCatalogVersion   func(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest])
	afterCreateCatalogVersionCounter  uint64
	beforeCreateCatalogVersionCounter uint64
	CreateCatalogVersionMock          mBillingServiceClientMockCreateCatalogVersion

	funcCreateComponent          func(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest]) (pp2 *connect.Response[v1.CreateComponentResponse], err error)
	funcCreateComponentOrigin    string
	inspectFuncCreateComponent   func(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest])
	afterCreateComponentCounter  uint64
	beforeCreateComponentCounter uint64
	CreateComponentMock          mBillingServiceClientMockCreateComponent

	funcCreateDiscount          func(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest]) (pp2 *connect.Response[v1.CreateDiscountResponse], err error)
	funcCreateDiscountOrigin    string
	inspectFuncCreateDiscount   func(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest])
	afterCreateDiscountCounter  uint64
	beforeCreateDiscountCounter uint64
	CreateDiscountMock          mBillingServiceClientMockCreateDiscount

	funcCreatePlan          func(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest]) (pp2 *connect.Response[v1.CreatePlanResponse], err error)
	funcCreatePlanOrigin    string
	inspectFuncCreatePlan   func(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest])
	afterCreatePlanCounter  uint64
	beforeCreatePlanCounter uint64
	CreatePlanMock          mBillingServiceClientMockCreatePlan

	funcCreateSubscription          func(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest]) (pp2 *connect.Response[v1.CreateSubscriptionResponse], err error)
	funcCreateSubscriptionOrigin    string
	inspectFuncCreateSubscription   func(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest])
	afterCreateSubscriptionCounter  uint64
	beforeCreateSubscriptionCounter uint64
	CreateSubscriptionMock          mBillingServiceClientMockCreateSubscription

	funcCreateTier          func(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest]) (pp2 *connect.Response[v1.CreateTierResponse], err error)
	funcCreateTierOrigin    string
	inspectFuncCreateTier   func(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest])
	afterCreateTierCounter  uint64
	beforeCreateTierCounter uint64
	CreateTierMock          mBillingServiceClientMockCreateTier

	funcGetBillingRun          func(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest]) (pp2 *connect.Response[v1.GetBillingRunResponse], err error)
	funcGetBillingRunOrigin    string
	inspectFuncGetBillingRun   func(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest])
	afterGetBillingRunCounter  uint64
	beforeGetBillingRunCounter uint64
	GetBillingRunMock          mBillingServiceClientMockGetBillingRun

	funcGetCatalogVersion          func(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest]) (pp2 *connect.Response[v1.GetCatalogVersionResponse], err error)
	funcGetCatalogVersionOrigin    string
	inspectFuncGetCatalogVersion   func(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest])
	afterGetCatalogVersionCounter  uint64
	beforeGetCatalogVersionCounter uint64
	GetCatalogVersionMock          mBillingServiceClientMockGetCatalogVersion

	funcGetCreditBalance          func(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest]) (pp2 *connect.Response[v1.GetCreditBalanceResponse], err error)
	funcGetCreditBalanceOrigin    string
	inspectFuncGetCreditBalance   func(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest])
	afterGetCreditBalanceCounter  uint64
	beforeGetCreditBalanceCounter uint64
	GetCreditBalanceMock          mBillingServiceClientMockGetCreditBalance

	funcGetInvoice          func(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest]) (pp2 *connect.Response[v1.GetInvoiceResponse], err error)
	funcGetInvoiceOrigin    string
	inspectFuncGetInvoice   func(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest])
	afterGetInvoiceCounter  uint64
	beforeGetInvoiceCounter uint64
	GetInvoiceMock          mBillingServiceClientMockGetInvoice

	funcGetSubscription          func(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest]) (pp2 *connect.Response[v1.GetSubscriptionResponse], err error)
	funcGetSubscriptionOrigin    string
	inspectFuncGetSubscription   func(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest])
	afterGetSubscriptionCounter  uint64
	beforeGetSubscriptionCounter uint64
	GetSubscriptionMock          mBillingServiceClientMockGetSubscription

	funcGrantCredit          func(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest]) (pp2 *connect.Response[v1.GrantCreditResponse], err error)
	funcGrantCreditOrigin    string
	inspectFuncGrantCredit   func(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest])
	afterGrantCreditCounter  uint64
	beforeGrantCreditCounter uint64
	GrantCreditMock          mBillingServiceClientMockGrantCredit

	funcIngestUsageBatch          func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest]) (pp2 *connect.Response[v1.IngestUsageBatchResponse], err error)
	funcIngestUsageBatchOrigin    string
	inspectFuncIngestUsageBatch   func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest])
	afterIngestUsageBatchCounter  uint64
	beforeIngestUsageBatchCounter uint64
	IngestUsageBatchMock          mBillingServiceClientMockIngestUsageBatch

	funcIngestUsageEvent          func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest]) (pp2 *connect.Response[v1.IngestUsageEventResponse], err error)
	funcIngestUsageEventOrigin    string
	inspectFuncIngestUsageEvent   func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest])
	afterIngestUsageEventCounter  uint64
	beforeIngestUsageEventCounter uint64
	IngestUsageEventMock          mBillingServiceClientMockIngestUsageEvent

	funcIssueInvoice          func(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest]) (pp2 *connect.Response[v1.IssueInvoiceResponse], err error)
	funcIssueInvoiceOrigin    string
	inspectFuncIssueInvoice   func(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest])
	afterIssueInvoiceCounter  uint64
	beforeIssueInvoiceCounter uint64
	IssueInvoiceMock          mBillingServiceClientMockIssueInvoice

	funcListSubscriptions          func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest]) (pp2 *connect.Response[v1.ListSubscriptionsResponse], err error)
	funcListSubscriptionsOrigin    string
	inspectFuncListSubscriptions   func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest])
	afterListSubscriptionsCounter  uint64
	beforeListSubscriptionsCounter uint64
	ListSubscriptionsMock          mBillingServiceClientMockListSubscriptions

	funcPublishCatalogVersion          func(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest]) (pp2 *connect.Response[v1.PublishCatalogVersionResponse], err error)
	funcPublishCatalogVersionOrigin    string
	inspectFuncPublishCatalogVersion   func(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest])
	afterPublishCatalogVersionCounter  uint64
	beforePublishCatalogVersionCounter uint64
	PublishCatalogVersionMock          mBillingServiceClientMockPublishCatalogVersion

	funcRecordPayment          func(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest]) (pp2 *connect.Response[v1.RecordPaymentResponse], err error)
	funcRecordPaymentOrigin    string
	inspectFuncRecordPayment   func(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest])
	afterRecordPaymentCounter  uint64
	beforeRecordPaymentCounter uint64
	RecordPaymentMock          mBillingServiceClientMockRecordPayment

	funcRunBilling          func(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest]) (pp2 *connect.Response[v1.RunBillingResponse], err error)
	funcRunBillingOrigin    string
	inspectFuncRunBilling   func(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest])
	afterRunBillingCounter  uint64
	beforeRunBillingCounter uint64
	RunBillingMock          mBillingServiceClientMockRunBilling

	funcSearchCatalogVersions          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchCatalogVersionsResponse], err error)
	funcSearchCatalogVersionsOrigin    string
	inspectFuncSearchCatalogVersions   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchCatalogVersionsCounter  uint64
	beforeSearchCatalogVersionsCounter uint64
	SearchCatalogVersionsMock          mBillingServiceClientMockSearchCatalogVersions

	funcSearchDiscounts          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchDiscountsResponse], err error)
	funcSearchDiscountsOrigin    string
	inspectFuncSearchDiscounts   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchDiscountsCounter  uint64
	beforeSearchDiscountsCounter uint64
	SearchDiscountsMock          mBillingServiceClientMockSearchDiscounts

	funcSearchInvoices          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchInvoicesResponse], err error)
	funcSearchInvoicesOrigin    string
	inspectFuncSearchInvoices   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchInvoicesCounter  uint64
	beforeSearchInvoicesCounter uint64
	SearchInvoicesMock          mBillingServiceClientMockSearchInvoices

	funcSearchUsageEvents          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchUsageEventsResponse], err error)
	funcSearchUsageEventsOrigin    string
	inspectFuncSearchUsageEvents   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchUsageEventsCounter  uint64
	beforeSearchUsageEventsCounter uint64
	SearchUsageEventsMock          mBillingServiceClientMockSearchUsageEvents

	funcVoidInvoice          func(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest]) (pp2 *connect.Response[v1.VoidInvoiceResponse], err error)
	funcVoidInvoiceOrigin    string
	inspectFuncVoidInvoice   func(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest])
	afterVoidInvoiceCounter  uint64
	beforeVoidInvoiceCounter uint64
	VoidInvoiceMock          mBillingServiceClientMockVoidInvoice
}

// NewBillingServiceClientMock returns a mock for mm_billingv1connect.BillingServiceClient
func NewBillingServiceClientMock(t minimock.Tester) *BillingServiceClientMock {
	m := &BillingServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelSubscriptionMock = mBillingServiceClientMockCancelSubscription{mock: m}
	m.CancelSubscriptionMock.callArgs = []*BillingServiceClientMockCancelSubscriptionParams{}

	m.CreateCatalogVersionMock = mBillingServiceClientMockCreateCatalogVersion{mock: m}
	m.CreateCatalogVersionMock.callArgs = []*BillingServiceClientMockCreateCatalogVersionParams{}

	m.CreateComponentMock = mBillingServiceClientMockCreateComponent{mock: m}
	m.CreateComponentMock.callArgs = []*BillingServiceClientMockCreateComponentParams{}

	m.CreateDiscountMock = mBillingServiceClientMockCreateDiscount{mock: m}
	m.CreateDiscountMock.callArgs = []*BillingServiceClientMockCreateDiscountParams{}

	m.CreatePlanMock = mBillingServiceClientMockCreatePlan{mock: m}
	m.CreatePlanMock.callArgs = []*BillingServiceClientMockCreatePlanParams{}

	m.CreateSubscriptionMock = mBillingServiceClientMockCreateSubscription{mock: m}
	m.CreateSubscriptionMock.callArgs = []*BillingServiceClientMockCreateSubscriptionParams{}

	m.CreateTierMock = mBillingServiceClientMockCreateTier{mock: m}
	m.CreateTierMock.callArgs = []*BillingServiceClientMockCreateTierParams{}

	m.GetBillingRunMock = mBillingServiceClientMockGetBillingRun{mock: m}
	m.GetBillingRunMock.callArgs = []*BillingServiceClientMockGetBillingRunParams{}

	m.GetCatalogVersionMock = mBillingServiceClientMockGetCatalogVersion{mock: m}
	m.GetCatalogVersionMock.callArgs = []*BillingServiceClientMockGetCatalogVersionParams{}

	m.GetCreditBalanceMock = mBillingServiceClientMockGetCreditBalance{mock: m}
	m.GetCreditBalanceMock.callArgs = []*BillingServiceClientMockGetCreditBalanceParams{}

	m.GetInvoiceMock = mBillingServiceClientMockGetInvoice{mock: m}
	m.GetInvoiceMock.callArgs = []*BillingServiceClientMockGetInvoiceParams{}

	m.GetSubscriptionMock = mBillingServiceClientMockGetSubscription{mock: m}
	m.GetSubscriptionMock.callArgs = []*BillingServiceClientMockGetSubscriptionParams{}

	m.GrantCreditMock = mBillingServiceClientMockGrantCredit{mock: m}
	m.GrantCreditMock.callArgs = []*BillingServiceClientMockGrantCreditParams{}

	m.IngestUsageBatchMock = mBillingServiceClientMockIngestUsageBatch{mock: m}
	m.IngestUsageBatchMock.callArgs = []*BillingServiceClientMockIngestUsageBatchParams{}

	m.IngestUsageEventMock = mBillingServiceClientMockIngestUsageEvent{mock: m}
	m.IngestUsageEventMock.callArgs = []*BillingServiceClientMockIngestUsageEventParams{}

	m.IssueInvoiceMock = mBillingServiceClientMockIssueInvoice{mock: m}
	m.IssueInvoiceMock.callArgs = []*BillingServiceClientMockIssueInvoiceParams{}

	m.ListSubscriptionsMock = mBillingServiceClientMockListSubscriptions{mock: m}
	m.ListSubscriptionsMock.callArgs = []*BillingServiceClientMockListSubscriptionsParams{}

	m.PublishCatalogVersionMock = mBillingServiceClientMockPublishCatalogVersion{mock: m}
	m.PublishCatalogVersionMock.callArgs = []*BillingServiceClientMockPublishCatalogVersionParams{}

	m.RecordPaymentMock = mBillingServiceClientMockRecordPayment{mock: m}
	m.RecordPaymentMock.callArgs = []*BillingServiceClientMockRecordPaymentParams{}

	m.RunBillingMock = mBillingServiceClientMockRunBilling{mock: m}
	m.RunBillingMock.callArgs = []*BillingServiceClientMockRunBillingParams{}

	m.SearchCatalogVersionsMock = mBillingServiceClientMockSearchCatalogVersions{mock: m}
	m.SearchCatalogVersionsMock.callArgs = []*BillingServiceClientMockSearchCatalogVersionsParams{}

	m.SearchDiscountsMock = mBillingServiceClientMockSearchDiscounts{mock: m}
	m.SearchDiscountsMock.callArgs = []*BillingServiceClientMockSearchDiscountsParams{}

	m.SearchInvoicesMock = mBillingServiceClientMockSearchInvoices{mock: m}
	m.SearchInvoicesMock.callArgs = []*BillingServiceClientMockSearchInvoicesParams{}

	m.SearchUsageEventsMock = mBillingServiceClientMockSearchUsageEvents{mock: m}
	m.SearchUsageEventsMock.callArgs = []*BillingServiceClientMockSearchUsageEventsParams{}

	m.VoidInvoiceMock = mBillingServiceClientMockVoidInvoice{mock: m}
	m.VoidInvoiceMock.callArgs = []*BillingServiceClientMockVoidInvoiceParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mBillingServiceClientMockCancelSubscription struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCancelSubscriptionExpectation
	expectations       []*BillingServiceClientMockCancelSubscriptionExpectation

	callArgs []*BillingServiceClientMockCancelSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCancelSubscriptionExpectation specifies expectation struct of the BillingServiceClient.CancelSubscription
type BillingServiceClientMockCancelSubscriptionExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCancelSubscriptionParams
	paramPtrs          *BillingServiceClientMockCancelSubscriptionParamPtrs
	expectationOrigins BillingServiceClientMockCancelSubscriptionExpectationOrigins
	results            *BillingServiceClientMockCancelSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCancelSubscriptionParams contains parameters of the BillingServiceClient.CancelSubscription
type BillingServiceClientMockCancelSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CancelSubscriptionRequest]
}

// BillingServiceClientMockCancelSubscriptionParamPtrs contains pointers to parameters of the BillingServiceClient.CancelSubscription
type BillingServiceClientMockCancelSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CancelSubscriptionRequest]
}

// BillingServiceClientMockCancelSubscriptionResults contains results of the BillingServiceClient.CancelSubscription
type BillingServiceClientMockCancelSubscriptionResults struct {
	pp2 *connect.Response[v1.CancelSubscriptionResponse]
	err error
}

// BillingServiceClientMockCancelSubscriptionOrigins contains origins of expectations of the BillingServiceClient.CancelSubscription
type BillingServiceClientMockCancelSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Optional() *mBillingServiceClientMockCancelSubscription {
	mmCancelSubscription.optional = true
	return mmCancelSubscription
}

// Expect sets up expected params for BillingServiceClient.CancelSubscription
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest]) *mBillingServiceClientMockCancelSubscription {
	if mmCancelSubscription.mock.funcCancelSubscription != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Set")
	}

	if mmCancelSubscription.defaultExpectation == nil {
		mmCancelSubscription.defaultExpectation = &BillingServiceClientMockCancelSubscriptionExpectation{}
	}

	if mmCancelSubscription.defaultExpectation.paramPtrs != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by ExpectParams functions")
	}

	mmCancelSubscription.defaultExpectation.params = &BillingServiceClientMockCancelSubscriptionParams{ctx, pp1}
	mmCancelSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancelSubscription.expectations {
		if minimock.Equal(e.params, mmCancelSubscription.defaultExpectation.params) {
			mmCancelSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelSubscription.defaultExpectation.params)
		}
	}

	return mmCancelSubscription
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CancelSubscription
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCancelSubscription {
	if mmCancelSubscription.mock.funcCancelSubscription != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Set")
	}

	if mmCancelSubscription.defaultExpectation == nil {
		mmCancelSubscription.defaultExpectation = &BillingServiceClientMockCancelSubscriptionExpectation{}
	}

	if mmCancelSubscription.defaultExpectation.params != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Expect")
	}

	if mmCancelSubscription.defaultExpectation.paramPtrs == nil {
		mmCancelSubscription.defaultExpectation.paramPtrs = &BillingServiceClientMockCancelSubscriptionParamPtrs{}
	}
	mmCancelSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmCancelSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCancelSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CancelSubscription
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.CancelSubscriptionRequest]) *mBillingServiceClientMockCancelSubscription {
	if mmCancelSubscription.mock.funcCancelSubscription != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Set")
	}

	if mmCancelSubscription.defaultExpectation == nil {
		mmCancelSubscription.defaultExpectation = &BillingServiceClientMockCancelSubscriptionExpectation{}
	}

	if mmCancelSubscription.defaultExpectation.params != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Expect")
	}

	if mmCancelSubscription.defaultExpectation.paramPtrs == nil {
		mmCancelSubscription.defaultExpectation.paramPtrs = &BillingServiceClientMockCancelSubscriptionParamPtrs{}
	}
	mmCancelSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCancelSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCancelSubscription
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CancelSubscription
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest])) *mBillingServiceClientMockCancelSubscription {
	if mmCancelSubscription.mock.inspectFuncCancelSubscription != nil {
		mmCancelSubscription.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CancelSubscription")
	}

	mmCancelSubscription.mock.inspectFuncCancelSubscription = f

	return mmCancelSubscription
}

// Return sets up results that will be returned by BillingServiceClient.CancelSubscription
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Return(pp2 *connect.Response[v1.CancelSubscriptionResponse], err error) *BillingServiceClientMock {
	if mmCancelSubscription.mock.funcCancelSubscription != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Set")
	}

	if mmCancelSubscription.defaultExpectation == nil {
		mmCancelSubscription.defaultExpectation = &BillingServiceClientMockCancelSubscriptionExpectation{mock: mmCancelSubscription.mock}
	}
	mmCancelSubscription.defaultExpectation.results = &BillingServiceClientMockCancelSubscriptionResults{pp2, err}
	mmCancelSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelSubscription.mock
}

// Set uses given function f to mock the BillingServiceClient.CancelSubscription method
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest]) (pp2 *connect.Response[v1.CancelSubscriptionResponse], err error)) *BillingServiceClientMock {
	if mmCancelSubscription.defaultExpectation != nil {
		mmCancelSubscription.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CancelSubscription method")
	}

	if len(mmCancelSubscription.expectations) > 0 {
		mmCancelSubscription.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CancelSubscription method")
	}

	mmCancelSubscription.mock.funcCancelSubscription = f
	mmCancelSubscription.mock.funcCancelSubscriptionOrigin = minimock.CallerInfo(1)
	return mmCancelSubscription.mock
}

// When sets expectation for the BillingServiceClient.CancelSubscription which will trigger the result defined by the following
// Then helper
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) When(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest]) *BillingServiceClientMockCancelSubscriptionExpectation {
	if mmCancelSubscription.mock.funcCancelSubscription != nil {
		mmCancelSubscription.mock.t.Fatalf("BillingServiceClientMock.CancelSubscription mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCancelSubscriptionExpectation{
		mock:               mmCancelSubscription.mock,
		params:             &BillingServiceClientMockCancelSubscriptionParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCancelSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancelSubscription.expectations = append(mmCancelSubscription.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CancelSubscription return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCancelSubscriptionExpectation) Then(pp2 *connect.Response[v1.CancelSubscriptionResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCancelSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CancelSubscription should be invoked
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Times(n uint64) *mBillingServiceClientMockCancelSubscription {
	if n == 0 {
		mmCancelSubscription.mock.t.Fatalf("Times of BillingServiceClientMock.CancelSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelSubscription.expectedInvocations, n)
	mmCancelSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelSubscription
}

func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) invocationsDone() bool {
	if len(mmCancelSubscription.expectations) == 0 && mmCancelSubscription.defaultExpectation == nil && mmCancelSubscription.mock.funcCancelSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelSubscription.mock.afterCancelSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelSubscription implements mm_billingv1connect.BillingServiceClient
func (mmCancelSubscription *BillingServiceClientMock) CancelSubscription(ctx context.Context, pp1 *connect.Request[v1.CancelSubscriptionRequest]) (pp2 *connect.Response[v1.CancelSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmCancelSubscription.beforeCancelSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelSubscription.afterCancelSubscriptionCounter, 1)

	mmCancelSubscription.t.Helper()

	if mmCancelSubscription.inspectFuncCancelSubscription != nil {
		mmCancelSubscription.inspectFuncCancelSubscription(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCancelSubscriptionParams{ctx, pp1}

	// Record call args
	mmCancelSubscription.CancelSubscriptionMock.mutex.Lock()
	mmCancelSubscription.CancelSubscriptionMock.callArgs = append(mmCancelSubscription.CancelSubscriptionMock.callArgs, &mm_params)
	mmCancelSubscription.CancelSubscriptionMock.mutex.Unlock()

	for _, e := range mmCancelSubscription.CancelSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCancelSubscription.CancelSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCancelSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelSubscription.t.Errorf("BillingServiceClientMock.CancelSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCancelSubscription.t.Errorf("BillingServiceClientMock.CancelSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelSubscription.t.Errorf("BillingServiceClientMock.CancelSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelSubscription.CancelSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelSubscription.t.Fatal("No results are set for the BillingServiceClientMock.CancelSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCancelSubscription.funcCancelSubscription != nil {
		return mmCancelSubscription.funcCancelSubscription(ctx, pp1)
	}
	mmCancelSubscription.t.Fatalf("Unexpected call to BillingServiceClientMock.CancelSubscription. %v %v", ctx, pp1)
	return
}

// CancelSubscriptionAfterCounter returns a count of finished BillingServiceClientMock.CancelSubscription invocations
func (mmCancelSubscription *BillingServiceClientMock) CancelSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelSubscription.afterCancelSubscriptionCounter)
}

// CancelSubscriptionBeforeCounter returns a count of BillingServiceClientMock.CancelSubscription invocations
func (mmCancelSubscription *BillingServiceClientMock) CancelSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelSubscription.beforeCancelSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CancelSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelSubscription *mBillingServiceClientMockCancelSubscription) Calls() []*BillingServiceClientMockCancelSubscriptionParams {
	mmCancelSubscription.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCancelSubscriptionParams, len(mmCancelSubscription.callArgs))
	copy(argCopy, mmCancelSubscription.callArgs)

	mmCancelSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockCancelSubscriptionDone returns true if the count of the CancelSubscription invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCancelSubscriptionDone() bool {
	if m.CancelSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelSubscriptionMock.invocationsDone()
}

// MinimockCancelSubscriptionInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCancelSubscriptionInspect() {
	for _, e := range m.CancelSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CancelSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelSubscriptionCounter := mm_atomic.LoadUint64(&m.afterCancelSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelSubscriptionMock.defaultExpectation != nil && afterCancelSubscriptionCounter < 1 {
		if m.CancelSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CancelSubscription at\n%s", m.CancelSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CancelSubscription at\n%s with params: %#v", m.CancelSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.CancelSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelSubscription != nil && afterCancelSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CancelSubscription at\n%s", m.funcCancelSubscriptionOrigin)
	}

	if !m.CancelSubscriptionMock.invocationsDone() && afterCancelSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CancelSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelSubscriptionMock.expectedInvocations), m.CancelSubscriptionMock.expectedInvocationsOrigin, afterCancelSubscriptionCounter)
	}
}

type mBillingServiceClientMockCreateCatalogVersion struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCreateCatalogVersionExpectation
	expectations       []*BillingServiceClientMockCreateCatalogVersionExpectation

	callArgs []*BillingServiceClientMockCreateCatalogVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCreateCatalogVersionExpectation specifies expectation struct of the BillingServiceClient.CreateCatalogVersion
type BillingServiceClientMockCreateCatalogVersionExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCreateCatalogVersionParams
	paramPtrs          *BillingServiceClientMockCreateCatalogVersionParamPtrs
	expectationOrigins BillingServiceClientMockCreateCatalogVersionExpectationOrigins
	results            *BillingServiceClientMockCreateCatalogVersionResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCreateCatalogVersionParams contains parameters of the BillingServiceClient.CreateCatalogVersion
type BillingServiceClientMockCreateCatalogVersionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateCatalogVersionRequest]
}

// BillingServiceClientMockCreateCatalogVersionParamPtrs contains pointers to parameters of the BillingServiceClient.CreateCatalogVersion
type BillingServiceClientMockCreateCatalogVersionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateCatalogVersionRequest]
}

// BillingServiceClientMockCreateCatalogVersionResults contains results of the BillingServiceClient.CreateCatalogVersion
type BillingServiceClientMockCreateCatalogVersionResults struct {
	pp2 *connect.Response[v1.CreateCatalogVersionResponse]
	err error
}

// BillingServiceClientMockCreateCatalogVersionOrigins contains origins of expectations of the BillingServiceClient.CreateCatalogVersion
type BillingServiceClientMockCreateCatalogVersionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Optional() *mBillingServiceClientMockCreateCatalogVersion {
	mmCreateCatalogVersion.optional = true
	return mmCreateCatalogVersion
}

// Expect sets up expected params for BillingServiceClient.CreateCatalogVersion
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest]) *mBillingServiceClientMockCreateCatalogVersion {
	if mmCreateCatalogVersion.mock.funcCreateCatalogVersion != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Set")
	}

	if mmCreateCatalogVersion.defaultExpectation == nil {
		mmCreateCatalogVersion.defaultExpectation = &BillingServiceClientMockCreateCatalogVersionExpectation{}
	}

	if mmCreateCatalogVersion.defaultExpectation.paramPtrs != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by ExpectParams functions")
	}

	mmCreateCatalogVersion.defaultExpectation.params = &BillingServiceClientMockCreateCatalogVersionParams{ctx, pp1}
	mmCreateCatalogVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCatalogVersion.expectations {
		if minimock.Equal(e.params, mmCreateCatalogVersion.defaultExpectation.params) {
			mmCreateCatalogVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCatalogVersion.defaultExpectation.params)
		}
	}

	return mmCreateCatalogVersion
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CreateCatalogVersion
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCreateCatalogVersion {
	if mmCreateCatalogVersion.mock.funcCreateCatalogVersion != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Set")
	}

	if mmCreateCatalogVersion.defaultExpectation == nil {
		mmCreateCatalogVersion.defaultExpectation = &BillingServiceClientMockCreateCatalogVersionExpectation{}
	}

	if mmCreateCatalogVersion.defaultExpectation.params != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Expect")
	}

	if mmCreateCatalogVersion.defaultExpectation.paramPtrs == nil {
		mmCreateCatalogVersion.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateCatalogVersionParamPtrs{}
	}
	mmCreateCatalogVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCatalogVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCatalogVersion
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CreateCatalogVersion
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) ExpectPp1Param2(pp1 *connect.Request[v1.CreateCatalogVersionRequest]) *mBillingServiceClientMockCreateCatalogVersion {
	if mmCreateCatalogVersion.mock.funcCreateCatalogVersion != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Set")
	}

	if mmCreateCatalogVersion.defaultExpectation == nil {
		mmCreateCatalogVersion.defaultExpectation = &BillingServiceClientMockCreateCatalogVersionExpectation{}
	}

	if mmCreateCatalogVersion.defaultExpectation.params != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Expect")
	}

	if mmCreateCatalogVersion.defaultExpectation.paramPtrs == nil {
		mmCreateCatalogVersion.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateCatalogVersionParamPtrs{}
	}
	mmCreateCatalogVersion.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateCatalogVersion.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateCatalogVersion
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CreateCatalogVersion
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest])) *mBillingServiceClientMockCreateCatalogVersion {
	if mmCreateCatalogVersion.mock.inspectFuncCreateCatalogVersion != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CreateCatalogVersion")
	}

	mmCreateCatalogVersion.mock.inspectFuncCreateCatalogVersion = f

	return mmCreateCatalogVersion
}

// Return sets up results that will be returned by BillingServiceClient.CreateCatalogVersion
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Return(pp2 *connect.Response[v1.CreateCatalogVersionResponse], err error) *BillingServiceClientMock {
	if mmCreateCatalogVersion.mock.funcCreateCatalogVersion != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Set")
	}

	if mmCreateCatalogVersion.defaultExpectation == nil {
		mmCreateCatalogVersion.defaultExpectation = &BillingServiceClientMockCreateCatalogVersionExpectation{mock: mmCreateCatalogVersion.mock}
	}
	mmCreateCatalogVersion.defaultExpectation.results = &BillingServiceClientMockCreateCatalogVersionResults{pp2, err}
	mmCreateCatalogVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCatalogVersion.mock
}

// Set uses given function f to mock the BillingServiceClient.CreateCatalogVersion method
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest]) (pp2 *connect.Response[v1.CreateCatalogVersionResponse], err error)) *BillingServiceClientMock {
	if mmCreateCatalogVersion.defaultExpectation != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CreateCatalogVersion method")
	}

	if len(mmCreateCatalogVersion.expectations) > 0 {
		mmCreateCatalogVersion.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CreateCatalogVersion method")
	}

	mmCreateCatalogVersion.mock.funcCreateCatalogVersion = f
	mmCreateCatalogVersion.mock.funcCreateCatalogVersionOrigin = minimock.CallerInfo(1)
	return mmCreateCatalogVersion.mock
}

// When sets expectation for the BillingServiceClient.CreateCatalogVersion which will trigger the result defined by the following
// Then helper
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) When(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest]) *BillingServiceClientMockCreateCatalogVersionExpectation {
	if mmCreateCatalogVersion.mock.funcCreateCatalogVersion != nil {
		mmCreateCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.CreateCatalogVersion mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCreateCatalogVersionExpectation{
		mock:               mmCreateCatalogVersion.mock,
		params:             &BillingServiceClientMockCreateCatalogVersionParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCreateCatalogVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCatalogVersion.expectations = append(mmCreateCatalogVersion.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CreateCatalogVersion return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCreateCatalogVersionExpectation) Then(pp2 *connect.Response[v1.CreateCatalogVersionResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCreateCatalogVersionResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CreateCatalogVersion should be invoked
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Times(n uint64) *mBillingServiceClientMockCreateCatalogVersion {
	if n == 0 {
		mmCreateCatalogVersion.mock.t.Fatalf("Times of BillingServiceClientMock.CreateCatalogVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCatalogVersion.expectedInvocations, n)
	mmCreateCatalogVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCatalogVersion
}

func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) invocationsDone() bool {
	if len(mmCreateCatalogVersion.expectations) == 0 && mmCreateCatalogVersion.defaultExpectation == nil && mmCreateCatalogVersion.mock.funcCreateCatalogVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCatalogVersion.mock.afterCreateCatalogVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCatalogVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCatalogVersion implements mm_billingv1connect.BillingServiceClient
func (mmCreateCatalogVersion *BillingServiceClientMock) CreateCatalogVersion(ctx context.Context, pp1 *connect.Request[v1.CreateCatalogVersionRequest]) (pp2 *connect.Response[v1.CreateCatalogVersionResponse], err error) {
	mm_atomic.AddUint64(&mmCreateCatalogVersion.beforeCreateCatalogVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCatalogVersion.afterCreateCatalogVersionCounter, 1)

	mmCreateCatalogVersion.t.Helper()

	if mmCreateCatalogVersion.inspectFuncCreateCatalogVersion != nil {
		mmCreateCatalogVersion.inspectFuncCreateCatalogVersion(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCreateCatalogVersionParams{ctx, pp1}

	// Record call args
	mmCreateCatalogVersion.CreateCatalogVersionMock.mutex.Lock()
	mmCreateCatalogVersion.CreateCatalogVersionMock.callArgs = append(mmCreateCatalogVersion.CreateCatalogVersionMock.callArgs, &mm_params)
	mmCreateCatalogVersion.CreateCatalogVersionMock.mutex.Unlock()

	for _, e := range mmCreateCatalogVersion.CreateCatalogVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCreateCatalogVersionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCatalogVersion.t.Errorf("BillingServiceClientMock.CreateCatalogVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateCatalogVersion.t.Errorf("BillingServiceClientMock.CreateCatalogVersion got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCatalogVersion.t.Errorf("BillingServiceClientMock.CreateCatalogVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCatalogVersion.CreateCatalogVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCatalogVersion.t.Fatal("No results are set for the BillingServiceClientMock.CreateCatalogVersion")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateCatalogVersion.funcCreateCatalogVersion != nil {
		return mmCreateCatalogVersion.funcCreateCatalogVersion(ctx, pp1)
	}
	mmCreateCatalogVersion.t.Fatalf("Unexpected call to BillingServiceClientMock.CreateCatalogVersion. %v %v", ctx, pp1)
	return
}

// CreateCatalogVersionAfterCounter returns a count of finished BillingServiceClientMock.CreateCatalogVersion invocations
func (mmCreateCatalogVersion *BillingServiceClientMock) CreateCatalogVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalogVersion.afterCreateCatalogVersionCounter)
}

// CreateCatalogVersionBeforeCounter returns a count of BillingServiceClientMock.CreateCatalogVersion invocations
func (mmCreateCatalogVersion *BillingServiceClientMock) CreateCatalogVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCatalogVersion.beforeCreateCatalogVersionCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CreateCatalogVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCatalogVersion *mBillingServiceClientMockCreateCatalogVersion) Calls() []*BillingServiceClientMockCreateCatalogVersionParams {
	mmCreateCatalogVersion.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCreateCatalogVersionParams, len(mmCreateCatalogVersion.callArgs))
	copy(argCopy, mmCreateCatalogVersion.callArgs)

	mmCreateCatalogVersion.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCatalogVersionDone returns true if the count of the CreateCatalogVersion invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCreateCatalogVersionDone() bool {
	if m.CreateCatalogVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCatalogVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCatalogVersionMock.invocationsDone()
}

// MinimockCreateCatalogVersionInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCreateCatalogVersionInspect() {
	for _, e := range m.CreateCatalogVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateCatalogVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCatalogVersionCounter := mm_atomic.LoadUint64(&m.afterCreateCatalogVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCatalogVersionMock.defaultExpectation != nil && afterCreateCatalogVersionCounter < 1 {
		if m.CreateCatalogVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateCatalogVersion at\n%s", m.CreateCatalogVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateCatalogVersion at\n%s with params: %#v", m.CreateCatalogVersionMock.defaultExpectation.expectationOrigins.origin, *m.CreateCatalogVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCatalogVersion != nil && afterCreateCatalogVersionCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CreateCatalogVersion at\n%s", m.funcCreateCatalogVersionOrigin)
	}

	if !m.CreateCatalogVersionMock.invocationsDone() && afterCreateCatalogVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CreateCatalogVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCatalogVersionMock.expectedInvocations), m.CreateCatalogVersionMock.expectedInvocationsOrigin, afterCreateCatalogVersionCounter)
	}
}

type mBillingServiceClientMockCreateComponent struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCreateComponentExpectation
	expectations       []*BillingServiceClientMockCreateComponentExpectation

	callArgs []*BillingServiceClientMockCreateComponentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCreateComponentExpectation specifies expectation struct of the BillingServiceClient.CreateComponent
type BillingServiceClientMockCreateComponentExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCreateComponentParams
	paramPtrs          *BillingServiceClientMockCreateComponentParamPtrs
	expectationOrigins BillingServiceClientMockCreateComponentExpectationOrigins
	results            *BillingServiceClientMockCreateComponentResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCreateComponentParams contains parameters of the BillingServiceClient.CreateComponent
type BillingServiceClientMockCreateComponentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateComponentRequest]
}

// BillingServiceClientMockCreateComponentParamPtrs contains pointers to parameters of the BillingServiceClient.CreateComponent
type BillingServiceClientMockCreateComponentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateComponentRequest]
}

// BillingServiceClientMockCreateComponentResults contains results of the BillingServiceClient.CreateComponent
type BillingServiceClientMockCreateComponentResults struct {
	pp2 *connect.Response[v1.CreateComponentResponse]
	err error
}

// BillingServiceClientMockCreateComponentOrigins contains origins of expectations of the BillingServiceClient.CreateComponent
type BillingServiceClientMockCreateComponentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Optional() *mBillingServiceClientMockCreateComponent {
	mmCreateComponent.optional = true
	return mmCreateComponent
}

// Expect sets up expected params for BillingServiceClient.CreateComponent
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest]) *mBillingServiceClientMockCreateComponent {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Set")
	}

	if mmCreateComponent.defaultExpectation == nil {
		mmCreateComponent.defaultExpectation = &BillingServiceClientMockCreateComponentExpectation{}
	}

	if mmCreateComponent.defaultExpectation.paramPtrs != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by ExpectParams functions")
	}

	mmCreateComponent.defaultExpectation.params = &BillingServiceClientMockCreateComponentParams{ctx, pp1}
	mmCreateComponent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateComponent.expectations {
		if minimock.Equal(e.params, mmCreateComponent.defaultExpectation.params) {
			mmCreateComponent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateComponent.defaultExpectation.params)
		}
	}

	return mmCreateComponent
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CreateComponent
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCreateComponent {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Set")
	}

	if mmCreateComponent.defaultExpectation == nil {
		mmCreateComponent.defaultExpectation = &BillingServiceClientMockCreateComponentExpectation{}
	}

	if mmCreateComponent.defaultExpectation.params != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Expect")
	}

	if mmCreateComponent.defaultExpectation.paramPtrs == nil {
		mmCreateComponent.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateComponentParamPtrs{}
	}
	mmCreateComponent.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateComponent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateComponent
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CreateComponent
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) ExpectPp1Param2(pp1 *connect.Request[v1.CreateComponentRequest]) *mBillingServiceClientMockCreateComponent {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Set")
	}

	if mmCreateComponent.defaultExpectation == nil {
		mmCreateComponent.defaultExpectation = &BillingServiceClientMockCreateComponentExpectation{}
	}

	if mmCreateComponent.defaultExpectation.params != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Expect")
	}

	if mmCreateComponent.defaultExpectation.paramPtrs == nil {
		mmCreateComponent.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateComponentParamPtrs{}
	}
	mmCreateComponent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateComponent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateComponent
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CreateComponent
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest])) *mBillingServiceClientMockCreateComponent {
	if mmCreateComponent.mock.inspectFuncCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CreateComponent")
	}

	mmCreateComponent.mock.inspectFuncCreateComponent = f

	return mmCreateComponent
}

// Return sets up results that will be returned by BillingServiceClient.CreateComponent
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Return(pp2 *connect.Response[v1.CreateComponentResponse], err error) *BillingServiceClientMock {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Set")
	}

	if mmCreateComponent.defaultExpectation == nil {
		mmCreateComponent.defaultExpectation = &BillingServiceClientMockCreateComponentExpectation{mock: mmCreateComponent.mock}
	}
	mmCreateComponent.defaultExpectation.results = &BillingServiceClientMockCreateComponentResults{pp2, err}
	mmCreateComponent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateComponent.mock
}

// Set uses given function f to mock the BillingServiceClient.CreateComponent method
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest]) (pp2 *connect.Response[v1.CreateComponentResponse], err error)) *BillingServiceClientMock {
	if mmCreateComponent.defaultExpectation != nil {
		mmCreateComponent.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CreateComponent method")
	}

	if len(mmCreateComponent.expectations) > 0 {
		mmCreateComponent.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CreateComponent method")
	}

	mmCreateComponent.mock.funcCreateComponent = f
	mmCreateComponent.mock.funcCreateComponentOrigin = minimock.CallerInfo(1)
	return mmCreateComponent.mock
}

// When sets expectation for the BillingServiceClient.CreateComponent which will trigger the result defined by the following
// Then helper
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) When(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest]) *BillingServiceClientMockCreateComponentExpectation {
	if mmCreateComponent.mock.funcCreateComponent != nil {
		mmCreateComponent.mock.t.Fatalf("BillingServiceClientMock.CreateComponent mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCreateComponentExpectation{
		mock:               mmCreateComponent.mock,
		params:             &BillingServiceClientMockCreateComponentParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCreateComponentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateComponent.expectations = append(mmCreateComponent.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CreateComponent return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCreateComponentExpectation) Then(pp2 *connect.Response[v1.CreateComponentResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCreateComponentResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CreateComponent should be invoked
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Times(n uint64) *mBillingServiceClientMockCreateComponent {
	if n == 0 {
		mmCreateComponent.mock.t.Fatalf("Times of BillingServiceClientMock.CreateComponent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateComponent.expectedInvocations, n)
	mmCreateComponent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateComponent
}

func (mmCreateComponent *mBillingServiceClientMockCreateComponent) invocationsDone() bool {
	if len(mmCreateComponent.expectations) == 0 && mmCreateComponent.defaultExpectation == nil && mmCreateComponent.mock.funcCreateComponent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateComponent.mock.afterCreateComponentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateComponent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateComponent implements mm_billingv1connect.BillingServiceClient
func (mmCreateComponent *BillingServiceClientMock) CreateComponent(ctx context.Context, pp1 *connect.Request[v1.CreateComponentRequest]) (pp2 *connect.Response[v1.CreateComponentResponse], err error) {
	mm_atomic.AddUint64(&mmCreateComponent.beforeCreateComponentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateComponent.afterCreateComponentCounter, 1)

	mmCreateComponent.t.Helper()

	if mmCreateComponent.inspectFuncCreateComponent != nil {
		mmCreateComponent.inspectFuncCreateComponent(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCreateComponentParams{ctx, pp1}

	// Record call args
	mmCreateComponent.CreateComponentMock.mutex.Lock()
	mmCreateComponent.CreateComponentMock.callArgs = append(mmCreateComponent.CreateComponentMock.callArgs, &mm_params)
	mmCreateComponent.CreateComponentMock.mutex.Unlock()

	for _, e := range mmCreateComponent.CreateComponentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateComponent.CreateComponentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateComponent.CreateComponentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateComponent.CreateComponentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateComponent.CreateComponentMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCreateComponentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateComponent.t.Errorf("BillingServiceClientMock.CreateComponent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateComponent.CreateComponentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateComponent.t.Errorf("BillingServiceClientMock.CreateComponent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateComponent.CreateComponentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateComponent.t.Errorf("BillingServiceClientMock.CreateComponent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateComponent.CreateComponentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateComponent.CreateComponentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateComponent.t.Fatal("No results are set for the BillingServiceClientMock.CreateComponent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateComponent.funcCreateComponent != nil {
		return mmCreateComponent.funcCreateComponent(ctx, pp1)
	}
	mmCreateComponent.t.Fatalf("Unexpected call to BillingServiceClientMock.CreateComponent. %v %v", ctx, pp1)
	return
}

// CreateComponentAfterCounter returns a count of finished BillingServiceClientMock.CreateComponent invocations
func (mmCreateComponent *BillingServiceClientMock) CreateComponentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComponent.afterCreateComponentCounter)
}

// CreateComponentBeforeCounter returns a count of BillingServiceClientMock.CreateComponent invocations
func (mmCreateComponent *BillingServiceClientMock) CreateComponentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComponent.beforeCreateComponentCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CreateComponent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateComponent *mBillingServiceClientMockCreateComponent) Calls() []*BillingServiceClientMockCreateComponentParams {
	mmCreateComponent.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCreateComponentParams, len(mmCreateComponent.callArgs))
	copy(argCopy, mmCreateComponent.callArgs)

	mmCreateComponent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateComponentDone returns true if the count of the CreateComponent invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCreateComponentDone() bool {
	if m.CreateComponentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateComponentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateComponentMock.invocationsDone()
}

// MinimockCreateComponentInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCreateComponentInspect() {
	for _, e := range m.CreateComponentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateComponent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateComponentCounter := mm_atomic.LoadUint64(&m.afterCreateComponentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateComponentMock.defaultExpectation != nil && afterCreateComponentCounter < 1 {
		if m.CreateComponentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateComponent at\n%s", m.CreateComponentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateComponent at\n%s with params: %#v", m.CreateComponentMock.defaultExpectation.expectationOrigins.origin, *m.CreateComponentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateComponent != nil && afterCreateComponentCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CreateComponent at\n%s", m.funcCreateComponentOrigin)
	}

	if !m.CreateComponentMock.invocationsDone() && afterCreateComponentCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CreateComponent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateComponentMock.expectedInvocations), m.CreateComponentMock.expectedInvocationsOrigin, afterCreateComponentCounter)
	}
}

type mBillingServiceClientMockCreateDiscount struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCreateDiscountExpectation
	expectations       []*BillingServiceClientMockCreateDiscountExpectation

	callArgs []*BillingServiceClientMockCreateDiscountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCreateDiscountExpectation specifies expectation struct of the BillingServiceClient.CreateDiscount
type BillingServiceClientMockCreateDiscountExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCreateDiscountParams
	paramPtrs          *BillingServiceClientMockCreateDiscountParamPtrs
	expectationOrigins BillingServiceClientMockCreateDiscountExpectationOrigins
	results            *BillingServiceClientMockCreateDiscountResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCreateDiscountParams contains parameters of the BillingServiceClient.CreateDiscount
type BillingServiceClientMockCreateDiscountParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateDiscountRequest]
}

// BillingServiceClientMockCreateDiscountParamPtrs contains pointers to parameters of the BillingServiceClient.CreateDiscount
type BillingServiceClientMockCreateDiscountParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateDiscountRequest]
}

// BillingServiceClientMockCreateDiscountResults contains results of the BillingServiceClient.CreateDiscount
type BillingServiceClientMockCreateDiscountResults struct {
	pp2 *connect.Response[v1.CreateDiscountResponse]
	err error
}

// BillingServiceClientMockCreateDiscountOrigins contains origins of expectations of the BillingServiceClient.CreateDiscount
type BillingServiceClientMockCreateDiscountExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Optional() *mBillingServiceClientMockCreateDiscount {
	mmCreateDiscount.optional = true
	return mmCreateDiscount
}

// Expect sets up expected params for BillingServiceClient.CreateDiscount
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest]) *mBillingServiceClientMockCreateDiscount {
	if mmCreateDiscount.mock.funcCreateDiscount != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Set")
	}

	if mmCreateDiscount.defaultExpectation == nil {
		mmCreateDiscount.defaultExpectation = &BillingServiceClientMockCreateDiscountExpectation{}
	}

	if mmCreateDiscount.defaultExpectation.paramPtrs != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by ExpectParams functions")
	}

	mmCreateDiscount.defaultExpectation.params = &BillingServiceClientMockCreateDiscountParams{ctx, pp1}
	mmCreateDiscount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateDiscount.expectations {
		if minimock.Equal(e.params, mmCreateDiscount.defaultExpectation.params) {
			mmCreateDiscount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateDiscount.defaultExpectation.params)
		}
	}

	return mmCreateDiscount
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CreateDiscount
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCreateDiscount {
	if mmCreateDiscount.mock.funcCreateDiscount != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Set")
	}

	if mmCreateDiscount.defaultExpectation == nil {
		mmCreateDiscount.defaultExpectation = &BillingServiceClientMockCreateDiscountExpectation{}
	}

	if mmCreateDiscount.defaultExpectation.params != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Expect")
	}

	if mmCreateDiscount.defaultExpectation.paramPtrs == nil {
		mmCreateDiscount.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateDiscountParamPtrs{}
	}
	mmCreateDiscount.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateDiscount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateDiscount
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CreateDiscount
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) ExpectPp1Param2(pp1 *connect.Request[v1.CreateDiscountRequest]) *mBillingServiceClientMockCreateDiscount {
	if mmCreateDiscount.mock.funcCreateDiscount != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Set")
	}

	if mmCreateDiscount.defaultExpectation == nil {
		mmCreateDiscount.defaultExpectation = &BillingServiceClientMockCreateDiscountExpectation{}
	}

	if mmCreateDiscount.defaultExpectation.params != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Expect")
	}

	if mmCreateDiscount.defaultExpectation.paramPtrs == nil {
		mmCreateDiscount.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateDiscountParamPtrs{}
	}
	mmCreateDiscount.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateDiscount.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateDiscount
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CreateDiscount
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest])) *mBillingServiceClientMockCreateDiscount {
	if mmCreateDiscount.mock.inspectFuncCreateDiscount != nil {
		mmCreateDiscount.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CreateDiscount")
	}

	mmCreateDiscount.mock.inspectFuncCreateDiscount = f

	return mmCreateDiscount
}

// Return sets up results that will be returned by BillingServiceClient.CreateDiscount
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Return(pp2 *connect.Response[v1.CreateDiscountResponse], err error) *BillingServiceClientMock {
	if mmCreateDiscount.mock.funcCreateDiscount != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Set")
	}

	if mmCreateDiscount.defaultExpectation == nil {
		mmCreateDiscount.defaultExpectation = &BillingServiceClientMockCreateDiscountExpectation{mock: mmCreateDiscount.mock}
	}
	mmCreateDiscount.defaultExpectation.results = &BillingServiceClientMockCreateDiscountResults{pp2, err}
	mmCreateDiscount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateDiscount.mock
}

// Set uses given function f to mock the BillingServiceClient.CreateDiscount method
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest]) (pp2 *connect.Response[v1.CreateDiscountResponse], err error)) *BillingServiceClientMock {
	if mmCreateDiscount.defaultExpectation != nil {
		mmCreateDiscount.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CreateDiscount method")
	}

	if len(mmCreateDiscount.expectations) > 0 {
		mmCreateDiscount.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CreateDiscount method")
	}

	mmCreateDiscount.mock.funcCreateDiscount = f
	mmCreateDiscount.mock.funcCreateDiscountOrigin = minimock.CallerInfo(1)
	return mmCreateDiscount.mock
}

// When sets expectation for the BillingServiceClient.CreateDiscount which will trigger the result defined by the following
// Then helper
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) When(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest]) *BillingServiceClientMockCreateDiscountExpectation {
	if mmCreateDiscount.mock.funcCreateDiscount != nil {
		mmCreateDiscount.mock.t.Fatalf("BillingServiceClientMock.CreateDiscount mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCreateDiscountExpectation{
		mock:               mmCreateDiscount.mock,
		params:             &BillingServiceClientMockCreateDiscountParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCreateDiscountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateDiscount.expectations = append(mmCreateDiscount.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CreateDiscount return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCreateDiscountExpectation) Then(pp2 *connect.Response[v1.CreateDiscountResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCreateDiscountResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CreateDiscount should be invoked
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Times(n uint64) *mBillingServiceClientMockCreateDiscount {
	if n == 0 {
		mmCreateDiscount.mock.t.Fatalf("Times of BillingServiceClientMock.CreateDiscount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateDiscount.expectedInvocations, n)
	mmCreateDiscount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateDiscount
}

func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) invocationsDone() bool {
	if len(mmCreateDiscount.expectations) == 0 && mmCreateDiscount.defaultExpectation == nil && mmCreateDiscount.mock.funcCreateDiscount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateDiscount.mock.afterCreateDiscountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateDiscount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateDiscount implements mm_billingv1connect.BillingServiceClient
func (mmCreateDiscount *BillingServiceClientMock) CreateDiscount(ctx context.Context, pp1 *connect.Request[v1.CreateDiscountRequest]) (pp2 *connect.Response[v1.CreateDiscountResponse], err error) {
	mm_atomic.AddUint64(&mmCreateDiscount.beforeCreateDiscountCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateDiscount.afterCreateDiscountCounter, 1)

	mmCreateDiscount.t.Helper()

	if mmCreateDiscount.inspectFuncCreateDiscount != nil {
		mmCreateDiscount.inspectFuncCreateDiscount(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCreateDiscountParams{ctx, pp1}

	// Record call args
	mmCreateDiscount.CreateDiscountMock.mutex.Lock()
	mmCreateDiscount.CreateDiscountMock.callArgs = append(mmCreateDiscount.CreateDiscountMock.callArgs, &mm_params)
	mmCreateDiscount.CreateDiscountMock.mutex.Unlock()

	for _, e := range mmCreateDiscount.CreateDiscountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateDiscount.CreateDiscountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateDiscount.CreateDiscountMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateDiscount.CreateDiscountMock.defaultExpectation.params
		mm_want_ptrs := mmCreateDiscount.CreateDiscountMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCreateDiscountParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateDiscount.t.Errorf("BillingServiceClientMock.CreateDiscount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateDiscount.CreateDiscountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateDiscount.t.Errorf("BillingServiceClientMock.CreateDiscount got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateDiscount.CreateDiscountMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateDiscount.t.Errorf("BillingServiceClientMock.CreateDiscount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateDiscount.CreateDiscountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateDiscount.CreateDiscountMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateDiscount.t.Fatal("No results are set for the BillingServiceClientMock.CreateDiscount")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateDiscount.funcCreateDiscount != nil {
		return mmCreateDiscount.funcCreateDiscount(ctx, pp1)
	}
	mmCreateDiscount.t.Fatalf("Unexpected call to BillingServiceClientMock.CreateDiscount. %v %v", ctx, pp1)
	return
}

// CreateDiscountAfterCounter returns a count of finished BillingServiceClientMock.CreateDiscount invocations
func (mmCreateDiscount *BillingServiceClientMock) CreateDiscountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDiscount.afterCreateDiscountCounter)
}

// CreateDiscountBeforeCounter returns a count of BillingServiceClientMock.CreateDiscount invocations
func (mmCreateDiscount *BillingServiceClientMock) CreateDiscountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateDiscount.beforeCreateDiscountCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CreateDiscount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateDiscount *mBillingServiceClientMockCreateDiscount) Calls() []*BillingServiceClientMockCreateDiscountParams {
	mmCreateDiscount.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCreateDiscountParams, len(mmCreateDiscount.callArgs))
	copy(argCopy, mmCreateDiscount.callArgs)

	mmCreateDiscount.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDiscountDone returns true if the count of the CreateDiscount invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCreateDiscountDone() bool {
	if m.CreateDiscountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateDiscountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateDiscountMock.invocationsDone()
}

// MinimockCreateDiscountInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCreateDiscountInspect() {
	for _, e := range m.CreateDiscountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateDiscount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateDiscountCounter := mm_atomic.LoadUint64(&m.afterCreateDiscountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateDiscountMock.defaultExpectation != nil && afterCreateDiscountCounter < 1 {
		if m.CreateDiscountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateDiscount at\n%s", m.CreateDiscountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateDiscount at\n%s with params: %#v", m.CreateDiscountMock.defaultExpectation.expectationOrigins.origin, *m.CreateDiscountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateDiscount != nil && afterCreateDiscountCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CreateDiscount at\n%s", m.funcCreateDiscountOrigin)
	}

	if !m.CreateDiscountMock.invocationsDone() && afterCreateDiscountCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CreateDiscount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateDiscountMock.expectedInvocations), m.CreateDiscountMock.expectedInvocationsOrigin, afterCreateDiscountCounter)
	}
}

type mBillingServiceClientMockCreatePlan struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCreatePlanExpectation
	expectations       []*BillingServiceClientMockCreatePlanExpectation

	callArgs []*BillingServiceClientMockCreatePlanParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCreatePlanExpectation specifies expectation struct of the BillingServiceClient.CreatePlan
type BillingServiceClientMockCreatePlanExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCreatePlanParams
	paramPtrs          *BillingServiceClientMockCreatePlanParamPtrs
	expectationOrigins BillingServiceClientMockCreatePlanExpectationOrigins
	results            *BillingServiceClientMockCreatePlanResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCreatePlanParams contains parameters of the BillingServiceClient.CreatePlan
type BillingServiceClientMockCreatePlanParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePlanRequest]
}

// BillingServiceClientMockCreatePlanParamPtrs contains pointers to parameters of the BillingServiceClient.CreatePlan
type BillingServiceClientMockCreatePlanParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePlanRequest]
}

// BillingServiceClientMockCreatePlanResults contains results of the BillingServiceClient.CreatePlan
type BillingServiceClientMockCreatePlanResults struct {
	pp2 *connect.Response[v1.CreatePlanResponse]
	err error
}

// BillingServiceClientMockCreatePlanOrigins contains origins of expectations of the BillingServiceClient.CreatePlan
type BillingServiceClientMockCreatePlanExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Optional() *mBillingServiceClientMockCreatePlan {
	mmCreatePlan.optional = true
	return mmCreatePlan
}

// Expect sets up expected params for BillingServiceClient.CreatePlan
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest]) *mBillingServiceClientMockCreatePlan {
	if mmCreatePlan.mock.funcCreatePlan != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Set")
	}

	if mmCreatePlan.defaultExpectation == nil {
		mmCreatePlan.defaultExpectation = &BillingServiceClientMockCreatePlanExpectation{}
	}

	if mmCreatePlan.defaultExpectation.paramPtrs != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by ExpectParams functions")
	}

	mmCreatePlan.defaultExpectation.params = &BillingServiceClientMockCreatePlanParams{ctx, pp1}
	mmCreatePlan.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePlan.expectations {
		if minimock.Equal(e.params, mmCreatePlan.defaultExpectation.params) {
			mmCreatePlan.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePlan.defaultExpectation.params)
		}
	}

	return mmCreatePlan
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CreatePlan
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCreatePlan {
	if mmCreatePlan.mock.funcCreatePlan != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Set")
	}

	if mmCreatePlan.defaultExpectation == nil {
		mmCreatePlan.defaultExpectation = &BillingServiceClientMockCreatePlanExpectation{}
	}

	if mmCreatePlan.defaultExpectation.params != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Expect")
	}

	if mmCreatePlan.defaultExpectation.paramPtrs == nil {
		mmCreatePlan.defaultExpectation.paramPtrs = &BillingServiceClientMockCreatePlanParamPtrs{}
	}
	mmCreatePlan.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePlan.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePlan
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CreatePlan
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePlanRequest]) *mBillingServiceClientMockCreatePlan {
	if mmCreatePlan.mock.funcCreatePlan != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Set")
	}

	if mmCreatePlan.defaultExpectation == nil {
		mmCreatePlan.defaultExpectation = &BillingServiceClientMockCreatePlanExpectation{}
	}

	if mmCreatePlan.defaultExpectation.params != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Expect")
	}

	if mmCreatePlan.defaultExpectation.paramPtrs == nil {
		mmCreatePlan.defaultExpectation.paramPtrs = &BillingServiceClientMockCreatePlanParamPtrs{}
	}
	mmCreatePlan.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePlan.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePlan
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CreatePlan
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest])) *mBillingServiceClientMockCreatePlan {
	if mmCreatePlan.mock.inspectFuncCreatePlan != nil {
		mmCreatePlan.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CreatePlan")
	}

	mmCreatePlan.mock.inspectFuncCreatePlan = f

	return mmCreatePlan
}

// Return sets up results that will be returned by BillingServiceClient.CreatePlan
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Return(pp2 *connect.Response[v1.CreatePlanResponse], err error) *BillingServiceClientMock {
	if mmCreatePlan.mock.funcCreatePlan != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Set")
	}

	if mmCreatePlan.defaultExpectation == nil {
		mmCreatePlan.defaultExpectation = &BillingServiceClientMockCreatePlanExpectation{mock: mmCreatePlan.mock}
	}
	mmCreatePlan.defaultExpectation.results = &BillingServiceClientMockCreatePlanResults{pp2, err}
	mmCreatePlan.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePlan.mock
}

// Set uses given function f to mock the BillingServiceClient.CreatePlan method
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest]) (pp2 *connect.Response[v1.CreatePlanResponse], err error)) *BillingServiceClientMock {
	if mmCreatePlan.defaultExpectation != nil {
		mmCreatePlan.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CreatePlan method")
	}

	if len(mmCreatePlan.expectations) > 0 {
		mmCreatePlan.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CreatePlan method")
	}

	mmCreatePlan.mock.funcCreatePlan = f
	mmCreatePlan.mock.funcCreatePlanOrigin = minimock.CallerInfo(1)
	return mmCreatePlan.mock
}

// When sets expectation for the BillingServiceClient.CreatePlan which will trigger the result defined by the following
// Then helper
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) When(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest]) *BillingServiceClientMockCreatePlanExpectation {
	if mmCreatePlan.mock.funcCreatePlan != nil {
		mmCreatePlan.mock.t.Fatalf("BillingServiceClientMock.CreatePlan mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCreatePlanExpectation{
		mock:               mmCreatePlan.mock,
		params:             &BillingServiceClientMockCreatePlanParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCreatePlanExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePlan.expectations = append(mmCreatePlan.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CreatePlan return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCreatePlanExpectation) Then(pp2 *connect.Response[v1.CreatePlanResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCreatePlanResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CreatePlan should be invoked
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Times(n uint64) *mBillingServiceClientMockCreatePlan {
	if n == 0 {
		mmCreatePlan.mock.t.Fatalf("Times of BillingServiceClientMock.CreatePlan mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePlan.expectedInvocations, n)
	mmCreatePlan.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePlan
}

func (mmCreatePlan *mBillingServiceClientMockCreatePlan) invocationsDone() bool {
	if len(mmCreatePlan.expectations) == 0 && mmCreatePlan.defaultExpectation == nil && mmCreatePlan.mock.funcCreatePlan == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePlan.mock.afterCreatePlanCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePlan.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePlan implements mm_billingv1connect.BillingServiceClient
func (mmCreatePlan *BillingServiceClientMock) CreatePlan(ctx context.Context, pp1 *connect.Request[v1.CreatePlanRequest]) (pp2 *connect.Response[v1.CreatePlanResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePlan.beforeCreatePlanCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePlan.afterCreatePlanCounter, 1)

	mmCreatePlan.t.Helper()

	if mmCreatePlan.inspectFuncCreatePlan != nil {
		mmCreatePlan.inspectFuncCreatePlan(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCreatePlanParams{ctx, pp1}

	// Record call args
	mmCreatePlan.CreatePlanMock.mutex.Lock()
	mmCreatePlan.CreatePlanMock.callArgs = append(mmCreatePlan.CreatePlanMock.callArgs, &mm_params)
	mmCreatePlan.CreatePlanMock.mutex.Unlock()

	for _, e := range mmCreatePlan.CreatePlanMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePlan.CreatePlanMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePlan.CreatePlanMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePlan.CreatePlanMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePlan.CreatePlanMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCreatePlanParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePlan.t.Errorf("BillingServiceClientMock.CreatePlan got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePlan.CreatePlanMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePlan.t.Errorf("BillingServiceClientMock.CreatePlan got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePlan.CreatePlanMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePlan.t.Errorf("BillingServiceClientMock.CreatePlan got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePlan.CreatePlanMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePlan.CreatePlanMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePlan.t.Fatal("No results are set for the BillingServiceClientMock.CreatePlan")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePlan.funcCreatePlan != nil {
		return mmCreatePlan.funcCreatePlan(ctx, pp1)
	}
	mmCreatePlan.t.Fatalf("Unexpected call to BillingServiceClientMock.CreatePlan. %v %v", ctx, pp1)
	return
}

// CreatePlanAfterCounter returns a count of finished BillingServiceClientMock.CreatePlan invocations
func (mmCreatePlan *BillingServiceClientMock) CreatePlanAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePlan.afterCreatePlanCounter)
}

// CreatePlanBeforeCounter returns a count of BillingServiceClientMock.CreatePlan invocations
func (mmCreatePlan *BillingServiceClientMock) CreatePlanBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePlan.beforeCreatePlanCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CreatePlan.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePlan *mBillingServiceClientMockCreatePlan) Calls() []*BillingServiceClientMockCreatePlanParams {
	mmCreatePlan.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCreatePlanParams, len(mmCreatePlan.callArgs))
	copy(argCopy, mmCreatePlan.callArgs)

	mmCreatePlan.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePlanDone returns true if the count of the CreatePlan invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCreatePlanDone() bool {
	if m.CreatePlanMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePlanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePlanMock.invocationsDone()
}

// MinimockCreatePlanInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCreatePlanInspect() {
	for _, e := range m.CreatePlanMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreatePlan at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePlanCounter := mm_atomic.LoadUint64(&m.afterCreatePlanCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePlanMock.defaultExpectation != nil && afterCreatePlanCounter < 1 {
		if m.CreatePlanMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreatePlan at\n%s", m.CreatePlanMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreatePlan at\n%s with params: %#v", m.CreatePlanMock.defaultExpectation.expectationOrigins.origin, *m.CreatePlanMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePlan != nil && afterCreatePlanCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CreatePlan at\n%s", m.funcCreatePlanOrigin)
	}

	if !m.CreatePlanMock.invocationsDone() && afterCreatePlanCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CreatePlan at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePlanMock.expectedInvocations), m.CreatePlanMock.expectedInvocationsOrigin, afterCreatePlanCounter)
	}
}

type mBillingServiceClientMockCreateSubscription struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCreateSubscriptionExpectation
	expectations       []*BillingServiceClientMockCreateSubscriptionExpectation

	callArgs []*BillingServiceClientMockCreateSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCreateSubscriptionExpectation specifies expectation struct of the BillingServiceClient.CreateSubscription
type BillingServiceClientMockCreateSubscriptionExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCreateSubscriptionParams
	paramPtrs          *BillingServiceClientMockCreateSubscriptionParamPtrs
	expectationOrigins BillingServiceClientMockCreateSubscriptionExpectationOrigins
	results            *BillingServiceClientMockCreateSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCreateSubscriptionParams contains parameters of the BillingServiceClient.CreateSubscription
type BillingServiceClientMockCreateSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateSubscriptionRequest]
}

// BillingServiceClientMockCreateSubscriptionParamPtrs contains pointers to parameters of the BillingServiceClient.CreateSubscription
type BillingServiceClientMockCreateSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateSubscriptionRequest]
}

// BillingServiceClientMockCreateSubscriptionResults contains results of the BillingServiceClient.CreateSubscription
type BillingServiceClientMockCreateSubscriptionResults struct {
	pp2 *connect.Response[v1.CreateSubscriptionResponse]
	err error
}

// BillingServiceClientMockCreateSubscriptionOrigins contains origins of expectations of the BillingServiceClient.CreateSubscription
type BillingServiceClientMockCreateSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Optional() *mBillingServiceClientMockCreateSubscription {
	mmCreateSubscription.optional = true
	return mmCreateSubscription
}

// Expect sets up expected params for BillingServiceClient.CreateSubscription
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest]) *mBillingServiceClientMockCreateSubscription {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &BillingServiceClientMockCreateSubscriptionExpectation{}
	}

	if mmCreateSubscription.defaultExpectation.paramPtrs != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by ExpectParams functions")
	}

	mmCreateSubscription.defaultExpectation.params = &BillingServiceClientMockCreateSubscriptionParams{ctx, pp1}
	mmCreateSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateSubscription.expectations {
		if minimock.Equal(e.params, mmCreateSubscription.defaultExpectation.params) {
			mmCreateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscription.defaultExpectation.params)
		}
	}

	return mmCreateSubscription
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CreateSubscription
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCreateSubscription {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &BillingServiceClientMockCreateSubscriptionExpectation{}
	}

	if mmCreateSubscription.defaultExpectation.params != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Expect")
	}

	if mmCreateSubscription.defaultExpectation.paramPtrs == nil {
		mmCreateSubscription.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateSubscriptionParamPtrs{}
	}
	mmCreateSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CreateSubscription
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.CreateSubscriptionRequest]) *mBillingServiceClientMockCreateSubscription {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &BillingServiceClientMockCreateSubscriptionExpectation{}
	}

	if mmCreateSubscription.defaultExpectation.params != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Expect")
	}

	if mmCreateSubscription.defaultExpectation.paramPtrs == nil {
		mmCreateSubscription.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateSubscriptionParamPtrs{}
	}
	mmCreateSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateSubscription
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CreateSubscription
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest])) *mBillingServiceClientMockCreateSubscription {
	if mmCreateSubscription.mock.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CreateSubscription")
	}

	mmCreateSubscription.mock.inspectFuncCreateSubscription = f

	return mmCreateSubscription
}

// Return sets up results that will be returned by BillingServiceClient.CreateSubscription
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Return(pp2 *connect.Response[v1.CreateSubscriptionResponse], err error) *BillingServiceClientMock {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &BillingServiceClientMockCreateSubscriptionExpectation{mock: mmCreateSubscription.mock}
	}
	mmCreateSubscription.defaultExpectation.results = &BillingServiceClientMockCreateSubscriptionResults{pp2, err}
	mmCreateSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateSubscription.mock
}

// Set uses given function f to mock the BillingServiceClient.CreateSubscription method
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest]) (pp2 *connect.Response[v1.CreateSubscriptionResponse], err error)) *BillingServiceClientMock {
	if mmCreateSubscription.defaultExpectation != nil {
		mmCreateSubscription.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CreateSubscription method")
	}

	if len(mmCreateSubscription.expectations) > 0 {
		mmCreateSubscription.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CreateSubscription method")
	}

	mmCreateSubscription.mock.funcCreateSubscription = f
	mmCreateSubscription.mock.funcCreateSubscriptionOrigin = minimock.CallerInfo(1)
	return mmCreateSubscription.mock
}

// When sets expectation for the BillingServiceClient.CreateSubscription which will trigger the result defined by the following
// Then helper
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) When(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest]) *BillingServiceClientMockCreateSubscriptionExpectation {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("BillingServiceClientMock.CreateSubscription mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCreateSubscriptionExpectation{
		mock:               mmCreateSubscription.mock,
		params:             &BillingServiceClientMockCreateSubscriptionParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCreateSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateSubscription.expectations = append(mmCreateSubscription.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CreateSubscription return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCreateSubscriptionExpectation) Then(pp2 *connect.Response[v1.CreateSubscriptionResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCreateSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CreateSubscription should be invoked
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Times(n uint64) *mBillingServiceClientMockCreateSubscription {
	if n == 0 {
		mmCreateSubscription.mock.t.Fatalf("Times of BillingServiceClientMock.CreateSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateSubscription.expectedInvocations, n)
	mmCreateSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateSubscription
}

func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) invocationsDone() bool {
	if len(mmCreateSubscription.expectations) == 0 && mmCreateSubscription.defaultExpectation == nil && mmCreateSubscription.mock.funcCreateSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateSubscription.mock.afterCreateSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateSubscription implements mm_billingv1connect.BillingServiceClient
func (mmCreateSubscription *BillingServiceClientMock) CreateSubscription(ctx context.Context, pp1 *connect.Request[v1.CreateSubscriptionRequest]) (pp2 *connect.Response[v1.CreateSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscription.afterCreateSubscriptionCounter, 1)

	mmCreateSubscription.t.Helper()

	if mmCreateSubscription.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.inspectFuncCreateSubscription(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCreateSubscriptionParams{ctx, pp1}

	// Record call args
	mmCreateSubscription.CreateSubscriptionMock.mutex.Lock()
	mmCreateSubscription.CreateSubscriptionMock.callArgs = append(mmCreateSubscription.CreateSubscriptionMock.callArgs, &mm_params)
	mmCreateSubscription.CreateSubscriptionMock.mutex.Unlock()

	for _, e := range mmCreateSubscription.CreateSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateSubscription.CreateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCreateSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateSubscription.t.Errorf("BillingServiceClientMock.CreateSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateSubscription.t.Errorf("BillingServiceClientMock.CreateSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscription.t.Errorf("BillingServiceClientMock.CreateSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscription.t.Fatal("No results are set for the BillingServiceClientMock.CreateSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateSubscription.funcCreateSubscription != nil {
		return mmCreateSubscription.funcCreateSubscription(ctx, pp1)
	}
	mmCreateSubscription.t.Fatalf("Unexpected call to BillingServiceClientMock.CreateSubscription. %v %v", ctx, pp1)
	return
}

// CreateSubscriptionAfterCounter returns a count of finished BillingServiceClientMock.CreateSubscription invocations
func (mmCreateSubscription *BillingServiceClientMock) CreateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.afterCreateSubscriptionCounter)
}

// CreateSubscriptionBeforeCounter returns a count of BillingServiceClientMock.CreateSubscription invocations
func (mmCreateSubscription *BillingServiceClientMock) CreateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CreateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscription *mBillingServiceClientMockCreateSubscription) Calls() []*BillingServiceClientMockCreateSubscriptionParams {
	mmCreateSubscription.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCreateSubscriptionParams, len(mmCreateSubscription.callArgs))
	copy(argCopy, mmCreateSubscription.callArgs)

	mmCreateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriptionDone returns true if the count of the CreateSubscription invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCreateSubscriptionDone() bool {
	if m.CreateSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateSubscriptionMock.invocationsDone()
}

// MinimockCreateSubscriptionInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCreateSubscriptionInspect() {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateSubscriptionCounter := mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && afterCreateSubscriptionCounter < 1 {
		if m.CreateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateSubscription at\n%s", m.CreateSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateSubscription at\n%s with params: %#v", m.CreateSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.CreateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && afterCreateSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CreateSubscription at\n%s", m.funcCreateSubscriptionOrigin)
	}

	if !m.CreateSubscriptionMock.invocationsDone() && afterCreateSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CreateSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateSubscriptionMock.expectedInvocations), m.CreateSubscriptionMock.expectedInvocationsOrigin, afterCreateSubscriptionCounter)
	}
}

type mBillingServiceClientMockCreateTier struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockCreateTierExpectation
	expectations       []*BillingServiceClientMockCreateTierExpectation

	callArgs []*BillingServiceClientMockCreateTierParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockCreateTierExpectation specifies expectation struct of the BillingServiceClient.CreateTier
type BillingServiceClientMockCreateTierExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockCreateTierParams
	paramPtrs          *BillingServiceClientMockCreateTierParamPtrs
	expectationOrigins BillingServiceClientMockCreateTierExpectationOrigins
	results            *BillingServiceClientMockCreateTierResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockCreateTierParams contains parameters of the BillingServiceClient.CreateTier
type BillingServiceClientMockCreateTierParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateTierRequest]
}

// BillingServiceClientMockCreateTierParamPtrs contains pointers to parameters of the BillingServiceClient.CreateTier
type BillingServiceClientMockCreateTierParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateTierRequest]
}

// BillingServiceClientMockCreateTierResults contains results of the BillingServiceClient.CreateTier
type BillingServiceClientMockCreateTierResults struct {
	pp2 *connect.Response[v1.CreateTierResponse]
	err error
}

// BillingServiceClientMockCreateTierOrigins contains origins of expectations of the BillingServiceClient.CreateTier
type BillingServiceClientMockCreateTierExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTier *mBillingServiceClientMockCreateTier) Optional() *mBillingServiceClientMockCreateTier {
	mmCreateTier.optional = true
	return mmCreateTier
}

// Expect sets up expected params for BillingServiceClient.CreateTier
func (mmCreateTier *mBillingServiceClientMockCreateTier) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest]) *mBillingServiceClientMockCreateTier {
	if mmCreateTier.mock.funcCreateTier != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Set")
	}

	if mmCreateTier.defaultExpectation == nil {
		mmCreateTier.defaultExpectation = &BillingServiceClientMockCreateTierExpectation{}
	}

	if mmCreateTier.defaultExpectation.paramPtrs != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by ExpectParams functions")
	}

	mmCreateTier.defaultExpectation.params = &BillingServiceClientMockCreateTierParams{ctx, pp1}
	mmCreateTier.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTier.expectations {
		if minimock.Equal(e.params, mmCreateTier.defaultExpectation.params) {
			mmCreateTier.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTier.defaultExpectation.params)
		}
	}

	return mmCreateTier
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.CreateTier
func (mmCreateTier *mBillingServiceClientMockCreateTier) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockCreateTier {
	if mmCreateTier.mock.funcCreateTier != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Set")
	}

	if mmCreateTier.defaultExpectation == nil {
		mmCreateTier.defaultExpectation = &BillingServiceClientMockCreateTierExpectation{}
	}

	if mmCreateTier.defaultExpectation.params != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Expect")
	}

	if mmCreateTier.defaultExpectation.paramPtrs == nil {
		mmCreateTier.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateTierParamPtrs{}
	}
	mmCreateTier.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTier.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTier
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.CreateTier
func (mmCreateTier *mBillingServiceClientMockCreateTier) ExpectPp1Param2(pp1 *connect.Request[v1.CreateTierRequest]) *mBillingServiceClientMockCreateTier {
	if mmCreateTier.mock.funcCreateTier != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Set")
	}

	if mmCreateTier.defaultExpectation == nil {
		mmCreateTier.defaultExpectation = &BillingServiceClientMockCreateTierExpectation{}
	}

	if mmCreateTier.defaultExpectation.params != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Expect")
	}

	if mmCreateTier.defaultExpectation.paramPtrs == nil {
		mmCreateTier.defaultExpectation.paramPtrs = &BillingServiceClientMockCreateTierParamPtrs{}
	}
	mmCreateTier.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateTier.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateTier
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.CreateTier
func (mmCreateTier *mBillingServiceClientMockCreateTier) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest])) *mBillingServiceClientMockCreateTier {
	if mmCreateTier.mock.inspectFuncCreateTier != nil {
		mmCreateTier.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.CreateTier")
	}

	mmCreateTier.mock.inspectFuncCreateTier = f

	return mmCreateTier
}

// Return sets up results that will be returned by BillingServiceClient.CreateTier
func (mmCreateTier *mBillingServiceClientMockCreateTier) Return(pp2 *connect.Response[v1.CreateTierResponse], err error) *BillingServiceClientMock {
	if mmCreateTier.mock.funcCreateTier != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Set")
	}

	if mmCreateTier.defaultExpectation == nil {
		mmCreateTier.defaultExpectation = &BillingServiceClientMockCreateTierExpectation{mock: mmCreateTier.mock}
	}
	mmCreateTier.defaultExpectation.results = &BillingServiceClientMockCreateTierResults{pp2, err}
	mmCreateTier.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTier.mock
}

// Set uses given function f to mock the BillingServiceClient.CreateTier method
func (mmCreateTier *mBillingServiceClientMockCreateTier) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest]) (pp2 *connect.Response[v1.CreateTierResponse], err error)) *BillingServiceClientMock {
	if mmCreateTier.defaultExpectation != nil {
		mmCreateTier.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.CreateTier method")
	}

	if len(mmCreateTier.expectations) > 0 {
		mmCreateTier.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.CreateTier method")
	}

	mmCreateTier.mock.funcCreateTier = f
	mmCreateTier.mock.funcCreateTierOrigin = minimock.CallerInfo(1)
	return mmCreateTier.mock
}

// When sets expectation for the BillingServiceClient.CreateTier which will trigger the result defined by the following
// Then helper
func (mmCreateTier *mBillingServiceClientMockCreateTier) When(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest]) *BillingServiceClientMockCreateTierExpectation {
	if mmCreateTier.mock.funcCreateTier != nil {
		mmCreateTier.mock.t.Fatalf("BillingServiceClientMock.CreateTier mock is already set by Set")
	}

	expectation := &BillingServiceClientMockCreateTierExpectation{
		mock:               mmCreateTier.mock,
		params:             &BillingServiceClientMockCreateTierParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockCreateTierExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTier.expectations = append(mmCreateTier.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.CreateTier return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockCreateTierExpectation) Then(pp2 *connect.Response[v1.CreateTierResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockCreateTierResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.CreateTier should be invoked
func (mmCreateTier *mBillingServiceClientMockCreateTier) Times(n uint64) *mBillingServiceClientMockCreateTier {
	if n == 0 {
		mmCreateTier.mock.t.Fatalf("Times of BillingServiceClientMock.CreateTier mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTier.expectedInvocations, n)
	mmCreateTier.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTier
}

func (mmCreateTier *mBillingServiceClientMockCreateTier) invocationsDone() bool {
	if len(mmCreateTier.expectations) == 0 && mmCreateTier.defaultExpectation == nil && mmCreateTier.mock.funcCreateTier == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTier.mock.afterCreateTierCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTier.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTier implements mm_billingv1connect.BillingServiceClient
func (mmCreateTier *BillingServiceClientMock) CreateTier(ctx context.Context, pp1 *connect.Request[v1.CreateTierRequest]) (pp2 *connect.Response[v1.CreateTierResponse], err error) {
	mm_atomic.AddUint64(&mmCreateTier.beforeCreateTierCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTier.afterCreateTierCounter, 1)

	mmCreateTier.t.Helper()

	if mmCreateTier.inspectFuncCreateTier != nil {
		mmCreateTier.inspectFuncCreateTier(ctx, pp1)
	}

	mm_params := BillingServiceClientMockCreateTierParams{ctx, pp1}

	// Record call args
	mmCreateTier.CreateTierMock.mutex.Lock()
	mmCreateTier.CreateTierMock.callArgs = append(mmCreateTier.CreateTierMock.callArgs, &mm_params)
	mmCreateTier.CreateTierMock.mutex.Unlock()

	for _, e := range mmCreateTier.CreateTierMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateTier.CreateTierMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTier.CreateTierMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTier.CreateTierMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTier.CreateTierMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockCreateTierParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTier.t.Errorf("BillingServiceClientMock.CreateTier got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTier.CreateTierMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateTier.t.Errorf("BillingServiceClientMock.CreateTier got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTier.CreateTierMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTier.t.Errorf("BillingServiceClientMock.CreateTier got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTier.CreateTierMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTier.CreateTierMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTier.t.Fatal("No results are set for the BillingServiceClientMock.CreateTier")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateTier.funcCreateTier != nil {
		return mmCreateTier.funcCreateTier(ctx, pp1)
	}
	mmCreateTier.t.Fatalf("Unexpected call to BillingServiceClientMock.CreateTier. %v %v", ctx, pp1)
	return
}

// CreateTierAfterCounter returns a count of finished BillingServiceClientMock.CreateTier invocations
func (mmCreateTier *BillingServiceClientMock) CreateTierAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTier.afterCreateTierCounter)
}

// CreateTierBeforeCounter returns a count of BillingServiceClientMock.CreateTier invocations
func (mmCreateTier *BillingServiceClientMock) CreateTierBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTier.beforeCreateTierCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.CreateTier.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTier *mBillingServiceClientMockCreateTier) Calls() []*BillingServiceClientMockCreateTierParams {
	mmCreateTier.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockCreateTierParams, len(mmCreateTier.callArgs))
	copy(argCopy, mmCreateTier.callArgs)

	mmCreateTier.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTierDone returns true if the count of the CreateTier invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockCreateTierDone() bool {
	if m.CreateTierMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTierMock.invocationsDone()
}

// MinimockCreateTierInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockCreateTierInspect() {
	for _, e := range m.CreateTierMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateTier at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTierCounter := mm_atomic.LoadUint64(&m.afterCreateTierCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTierMock.defaultExpectation != nil && afterCreateTierCounter < 1 {
		if m.CreateTierMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateTier at\n%s", m.CreateTierMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.CreateTier at\n%s with params: %#v", m.CreateTierMock.defaultExpectation.expectationOrigins.origin, *m.CreateTierMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTier != nil && afterCreateTierCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.CreateTier at\n%s", m.funcCreateTierOrigin)
	}

	if !m.CreateTierMock.invocationsDone() && afterCreateTierCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.CreateTier at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTierMock.expectedInvocations), m.CreateTierMock.expectedInvocationsOrigin, afterCreateTierCounter)
	}
}

type mBillingServiceClientMockGetBillingRun struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockGetBillingRunExpectation
	expectations       []*BillingServiceClientMockGetBillingRunExpectation

	callArgs []*BillingServiceClientMockGetBillingRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockGetBillingRunExpectation specifies expectation struct of the BillingServiceClient.GetBillingRun
type BillingServiceClientMockGetBillingRunExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockGetBillingRunParams
	paramPtrs          *BillingServiceClientMockGetBillingRunParamPtrs
	expectationOrigins BillingServiceClientMockGetBillingRunExpectationOrigins
	results            *BillingServiceClientMockGetBillingRunResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockGetBillingRunParams contains parameters of the BillingServiceClient.GetBillingRun
type BillingServiceClientMockGetBillingRunParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetBillingRunRequest]
}

// BillingServiceClientMockGetBillingRunParamPtrs contains pointers to parameters of the BillingServiceClient.GetBillingRun
type BillingServiceClientMockGetBillingRunParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetBillingRunRequest]
}

// BillingServiceClientMockGetBillingRunResults contains results of the BillingServiceClient.GetBillingRun
type BillingServiceClientMockGetBillingRunResults struct {
	pp2 *connect.Response[v1.GetBillingRunResponse]
	err error
}

// BillingServiceClientMockGetBillingRunOrigins contains origins of expectations of the BillingServiceClient.GetBillingRun
type BillingServiceClientMockGetBillingRunExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Optional() *mBillingServiceClientMockGetBillingRun {
	mmGetBillingRun.optional = true
	return mmGetBillingRun
}

// Expect sets up expected params for BillingServiceClient.GetBillingRun
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Expect(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest]) *mBillingServiceClientMockGetBillingRun {
	if mmGetBillingRun.mock.funcGetBillingRun != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Set")
	}

	if mmGetBillingRun.defaultExpectation == nil {
		mmGetBillingRun.defaultExpectation = &BillingServiceClientMockGetBillingRunExpectation{}
	}

	if mmGetBillingRun.defaultExpectation.paramPtrs != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by ExpectParams functions")
	}

	mmGetBillingRun.defaultExpectation.params = &BillingServiceClientMockGetBillingRunParams{ctx, pp1}
	mmGetBillingRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBillingRun.expectations {
		if minimock.Equal(e.params, mmGetBillingRun.defaultExpectation.params) {
			mmGetBillingRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBillingRun.defaultExpectation.params)
		}
	}

	return mmGetBillingRun
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.GetBillingRun
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockGetBillingRun {
	if mmGetBillingRun.mock.funcGetBillingRun != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Set")
	}

	if mmGetBillingRun.defaultExpectation == nil {
		mmGetBillingRun.defaultExpectation = &BillingServiceClientMockGetBillingRunExpectation{}
	}

	if mmGetBillingRun.defaultExpectation.params != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Expect")
	}

	if mmGetBillingRun.defaultExpectation.paramPtrs == nil {
		mmGetBillingRun.defaultExpectation.paramPtrs = &BillingServiceClientMockGetBillingRunParamPtrs{}
	}
	mmGetBillingRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBillingRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBillingRun
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.GetBillingRun
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) ExpectPp1Param2(pp1 *connect.Request[v1.GetBillingRunRequest]) *mBillingServiceClientMockGetBillingRun {
	if mmGetBillingRun.mock.funcGetBillingRun != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Set")
	}

	if mmGetBillingRun.defaultExpectation == nil {
		mmGetBillingRun.defaultExpectation = &BillingServiceClientMockGetBillingRunExpectation{}
	}

	if mmGetBillingRun.defaultExpectation.params != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Expect")
	}

	if mmGetBillingRun.defaultExpectation.paramPtrs == nil {
		mmGetBillingRun.defaultExpectation.paramPtrs = &BillingServiceClientMockGetBillingRunParamPtrs{}
	}
	mmGetBillingRun.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetBillingRun.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetBillingRun
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.GetBillingRun
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest])) *mBillingServiceClientMockGetBillingRun {
	if mmGetBillingRun.mock.inspectFuncGetBillingRun != nil {
		mmGetBillingRun.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.GetBillingRun")
	}

	mmGetBillingRun.mock.inspectFuncGetBillingRun = f

	return mmGetBillingRun
}

// Return sets up results that will be returned by BillingServiceClient.GetBillingRun
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Return(pp2 *connect.Response[v1.GetBillingRunResponse], err error) *BillingServiceClientMock {
	if mmGetBillingRun.mock.funcGetBillingRun != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Set")
	}

	if mmGetBillingRun.defaultExpectation == nil {
		mmGetBillingRun.defaultExpectation = &BillingServiceClientMockGetBillingRunExpectation{mock: mmGetBillingRun.mock}
	}
	mmGetBillingRun.defaultExpectation.results = &BillingServiceClientMockGetBillingRunResults{pp2, err}
	mmGetBillingRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBillingRun.mock
}

// Set uses given function f to mock the BillingServiceClient.GetBillingRun method
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest]) (pp2 *connect.Response[v1.GetBillingRunResponse], err error)) *BillingServiceClientMock {
	if mmGetBillingRun.defaultExpectation != nil {
		mmGetBillingRun.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.GetBillingRun method")
	}

	if len(mmGetBillingRun.expectations) > 0 {
		mmGetBillingRun.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.GetBillingRun method")
	}

	mmGetBillingRun.mock.funcGetBillingRun = f
	mmGetBillingRun.mock.funcGetBillingRunOrigin = minimock.CallerInfo(1)
	return mmGetBillingRun.mock
}

// When sets expectation for the BillingServiceClient.GetBillingRun which will trigger the result defined by the following
// Then helper
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) When(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest]) *BillingServiceClientMockGetBillingRunExpectation {
	if mmGetBillingRun.mock.funcGetBillingRun != nil {
		mmGetBillingRun.mock.t.Fatalf("BillingServiceClientMock.GetBillingRun mock is already set by Set")
	}

	expectation := &BillingServiceClientMockGetBillingRunExpectation{
		mock:               mmGetBillingRun.mock,
		params:             &BillingServiceClientMockGetBillingRunParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockGetBillingRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBillingRun.expectations = append(mmGetBillingRun.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.GetBillingRun return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockGetBillingRunExpectation) Then(pp2 *connect.Response[v1.GetBillingRunResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockGetBillingRunResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.GetBillingRun should be invoked
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Times(n uint64) *mBillingServiceClientMockGetBillingRun {
	if n == 0 {
		mmGetBillingRun.mock.t.Fatalf("Times of BillingServiceClientMock.GetBillingRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBillingRun.expectedInvocations, n)
	mmGetBillingRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBillingRun
}

func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) invocationsDone() bool {
	if len(mmGetBillingRun.expectations) == 0 && mmGetBillingRun.defaultExpectation == nil && mmGetBillingRun.mock.funcGetBillingRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBillingRun.mock.afterGetBillingRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBillingRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBillingRun implements mm_billingv1connect.BillingServiceClient
func (mmGetBillingRun *BillingServiceClientMock) GetBillingRun(ctx context.Context, pp1 *connect.Request[v1.GetBillingRunRequest]) (pp2 *connect.Response[v1.GetBillingRunResponse], err error) {
	mm_atomic.AddUint64(&mmGetBillingRun.beforeGetBillingRunCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBillingRun.afterGetBillingRunCounter, 1)

	mmGetBillingRun.t.Helper()

	if mmGetBillingRun.inspectFuncGetBillingRun != nil {
		mmGetBillingRun.inspectFuncGetBillingRun(ctx, pp1)
	}

	mm_params := BillingServiceClientMockGetBillingRunParams{ctx, pp1}

	// Record call args
	mmGetBillingRun.GetBillingRunMock.mutex.Lock()
	mmGetBillingRun.GetBillingRunMock.callArgs = append(mmGetBillingRun.GetBillingRunMock.callArgs, &mm_params)
	mmGetBillingRun.GetBillingRunMock.mutex.Unlock()

	for _, e := range mmGetBillingRun.GetBillingRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetBillingRun.GetBillingRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBillingRun.GetBillingRunMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBillingRun.GetBillingRunMock.defaultExpectation.params
		mm_want_ptrs := mmGetBillingRun.GetBillingRunMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockGetBillingRunParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBillingRun.t.Errorf("BillingServiceClientMock.GetBillingRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBillingRun.GetBillingRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetBillingRun.t.Errorf("BillingServiceClientMock.GetBillingRun got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBillingRun.GetBillingRunMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBillingRun.t.Errorf("BillingServiceClientMock.GetBillingRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBillingRun.GetBillingRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBillingRun.GetBillingRunMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBillingRun.t.Fatal("No results are set for the BillingServiceClientMock.GetBillingRun")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetBillingRun.funcGetBillingRun != nil {
		return mmGetBillingRun.funcGetBillingRun(ctx, pp1)
	}
	mmGetBillingRun.t.Fatalf("Unexpected call to BillingServiceClientMock.GetBillingRun. %v %v", ctx, pp1)
	return
}

// GetBillingRunAfterCounter returns a count of finished BillingServiceClientMock.GetBillingRun invocations
func (mmGetBillingRun *BillingServiceClientMock) GetBillingRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBillingRun.afterGetBillingRunCounter)
}

// GetBillingRunBeforeCounter returns a count of BillingServiceClientMock.GetBillingRun invocations
func (mmGetBillingRun *BillingServiceClientMock) GetBillingRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBillingRun.beforeGetBillingRunCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.GetBillingRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBillingRun *mBillingServiceClientMockGetBillingRun) Calls() []*BillingServiceClientMockGetBillingRunParams {
	mmGetBillingRun.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockGetBillingRunParams, len(mmGetBillingRun.callArgs))
	copy(argCopy, mmGetBillingRun.callArgs)

	mmGetBillingRun.mutex.RUnlock()

	return argCopy
}

// MinimockGetBillingRunDone returns true if the count of the GetBillingRun invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockGetBillingRunDone() bool {
	if m.GetBillingRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBillingRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBillingRunMock.invocationsDone()
}

// MinimockGetBillingRunInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockGetBillingRunInspect() {
	for _, e := range m.GetBillingRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetBillingRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBillingRunCounter := mm_atomic.LoadUint64(&m.afterGetBillingRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBillingRunMock.defaultExpectation != nil && afterGetBillingRunCounter < 1 {
		if m.GetBillingRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetBillingRun at\n%s", m.GetBillingRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetBillingRun at\n%s with params: %#v", m.GetBillingRunMock.defaultExpectation.expectationOrigins.origin, *m.GetBillingRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBillingRun != nil && afterGetBillingRunCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.GetBillingRun at\n%s", m.funcGetBillingRunOrigin)
	}

	if !m.GetBillingRunMock.invocationsDone() && afterGetBillingRunCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.GetBillingRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBillingRunMock.expectedInvocations), m.GetBillingRunMock.expectedInvocationsOrigin, afterGetBillingRunCounter)
	}
}

type mBillingServiceClientMockGetCatalogVersion struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockGetCatalogVersionExpectation
	expectations       []*BillingServiceClientMockGetCatalogVersionExpectation

	callArgs []*BillingServiceClientMockGetCatalogVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockGetCatalogVersionExpectation specifies expectation struct of the BillingServiceClient.GetCatalogVersion
type BillingServiceClientMockGetCatalogVersionExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockGetCatalogVersionParams
	paramPtrs          *BillingServiceClientMockGetCatalogVersionParamPtrs
	expectationOrigins BillingServiceClientMockGetCatalogVersionExpectationOrigins
	results            *BillingServiceClientMockGetCatalogVersionResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockGetCatalogVersionParams contains parameters of the BillingServiceClient.GetCatalogVersion
type BillingServiceClientMockGetCatalogVersionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetCatalogVersionRequest]
}

// BillingServiceClientMockGetCatalogVersionParamPtrs contains pointers to parameters of the BillingServiceClient.GetCatalogVersion
type BillingServiceClientMockGetCatalogVersionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetCatalogVersionRequest]
}

// BillingServiceClientMockGetCatalogVersionResults contains results of the BillingServiceClient.GetCatalogVersion
type BillingServiceClientMockGetCatalogVersionResults struct {
	pp2 *connect.Response[v1.GetCatalogVersionResponse]
	err error
}

// BillingServiceClientMockGetCatalogVersionOrigins contains origins of expectations of the BillingServiceClient.GetCatalogVersion
type BillingServiceClientMockGetCatalogVersionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Optional() *mBillingServiceClientMockGetCatalogVersion {
	mmGetCatalogVersion.optional = true
	return mmGetCatalogVersion
}

// Expect sets up expected params for BillingServiceClient.GetCatalogVersion
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Expect(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest]) *mBillingServiceClientMockGetCatalogVersion {
	if mmGetCatalogVersion.mock.funcGetCatalogVersion != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Set")
	}

	if mmGetCatalogVersion.defaultExpectation == nil {
		mmGetCatalogVersion.defaultExpectation = &BillingServiceClientMockGetCatalogVersionExpectation{}
	}

	if mmGetCatalogVersion.defaultExpectation.paramPtrs != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by ExpectParams functions")
	}

	mmGetCatalogVersion.defaultExpectation.params = &BillingServiceClientMockGetCatalogVersionParams{ctx, pp1}
	mmGetCatalogVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCatalogVersion.expectations {
		if minimock.Equal(e.params, mmGetCatalogVersion.defaultExpectation.params) {
			mmGetCatalogVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCatalogVersion.defaultExpectation.params)
		}
	}

	return mmGetCatalogVersion
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.GetCatalogVersion
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockGetCatalogVersion {
	if mmGetCatalogVersion.mock.funcGetCatalogVersion != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Set")
	}

	if mmGetCatalogVersion.defaultExpectation == nil {
		mmGetCatalogVersion.defaultExpectation = &BillingServiceClientMockGetCatalogVersionExpectation{}
	}

	if mmGetCatalogVersion.defaultExpectation.params != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Expect")
	}

	if mmGetCatalogVersion.defaultExpectation.paramPtrs == nil {
		mmGetCatalogVersion.defaultExpectation.paramPtrs = &BillingServiceClientMockGetCatalogVersionParamPtrs{}
	}
	mmGetCatalogVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCatalogVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCatalogVersion
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.GetCatalogVersion
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) ExpectPp1Param2(pp1 *connect.Request[v1.GetCatalogVersionRequest]) *mBillingServiceClientMockGetCatalogVersion {
	if mmGetCatalogVersion.mock.funcGetCatalogVersion != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Set")
	}

	if mmGetCatalogVersion.defaultExpectation == nil {
		mmGetCatalogVersion.defaultExpectation = &BillingServiceClientMockGetCatalogVersionExpectation{}
	}

	if mmGetCatalogVersion.defaultExpectation.params != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Expect")
	}

	if mmGetCatalogVersion.defaultExpectation.paramPtrs == nil {
		mmGetCatalogVersion.defaultExpectation.paramPtrs = &BillingServiceClientMockGetCatalogVersionParamPtrs{}
	}
	mmGetCatalogVersion.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetCatalogVersion.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetCatalogVersion
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.GetCatalogVersion
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest])) *mBillingServiceClientMockGetCatalogVersion {
	if mmGetCatalogVersion.mock.inspectFuncGetCatalogVersion != nil {
		mmGetCatalogVersion.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.GetCatalogVersion")
	}

	mmGetCatalogVersion.mock.inspectFuncGetCatalogVersion = f

	return mmGetCatalogVersion
}

// Return sets up results that will be returned by BillingServiceClient.GetCatalogVersion
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Return(pp2 *connect.Response[v1.GetCatalogVersionResponse], err error) *BillingServiceClientMock {
	if mmGetCatalogVersion.mock.funcGetCatalogVersion != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Set")
	}

	if mmGetCatalogVersion.defaultExpectation == nil {
		mmGetCatalogVersion.defaultExpectation = &BillingServiceClientMockGetCatalogVersionExpectation{mock: mmGetCatalogVersion.mock}
	}
	mmGetCatalogVersion.defaultExpectation.results = &BillingServiceClientMockGetCatalogVersionResults{pp2, err}
	mmGetCatalogVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCatalogVersion.mock
}

// Set uses given function f to mock the BillingServiceClient.GetCatalogVersion method
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest]) (pp2 *connect.Response[v1.GetCatalogVersionResponse], err error)) *BillingServiceClientMock {
	if mmGetCatalogVersion.defaultExpectation != nil {
		mmGetCatalogVersion.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.GetCatalogVersion method")
	}

	if len(mmGetCatalogVersion.expectations) > 0 {
		mmGetCatalogVersion.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.GetCatalogVersion method")
	}

	mmGetCatalogVersion.mock.funcGetCatalogVersion = f
	mmGetCatalogVersion.mock.funcGetCatalogVersionOrigin = minimock.CallerInfo(1)
	return mmGetCatalogVersion.mock
}

// When sets expectation for the BillingServiceClient.GetCatalogVersion which will trigger the result defined by the following
// Then helper
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) When(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest]) *BillingServiceClientMockGetCatalogVersionExpectation {
	if mmGetCatalogVersion.mock.funcGetCatalogVersion != nil {
		mmGetCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.GetCatalogVersion mock is already set by Set")
	}

	expectation := &BillingServiceClientMockGetCatalogVersionExpectation{
		mock:               mmGetCatalogVersion.mock,
		params:             &BillingServiceClientMockGetCatalogVersionParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockGetCatalogVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCatalogVersion.expectations = append(mmGetCatalogVersion.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.GetCatalogVersion return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockGetCatalogVersionExpectation) Then(pp2 *connect.Response[v1.GetCatalogVersionResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockGetCatalogVersionResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.GetCatalogVersion should be invoked
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Times(n uint64) *mBillingServiceClientMockGetCatalogVersion {
	if n == 0 {
		mmGetCatalogVersion.mock.t.Fatalf("Times of BillingServiceClientMock.GetCatalogVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCatalogVersion.expectedInvocations, n)
	mmGetCatalogVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCatalogVersion
}

func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) invocationsDone() bool {
	if len(mmGetCatalogVersion.expectations) == 0 && mmGetCatalogVersion.defaultExpectation == nil && mmGetCatalogVersion.mock.funcGetCatalogVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCatalogVersion.mock.afterGetCatalogVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCatalogVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCatalogVersion implements mm_billingv1connect.BillingServiceClient
func (mmGetCatalogVersion *BillingServiceClientMock) GetCatalogVersion(ctx context.Context, pp1 *connect.Request[v1.GetCatalogVersionRequest]) (pp2 *connect.Response[v1.GetCatalogVersionResponse], err error) {
	mm_atomic.AddUint64(&mmGetCatalogVersion.beforeGetCatalogVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCatalogVersion.afterGetCatalogVersionCounter, 1)

	mmGetCatalogVersion.t.Helper()

	if mmGetCatalogVersion.inspectFuncGetCatalogVersion != nil {
		mmGetCatalogVersion.inspectFuncGetCatalogVersion(ctx, pp1)
	}

	mm_params := BillingServiceClientMockGetCatalogVersionParams{ctx, pp1}

	// Record call args
	mmGetCatalogVersion.GetCatalogVersionMock.mutex.Lock()
	mmGetCatalogVersion.GetCatalogVersionMock.callArgs = append(mmGetCatalogVersion.GetCatalogVersionMock.callArgs, &mm_params)
	mmGetCatalogVersion.GetCatalogVersionMock.mutex.Unlock()

	for _, e := range mmGetCatalogVersion.GetCatalogVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.params
		mm_want_ptrs := mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockGetCatalogVersionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCatalogVersion.t.Errorf("BillingServiceClientMock.GetCatalogVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetCatalogVersion.t.Errorf("BillingServiceClientMock.GetCatalogVersion got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCatalogVersion.t.Errorf("BillingServiceClientMock.GetCatalogVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCatalogVersion.GetCatalogVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCatalogVersion.t.Fatal("No results are set for the BillingServiceClientMock.GetCatalogVersion")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetCatalogVersion.funcGetCatalogVersion != nil {
		return mmGetCatalogVersion.funcGetCatalogVersion(ctx, pp1)
	}
	mmGetCatalogVersion.t.Fatalf("Unexpected call to BillingServiceClientMock.GetCatalogVersion. %v %v", ctx, pp1)
	return
}

// GetCatalogVersionAfterCounter returns a count of finished BillingServiceClientMock.GetCatalogVersion invocations
func (mmGetCatalogVersion *BillingServiceClientMock) GetCatalogVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCatalogVersion.afterGetCatalogVersionCounter)
}

// GetCatalogVersionBeforeCounter returns a count of BillingServiceClientMock.GetCatalogVersion invocations
func (mmGetCatalogVersion *BillingServiceClientMock) GetCatalogVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCatalogVersion.beforeGetCatalogVersionCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.GetCatalogVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCatalogVersion *mBillingServiceClientMockGetCatalogVersion) Calls() []*BillingServiceClientMockGetCatalogVersionParams {
	mmGetCatalogVersion.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockGetCatalogVersionParams, len(mmGetCatalogVersion.callArgs))
	copy(argCopy, mmGetCatalogVersion.callArgs)

	mmGetCatalogVersion.mutex.RUnlock()

	return argCopy
}

// MinimockGetCatalogVersionDone returns true if the count of the GetCatalogVersion invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockGetCatalogVersionDone() bool {
	if m.GetCatalogVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCatalogVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCatalogVersionMock.invocationsDone()
}

// MinimockGetCatalogVersionInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockGetCatalogVersionInspect() {
	for _, e := range m.GetCatalogVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetCatalogVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCatalogVersionCounter := mm_atomic.LoadUint64(&m.afterGetCatalogVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCatalogVersionMock.defaultExpectation != nil && afterGetCatalogVersionCounter < 1 {
		if m.GetCatalogVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetCatalogVersion at\n%s", m.GetCatalogVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetCatalogVersion at\n%s with params: %#v", m.GetCatalogVersionMock.defaultExpectation.expectationOrigins.origin, *m.GetCatalogVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCatalogVersion != nil && afterGetCatalogVersionCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.GetCatalogVersion at\n%s", m.funcGetCatalogVersionOrigin)
	}

	if !m.GetCatalogVersionMock.invocationsDone() && afterGetCatalogVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.GetCatalogVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCatalogVersionMock.expectedInvocations), m.GetCatalogVersionMock.expectedInvocationsOrigin, afterGetCatalogVersionCounter)
	}
}

type mBillingServiceClientMockGetCreditBalance struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockGetCreditBalanceExpectation
	expectations       []*BillingServiceClientMockGetCreditBalanceExpectation

	callArgs []*BillingServiceClientMockGetCreditBalanceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockGetCreditBalanceExpectation specifies expectation struct of the BillingServiceClient.GetCreditBalance
type BillingServiceClientMockGetCreditBalanceExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockGetCreditBalanceParams
	paramPtrs          *BillingServiceClientMockGetCreditBalanceParamPtrs
	expectationOrigins BillingServiceClientMockGetCreditBalanceExpectationOrigins
	results            *BillingServiceClientMockGetCreditBalanceResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockGetCreditBalanceParams contains parameters of the BillingServiceClient.GetCreditBalance
type BillingServiceClientMockGetCreditBalanceParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetCreditBalanceRequest]
}

// BillingServiceClientMockGetCreditBalanceParamPtrs contains pointers to parameters of the BillingServiceClient.GetCreditBalance
type BillingServiceClientMockGetCreditBalanceParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetCreditBalanceRequest]
}

// BillingServiceClientMockGetCreditBalanceResults contains results of the BillingServiceClient.GetCreditBalance
type BillingServiceClientMockGetCreditBalanceResults struct {
	pp2 *connect.Response[v1.GetCreditBalanceResponse]
	err error
}

// BillingServiceClientMockGetCreditBalanceOrigins contains origins of expectations of the BillingServiceClient.GetCreditBalance
type BillingServiceClientMockGetCreditBalanceExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Optional() *mBillingServiceClientMockGetCreditBalance {
	mmGetCreditBalance.optional = true
	return mmGetCreditBalance
}

// Expect sets up expected params for BillingServiceClient.GetCreditBalance
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Expect(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest]) *mBillingServiceClientMockGetCreditBalance {
	if mmGetCreditBalance.mock.funcGetCreditBalance != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Set")
	}

	if mmGetCreditBalance.defaultExpectation == nil {
		mmGetCreditBalance.defaultExpectation = &BillingServiceClientMockGetCreditBalanceExpectation{}
	}

	if mmGetCreditBalance.defaultExpectation.paramPtrs != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by ExpectParams functions")
	}

	mmGetCreditBalance.defaultExpectation.params = &BillingServiceClientMockGetCreditBalanceParams{ctx, pp1}
	mmGetCreditBalance.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCreditBalance.expectations {
		if minimock.Equal(e.params, mmGetCreditBalance.defaultExpectation.params) {
			mmGetCreditBalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCreditBalance.defaultExpectation.params)
		}
	}

	return mmGetCreditBalance
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.GetCreditBalance
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockGetCreditBalance {
	if mmGetCreditBalance.mock.funcGetCreditBalance != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Set")
	}

	if mmGetCreditBalance.defaultExpectation == nil {
		mmGetCreditBalance.defaultExpectation = &BillingServiceClientMockGetCreditBalanceExpectation{}
	}

	if mmGetCreditBalance.defaultExpectation.params != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Expect")
	}

	if mmGetCreditBalance.defaultExpectation.paramPtrs == nil {
		mmGetCreditBalance.defaultExpectation.paramPtrs = &BillingServiceClientMockGetCreditBalanceParamPtrs{}
	}
	mmGetCreditBalance.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCreditBalance.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCreditBalance
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.GetCreditBalance
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) ExpectPp1Param2(pp1 *connect.Request[v1.GetCreditBalanceRequest]) *mBillingServiceClientMockGetCreditBalance {
	if mmGetCreditBalance.mock.funcGetCreditBalance != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Set")
	}

	if mmGetCreditBalance.defaultExpectation == nil {
		mmGetCreditBalance.defaultExpectation = &BillingServiceClientMockGetCreditBalanceExpectation{}
	}

	if mmGetCreditBalance.defaultExpectation.params != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Expect")
	}

	if mmGetCreditBalance.defaultExpectation.paramPtrs == nil {
		mmGetCreditBalance.defaultExpectation.paramPtrs = &BillingServiceClientMockGetCreditBalanceParamPtrs{}
	}
	mmGetCreditBalance.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetCreditBalance.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetCreditBalance
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.GetCreditBalance
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest])) *mBillingServiceClientMockGetCreditBalance {
	if mmGetCreditBalance.mock.inspectFuncGetCreditBalance != nil {
		mmGetCreditBalance.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.GetCreditBalance")
	}

	mmGetCreditBalance.mock.inspectFuncGetCreditBalance = f

	return mmGetCreditBalance
}

// Return sets up results that will be returned by BillingServiceClient.GetCreditBalance
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Return(pp2 *connect.Response[v1.GetCreditBalanceResponse], err error) *BillingServiceClientMock {
	if mmGetCreditBalance.mock.funcGetCreditBalance != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Set")
	}

	if mmGetCreditBalance.defaultExpectation == nil {
		mmGetCreditBalance.defaultExpectation = &BillingServiceClientMockGetCreditBalanceExpectation{mock: mmGetCreditBalance.mock}
	}
	mmGetCreditBalance.defaultExpectation.results = &BillingServiceClientMockGetCreditBalanceResults{pp2, err}
	mmGetCreditBalance.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCreditBalance.mock
}

// Set uses given function f to mock the BillingServiceClient.GetCreditBalance method
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest]) (pp2 *connect.Response[v1.GetCreditBalanceResponse], err error)) *BillingServiceClientMock {
	if mmGetCreditBalance.defaultExpectation != nil {
		mmGetCreditBalance.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.GetCreditBalance method")
	}

	if len(mmGetCreditBalance.expectations) > 0 {
		mmGetCreditBalance.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.GetCreditBalance method")
	}

	mmGetCreditBalance.mock.funcGetCreditBalance = f
	mmGetCreditBalance.mock.funcGetCreditBalanceOrigin = minimock.CallerInfo(1)
	return mmGetCreditBalance.mock
}

// When sets expectation for the BillingServiceClient.GetCreditBalance which will trigger the result defined by the following
// Then helper
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) When(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest]) *BillingServiceClientMockGetCreditBalanceExpectation {
	if mmGetCreditBalance.mock.funcGetCreditBalance != nil {
		mmGetCreditBalance.mock.t.Fatalf("BillingServiceClientMock.GetCreditBalance mock is already set by Set")
	}

	expectation := &BillingServiceClientMockGetCreditBalanceExpectation{
		mock:               mmGetCreditBalance.mock,
		params:             &BillingServiceClientMockGetCreditBalanceParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockGetCreditBalanceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCreditBalance.expectations = append(mmGetCreditBalance.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.GetCreditBalance return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockGetCreditBalanceExpectation) Then(pp2 *connect.Response[v1.GetCreditBalanceResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockGetCreditBalanceResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.GetCreditBalance should be invoked
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Times(n uint64) *mBillingServiceClientMockGetCreditBalance {
	if n == 0 {
		mmGetCreditBalance.mock.t.Fatalf("Times of BillingServiceClientMock.GetCreditBalance mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCreditBalance.expectedInvocations, n)
	mmGetCreditBalance.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCreditBalance
}

func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) invocationsDone() bool {
	if len(mmGetCreditBalance.expectations) == 0 && mmGetCreditBalance.defaultExpectation == nil && mmGetCreditBalance.mock.funcGetCreditBalance == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCreditBalance.mock.afterGetCreditBalanceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCreditBalance.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCreditBalance implements mm_billingv1connect.BillingServiceClient
func (mmGetCreditBalance *BillingServiceClientMock) GetCreditBalance(ctx context.Context, pp1 *connect.Request[v1.GetCreditBalanceRequest]) (pp2 *connect.Response[v1.GetCreditBalanceResponse], err error) {
	mm_atomic.AddUint64(&mmGetCreditBalance.beforeGetCreditBalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCreditBalance.afterGetCreditBalanceCounter, 1)

	mmGetCreditBalance.t.Helper()

	if mmGetCreditBalance.inspectFuncGetCreditBalance != nil {
		mmGetCreditBalance.inspectFuncGetCreditBalance(ctx, pp1)
	}

	mm_params := BillingServiceClientMockGetCreditBalanceParams{ctx, pp1}

	// Record call args
	mmGetCreditBalance.GetCreditBalanceMock.mutex.Lock()
	mmGetCreditBalance.GetCreditBalanceMock.callArgs = append(mmGetCreditBalance.GetCreditBalanceMock.callArgs, &mm_params)
	mmGetCreditBalance.GetCreditBalanceMock.mutex.Unlock()

	for _, e := range mmGetCreditBalance.GetCreditBalanceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.params
		mm_want_ptrs := mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockGetCreditBalanceParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCreditBalance.t.Errorf("BillingServiceClientMock.GetCreditBalance got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetCreditBalance.t.Errorf("BillingServiceClientMock.GetCreditBalance got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCreditBalance.t.Errorf("BillingServiceClientMock.GetCreditBalance got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCreditBalance.GetCreditBalanceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCreditBalance.t.Fatal("No results are set for the BillingServiceClientMock.GetCreditBalance")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetCreditBalance.funcGetCreditBalance != nil {
		return mmGetCreditBalance.funcGetCreditBalance(ctx, pp1)
	}
	mmGetCreditBalance.t.Fatalf("Unexpected call to BillingServiceClientMock.GetCreditBalance. %v %v", ctx, pp1)
	return
}

// GetCreditBalanceAfterCounter returns a count of finished BillingServiceClientMock.GetCreditBalance invocations
func (mmGetCreditBalance *BillingServiceClientMock) GetCreditBalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCreditBalance.afterGetCreditBalanceCounter)
}

// GetCreditBalanceBeforeCounter returns a count of BillingServiceClientMock.GetCreditBalance invocations
func (mmGetCreditBalance *BillingServiceClientMock) GetCreditBalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCreditBalance.beforeGetCreditBalanceCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.GetCreditBalance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCreditBalance *mBillingServiceClientMockGetCreditBalance) Calls() []*BillingServiceClientMockGetCreditBalanceParams {
	mmGetCreditBalance.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockGetCreditBalanceParams, len(mmGetCreditBalance.callArgs))
	copy(argCopy, mmGetCreditBalance.callArgs)

	mmGetCreditBalance.mutex.RUnlock()

	return argCopy
}

// MinimockGetCreditBalanceDone returns true if the count of the GetCreditBalance invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockGetCreditBalanceDone() bool {
	if m.GetCreditBalanceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCreditBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCreditBalanceMock.invocationsDone()
}

// MinimockGetCreditBalanceInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockGetCreditBalanceInspect() {
	for _, e := range m.GetCreditBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetCreditBalance at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCreditBalanceCounter := mm_atomic.LoadUint64(&m.afterGetCreditBalanceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCreditBalanceMock.defaultExpectation != nil && afterGetCreditBalanceCounter < 1 {
		if m.GetCreditBalanceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetCreditBalance at\n%s", m.GetCreditBalanceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetCreditBalance at\n%s with params: %#v", m.GetCreditBalanceMock.defaultExpectation.expectationOrigins.origin, *m.GetCreditBalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCreditBalance != nil && afterGetCreditBalanceCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.GetCreditBalance at\n%s", m.funcGetCreditBalanceOrigin)
	}

	if !m.GetCreditBalanceMock.invocationsDone() && afterGetCreditBalanceCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.GetCreditBalance at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCreditBalanceMock.expectedInvocations), m.GetCreditBalanceMock.expectedInvocationsOrigin, afterGetCreditBalanceCounter)
	}
}

type mBillingServiceClientMockGetInvoice struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockGetInvoiceExpectation
	expectations       []*BillingServiceClientMockGetInvoiceExpectation

	callArgs []*BillingServiceClientMockGetInvoiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockGetInvoiceExpectation specifies expectation struct of the BillingServiceClient.GetInvoice
type BillingServiceClientMockGetInvoiceExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockGetInvoiceParams
	paramPtrs          *BillingServiceClientMockGetInvoiceParamPtrs
	expectationOrigins BillingServiceClientMockGetInvoiceExpectationOrigins
	results            *BillingServiceClientMockGetInvoiceResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockGetInvoiceParams contains parameters of the BillingServiceClient.GetInvoice
type BillingServiceClientMockGetInvoiceParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetInvoiceRequest]
}

// BillingServiceClientMockGetInvoiceParamPtrs contains pointers to parameters of the BillingServiceClient.GetInvoice
type BillingServiceClientMockGetInvoiceParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetInvoiceRequest]
}

// BillingServiceClientMockGetInvoiceResults contains results of the BillingServiceClient.GetInvoice
type BillingServiceClientMockGetInvoiceResults struct {
	pp2 *connect.Response[v1.GetInvoiceResponse]
	err error
}

// BillingServiceClientMockGetInvoiceOrigins contains origins of expectations of the BillingServiceClient.GetInvoice
type BillingServiceClientMockGetInvoiceExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Optional() *mBillingServiceClientMockGetInvoice {
	mmGetInvoice.optional = true
	return mmGetInvoice
}

// Expect sets up expected params for BillingServiceClient.GetInvoice
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Expect(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest]) *mBillingServiceClientMockGetInvoice {
	if mmGetInvoice.mock.funcGetInvoice != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Set")
	}

	if mmGetInvoice.defaultExpectation == nil {
		mmGetInvoice.defaultExpectation = &BillingServiceClientMockGetInvoiceExpectation{}
	}

	if mmGetInvoice.defaultExpectation.paramPtrs != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by ExpectParams functions")
	}

	mmGetInvoice.defaultExpectation.params = &BillingServiceClientMockGetInvoiceParams{ctx, pp1}
	mmGetInvoice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetInvoice.expectations {
		if minimock.Equal(e.params, mmGetInvoice.defaultExpectation.params) {
			mmGetInvoice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInvoice.defaultExpectation.params)
		}
	}

	return mmGetInvoice
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.GetInvoice
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockGetInvoice {
	if mmGetInvoice.mock.funcGetInvoice != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Set")
	}

	if mmGetInvoice.defaultExpectation == nil {
		mmGetInvoice.defaultExpectation = &BillingServiceClientMockGetInvoiceExpectation{}
	}

	if mmGetInvoice.defaultExpectation.params != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Expect")
	}

	if mmGetInvoice.defaultExpectation.paramPtrs == nil {
		mmGetInvoice.defaultExpectation.paramPtrs = &BillingServiceClientMockGetInvoiceParamPtrs{}
	}
	mmGetInvoice.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetInvoice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetInvoice
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.GetInvoice
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) ExpectPp1Param2(pp1 *connect.Request[v1.GetInvoiceRequest]) *mBillingServiceClientMockGetInvoice {
	if mmGetInvoice.mock.funcGetInvoice != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Set")
	}

	if mmGetInvoice.defaultExpectation == nil {
		mmGetInvoice.defaultExpectation = &BillingServiceClientMockGetInvoiceExpectation{}
	}

	if mmGetInvoice.defaultExpectation.params != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Expect")
	}

	if mmGetInvoice.defaultExpectation.paramPtrs == nil {
		mmGetInvoice.defaultExpectation.paramPtrs = &BillingServiceClientMockGetInvoiceParamPtrs{}
	}
	mmGetInvoice.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetInvoice.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetInvoice
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.GetInvoice
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest])) *mBillingServiceClientMockGetInvoice {
	if mmGetInvoice.mock.inspectFuncGetInvoice != nil {
		mmGetInvoice.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.GetInvoice")
	}

	mmGetInvoice.mock.inspectFuncGetInvoice = f

	return mmGetInvoice
}

// Return sets up results that will be returned by BillingServiceClient.GetInvoice
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Return(pp2 *connect.Response[v1.GetInvoiceResponse], err error) *BillingServiceClientMock {
	if mmGetInvoice.mock.funcGetInvoice != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Set")
	}

	if mmGetInvoice.defaultExpectation == nil {
		mmGetInvoice.defaultExpectation = &BillingServiceClientMockGetInvoiceExpectation{mock: mmGetInvoice.mock}
	}
	mmGetInvoice.defaultExpectation.results = &BillingServiceClientMockGetInvoiceResults{pp2, err}
	mmGetInvoice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetInvoice.mock
}

// Set uses given function f to mock the BillingServiceClient.GetInvoice method
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest]) (pp2 *connect.Response[v1.GetInvoiceResponse], err error)) *BillingServiceClientMock {
	if mmGetInvoice.defaultExpectation != nil {
		mmGetInvoice.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.GetInvoice method")
	}

	if len(mmGetInvoice.expectations) > 0 {
		mmGetInvoice.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.GetInvoice method")
	}

	mmGetInvoice.mock.funcGetInvoice = f
	mmGetInvoice.mock.funcGetInvoiceOrigin = minimock.CallerInfo(1)
	return mmGetInvoice.mock
}

// When sets expectation for the BillingServiceClient.GetInvoice which will trigger the result defined by the following
// Then helper
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) When(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest]) *BillingServiceClientMockGetInvoiceExpectation {
	if mmGetInvoice.mock.funcGetInvoice != nil {
		mmGetInvoice.mock.t.Fatalf("BillingServiceClientMock.GetInvoice mock is already set by Set")
	}

	expectation := &BillingServiceClientMockGetInvoiceExpectation{
		mock:               mmGetInvoice.mock,
		params:             &BillingServiceClientMockGetInvoiceParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockGetInvoiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetInvoice.expectations = append(mmGetInvoice.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.GetInvoice return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockGetInvoiceExpectation) Then(pp2 *connect.Response[v1.GetInvoiceResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockGetInvoiceResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.GetInvoice should be invoked
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Times(n uint64) *mBillingServiceClientMockGetInvoice {
	if n == 0 {
		mmGetInvoice.mock.t.Fatalf("Times of BillingServiceClientMock.GetInvoice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetInvoice.expectedInvocations, n)
	mmGetInvoice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetInvoice
}

func (mmGetInvoice *mBillingServiceClientMockGetInvoice) invocationsDone() bool {
	if len(mmGetInvoice.expectations) == 0 && mmGetInvoice.defaultExpectation == nil && mmGetInvoice.mock.funcGetInvoice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetInvoice.mock.afterGetInvoiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetInvoice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetInvoice implements mm_billingv1connect.BillingServiceClient
func (mmGetInvoice *BillingServiceClientMock) GetInvoice(ctx context.Context, pp1 *connect.Request[v1.GetInvoiceRequest]) (pp2 *connect.Response[v1.GetInvoiceResponse], err error) {
	mm_atomic.AddUint64(&mmGetInvoice.beforeGetInvoiceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInvoice.afterGetInvoiceCounter, 1)

	mmGetInvoice.t.Helper()

	if mmGetInvoice.inspectFuncGetInvoice != nil {
		mmGetInvoice.inspectFuncGetInvoice(ctx, pp1)
	}

	mm_params := BillingServiceClientMockGetInvoiceParams{ctx, pp1}

	// Record call args
	mmGetInvoice.GetInvoiceMock.mutex.Lock()
	mmGetInvoice.GetInvoiceMock.callArgs = append(mmGetInvoice.GetInvoiceMock.callArgs, &mm_params)
	mmGetInvoice.GetInvoiceMock.mutex.Unlock()

	for _, e := range mmGetInvoice.GetInvoiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetInvoice.GetInvoiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInvoice.GetInvoiceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInvoice.GetInvoiceMock.defaultExpectation.params
		mm_want_ptrs := mmGetInvoice.GetInvoiceMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockGetInvoiceParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetInvoice.t.Errorf("BillingServiceClientMock.GetInvoice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInvoice.GetInvoiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetInvoice.t.Errorf("BillingServiceClientMock.GetInvoice got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetInvoice.GetInvoiceMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInvoice.t.Errorf("BillingServiceClientMock.GetInvoice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetInvoice.GetInvoiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInvoice.GetInvoiceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInvoice.t.Fatal("No results are set for the BillingServiceClientMock.GetInvoice")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetInvoice.funcGetInvoice != nil {
		return mmGetInvoice.funcGetInvoice(ctx, pp1)
	}
	mmGetInvoice.t.Fatalf("Unexpected call to BillingServiceClientMock.GetInvoice. %v %v", ctx, pp1)
	return
}

// GetInvoiceAfterCounter returns a count of finished BillingServiceClientMock.GetInvoice invocations
func (mmGetInvoice *BillingServiceClientMock) GetInvoiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInvoice.afterGetInvoiceCounter)
}

// GetInvoiceBeforeCounter returns a count of BillingServiceClientMock.GetInvoice invocations
func (mmGetInvoice *BillingServiceClientMock) GetInvoiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInvoice.beforeGetInvoiceCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.GetInvoice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInvoice *mBillingServiceClientMockGetInvoice) Calls() []*BillingServiceClientMockGetInvoiceParams {
	mmGetInvoice.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockGetInvoiceParams, len(mmGetInvoice.callArgs))
	copy(argCopy, mmGetInvoice.callArgs)

	mmGetInvoice.mutex.RUnlock()

	return argCopy
}

// MinimockGetInvoiceDone returns true if the count of the GetInvoice invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockGetInvoiceDone() bool {
	if m.GetInvoiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetInvoiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetInvoiceMock.invocationsDone()
}

// MinimockGetInvoiceInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockGetInvoiceInspect() {
	for _, e := range m.GetInvoiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetInvoice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetInvoiceCounter := mm_atomic.LoadUint64(&m.afterGetInvoiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetInvoiceMock.defaultExpectation != nil && afterGetInvoiceCounter < 1 {
		if m.GetInvoiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetInvoice at\n%s", m.GetInvoiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetInvoice at\n%s with params: %#v", m.GetInvoiceMock.defaultExpectation.expectationOrigins.origin, *m.GetInvoiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInvoice != nil && afterGetInvoiceCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.GetInvoice at\n%s", m.funcGetInvoiceOrigin)
	}

	if !m.GetInvoiceMock.invocationsDone() && afterGetInvoiceCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.GetInvoice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetInvoiceMock.expectedInvocations), m.GetInvoiceMock.expectedInvocationsOrigin, afterGetInvoiceCounter)
	}
}

type mBillingServiceClientMockGetSubscription struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockGetSubscriptionExpectation
	expectations       []*BillingServiceClientMockGetSubscriptionExpectation

	callArgs []*BillingServiceClientMockGetSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockGetSubscriptionExpectation specifies expectation struct of the BillingServiceClient.GetSubscription
type BillingServiceClientMockGetSubscriptionExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockGetSubscriptionParams
	paramPtrs          *BillingServiceClientMockGetSubscriptionParamPtrs
	expectationOrigins BillingServiceClientMockGetSubscriptionExpectationOrigins
	results            *BillingServiceClientMockGetSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockGetSubscriptionParams contains parameters of the BillingServiceClient.GetSubscription
type BillingServiceClientMockGetSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetSubscriptionRequest]
}

// BillingServiceClientMockGetSubscriptionParamPtrs contains pointers to parameters of the BillingServiceClient.GetSubscription
type BillingServiceClientMockGetSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetSubscriptionRequest]
}

// BillingServiceClientMockGetSubscriptionResults contains results of the BillingServiceClient.GetSubscription
type BillingServiceClientMockGetSubscriptionResults struct {
	pp2 *connect.Response[v1.GetSubscriptionResponse]
	err error
}

// BillingServiceClientMockGetSubscriptionOrigins contains origins of expectations of the BillingServiceClient.GetSubscription
type BillingServiceClientMockGetSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Optional() *mBillingServiceClientMockGetSubscription {
	mmGetSubscription.optional = true
	return mmGetSubscription
}

// Expect sets up expected params for BillingServiceClient.GetSubscription
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest]) *mBillingServiceClientMockGetSubscription {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Set")
	}

	if mmGetSubscription.defaultExpectation == nil {
		mmGetSubscription.defaultExpectation = &BillingServiceClientMockGetSubscriptionExpectation{}
	}

	if mmGetSubscription.defaultExpectation.paramPtrs != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by ExpectParams functions")
	}

	mmGetSubscription.defaultExpectation.params = &BillingServiceClientMockGetSubscriptionParams{ctx, pp1}
	mmGetSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetSubscription.expectations {
		if minimock.Equal(e.params, mmGetSubscription.defaultExpectation.params) {
			mmGetSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscription.defaultExpectation.params)
		}
	}

	return mmGetSubscription
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.GetSubscription
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockGetSubscription {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Set")
	}

	if mmGetSubscription.defaultExpectation == nil {
		mmGetSubscription.defaultExpectation = &BillingServiceClientMockGetSubscriptionExpectation{}
	}

	if mmGetSubscription.defaultExpectation.params != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Expect")
	}

	if mmGetSubscription.defaultExpectation.paramPtrs == nil {
		mmGetSubscription.defaultExpectation.paramPtrs = &BillingServiceClientMockGetSubscriptionParamPtrs{}
	}
	mmGetSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.GetSubscription
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.GetSubscriptionRequest]) *mBillingServiceClientMockGetSubscription {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Set")
	}

	if mmGetSubscription.defaultExpectation == nil {
		mmGetSubscription.defaultExpectation = &BillingServiceClientMockGetSubscriptionExpectation{}
	}

	if mmGetSubscription.defaultExpectation.params != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Expect")
	}

	if mmGetSubscription.defaultExpectation.paramPtrs == nil {
		mmGetSubscription.defaultExpectation.paramPtrs = &BillingServiceClientMockGetSubscriptionParamPtrs{}
	}
	mmGetSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetSubscription
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.GetSubscription
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest])) *mBillingServiceClientMockGetSubscription {
	if mmGetSubscription.mock.inspectFuncGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.GetSubscription")
	}

	mmGetSubscription.mock.inspectFuncGetSubscription = f

	return mmGetSubscription
}

// Return sets up results that will be returned by BillingServiceClient.GetSubscription
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Return(pp2 *connect.Response[v1.GetSubscriptionResponse], err error) *BillingServiceClientMock {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Set")
	}

	if mmGetSubscription.defaultExpectation == nil {
		mmGetSubscription.defaultExpectation = &BillingServiceClientMockGetSubscriptionExpectation{mock: mmGetSubscription.mock}
	}
	mmGetSubscription.defaultExpectation.results = &BillingServiceClientMockGetSubscriptionResults{pp2, err}
	mmGetSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetSubscription.mock
}

// Set uses given function f to mock the BillingServiceClient.GetSubscription method
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest]) (pp2 *connect.Response[v1.GetSubscriptionResponse], err error)) *BillingServiceClientMock {
	if mmGetSubscription.defaultExpectation != nil {
		mmGetSubscription.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.GetSubscription method")
	}

	if len(mmGetSubscription.expectations) > 0 {
		mmGetSubscription.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.GetSubscription method")
	}

	mmGetSubscription.mock.funcGetSubscription = f
	mmGetSubscription.mock.funcGetSubscriptionOrigin = minimock.CallerInfo(1)
	return mmGetSubscription.mock
}

// When sets expectation for the BillingServiceClient.GetSubscription which will trigger the result defined by the following
// Then helper
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) When(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest]) *BillingServiceClientMockGetSubscriptionExpectation {
	if mmGetSubscription.mock.funcGetSubscription != nil {
		mmGetSubscription.mock.t.Fatalf("BillingServiceClientMock.GetSubscription mock is already set by Set")
	}

	expectation := &BillingServiceClientMockGetSubscriptionExpectation{
		mock:               mmGetSubscription.mock,
		params:             &BillingServiceClientMockGetSubscriptionParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockGetSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetSubscription.expectations = append(mmGetSubscription.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.GetSubscription return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockGetSubscriptionExpectation) Then(pp2 *connect.Response[v1.GetSubscriptionResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockGetSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.GetSubscription should be invoked
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Times(n uint64) *mBillingServiceClientMockGetSubscription {
	if n == 0 {
		mmGetSubscription.mock.t.Fatalf("Times of BillingServiceClientMock.GetSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetSubscription.expectedInvocations, n)
	mmGetSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetSubscription
}

func (mmGetSubscription *mBillingServiceClientMockGetSubscription) invocationsDone() bool {
	if len(mmGetSubscription.expectations) == 0 && mmGetSubscription.defaultExpectation == nil && mmGetSubscription.mock.funcGetSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetSubscription.mock.afterGetSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetSubscription implements mm_billingv1connect.BillingServiceClient
func (mmGetSubscription *BillingServiceClientMock) GetSubscription(ctx context.Context, pp1 *connect.Request[v1.GetSubscriptionRequest]) (pp2 *connect.Response[v1.GetSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmGetSubscription.beforeGetSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscription.afterGetSubscriptionCounter, 1)

	mmGetSubscription.t.Helper()

	if mmGetSubscription.inspectFuncGetSubscription != nil {
		mmGetSubscription.inspectFuncGetSubscription(ctx, pp1)
	}

	mm_params := BillingServiceClientMockGetSubscriptionParams{ctx, pp1}

	// Record call args
	mmGetSubscription.GetSubscriptionMock.mutex.Lock()
	mmGetSubscription.GetSubscriptionMock.callArgs = append(mmGetSubscription.GetSubscriptionMock.callArgs, &mm_params)
	mmGetSubscription.GetSubscriptionMock.mutex.Unlock()

	for _, e := range mmGetSubscription.GetSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetSubscription.GetSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscription.GetSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscription.GetSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmGetSubscription.GetSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockGetSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetSubscription.t.Errorf("BillingServiceClientMock.GetSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSubscription.GetSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetSubscription.t.Errorf("BillingServiceClientMock.GetSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetSubscription.GetSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscription.t.Errorf("BillingServiceClientMock.GetSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetSubscription.GetSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscription.GetSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscription.t.Fatal("No results are set for the BillingServiceClientMock.GetSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetSubscription.funcGetSubscription != nil {
		return mmGetSubscription.funcGetSubscription(ctx, pp1)
	}
	mmGetSubscription.t.Fatalf("Unexpected call to BillingServiceClientMock.GetSubscription. %v %v", ctx, pp1)
	return
}

// GetSubscriptionAfterCounter returns a count of finished BillingServiceClientMock.GetSubscription invocations
func (mmGetSubscription *BillingServiceClientMock) GetSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscription.afterGetSubscriptionCounter)
}

// GetSubscriptionBeforeCounter returns a count of BillingServiceClientMock.GetSubscription invocations
func (mmGetSubscription *BillingServiceClientMock) GetSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscription.beforeGetSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.GetSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscription *mBillingServiceClientMockGetSubscription) Calls() []*BillingServiceClientMockGetSubscriptionParams {
	mmGetSubscription.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockGetSubscriptionParams, len(mmGetSubscription.callArgs))
	copy(argCopy, mmGetSubscription.callArgs)

	mmGetSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionDone returns true if the count of the GetSubscription invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockGetSubscriptionDone() bool {
	if m.GetSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetSubscriptionMock.invocationsDone()
}

// MinimockGetSubscriptionInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockGetSubscriptionInspect() {
	for _, e := range m.GetSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetSubscriptionCounter := mm_atomic.LoadUint64(&m.afterGetSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionMock.defaultExpectation != nil && afterGetSubscriptionCounter < 1 {
		if m.GetSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetSubscription at\n%s", m.GetSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.GetSubscription at\n%s with params: %#v", m.GetSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.GetSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscription != nil && afterGetSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.GetSubscription at\n%s", m.funcGetSubscriptionOrigin)
	}

	if !m.GetSubscriptionMock.invocationsDone() && afterGetSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.GetSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetSubscriptionMock.expectedInvocations), m.GetSubscriptionMock.expectedInvocationsOrigin, afterGetSubscriptionCounter)
	}
}

type mBillingServiceClientMockGrantCredit struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockGrantCreditExpectation
	expectations       []*BillingServiceClientMockGrantCreditExpectation

	callArgs []*BillingServiceClientMockGrantCreditParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockGrantCreditExpectation specifies expectation struct of the BillingServiceClient.GrantCredit
type BillingServiceClientMockGrantCreditExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockGrantCreditParams
	paramPtrs          *BillingServiceClientMockGrantCreditParamPtrs
	expectationOrigins BillingServiceClientMockGrantCreditExpectationOrigins
	results            *BillingServiceClientMockGrantCreditResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockGrantCreditParams contains parameters of the BillingServiceClient.GrantCredit
type BillingServiceClientMockGrantCreditParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GrantCreditRequest]
}

// BillingServiceClientMockGrantCreditParamPtrs contains pointers to parameters of the BillingServiceClient.GrantCredit
type BillingServiceClientMockGrantCreditParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GrantCreditRequest]
}

// BillingServiceClientMockGrantCreditResults contains results of the BillingServiceClient.GrantCredit
type BillingServiceClientMockGrantCreditResults struct {
	pp2 *connect.Response[v1.GrantCreditResponse]
	err error
}

// BillingServiceClientMockGrantCreditOrigins contains origins of expectations of the BillingServiceClient.GrantCredit
type BillingServiceClientMockGrantCreditExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Optional() *mBillingServiceClientMockGrantCredit {
	mmGrantCredit.optional = true
	return mmGrantCredit
}

// Expect sets up expected params for BillingServiceClient.GrantCredit
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Expect(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest]) *mBillingServiceClientMockGrantCredit {
	if mmGrantCredit.mock.funcGrantCredit != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Set")
	}

	if mmGrantCredit.defaultExpectation == nil {
		mmGrantCredit.defaultExpectation = &BillingServiceClientMockGrantCreditExpectation{}
	}

	if mmGrantCredit.defaultExpectation.paramPtrs != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by ExpectParams functions")
	}

	mmGrantCredit.defaultExpectation.params = &BillingServiceClientMockGrantCreditParams{ctx, pp1}
	mmGrantCredit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGrantCredit.expectations {
		if minimock.Equal(e.params, mmGrantCredit.defaultExpectation.params) {
			mmGrantCredit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGrantCredit.defaultExpectation.params)
		}
	}

	return mmGrantCredit
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.GrantCredit
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockGrantCredit {
	if mmGrantCredit.mock.funcGrantCredit != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Set")
	}

	if mmGrantCredit.defaultExpectation == nil {
		mmGrantCredit.defaultExpectation = &BillingServiceClientMockGrantCreditExpectation{}
	}

	if mmGrantCredit.defaultExpectation.params != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Expect")
	}

	if mmGrantCredit.defaultExpectation.paramPtrs == nil {
		mmGrantCredit.defaultExpectation.paramPtrs = &BillingServiceClientMockGrantCreditParamPtrs{}
	}
	mmGrantCredit.defaultExpectation.paramPtrs.ctx = &ctx
	mmGrantCredit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGrantCredit
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.GrantCredit
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) ExpectPp1Param2(pp1 *connect.Request[v1.GrantCreditRequest]) *mBillingServiceClientMockGrantCredit {
	if mmGrantCredit.mock.funcGrantCredit != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Set")
	}

	if mmGrantCredit.defaultExpectation == nil {
		mmGrantCredit.defaultExpectation = &BillingServiceClientMockGrantCreditExpectation{}
	}

	if mmGrantCredit.defaultExpectation.params != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Expect")
	}

	if mmGrantCredit.defaultExpectation.paramPtrs == nil {
		mmGrantCredit.defaultExpectation.paramPtrs = &BillingServiceClientMockGrantCreditParamPtrs{}
	}
	mmGrantCredit.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGrantCredit.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGrantCredit
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.GrantCredit
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest])) *mBillingServiceClientMockGrantCredit {
	if mmGrantCredit.mock.inspectFuncGrantCredit != nil {
		mmGrantCredit.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.GrantCredit")
	}

	mmGrantCredit.mock.inspectFuncGrantCredit = f

	return mmGrantCredit
}

// Return sets up results that will be returned by BillingServiceClient.GrantCredit
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Return(pp2 *connect.Response[v1.GrantCreditResponse], err error) *BillingServiceClientMock {
	if mmGrantCredit.mock.funcGrantCredit != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Set")
	}

	if mmGrantCredit.defaultExpectation == nil {
		mmGrantCredit.defaultExpectation = &BillingServiceClientMockGrantCreditExpectation{mock: mmGrantCredit.mock}
	}
	mmGrantCredit.defaultExpectation.results = &BillingServiceClientMockGrantCreditResults{pp2, err}
	mmGrantCredit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGrantCredit.mock
}

// Set uses given function f to mock the BillingServiceClient.GrantCredit method
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest]) (pp2 *connect.Response[v1.GrantCreditResponse], err error)) *BillingServiceClientMock {
	if mmGrantCredit.defaultExpectation != nil {
		mmGrantCredit.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.GrantCredit method")
	}

	if len(mmGrantCredit.expectations) > 0 {
		mmGrantCredit.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.GrantCredit method")
	}

	mmGrantCredit.mock.funcGrantCredit = f
	mmGrantCredit.mock.funcGrantCreditOrigin = minimock.CallerInfo(1)
	return mmGrantCredit.mock
}

// When sets expectation for the BillingServiceClient.GrantCredit which will trigger the result defined by the following
// Then helper
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) When(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest]) *BillingServiceClientMockGrantCreditExpectation {
	if mmGrantCredit.mock.funcGrantCredit != nil {
		mmGrantCredit.mock.t.Fatalf("BillingServiceClientMock.GrantCredit mock is already set by Set")
	}

	expectation := &BillingServiceClientMockGrantCreditExpectation{
		mock:               mmGrantCredit.mock,
		params:             &BillingServiceClientMockGrantCreditParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockGrantCreditExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGrantCredit.expectations = append(mmGrantCredit.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.GrantCredit return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockGrantCreditExpectation) Then(pp2 *connect.Response[v1.GrantCreditResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockGrantCreditResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.GrantCredit should be invoked
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Times(n uint64) *mBillingServiceClientMockGrantCredit {
	if n == 0 {
		mmGrantCredit.mock.t.Fatalf("Times of BillingServiceClientMock.GrantCredit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrantCredit.expectedInvocations, n)
	mmGrantCredit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGrantCredit
}

func (mmGrantCredit *mBillingServiceClientMockGrantCredit) invocationsDone() bool {
	if len(mmGrantCredit.expectations) == 0 && mmGrantCredit.defaultExpectation == nil && mmGrantCredit.mock.funcGrantCredit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrantCredit.mock.afterGrantCreditCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrantCredit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GrantCredit implements mm_billingv1connect.BillingServiceClient
func (mmGrantCredit *BillingServiceClientMock) GrantCredit(ctx context.Context, pp1 *connect.Request[v1.GrantCreditRequest]) (pp2 *connect.Response[v1.GrantCreditResponse], err error) {
	mm_atomic.AddUint64(&mmGrantCredit.beforeGrantCreditCounter, 1)
	defer mm_atomic.AddUint64(&mmGrantCredit.afterGrantCreditCounter, 1)

	mmGrantCredit.t.Helper()

	if mmGrantCredit.inspectFuncGrantCredit != nil {
		mmGrantCredit.inspectFuncGrantCredit(ctx, pp1)
	}

	mm_params := BillingServiceClientMockGrantCreditParams{ctx, pp1}

	// Record call args
	mmGrantCredit.GrantCreditMock.mutex.Lock()
	mmGrantCredit.GrantCreditMock.callArgs = append(mmGrantCredit.GrantCreditMock.callArgs, &mm_params)
	mmGrantCredit.GrantCreditMock.mutex.Unlock()

	for _, e := range mmGrantCredit.GrantCreditMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGrantCredit.GrantCreditMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrantCredit.GrantCreditMock.defaultExpectation.Counter, 1)
		mm_want := mmGrantCredit.GrantCreditMock.defaultExpectation.params
		mm_want_ptrs := mmGrantCredit.GrantCreditMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockGrantCreditParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGrantCredit.t.Errorf("BillingServiceClientMock.GrantCredit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGrantCredit.GrantCreditMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGrantCredit.t.Errorf("BillingServiceClientMock.GrantCredit got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGrantCredit.GrantCreditMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGrantCredit.t.Errorf("BillingServiceClientMock.GrantCredit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGrantCredit.GrantCreditMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGrantCredit.GrantCreditMock.defaultExpectation.results
		if mm_results == nil {
			mmGrantCredit.t.Fatal("No results are set for the BillingServiceClientMock.GrantCredit")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGrantCredit.funcGrantCredit != nil {
		return mmGrantCredit.funcGrantCredit(ctx, pp1)
	}
	mmGrantCredit.t.Fatalf("Unexpected call to BillingServiceClientMock.GrantCredit. %v %v", ctx, pp1)
	return
}

// GrantCreditAfterCounter returns a count of finished BillingServiceClientMock.GrantCredit invocations
func (mmGrantCredit *BillingServiceClientMock) GrantCreditAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrantCredit.afterGrantCreditCounter)
}

// GrantCreditBeforeCounter returns a count of BillingServiceClientMock.GrantCredit invocations
func (mmGrantCredit *BillingServiceClientMock) GrantCreditBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrantCredit.beforeGrantCreditCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.GrantCredit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGrantCredit *mBillingServiceClientMockGrantCredit) Calls() []*BillingServiceClientMockGrantCreditParams {
	mmGrantCredit.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockGrantCreditParams, len(mmGrantCredit.callArgs))
	copy(argCopy, mmGrantCredit.callArgs)

	mmGrantCredit.mutex.RUnlock()

	return argCopy
}

// MinimockGrantCreditDone returns true if the count of the GrantCredit invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockGrantCreditDone() bool {
	if m.GrantCreditMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GrantCreditMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GrantCreditMock.invocationsDone()
}

// MinimockGrantCreditInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockGrantCreditInspect() {
	for _, e := range m.GrantCreditMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.GrantCredit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGrantCreditCounter := mm_atomic.LoadUint64(&m.afterGrantCreditCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GrantCreditMock.defaultExpectation != nil && afterGrantCreditCounter < 1 {
		if m.GrantCreditMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.GrantCredit at\n%s", m.GrantCreditMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.GrantCredit at\n%s with params: %#v", m.GrantCreditMock.defaultExpectation.expectationOrigins.origin, *m.GrantCreditMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrantCredit != nil && afterGrantCreditCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.GrantCredit at\n%s", m.funcGrantCreditOrigin)
	}

	if !m.GrantCreditMock.invocationsDone() && afterGrantCreditCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.GrantCredit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GrantCreditMock.expectedInvocations), m.GrantCreditMock.expectedInvocationsOrigin, afterGrantCreditCounter)
	}
}

type mBillingServiceClientMockIngestUsageBatch struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockIngestUsageBatchExpectation
	expectations       []*BillingServiceClientMockIngestUsageBatchExpectation

	callArgs []*BillingServiceClientMockIngestUsageBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockIngestUsageBatchExpectation specifies expectation struct of the BillingServiceClient.IngestUsageBatch
type BillingServiceClientMockIngestUsageBatchExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockIngestUsageBatchParams
	paramPtrs          *BillingServiceClientMockIngestUsageBatchParamPtrs
	expectationOrigins BillingServiceClientMockIngestUsageBatchExpectationOrigins
	results            *BillingServiceClientMockIngestUsageBatchResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockIngestUsageBatchParams contains parameters of the BillingServiceClient.IngestUsageBatch
type BillingServiceClientMockIngestUsageBatchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.IngestUsageBatchRequest]
}

// BillingServiceClientMockIngestUsageBatchParamPtrs contains pointers to parameters of the BillingServiceClient.IngestUsageBatch
type BillingServiceClientMockIngestUsageBatchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.IngestUsageBatchRequest]
}

// BillingServiceClientMockIngestUsageBatchResults contains results of the BillingServiceClient.IngestUsageBatch
type BillingServiceClientMockIngestUsageBatchResults struct {
	pp2 *connect.Response[v1.IngestUsageBatchResponse]
	err error
}

// BillingServiceClientMockIngestUsageBatchOrigins contains origins of expectations of the BillingServiceClient.IngestUsageBatch
type BillingServiceClientMockIngestUsageBatchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Optional() *mBillingServiceClientMockIngestUsageBatch {
	mmIngestUsageBatch.optional = true
	return mmIngestUsageBatch
}

// Expect sets up expected params for BillingServiceClient.IngestUsageBatch
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Expect(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest]) *mBillingServiceClientMockIngestUsageBatch {
	if mmIngestUsageBatch.mock.funcIngestUsageBatch != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Set")
	}

	if mmIngestUsageBatch.defaultExpectation == nil {
		mmIngestUsageBatch.defaultExpectation = &BillingServiceClientMockIngestUsageBatchExpectation{}
	}

	if mmIngestUsageBatch.defaultExpectation.paramPtrs != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by ExpectParams functions")
	}

	mmIngestUsageBatch.defaultExpectation.params = &BillingServiceClientMockIngestUsageBatchParams{ctx, pp1}
	mmIngestUsageBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIngestUsageBatch.expectations {
		if minimock.Equal(e.params, mmIngestUsageBatch.defaultExpectation.params) {
			mmIngestUsageBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIngestUsageBatch.defaultExpectation.params)
		}
	}

	return mmIngestUsageBatch
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.IngestUsageBatch
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockIngestUsageBatch {
	if mmIngestUsageBatch.mock.funcIngestUsageBatch != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Set")
	}

	if mmIngestUsageBatch.defaultExpectation == nil {
		mmIngestUsageBatch.defaultExpectation = &BillingServiceClientMockIngestUsageBatchExpectation{}
	}

	if mmIngestUsageBatch.defaultExpectation.params != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Expect")
	}

	if mmIngestUsageBatch.defaultExpectation.paramPtrs == nil {
		mmIngestUsageBatch.defaultExpectation.paramPtrs = &BillingServiceClientMockIngestUsageBatchParamPtrs{}
	}
	mmIngestUsageBatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmIngestUsageBatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIngestUsageBatch
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.IngestUsageBatch
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) ExpectPp1Param2(pp1 *connect.Request[v1.IngestUsageBatchRequest]) *mBillingServiceClientMockIngestUsageBatch {
	if mmIngestUsageBatch.mock.funcIngestUsageBatch != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Set")
	}

	if mmIngestUsageBatch.defaultExpectation == nil {
		mmIngestUsageBatch.defaultExpectation = &BillingServiceClientMockIngestUsageBatchExpectation{}
	}

	if mmIngestUsageBatch.defaultExpectation.params != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Expect")
	}

	if mmIngestUsageBatch.defaultExpectation.paramPtrs == nil {
		mmIngestUsageBatch.defaultExpectation.paramPtrs = &BillingServiceClientMockIngestUsageBatchParamPtrs{}
	}
	mmIngestUsageBatch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmIngestUsageBatch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmIngestUsageBatch
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.IngestUsageBatch
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest])) *mBillingServiceClientMockIngestUsageBatch {
	if mmIngestUsageBatch.mock.inspectFuncIngestUsageBatch != nil {
		mmIngestUsageBatch.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.IngestUsageBatch")
	}

	mmIngestUsageBatch.mock.inspectFuncIngestUsageBatch = f

	return mmIngestUsageBatch
}

// Return sets up results that will be returned by BillingServiceClient.IngestUsageBatch
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Return(pp2 *connect.Response[v1.IngestUsageBatchResponse], err error) *BillingServiceClientMock {
	if mmIngestUsageBatch.mock.funcIngestUsageBatch != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Set")
	}

	if mmIngestUsageBatch.defaultExpectation == nil {
		mmIngestUsageBatch.defaultExpectation = &BillingServiceClientMockIngestUsageBatchExpectation{mock: mmIngestUsageBatch.mock}
	}
	mmIngestUsageBatch.defaultExpectation.results = &BillingServiceClientMockIngestUsageBatchResults{pp2, err}
	mmIngestUsageBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIngestUsageBatch.mock
}

// Set uses given function f to mock the BillingServiceClient.IngestUsageBatch method
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest]) (pp2 *connect.Response[v1.IngestUsageBatchResponse], err error)) *BillingServiceClientMock {
	if mmIngestUsageBatch.defaultExpectation != nil {
		mmIngestUsageBatch.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.IngestUsageBatch method")
	}

	if len(mmIngestUsageBatch.expectations) > 0 {
		mmIngestUsageBatch.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.IngestUsageBatch method")
	}

	mmIngestUsageBatch.mock.funcIngestUsageBatch = f
	mmIngestUsageBatch.mock.funcIngestUsageBatchOrigin = minimock.CallerInfo(1)
	return mmIngestUsageBatch.mock
}

// When sets expectation for the BillingServiceClient.IngestUsageBatch which will trigger the result defined by the following
// Then helper
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) When(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest]) *BillingServiceClientMockIngestUsageBatchExpectation {
	if mmIngestUsageBatch.mock.funcIngestUsageBatch != nil {
		mmIngestUsageBatch.mock.t.Fatalf("BillingServiceClientMock.IngestUsageBatch mock is already set by Set")
	}

	expectation := &BillingServiceClientMockIngestUsageBatchExpectation{
		mock:               mmIngestUsageBatch.mock,
		params:             &BillingServiceClientMockIngestUsageBatchParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockIngestUsageBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIngestUsageBatch.expectations = append(mmIngestUsageBatch.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.IngestUsageBatch return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockIngestUsageBatchExpectation) Then(pp2 *connect.Response[v1.IngestUsageBatchResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockIngestUsageBatchResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.IngestUsageBatch should be invoked
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Times(n uint64) *mBillingServiceClientMockIngestUsageBatch {
	if n == 0 {
		mmIngestUsageBatch.mock.t.Fatalf("Times of BillingServiceClientMock.IngestUsageBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIngestUsageBatch.expectedInvocations, n)
	mmIngestUsageBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIngestUsageBatch
}

func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) invocationsDone() bool {
	if len(mmIngestUsageBatch.expectations) == 0 && mmIngestUsageBatch.defaultExpectation == nil && mmIngestUsageBatch.mock.funcIngestUsageBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIngestUsageBatch.mock.afterIngestUsageBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIngestUsageBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IngestUsageBatch implements mm_billingv1connect.BillingServiceClient
func (mmIngestUsageBatch *BillingServiceClientMock) IngestUsageBatch(ctx context.Context, pp1 *connect.Request[v1.IngestUsageBatchRequest]) (pp2 *connect.Response[v1.IngestUsageBatchResponse], err error) {
	mm_atomic.AddUint64(&mmIngestUsageBatch.beforeIngestUsageBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmIngestUsageBatch.afterIngestUsageBatchCounter, 1)

	mmIngestUsageBatch.t.Helper()

	if mmIngestUsageBatch.inspectFuncIngestUsageBatch != nil {
		mmIngestUsageBatch.inspectFuncIngestUsageBatch(ctx, pp1)
	}

	mm_params := BillingServiceClientMockIngestUsageBatchParams{ctx, pp1}

	// Record call args
	mmIngestUsageBatch.IngestUsageBatchMock.mutex.Lock()
	mmIngestUsageBatch.IngestUsageBatchMock.callArgs = append(mmIngestUsageBatch.IngestUsageBatchMock.callArgs, &mm_params)
	mmIngestUsageBatch.IngestUsageBatchMock.mutex.Unlock()

	for _, e := range mmIngestUsageBatch.IngestUsageBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.params
		mm_want_ptrs := mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockIngestUsageBatchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIngestUsageBatch.t.Errorf("BillingServiceClientMock.IngestUsageBatch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmIngestUsageBatch.t.Errorf("BillingServiceClientMock.IngestUsageBatch got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIngestUsageBatch.t.Errorf("BillingServiceClientMock.IngestUsageBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIngestUsageBatch.IngestUsageBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmIngestUsageBatch.t.Fatal("No results are set for the BillingServiceClientMock.IngestUsageBatch")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmIngestUsageBatch.funcIngestUsageBatch != nil {
		return mmIngestUsageBatch.funcIngestUsageBatch(ctx, pp1)
	}
	mmIngestUsageBatch.t.Fatalf("Unexpected call to BillingServiceClientMock.IngestUsageBatch. %v %v", ctx, pp1)
	return
}

// IngestUsageBatchAfterCounter returns a count of finished BillingServiceClientMock.IngestUsageBatch invocations
func (mmIngestUsageBatch *BillingServiceClientMock) IngestUsageBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIngestUsageBatch.afterIngestUsageBatchCounter)
}

// IngestUsageBatchBeforeCounter returns a count of BillingServiceClientMock.IngestUsageBatch invocations
func (mmIngestUsageBatch *BillingServiceClientMock) IngestUsageBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIngestUsageBatch.beforeIngestUsageBatchCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.IngestUsageBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIngestUsageBatch *mBillingServiceClientMockIngestUsageBatch) Calls() []*BillingServiceClientMockIngestUsageBatchParams {
	mmIngestUsageBatch.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockIngestUsageBatchParams, len(mmIngestUsageBatch.callArgs))
	copy(argCopy, mmIngestUsageBatch.callArgs)

	mmIngestUsageBatch.mutex.RUnlock()

	return argCopy
}

// MinimockIngestUsageBatchDone returns true if the count of the IngestUsageBatch invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockIngestUsageBatchDone() bool {
	if m.IngestUsageBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IngestUsageBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IngestUsageBatchMock.invocationsDone()
}

// MinimockIngestUsageBatchInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockIngestUsageBatchInspect() {
	for _, e := range m.IngestUsageBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIngestUsageBatchCounter := mm_atomic.LoadUint64(&m.afterIngestUsageBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IngestUsageBatchMock.defaultExpectation != nil && afterIngestUsageBatchCounter < 1 {
		if m.IngestUsageBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageBatch at\n%s", m.IngestUsageBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageBatch at\n%s with params: %#v", m.IngestUsageBatchMock.defaultExpectation.expectationOrigins.origin, *m.IngestUsageBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIngestUsageBatch != nil && afterIngestUsageBatchCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageBatch at\n%s", m.funcIngestUsageBatchOrigin)
	}

	if !m.IngestUsageBatchMock.invocationsDone() && afterIngestUsageBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.IngestUsageBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IngestUsageBatchMock.expectedInvocations), m.IngestUsageBatchMock.expectedInvocationsOrigin, afterIngestUsageBatchCounter)
	}
}

type mBillingServiceClientMockIngestUsageEvent struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockIngestUsageEventExpectation
	expectations       []*BillingServiceClientMockIngestUsageEventExpectation

	callArgs []*BillingServiceClientMockIngestUsageEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockIngestUsageEventExpectation specifies expectation struct of the BillingServiceClient.IngestUsageEvent
type BillingServiceClientMockIngestUsageEventExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockIngestUsageEventParams
	paramPtrs          *BillingServiceClientMockIngestUsageEventParamPtrs
	expectationOrigins BillingServiceClientMockIngestUsageEventExpectationOrigins
	results            *BillingServiceClientMockIngestUsageEventResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockIngestUsageEventParams contains parameters of the BillingServiceClient.IngestUsageEvent
type BillingServiceClientMockIngestUsageEventParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.IngestUsageEventRequest]
}

// BillingServiceClientMockIngestUsageEventParamPtrs contains pointers to parameters of the BillingServiceClient.IngestUsageEvent
type BillingServiceClientMockIngestUsageEventParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.IngestUsageEventRequest]
}

// BillingServiceClientMockIngestUsageEventResults contains results of the BillingServiceClient.IngestUsageEvent
type BillingServiceClientMockIngestUsageEventResults struct {
	pp2 *connect.Response[v1.IngestUsageEventResponse]
	err error
}

// BillingServiceClientMockIngestUsageEventOrigins contains origins of expectations of the BillingServiceClient.IngestUsageEvent
type BillingServiceClientMockIngestUsageEventExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Optional() *mBillingServiceClientMockIngestUsageEvent {
	mmIngestUsageEvent.optional = true
	return mmIngestUsageEvent
}

// Expect sets up expected params for BillingServiceClient.IngestUsageEvent
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Expect(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest]) *mBillingServiceClientMockIngestUsageEvent {
	if mmIngestUsageEvent.mock.funcIngestUsageEvent != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Set")
	}

	if mmIngestUsageEvent.defaultExpectation == nil {
		mmIngestUsageEvent.defaultExpectation = &BillingServiceClientMockIngestUsageEventExpectation{}
	}

	if mmIngestUsageEvent.defaultExpectation.paramPtrs != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by ExpectParams functions")
	}

	mmIngestUsageEvent.defaultExpectation.params = &BillingServiceClientMockIngestUsageEventParams{ctx, pp1}
	mmIngestUsageEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIngestUsageEvent.expectations {
		if minimock.Equal(e.params, mmIngestUsageEvent.defaultExpectation.params) {
			mmIngestUsageEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIngestUsageEvent.defaultExpectation.params)
		}
	}

	return mmIngestUsageEvent
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.IngestUsageEvent
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockIngestUsageEvent {
	if mmIngestUsageEvent.mock.funcIngestUsageEvent != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Set")
	}

	if mmIngestUsageEvent.defaultExpectation == nil {
		mmIngestUsageEvent.defaultExpectation = &BillingServiceClientMockIngestUsageEventExpectation{}
	}

	if mmIngestUsageEvent.defaultExpectation.params != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Expect")
	}

	if mmIngestUsageEvent.defaultExpectation.paramPtrs == nil {
		mmIngestUsageEvent.defaultExpectation.paramPtrs = &BillingServiceClientMockIngestUsageEventParamPtrs{}
	}
	mmIngestUsageEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmIngestUsageEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIngestUsageEvent
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.IngestUsageEvent
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) ExpectPp1Param2(pp1 *connect.Request[v1.IngestUsageEventRequest]) *mBillingServiceClientMockIngestUsageEvent {
	if mmIngestUsageEvent.mock.funcIngestUsageEvent != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Set")
	}

	if mmIngestUsageEvent.defaultExpectation == nil {
		mmIngestUsageEvent.defaultExpectation = &BillingServiceClientMockIngestUsageEventExpectation{}
	}

	if mmIngestUsageEvent.defaultExpectation.params != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Expect")
	}

	if mmIngestUsageEvent.defaultExpectation.paramPtrs == nil {
		mmIngestUsageEvent.defaultExpectation.paramPtrs = &BillingServiceClientMockIngestUsageEventParamPtrs{}
	}
	mmIngestUsageEvent.defaultExpectation.paramPtrs.pp1 = &pp1
	mmIngestUsageEvent.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmIngestUsageEvent
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.IngestUsageEvent
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest])) *mBillingServiceClientMockIngestUsageEvent {
	if mmIngestUsageEvent.mock.inspectFuncIngestUsageEvent != nil {
		mmIngestUsageEvent.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.IngestUsageEvent")
	}

	mmIngestUsageEvent.mock.inspectFuncIngestUsageEvent = f

	return mmIngestUsageEvent
}

// Return sets up results that will be returned by BillingServiceClient.IngestUsageEvent
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Return(pp2 *connect.Response[v1.IngestUsageEventResponse], err error) *BillingServiceClientMock {
	if mmIngestUsageEvent.mock.funcIngestUsageEvent != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Set")
	}

	if mmIngestUsageEvent.defaultExpectation == nil {
		mmIngestUsageEvent.defaultExpectation = &BillingServiceClientMockIngestUsageEventExpectation{mock: mmIngestUsageEvent.mock}
	}
	mmIngestUsageEvent.defaultExpectation.results = &BillingServiceClientMockIngestUsageEventResults{pp2, err}
	mmIngestUsageEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIngestUsageEvent.mock
}

// Set uses given function f to mock the BillingServiceClient.IngestUsageEvent method
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Set(f func(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest]) (pp2 *connect.Response[v1.IngestUsageEventResponse], err error)) *BillingServiceClientMock {
	if mmIngestUsageEvent.defaultExpectation != nil {
		mmIngestUsageEvent.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.IngestUsageEvent method")
	}

	if len(mmIngestUsageEvent.expectations) > 0 {
		mmIngestUsageEvent.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.IngestUsageEvent method")
	}

	mmIngestUsageEvent.mock.funcIngestUsageEvent = f
	mmIngestUsageEvent.mock.funcIngestUsageEventOrigin = minimock.CallerInfo(1)
	return mmIngestUsageEvent.mock
}

// When sets expectation for the BillingServiceClient.IngestUsageEvent which will trigger the result defined by the following
// Then helper
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) When(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest]) *BillingServiceClientMockIngestUsageEventExpectation {
	if mmIngestUsageEvent.mock.funcIngestUsageEvent != nil {
		mmIngestUsageEvent.mock.t.Fatalf("BillingServiceClientMock.IngestUsageEvent mock is already set by Set")
	}

	expectation := &BillingServiceClientMockIngestUsageEventExpectation{
		mock:               mmIngestUsageEvent.mock,
		params:             &BillingServiceClientMockIngestUsageEventParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockIngestUsageEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIngestUsageEvent.expectations = append(mmIngestUsageEvent.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.IngestUsageEvent return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockIngestUsageEventExpectation) Then(pp2 *connect.Response[v1.IngestUsageEventResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockIngestUsageEventResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.IngestUsageEvent should be invoked
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Times(n uint64) *mBillingServiceClientMockIngestUsageEvent {
	if n == 0 {
		mmIngestUsageEvent.mock.t.Fatalf("Times of BillingServiceClientMock.IngestUsageEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIngestUsageEvent.expectedInvocations, n)
	mmIngestUsageEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIngestUsageEvent
}

func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) invocationsDone() bool {
	if len(mmIngestUsageEvent.expectations) == 0 && mmIngestUsageEvent.defaultExpectation == nil && mmIngestUsageEvent.mock.funcIngestUsageEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIngestUsageEvent.mock.afterIngestUsageEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIngestUsageEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IngestUsageEvent implements mm_billingv1connect.BillingServiceClient
func (mmIngestUsageEvent *BillingServiceClientMock) IngestUsageEvent(ctx context.Context, pp1 *connect.Request[v1.IngestUsageEventRequest]) (pp2 *connect.Response[v1.IngestUsageEventResponse], err error) {
	mm_atomic.AddUint64(&mmIngestUsageEvent.beforeIngestUsageEventCounter, 1)
	defer mm_atomic.AddUint64(&mmIngestUsageEvent.afterIngestUsageEventCounter, 1)

	mmIngestUsageEvent.t.Helper()

	if mmIngestUsageEvent.inspectFuncIngestUsageEvent != nil {
		mmIngestUsageEvent.inspectFuncIngestUsageEvent(ctx, pp1)
	}

	mm_params := BillingServiceClientMockIngestUsageEventParams{ctx, pp1}

	// Record call args
	mmIngestUsageEvent.IngestUsageEventMock.mutex.Lock()
	mmIngestUsageEvent.IngestUsageEventMock.callArgs = append(mmIngestUsageEvent.IngestUsageEventMock.callArgs, &mm_params)
	mmIngestUsageEvent.IngestUsageEventMock.mutex.Unlock()

	for _, e := range mmIngestUsageEvent.IngestUsageEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.Counter, 1)
		mm_want := mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.params
		mm_want_ptrs := mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockIngestUsageEventParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIngestUsageEvent.t.Errorf("BillingServiceClientMock.IngestUsageEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmIngestUsageEvent.t.Errorf("BillingServiceClientMock.IngestUsageEvent got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIngestUsageEvent.t.Errorf("BillingServiceClientMock.IngestUsageEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIngestUsageEvent.IngestUsageEventMock.defaultExpectation.results
		if mm_results == nil {
			mmIngestUsageEvent.t.Fatal("No results are set for the BillingServiceClientMock.IngestUsageEvent")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmIngestUsageEvent.funcIngestUsageEvent != nil {
		return mmIngestUsageEvent.funcIngestUsageEvent(ctx, pp1)
	}
	mmIngestUsageEvent.t.Fatalf("Unexpected call to BillingServiceClientMock.IngestUsageEvent. %v %v", ctx, pp1)
	return
}

// IngestUsageEventAfterCounter returns a count of finished BillingServiceClientMock.IngestUsageEvent invocations
func (mmIngestUsageEvent *BillingServiceClientMock) IngestUsageEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIngestUsageEvent.afterIngestUsageEventCounter)
}

// IngestUsageEventBeforeCounter returns a count of BillingServiceClientMock.IngestUsageEvent invocations
func (mmIngestUsageEvent *BillingServiceClientMock) IngestUsageEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIngestUsageEvent.beforeIngestUsageEventCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.IngestUsageEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIngestUsageEvent *mBillingServiceClientMockIngestUsageEvent) Calls() []*BillingServiceClientMockIngestUsageEventParams {
	mmIngestUsageEvent.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockIngestUsageEventParams, len(mmIngestUsageEvent.callArgs))
	copy(argCopy, mmIngestUsageEvent.callArgs)

	mmIngestUsageEvent.mutex.RUnlock()

	return argCopy
}

// MinimockIngestUsageEventDone returns true if the count of the IngestUsageEvent invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockIngestUsageEventDone() bool {
	if m.IngestUsageEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IngestUsageEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IngestUsageEventMock.invocationsDone()
}

// MinimockIngestUsageEventInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockIngestUsageEventInspect() {
	for _, e := range m.IngestUsageEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIngestUsageEventCounter := mm_atomic.LoadUint64(&m.afterIngestUsageEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IngestUsageEventMock.defaultExpectation != nil && afterIngestUsageEventCounter < 1 {
		if m.IngestUsageEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageEvent at\n%s", m.IngestUsageEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageEvent at\n%s with params: %#v", m.IngestUsageEventMock.defaultExpectation.expectationOrigins.origin, *m.IngestUsageEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIngestUsageEvent != nil && afterIngestUsageEventCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.IngestUsageEvent at\n%s", m.funcIngestUsageEventOrigin)
	}

	if !m.IngestUsageEventMock.invocationsDone() && afterIngestUsageEventCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.IngestUsageEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IngestUsageEventMock.expectedInvocations), m.IngestUsageEventMock.expectedInvocationsOrigin, afterIngestUsageEventCounter)
	}
}

type mBillingServiceClientMockIssueInvoice struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockIssueInvoiceExpectation
	expectations       []*BillingServiceClientMockIssueInvoiceExpectation

	callArgs []*BillingServiceClientMockIssueInvoiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockIssueInvoiceExpectation specifies expectation struct of the BillingServiceClient.IssueInvoice
type BillingServiceClientMockIssueInvoiceExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockIssueInvoiceParams
	paramPtrs          *BillingServiceClientMockIssueInvoiceParamPtrs
	expectationOrigins BillingServiceClientMockIssueInvoiceExpectationOrigins
	results            *BillingServiceClientMockIssueInvoiceResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockIssueInvoiceParams contains parameters of the BillingServiceClient.IssueInvoice
type BillingServiceClientMockIssueInvoiceParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.IssueInvoiceRequest]
}

// BillingServiceClientMockIssueInvoiceParamPtrs contains pointers to parameters of the BillingServiceClient.IssueInvoice
type BillingServiceClientMockIssueInvoiceParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.IssueInvoiceRequest]
}

// BillingServiceClientMockIssueInvoiceResults contains results of the BillingServiceClient.IssueInvoice
type BillingServiceClientMockIssueInvoiceResults struct {
	pp2 *connect.Response[v1.IssueInvoiceResponse]
	err error
}

// BillingServiceClientMockIssueInvoiceOrigins contains origins of expectations of the BillingServiceClient.IssueInvoice
type BillingServiceClientMockIssueInvoiceExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Optional() *mBillingServiceClientMockIssueInvoice {
	mmIssueInvoice.optional = true
	return mmIssueInvoice
}

// Expect sets up expected params for BillingServiceClient.IssueInvoice
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Expect(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest]) *mBillingServiceClientMockIssueInvoice {
	if mmIssueInvoice.mock.funcIssueInvoice != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Set")
	}

	if mmIssueInvoice.defaultExpectation == nil {
		mmIssueInvoice.defaultExpectation = &BillingServiceClientMockIssueInvoiceExpectation{}
	}

	if mmIssueInvoice.defaultExpectation.paramPtrs != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by ExpectParams functions")
	}

	mmIssueInvoice.defaultExpectation.params = &BillingServiceClientMockIssueInvoiceParams{ctx, pp1}
	mmIssueInvoice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIssueInvoice.expectations {
		if minimock.Equal(e.params, mmIssueInvoice.defaultExpectation.params) {
			mmIssueInvoice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIssueInvoice.defaultExpectation.params)
		}
	}

	return mmIssueInvoice
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.IssueInvoice
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockIssueInvoice {
	if mmIssueInvoice.mock.funcIssueInvoice != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Set")
	}

	if mmIssueInvoice.defaultExpectation == nil {
		mmIssueInvoice.defaultExpectation = &BillingServiceClientMockIssueInvoiceExpectation{}
	}

	if mmIssueInvoice.defaultExpectation.params != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Expect")
	}

	if mmIssueInvoice.defaultExpectation.paramPtrs == nil {
		mmIssueInvoice.defaultExpectation.paramPtrs = &BillingServiceClientMockIssueInvoiceParamPtrs{}
	}
	mmIssueInvoice.defaultExpectation.paramPtrs.ctx = &ctx
	mmIssueInvoice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIssueInvoice
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.IssueInvoice
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) ExpectPp1Param2(pp1 *connect.Request[v1.IssueInvoiceRequest]) *mBillingServiceClientMockIssueInvoice {
	if mmIssueInvoice.mock.funcIssueInvoice != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Set")
	}

	if mmIssueInvoice.defaultExpectation == nil {
		mmIssueInvoice.defaultExpectation = &BillingServiceClientMockIssueInvoiceExpectation{}
	}

	if mmIssueInvoice.defaultExpectation.params != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Expect")
	}

	if mmIssueInvoice.defaultExpectation.paramPtrs == nil {
		mmIssueInvoice.defaultExpectation.paramPtrs = &BillingServiceClientMockIssueInvoiceParamPtrs{}
	}
	mmIssueInvoice.defaultExpectation.paramPtrs.pp1 = &pp1
	mmIssueInvoice.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmIssueInvoice
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.IssueInvoice
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest])) *mBillingServiceClientMockIssueInvoice {
	if mmIssueInvoice.mock.inspectFuncIssueInvoice != nil {
		mmIssueInvoice.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.IssueInvoice")
	}

	mmIssueInvoice.mock.inspectFuncIssueInvoice = f

	return mmIssueInvoice
}

// Return sets up results that will be returned by BillingServiceClient.IssueInvoice
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Return(pp2 *connect.Response[v1.IssueInvoiceResponse], err error) *BillingServiceClientMock {
	if mmIssueInvoice.mock.funcIssueInvoice != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Set")
	}

	if mmIssueInvoice.defaultExpectation == nil {
		mmIssueInvoice.defaultExpectation = &BillingServiceClientMockIssueInvoiceExpectation{mock: mmIssueInvoice.mock}
	}
	mmIssueInvoice.defaultExpectation.results = &BillingServiceClientMockIssueInvoiceResults{pp2, err}
	mmIssueInvoice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIssueInvoice.mock
}

// Set uses given function f to mock the BillingServiceClient.IssueInvoice method
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Set(f func(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest]) (pp2 *connect.Response[v1.IssueInvoiceResponse], err error)) *BillingServiceClientMock {
	if mmIssueInvoice.defaultExpectation != nil {
		mmIssueInvoice.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.IssueInvoice method")
	}

	if len(mmIssueInvoice.expectations) > 0 {
		mmIssueInvoice.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.IssueInvoice method")
	}

	mmIssueInvoice.mock.funcIssueInvoice = f
	mmIssueInvoice.mock.funcIssueInvoiceOrigin = minimock.CallerInfo(1)
	return mmIssueInvoice.mock
}

// When sets expectation for the BillingServiceClient.IssueInvoice which will trigger the result defined by the following
// Then helper
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) When(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest]) *BillingServiceClientMockIssueInvoiceExpectation {
	if mmIssueInvoice.mock.funcIssueInvoice != nil {
		mmIssueInvoice.mock.t.Fatalf("BillingServiceClientMock.IssueInvoice mock is already set by Set")
	}

	expectation := &BillingServiceClientMockIssueInvoiceExpectation{
		mock:               mmIssueInvoice.mock,
		params:             &BillingServiceClientMockIssueInvoiceParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockIssueInvoiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIssueInvoice.expectations = append(mmIssueInvoice.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.IssueInvoice return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockIssueInvoiceExpectation) Then(pp2 *connect.Response[v1.IssueInvoiceResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockIssueInvoiceResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.IssueInvoice should be invoked
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Times(n uint64) *mBillingServiceClientMockIssueInvoice {
	if n == 0 {
		mmIssueInvoice.mock.t.Fatalf("Times of BillingServiceClientMock.IssueInvoice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIssueInvoice.expectedInvocations, n)
	mmIssueInvoice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIssueInvoice
}

func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) invocationsDone() bool {
	if len(mmIssueInvoice.expectations) == 0 && mmIssueInvoice.defaultExpectation == nil && mmIssueInvoice.mock.funcIssueInvoice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIssueInvoice.mock.afterIssueInvoiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIssueInvoice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IssueInvoice implements mm_billingv1connect.BillingServiceClient
func (mmIssueInvoice *BillingServiceClientMock) IssueInvoice(ctx context.Context, pp1 *connect.Request[v1.IssueInvoiceRequest]) (pp2 *connect.Response[v1.IssueInvoiceResponse], err error) {
	mm_atomic.AddUint64(&mmIssueInvoice.beforeIssueInvoiceCounter, 1)
	defer mm_atomic.AddUint64(&mmIssueInvoice.afterIssueInvoiceCounter, 1)

	mmIssueInvoice.t.Helper()

	if mmIssueInvoice.inspectFuncIssueInvoice != nil {
		mmIssueInvoice.inspectFuncIssueInvoice(ctx, pp1)
	}

	mm_params := BillingServiceClientMockIssueInvoiceParams{ctx, pp1}

	// Record call args
	mmIssueInvoice.IssueInvoiceMock.mutex.Lock()
	mmIssueInvoice.IssueInvoiceMock.callArgs = append(mmIssueInvoice.IssueInvoiceMock.callArgs, &mm_params)
	mmIssueInvoice.IssueInvoiceMock.mutex.Unlock()

	for _, e := range mmIssueInvoice.IssueInvoiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmIssueInvoice.IssueInvoiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIssueInvoice.IssueInvoiceMock.defaultExpectation.Counter, 1)
		mm_want := mmIssueInvoice.IssueInvoiceMock.defaultExpectation.params
		mm_want_ptrs := mmIssueInvoice.IssueInvoiceMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockIssueInvoiceParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIssueInvoice.t.Errorf("BillingServiceClientMock.IssueInvoice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueInvoice.IssueInvoiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmIssueInvoice.t.Errorf("BillingServiceClientMock.IssueInvoice got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIssueInvoice.IssueInvoiceMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIssueInvoice.t.Errorf("BillingServiceClientMock.IssueInvoice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIssueInvoice.IssueInvoiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIssueInvoice.IssueInvoiceMock.defaultExpectation.results
		if mm_results == nil {
			mmIssueInvoice.t.Fatal("No results are set for the BillingServiceClientMock.IssueInvoice")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmIssueInvoice.funcIssueInvoice != nil {
		return mmIssueInvoice.funcIssueInvoice(ctx, pp1)
	}
	mmIssueInvoice.t.Fatalf("Unexpected call to BillingServiceClientMock.IssueInvoice. %v %v", ctx, pp1)
	return
}

// IssueInvoiceAfterCounter returns a count of finished BillingServiceClientMock.IssueInvoice invocations
func (mmIssueInvoice *BillingServiceClientMock) IssueInvoiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueInvoice.afterIssueInvoiceCounter)
}

// IssueInvoiceBeforeCounter returns a count of BillingServiceClientMock.IssueInvoice invocations
func (mmIssueInvoice *BillingServiceClientMock) IssueInvoiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIssueInvoice.beforeIssueInvoiceCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.IssueInvoice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIssueInvoice *mBillingServiceClientMockIssueInvoice) Calls() []*BillingServiceClientMockIssueInvoiceParams {
	mmIssueInvoice.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockIssueInvoiceParams, len(mmIssueInvoice.callArgs))
	copy(argCopy, mmIssueInvoice.callArgs)

	mmIssueInvoice.mutex.RUnlock()

	return argCopy
}

// MinimockIssueInvoiceDone returns true if the count of the IssueInvoice invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockIssueInvoiceDone() bool {
	if m.IssueInvoiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IssueInvoiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IssueInvoiceMock.invocationsDone()
}

// MinimockIssueInvoiceInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockIssueInvoiceInspect() {
	for _, e := range m.IssueInvoiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.IssueInvoice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIssueInvoiceCounter := mm_atomic.LoadUint64(&m.afterIssueInvoiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IssueInvoiceMock.defaultExpectation != nil && afterIssueInvoiceCounter < 1 {
		if m.IssueInvoiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.IssueInvoice at\n%s", m.IssueInvoiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.IssueInvoice at\n%s with params: %#v", m.IssueInvoiceMock.defaultExpectation.expectationOrigins.origin, *m.IssueInvoiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIssueInvoice != nil && afterIssueInvoiceCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.IssueInvoice at\n%s", m.funcIssueInvoiceOrigin)
	}

	if !m.IssueInvoiceMock.invocationsDone() && afterIssueInvoiceCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.IssueInvoice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IssueInvoiceMock.expectedInvocations), m.IssueInvoiceMock.expectedInvocationsOrigin, afterIssueInvoiceCounter)
	}
}

type mBillingServiceClientMockListSubscriptions struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockListSubscriptionsExpectation
	expectations       []*BillingServiceClientMockListSubscriptionsExpectation

	callArgs []*BillingServiceClientMockListSubscriptionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockListSubscriptionsExpectation specifies expectation struct of the BillingServiceClient.ListSubscriptions
type BillingServiceClientMockListSubscriptionsExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockListSubscriptionsParams
	paramPtrs          *BillingServiceClientMockListSubscriptionsParamPtrs
	expectationOrigins BillingServiceClientMockListSubscriptionsExpectationOrigins
	results            *BillingServiceClientMockListSubscriptionsResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockListSubscriptionsParams contains parameters of the BillingServiceClient.ListSubscriptions
type BillingServiceClientMockListSubscriptionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListSubscriptionsRequest]
}

// BillingServiceClientMockListSubscriptionsParamPtrs contains pointers to parameters of the BillingServiceClient.ListSubscriptions
type BillingServiceClientMockListSubscriptionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListSubscriptionsRequest]
}

// BillingServiceClientMockListSubscriptionsResults contains results of the BillingServiceClient.ListSubscriptions
type BillingServiceClientMockListSubscriptionsResults struct {
	pp2 *connect.Response[v1.ListSubscriptionsResponse]
	err error
}

// BillingServiceClientMockListSubscriptionsOrigins contains origins of expectations of the BillingServiceClient.ListSubscriptions
type BillingServiceClientMockListSubscriptionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Optional() *mBillingServiceClientMockListSubscriptions {
	mmListSubscriptions.optional = true
	return mmListSubscriptions
}

// Expect sets up expected params for BillingServiceClient.ListSubscriptions
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Expect(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest]) *mBillingServiceClientMockListSubscriptions {
	if mmListSubscriptions.mock.funcListSubscriptions != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Set")
	}

	if mmListSubscriptions.defaultExpectation == nil {
		mmListSubscriptions.defaultExpectation = &BillingServiceClientMockListSubscriptionsExpectation{}
	}

	if mmListSubscriptions.defaultExpectation.paramPtrs != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by ExpectParams functions")
	}

	mmListSubscriptions.defaultExpectation.params = &BillingServiceClientMockListSubscriptionsParams{ctx, pp1}
	mmListSubscriptions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSubscriptions.expectations {
		if minimock.Equal(e.params, mmListSubscriptions.defaultExpectation.params) {
			mmListSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSubscriptions.defaultExpectation.params)
		}
	}

	return mmListSubscriptions
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.ListSubscriptions
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockListSubscriptions {
	if mmListSubscriptions.mock.funcListSubscriptions != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Set")
	}

	if mmListSubscriptions.defaultExpectation == nil {
		mmListSubscriptions.defaultExpectation = &BillingServiceClientMockListSubscriptionsExpectation{}
	}

	if mmListSubscriptions.defaultExpectation.params != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Expect")
	}

	if mmListSubscriptions.defaultExpectation.paramPtrs == nil {
		mmListSubscriptions.defaultExpectation.paramPtrs = &BillingServiceClientMockListSubscriptionsParamPtrs{}
	}
	mmListSubscriptions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSubscriptions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSubscriptions
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.ListSubscriptions
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) ExpectPp1Param2(pp1 *connect.Request[v1.ListSubscriptionsRequest]) *mBillingServiceClientMockListSubscriptions {
	if mmListSubscriptions.mock.funcListSubscriptions != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Set")
	}

	if mmListSubscriptions.defaultExpectation == nil {
		mmListSubscriptions.defaultExpectation = &BillingServiceClientMockListSubscriptionsExpectation{}
	}

	if mmListSubscriptions.defaultExpectation.params != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Expect")
	}

	if mmListSubscriptions.defaultExpectation.paramPtrs == nil {
		mmListSubscriptions.defaultExpectation.paramPtrs = &BillingServiceClientMockListSubscriptionsParamPtrs{}
	}
	mmListSubscriptions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListSubscriptions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.ListSubscriptions
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest])) *mBillingServiceClientMockListSubscriptions {
	if mmListSubscriptions.mock.inspectFuncListSubscriptions != nil {
		mmListSubscriptions.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.ListSubscriptions")
	}

	mmListSubscriptions.mock.inspectFuncListSubscriptions = f

	return mmListSubscriptions
}

// Return sets up results that will be returned by BillingServiceClient.ListSubscriptions
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Return(pp2 *connect.Response[v1.ListSubscriptionsResponse], err error) *BillingServiceClientMock {
	if mmListSubscriptions.mock.funcListSubscriptions != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Set")
	}

	if mmListSubscriptions.defaultExpectation == nil {
		mmListSubscriptions.defaultExpectation = &BillingServiceClientMockListSubscriptionsExpectation{mock: mmListSubscriptions.mock}
	}
	mmListSubscriptions.defaultExpectation.results = &BillingServiceClientMockListSubscriptionsResults{pp2, err}
	mmListSubscriptions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSubscriptions.mock
}

// Set uses given function f to mock the BillingServiceClient.ListSubscriptions method
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest]) (pp2 *connect.Response[v1.ListSubscriptionsResponse], err error)) *BillingServiceClientMock {
	if mmListSubscriptions.defaultExpectation != nil {
		mmListSubscriptions.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.ListSubscriptions method")
	}

	if len(mmListSubscriptions.expectations) > 0 {
		mmListSubscriptions.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.ListSubscriptions method")
	}

	mmListSubscriptions.mock.funcListSubscriptions = f
	mmListSubscriptions.mock.funcListSubscriptionsOrigin = minimock.CallerInfo(1)
	return mmListSubscriptions.mock
}

// When sets expectation for the BillingServiceClient.ListSubscriptions which will trigger the result defined by the following
// Then helper
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) When(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest]) *BillingServiceClientMockListSubscriptionsExpectation {
	if mmListSubscriptions.mock.funcListSubscriptions != nil {
		mmListSubscriptions.mock.t.Fatalf("BillingServiceClientMock.ListSubscriptions mock is already set by Set")
	}

	expectation := &BillingServiceClientMockListSubscriptionsExpectation{
		mock:               mmListSubscriptions.mock,
		params:             &BillingServiceClientMockListSubscriptionsParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockListSubscriptionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSubscriptions.expectations = append(mmListSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.ListSubscriptions return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockListSubscriptionsExpectation) Then(pp2 *connect.Response[v1.ListSubscriptionsResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockListSubscriptionsResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.ListSubscriptions should be invoked
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Times(n uint64) *mBillingServiceClientMockListSubscriptions {
	if n == 0 {
		mmListSubscriptions.mock.t.Fatalf("Times of BillingServiceClientMock.ListSubscriptions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSubscriptions.expectedInvocations, n)
	mmListSubscriptions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSubscriptions
}

func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) invocationsDone() bool {
	if len(mmListSubscriptions.expectations) == 0 && mmListSubscriptions.defaultExpectation == nil && mmListSubscriptions.mock.funcListSubscriptions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSubscriptions.mock.afterListSubscriptionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSubscriptions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSubscriptions implements mm_billingv1connect.BillingServiceClient
func (mmListSubscriptions *BillingServiceClientMock) ListSubscriptions(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionsRequest]) (pp2 *connect.Response[v1.ListSubscriptionsResponse], err error) {
	mm_atomic.AddUint64(&mmListSubscriptions.beforeListSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListSubscriptions.afterListSubscriptionsCounter, 1)

	mmListSubscriptions.t.Helper()

	if mmListSubscriptions.inspectFuncListSubscriptions != nil {
		mmListSubscriptions.inspectFuncListSubscriptions(ctx, pp1)
	}

	mm_params := BillingServiceClientMockListSubscriptionsParams{ctx, pp1}

	// Record call args
	mmListSubscriptions.ListSubscriptionsMock.mutex.Lock()
	mmListSubscriptions.ListSubscriptionsMock.callArgs = append(mmListSubscriptions.ListSubscriptionsMock.callArgs, &mm_params)
	mmListSubscriptions.ListSubscriptionsMock.mutex.Unlock()

	for _, e := range mmListSubscriptions.ListSubscriptionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListSubscriptions.ListSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.params
		mm_want_ptrs := mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockListSubscriptionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSubscriptions.t.Errorf("BillingServiceClientMock.ListSubscriptions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListSubscriptions.t.Errorf("BillingServiceClientMock.ListSubscriptions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSubscriptions.t.Errorf("BillingServiceClientMock.ListSubscriptions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSubscriptions.ListSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListSubscriptions.t.Fatal("No results are set for the BillingServiceClientMock.ListSubscriptions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListSubscriptions.funcListSubscriptions != nil {
		return mmListSubscriptions.funcListSubscriptions(ctx, pp1)
	}
	mmListSubscriptions.t.Fatalf("Unexpected call to BillingServiceClientMock.ListSubscriptions. %v %v", ctx, pp1)
	return
}

// ListSubscriptionsAfterCounter returns a count of finished BillingServiceClientMock.ListSubscriptions invocations
func (mmListSubscriptions *BillingServiceClientMock) ListSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubscriptions.afterListSubscriptionsCounter)
}

// ListSubscriptionsBeforeCounter returns a count of BillingServiceClientMock.ListSubscriptions invocations
func (mmListSubscriptions *BillingServiceClientMock) ListSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubscriptions.beforeListSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.ListSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSubscriptions *mBillingServiceClientMockListSubscriptions) Calls() []*BillingServiceClientMockListSubscriptionsParams {
	mmListSubscriptions.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockListSubscriptionsParams, len(mmListSubscriptions.callArgs))
	copy(argCopy, mmListSubscriptions.callArgs)

	mmListSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockListSubscriptionsDone returns true if the count of the ListSubscriptions invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockListSubscriptionsDone() bool {
	if m.ListSubscriptionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSubscriptionsMock.invocationsDone()
}

// MinimockListSubscriptionsInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockListSubscriptionsInspect() {
	for _, e := range m.ListSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.ListSubscriptions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSubscriptionsCounter := mm_atomic.LoadUint64(&m.afterListSubscriptionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSubscriptionsMock.defaultExpectation != nil && afterListSubscriptionsCounter < 1 {
		if m.ListSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.ListSubscriptions at\n%s", m.ListSubscriptionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.ListSubscriptions at\n%s with params: %#v", m.ListSubscriptionsMock.defaultExpectation.expectationOrigins.origin, *m.ListSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSubscriptions != nil && afterListSubscriptionsCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.ListSubscriptions at\n%s", m.funcListSubscriptionsOrigin)
	}

	if !m.ListSubscriptionsMock.invocationsDone() && afterListSubscriptionsCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.ListSubscriptions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSubscriptionsMock.expectedInvocations), m.ListSubscriptionsMock.expectedInvocationsOrigin, afterListSubscriptionsCounter)
	}
}

type mBillingServiceClientMockPublishCatalogVersion struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockPublishCatalogVersionExpectation
	expectations       []*BillingServiceClientMockPublishCatalogVersionExpectation

	callArgs []*BillingServiceClientMockPublishCatalogVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockPublishCatalogVersionExpectation specifies expectation struct of the BillingServiceClient.PublishCatalogVersion
type BillingServiceClientMockPublishCatalogVersionExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockPublishCatalogVersionParams
	paramPtrs          *BillingServiceClientMockPublishCatalogVersionParamPtrs
	expectationOrigins BillingServiceClientMockPublishCatalogVersionExpectationOrigins
	results            *BillingServiceClientMockPublishCatalogVersionResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockPublishCatalogVersionParams contains parameters of the BillingServiceClient.PublishCatalogVersion
type BillingServiceClientMockPublishCatalogVersionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.PublishCatalogVersionRequest]
}

// BillingServiceClientMockPublishCatalogVersionParamPtrs contains pointers to parameters of the BillingServiceClient.PublishCatalogVersion
type BillingServiceClientMockPublishCatalogVersionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.PublishCatalogVersionRequest]
}

// BillingServiceClientMockPublishCatalogVersionResults contains results of the BillingServiceClient.PublishCatalogVersion
type BillingServiceClientMockPublishCatalogVersionResults struct {
	pp2 *connect.Response[v1.PublishCatalogVersionResponse]
	err error
}

// BillingServiceClientMockPublishCatalogVersionOrigins contains origins of expectations of the BillingServiceClient.PublishCatalogVersion
type BillingServiceClientMockPublishCatalogVersionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Optional() *mBillingServiceClientMockPublishCatalogVersion {
	mmPublishCatalogVersion.optional = true
	return mmPublishCatalogVersion
}

// Expect sets up expected params for BillingServiceClient.PublishCatalogVersion
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Expect(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest]) *mBillingServiceClientMockPublishCatalogVersion {
	if mmPublishCatalogVersion.mock.funcPublishCatalogVersion != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Set")
	}

	if mmPublishCatalogVersion.defaultExpectation == nil {
		mmPublishCatalogVersion.defaultExpectation = &BillingServiceClientMockPublishCatalogVersionExpectation{}
	}

	if mmPublishCatalogVersion.defaultExpectation.paramPtrs != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by ExpectParams functions")
	}

	mmPublishCatalogVersion.defaultExpectation.params = &BillingServiceClientMockPublishCatalogVersionParams{ctx, pp1}
	mmPublishCatalogVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPublishCatalogVersion.expectations {
		if minimock.Equal(e.params, mmPublishCatalogVersion.defaultExpectation.params) {
			mmPublishCatalogVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPublishCatalogVersion.defaultExpectation.params)
		}
	}

	return mmPublishCatalogVersion
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.PublishCatalogVersion
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockPublishCatalogVersion {
	if mmPublishCatalogVersion.mock.funcPublishCatalogVersion != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Set")
	}

	if mmPublishCatalogVersion.defaultExpectation == nil {
		mmPublishCatalogVersion.defaultExpectation = &BillingServiceClientMockPublishCatalogVersionExpectation{}
	}

	if mmPublishCatalogVersion.defaultExpectation.params != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Expect")
	}

	if mmPublishCatalogVersion.defaultExpectation.paramPtrs == nil {
		mmPublishCatalogVersion.defaultExpectation.paramPtrs = &BillingServiceClientMockPublishCatalogVersionParamPtrs{}
	}
	mmPublishCatalogVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmPublishCatalogVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPublishCatalogVersion
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.PublishCatalogVersion
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) ExpectPp1Param2(pp1 *connect.Request[v1.PublishCatalogVersionRequest]) *mBillingServiceClientMockPublishCatalogVersion {
	if mmPublishCatalogVersion.mock.funcPublishCatalogVersion != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Set")
	}

	if mmPublishCatalogVersion.defaultExpectation == nil {
		mmPublishCatalogVersion.defaultExpectation = &BillingServiceClientMockPublishCatalogVersionExpectation{}
	}

	if mmPublishCatalogVersion.defaultExpectation.params != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Expect")
	}

	if mmPublishCatalogVersion.defaultExpectation.paramPtrs == nil {
		mmPublishCatalogVersion.defaultExpectation.paramPtrs = &BillingServiceClientMockPublishCatalogVersionParamPtrs{}
	}
	mmPublishCatalogVersion.defaultExpectation.paramPtrs.pp1 = &pp1
	mmPublishCatalogVersion.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmPublishCatalogVersion
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.PublishCatalogVersion
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest])) *mBillingServiceClientMockPublishCatalogVersion {
	if mmPublishCatalogVersion.mock.inspectFuncPublishCatalogVersion != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.PublishCatalogVersion")
	}

	mmPublishCatalogVersion.mock.inspectFuncPublishCatalogVersion = f

	return mmPublishCatalogVersion
}

// Return sets up results that will be returned by BillingServiceClient.PublishCatalogVersion
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Return(pp2 *connect.Response[v1.PublishCatalogVersionResponse], err error) *BillingServiceClientMock {
	if mmPublishCatalogVersion.mock.funcPublishCatalogVersion != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Set")
	}

	if mmPublishCatalogVersion.defaultExpectation == nil {
		mmPublishCatalogVersion.defaultExpectation = &BillingServiceClientMockPublishCatalogVersionExpectation{mock: mmPublishCatalogVersion.mock}
	}
	mmPublishCatalogVersion.defaultExpectation.results = &BillingServiceClientMockPublishCatalogVersionResults{pp2, err}
	mmPublishCatalogVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPublishCatalogVersion.mock
}

// Set uses given function f to mock the BillingServiceClient.PublishCatalogVersion method
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Set(f func(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest]) (pp2 *connect.Response[v1.PublishCatalogVersionResponse], err error)) *BillingServiceClientMock {
	if mmPublishCatalogVersion.defaultExpectation != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.PublishCatalogVersion method")
	}

	if len(mmPublishCatalogVersion.expectations) > 0 {
		mmPublishCatalogVersion.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.PublishCatalogVersion method")
	}

	mmPublishCatalogVersion.mock.funcPublishCatalogVersion = f
	mmPublishCatalogVersion.mock.funcPublishCatalogVersionOrigin = minimock.CallerInfo(1)
	return mmPublishCatalogVersion.mock
}

// When sets expectation for the BillingServiceClient.PublishCatalogVersion which will trigger the result defined by the following
// Then helper
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) When(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest]) *BillingServiceClientMockPublishCatalogVersionExpectation {
	if mmPublishCatalogVersion.mock.funcPublishCatalogVersion != nil {
		mmPublishCatalogVersion.mock.t.Fatalf("BillingServiceClientMock.PublishCatalogVersion mock is already set by Set")
	}

	expectation := &BillingServiceClientMockPublishCatalogVersionExpectation{
		mock:               mmPublishCatalogVersion.mock,
		params:             &BillingServiceClientMockPublishCatalogVersionParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockPublishCatalogVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPublishCatalogVersion.expectations = append(mmPublishCatalogVersion.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.PublishCatalogVersion return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockPublishCatalogVersionExpectation) Then(pp2 *connect.Response[v1.PublishCatalogVersionResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockPublishCatalogVersionResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.PublishCatalogVersion should be invoked
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Times(n uint64) *mBillingServiceClientMockPublishCatalogVersion {
	if n == 0 {
		mmPublishCatalogVersion.mock.t.Fatalf("Times of BillingServiceClientMock.PublishCatalogVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPublishCatalogVersion.expectedInvocations, n)
	mmPublishCatalogVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPublishCatalogVersion
}

func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) invocationsDone() bool {
	if len(mmPublishCatalogVersion.expectations) == 0 && mmPublishCatalogVersion.defaultExpectation == nil && mmPublishCatalogVersion.mock.funcPublishCatalogVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPublishCatalogVersion.mock.afterPublishCatalogVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPublishCatalogVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PublishCatalogVersion implements mm_billingv1connect.BillingServiceClient
func (mmPublishCatalogVersion *BillingServiceClientMock) PublishCatalogVersion(ctx context.Context, pp1 *connect.Request[v1.PublishCatalogVersionRequest]) (pp2 *connect.Response[v1.PublishCatalogVersionResponse], err error) {
	mm_atomic.AddUint64(&mmPublishCatalogVersion.beforePublishCatalogVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmPublishCatalogVersion.afterPublishCatalogVersionCounter, 1)

	mmPublishCatalogVersion.t.Helper()

	if mmPublishCatalogVersion.inspectFuncPublishCatalogVersion != nil {
		mmPublishCatalogVersion.inspectFuncPublishCatalogVersion(ctx, pp1)
	}

	mm_params := BillingServiceClientMockPublishCatalogVersionParams{ctx, pp1}

	// Record call args
	mmPublishCatalogVersion.PublishCatalogVersionMock.mutex.Lock()
	mmPublishCatalogVersion.PublishCatalogVersionMock.callArgs = append(mmPublishCatalogVersion.PublishCatalogVersionMock.callArgs, &mm_params)
	mmPublishCatalogVersion.PublishCatalogVersionMock.mutex.Unlock()

	for _, e := range mmPublishCatalogVersion.PublishCatalogVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.params
		mm_want_ptrs := mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockPublishCatalogVersionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPublishCatalogVersion.t.Errorf("BillingServiceClientMock.PublishCatalogVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmPublishCatalogVersion.t.Errorf("BillingServiceClientMock.PublishCatalogVersion got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPublishCatalogVersion.t.Errorf("BillingServiceClientMock.PublishCatalogVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPublishCatalogVersion.PublishCatalogVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmPublishCatalogVersion.t.Fatal("No results are set for the BillingServiceClientMock.PublishCatalogVersion")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmPublishCatalogVersion.funcPublishCatalogVersion != nil {
		return mmPublishCatalogVersion.funcPublishCatalogVersion(ctx, pp1)
	}
	mmPublishCatalogVersion.t.Fatalf("Unexpected call to BillingServiceClientMock.PublishCatalogVersion. %v %v", ctx, pp1)
	return
}

// PublishCatalogVersionAfterCounter returns a count of finished BillingServiceClientMock.PublishCatalogVersion invocations
func (mmPublishCatalogVersion *BillingServiceClientMock) PublishCatalogVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishCatalogVersion.afterPublishCatalogVersionCounter)
}

// PublishCatalogVersionBeforeCounter returns a count of BillingServiceClientMock.PublishCatalogVersion invocations
func (mmPublishCatalogVersion *BillingServiceClientMock) PublishCatalogVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPublishCatalogVersion.beforePublishCatalogVersionCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.PublishCatalogVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPublishCatalogVersion *mBillingServiceClientMockPublishCatalogVersion) Calls() []*BillingServiceClientMockPublishCatalogVersionParams {
	mmPublishCatalogVersion.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockPublishCatalogVersionParams, len(mmPublishCatalogVersion.callArgs))
	copy(argCopy, mmPublishCatalogVersion.callArgs)

	mmPublishCatalogVersion.mutex.RUnlock()

	return argCopy
}

// MinimockPublishCatalogVersionDone returns true if the count of the PublishCatalogVersion invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockPublishCatalogVersionDone() bool {
	if m.PublishCatalogVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PublishCatalogVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PublishCatalogVersionMock.invocationsDone()
}

// MinimockPublishCatalogVersionInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockPublishCatalogVersionInspect() {
	for _, e := range m.PublishCatalogVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.PublishCatalogVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPublishCatalogVersionCounter := mm_atomic.LoadUint64(&m.afterPublishCatalogVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PublishCatalogVersionMock.defaultExpectation != nil && afterPublishCatalogVersionCounter < 1 {
		if m.PublishCatalogVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.PublishCatalogVersion at\n%s", m.PublishCatalogVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.PublishCatalogVersion at\n%s with params: %#v", m.PublishCatalogVersionMock.defaultExpectation.expectationOrigins.origin, *m.PublishCatalogVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPublishCatalogVersion != nil && afterPublishCatalogVersionCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.PublishCatalogVersion at\n%s", m.funcPublishCatalogVersionOrigin)
	}

	if !m.PublishCatalogVersionMock.invocationsDone() && afterPublishCatalogVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.PublishCatalogVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PublishCatalogVersionMock.expectedInvocations), m.PublishCatalogVersionMock.expectedInvocationsOrigin, afterPublishCatalogVersionCounter)
	}
}

type mBillingServiceClientMockRecordPayment struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockRecordPaymentExpectation
	expectations       []*BillingServiceClientMockRecordPaymentExpectation

	callArgs []*BillingServiceClientMockRecordPaymentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockRecordPaymentExpectation specifies expectation struct of the BillingServiceClient.RecordPayment
type BillingServiceClientMockRecordPaymentExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockRecordPaymentParams
	paramPtrs          *BillingServiceClientMockRecordPaymentParamPtrs
	expectationOrigins BillingServiceClientMockRecordPaymentExpectationOrigins
	results            *BillingServiceClientMockRecordPaymentResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockRecordPaymentParams contains parameters of the BillingServiceClient.RecordPayment
type BillingServiceClientMockRecordPaymentParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RecordPaymentRequest]
}

// BillingServiceClientMockRecordPaymentParamPtrs contains pointers to parameters of the BillingServiceClient.RecordPayment
type BillingServiceClientMockRecordPaymentParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RecordPaymentRequest]
}

// BillingServiceClientMockRecordPaymentResults contains results of the BillingServiceClient.RecordPayment
type BillingServiceClientMockRecordPaymentResults struct {
	pp2 *connect.Response[v1.RecordPaymentResponse]
	err error
}

// BillingServiceClientMockRecordPaymentOrigins contains origins of expectations of the BillingServiceClient.RecordPayment
type BillingServiceClientMockRecordPaymentExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Optional() *mBillingServiceClientMockRecordPayment {
	mmRecordPayment.optional = true
	return mmRecordPayment
}

// Expect sets up expected params for BillingServiceClient.RecordPayment
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Expect(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest]) *mBillingServiceClientMockRecordPayment {
	if mmRecordPayment.mock.funcRecordPayment != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Set")
	}

	if mmRecordPayment.defaultExpectation == nil {
		mmRecordPayment.defaultExpectation = &BillingServiceClientMockRecordPaymentExpectation{}
	}

	if mmRecordPayment.defaultExpectation.paramPtrs != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by ExpectParams functions")
	}

	mmRecordPayment.defaultExpectation.params = &BillingServiceClientMockRecordPaymentParams{ctx, pp1}
	mmRecordPayment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRecordPayment.expectations {
		if minimock.Equal(e.params, mmRecordPayment.defaultExpectation.params) {
			mmRecordPayment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecordPayment.defaultExpectation.params)
		}
	}

	return mmRecordPayment
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.RecordPayment
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockRecordPayment {
	if mmRecordPayment.mock.funcRecordPayment != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Set")
	}

	if mmRecordPayment.defaultExpectation == nil {
		mmRecordPayment.defaultExpectation = &BillingServiceClientMockRecordPaymentExpectation{}
	}

	if mmRecordPayment.defaultExpectation.params != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Expect")
	}

	if mmRecordPayment.defaultExpectation.paramPtrs == nil {
		mmRecordPayment.defaultExpectation.paramPtrs = &BillingServiceClientMockRecordPaymentParamPtrs{}
	}
	mmRecordPayment.defaultExpectation.paramPtrs.ctx = &ctx
	mmRecordPayment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRecordPayment
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.RecordPayment
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) ExpectPp1Param2(pp1 *connect.Request[v1.RecordPaymentRequest]) *mBillingServiceClientMockRecordPayment {
	if mmRecordPayment.mock.funcRecordPayment != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Set")
	}

	if mmRecordPayment.defaultExpectation == nil {
		mmRecordPayment.defaultExpectation = &BillingServiceClientMockRecordPaymentExpectation{}
	}

	if mmRecordPayment.defaultExpectation.params != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Expect")
	}

	if mmRecordPayment.defaultExpectation.paramPtrs == nil {
		mmRecordPayment.defaultExpectation.paramPtrs = &BillingServiceClientMockRecordPaymentParamPtrs{}
	}
	mmRecordPayment.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRecordPayment.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRecordPayment
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.RecordPayment
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest])) *mBillingServiceClientMockRecordPayment {
	if mmRecordPayment.mock.inspectFuncRecordPayment != nil {
		mmRecordPayment.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.RecordPayment")
	}

	mmRecordPayment.mock.inspectFuncRecordPayment = f

	return mmRecordPayment
}

// Return sets up results that will be returned by BillingServiceClient.RecordPayment
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Return(pp2 *connect.Response[v1.RecordPaymentResponse], err error) *BillingServiceClientMock {
	if mmRecordPayment.mock.funcRecordPayment != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Set")
	}

	if mmRecordPayment.defaultExpectation == nil {
		mmRecordPayment.defaultExpectation = &BillingServiceClientMockRecordPaymentExpectation{mock: mmRecordPayment.mock}
	}
	mmRecordPayment.defaultExpectation.results = &BillingServiceClientMockRecordPaymentResults{pp2, err}
	mmRecordPayment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRecordPayment.mock
}

// Set uses given function f to mock the BillingServiceClient.RecordPayment method
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest]) (pp2 *connect.Response[v1.RecordPaymentResponse], err error)) *BillingServiceClientMock {
	if mmRecordPayment.defaultExpectation != nil {
		mmRecordPayment.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.RecordPayment method")
	}

	if len(mmRecordPayment.expectations) > 0 {
		mmRecordPayment.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.RecordPayment method")
	}

	mmRecordPayment.mock.funcRecordPayment = f
	mmRecordPayment.mock.funcRecordPaymentOrigin = minimock.CallerInfo(1)
	return mmRecordPayment.mock
}

// When sets expectation for the BillingServiceClient.RecordPayment which will trigger the result defined by the following
// Then helper
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) When(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest]) *BillingServiceClientMockRecordPaymentExpectation {
	if mmRecordPayment.mock.funcRecordPayment != nil {
		mmRecordPayment.mock.t.Fatalf("BillingServiceClientMock.RecordPayment mock is already set by Set")
	}

	expectation := &BillingServiceClientMockRecordPaymentExpectation{
		mock:               mmRecordPayment.mock,
		params:             &BillingServiceClientMockRecordPaymentParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockRecordPaymentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRecordPayment.expectations = append(mmRecordPayment.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.RecordPayment return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockRecordPaymentExpectation) Then(pp2 *connect.Response[v1.RecordPaymentResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockRecordPaymentResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.RecordPayment should be invoked
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Times(n uint64) *mBillingServiceClientMockRecordPayment {
	if n == 0 {
		mmRecordPayment.mock.t.Fatalf("Times of BillingServiceClientMock.RecordPayment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRecordPayment.expectedInvocations, n)
	mmRecordPayment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRecordPayment
}

func (mmRecordPayment *mBillingServiceClientMockRecordPayment) invocationsDone() bool {
	if len(mmRecordPayment.expectations) == 0 && mmRecordPayment.defaultExpectation == nil && mmRecordPayment.mock.funcRecordPayment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRecordPayment.mock.afterRecordPaymentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRecordPayment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RecordPayment implements mm_billingv1connect.BillingServiceClient
func (mmRecordPayment *BillingServiceClientMock) RecordPayment(ctx context.Context, pp1 *connect.Request[v1.RecordPaymentRequest]) (pp2 *connect.Response[v1.RecordPaymentResponse], err error) {
	mm_atomic.AddUint64(&mmRecordPayment.beforeRecordPaymentCounter, 1)
	defer mm_atomic.AddUint64(&mmRecordPayment.afterRecordPaymentCounter, 1)

	mmRecordPayment.t.Helper()

	if mmRecordPayment.inspectFuncRecordPayment != nil {
		mmRecordPayment.inspectFuncRecordPayment(ctx, pp1)
	}

	mm_params := BillingServiceClientMockRecordPaymentParams{ctx, pp1}

	// Record call args
	mmRecordPayment.RecordPaymentMock.mutex.Lock()
	mmRecordPayment.RecordPaymentMock.callArgs = append(mmRecordPayment.RecordPaymentMock.callArgs, &mm_params)
	mmRecordPayment.RecordPaymentMock.mutex.Unlock()

	for _, e := range mmRecordPayment.RecordPaymentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRecordPayment.RecordPaymentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecordPayment.RecordPaymentMock.defaultExpectation.Counter, 1)
		mm_want := mmRecordPayment.RecordPaymentMock.defaultExpectation.params
		mm_want_ptrs := mmRecordPayment.RecordPaymentMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockRecordPaymentParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRecordPayment.t.Errorf("BillingServiceClientMock.RecordPayment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRecordPayment.RecordPaymentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRecordPayment.t.Errorf("BillingServiceClientMock.RecordPayment got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRecordPayment.RecordPaymentMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecordPayment.t.Errorf("BillingServiceClientMock.RecordPayment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRecordPayment.RecordPaymentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecordPayment.RecordPaymentMock.defaultExpectation.results
		if mm_results == nil {
			mmRecordPayment.t.Fatal("No results are set for the BillingServiceClientMock.RecordPayment")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRecordPayment.funcRecordPayment != nil {
		return mmRecordPayment.funcRecordPayment(ctx, pp1)
	}
	mmRecordPayment.t.Fatalf("Unexpected call to BillingServiceClientMock.RecordPayment. %v %v", ctx, pp1)
	return
}

// RecordPaymentAfterCounter returns a count of finished BillingServiceClientMock.RecordPayment invocations
func (mmRecordPayment *BillingServiceClientMock) RecordPaymentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordPayment.afterRecordPaymentCounter)
}

// RecordPaymentBeforeCounter returns a count of BillingServiceClientMock.RecordPayment invocations
func (mmRecordPayment *BillingServiceClientMock) RecordPaymentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecordPayment.beforeRecordPaymentCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.RecordPayment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecordPayment *mBillingServiceClientMockRecordPayment) Calls() []*BillingServiceClientMockRecordPaymentParams {
	mmRecordPayment.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockRecordPaymentParams, len(mmRecordPayment.callArgs))
	copy(argCopy, mmRecordPayment.callArgs)

	mmRecordPayment.mutex.RUnlock()

	return argCopy
}

// MinimockRecordPaymentDone returns true if the count of the RecordPayment invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockRecordPaymentDone() bool {
	if m.RecordPaymentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RecordPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RecordPaymentMock.invocationsDone()
}

// MinimockRecordPaymentInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockRecordPaymentInspect() {
	for _, e := range m.RecordPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.RecordPayment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRecordPaymentCounter := mm_atomic.LoadUint64(&m.afterRecordPaymentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RecordPaymentMock.defaultExpectation != nil && afterRecordPaymentCounter < 1 {
		if m.RecordPaymentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.RecordPayment at\n%s", m.RecordPaymentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.RecordPayment at\n%s with params: %#v", m.RecordPaymentMock.defaultExpectation.expectationOrigins.origin, *m.RecordPaymentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecordPayment != nil && afterRecordPaymentCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.RecordPayment at\n%s", m.funcRecordPaymentOrigin)
	}

	if !m.RecordPaymentMock.invocationsDone() && afterRecordPaymentCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.RecordPayment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RecordPaymentMock.expectedInvocations), m.RecordPaymentMock.expectedInvocationsOrigin, afterRecordPaymentCounter)
	}
}

type mBillingServiceClientMockRunBilling struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockRunBillingExpectation
	expectations       []*BillingServiceClientMockRunBillingExpectation

	callArgs []*BillingServiceClientMockRunBillingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockRunBillingExpectation specifies expectation struct of the BillingServiceClient.RunBilling
type BillingServiceClientMockRunBillingExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockRunBillingParams
	paramPtrs          *BillingServiceClientMockRunBillingParamPtrs
	expectationOrigins BillingServiceClientMockRunBillingExpectationOrigins
	results            *BillingServiceClientMockRunBillingResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockRunBillingParams contains parameters of the BillingServiceClient.RunBilling
type BillingServiceClientMockRunBillingParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RunBillingRequest]
}

// BillingServiceClientMockRunBillingParamPtrs contains pointers to parameters of the BillingServiceClient.RunBilling
type BillingServiceClientMockRunBillingParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RunBillingRequest]
}

// BillingServiceClientMockRunBillingResults contains results of the BillingServiceClient.RunBilling
type BillingServiceClientMockRunBillingResults struct {
	pp2 *connect.Response[v1.RunBillingResponse]
	err error
}

// BillingServiceClientMockRunBillingOrigins contains origins of expectations of the BillingServiceClient.RunBilling
type BillingServiceClientMockRunBillingExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRunBilling *mBillingServiceClientMockRunBilling) Optional() *mBillingServiceClientMockRunBilling {
	mmRunBilling.optional = true
	return mmRunBilling
}

// Expect sets up expected params for BillingServiceClient.RunBilling
func (mmRunBilling *mBillingServiceClientMockRunBilling) Expect(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest]) *mBillingServiceClientMockRunBilling {
	if mmRunBilling.mock.funcRunBilling != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Set")
	}

	if mmRunBilling.defaultExpectation == nil {
		mmRunBilling.defaultExpectation = &BillingServiceClientMockRunBillingExpectation{}
	}

	if mmRunBilling.defaultExpectation.paramPtrs != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by ExpectParams functions")
	}

	mmRunBilling.defaultExpectation.params = &BillingServiceClientMockRunBillingParams{ctx, pp1}
	mmRunBilling.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRunBilling.expectations {
		if minimock.Equal(e.params, mmRunBilling.defaultExpectation.params) {
			mmRunBilling.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunBilling.defaultExpectation.params)
		}
	}

	return mmRunBilling
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.RunBilling
func (mmRunBilling *mBillingServiceClientMockRunBilling) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockRunBilling {
	if mmRunBilling.mock.funcRunBilling != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Set")
	}

	if mmRunBilling.defaultExpectation == nil {
		mmRunBilling.defaultExpectation = &BillingServiceClientMockRunBillingExpectation{}
	}

	if mmRunBilling.defaultExpectation.params != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Expect")
	}

	if mmRunBilling.defaultExpectation.paramPtrs == nil {
		mmRunBilling.defaultExpectation.paramPtrs = &BillingServiceClientMockRunBillingParamPtrs{}
	}
	mmRunBilling.defaultExpectation.paramPtrs.ctx = &ctx
	mmRunBilling.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRunBilling
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.RunBilling
func (mmRunBilling *mBillingServiceClientMockRunBilling) ExpectPp1Param2(pp1 *connect.Request[v1.RunBillingRequest]) *mBillingServiceClientMockRunBilling {
	if mmRunBilling.mock.funcRunBilling != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Set")
	}

	if mmRunBilling.defaultExpectation == nil {
		mmRunBilling.defaultExpectation = &BillingServiceClientMockRunBillingExpectation{}
	}

	if mmRunBilling.defaultExpectation.params != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Expect")
	}

	if mmRunBilling.defaultExpectation.paramPtrs == nil {
		mmRunBilling.defaultExpectation.paramPtrs = &BillingServiceClientMockRunBillingParamPtrs{}
	}
	mmRunBilling.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRunBilling.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRunBilling
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.RunBilling
func (mmRunBilling *mBillingServiceClientMockRunBilling) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest])) *mBillingServiceClientMockRunBilling {
	if mmRunBilling.mock.inspectFuncRunBilling != nil {
		mmRunBilling.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.RunBilling")
	}

	mmRunBilling.mock.inspectFuncRunBilling = f

	return mmRunBilling
}

// Return sets up results that will be returned by BillingServiceClient.RunBilling
func (mmRunBilling *mBillingServiceClientMockRunBilling) Return(pp2 *connect.Response[v1.RunBillingResponse], err error) *BillingServiceClientMock {
	if mmRunBilling.mock.funcRunBilling != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Set")
	}

	if mmRunBilling.defaultExpectation == nil {
		mmRunBilling.defaultExpectation = &BillingServiceClientMockRunBillingExpectation{mock: mmRunBilling.mock}
	}
	mmRunBilling.defaultExpectation.results = &BillingServiceClientMockRunBillingResults{pp2, err}
	mmRunBilling.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRunBilling.mock
}

// Set uses given function f to mock the BillingServiceClient.RunBilling method
func (mmRunBilling *mBillingServiceClientMockRunBilling) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest]) (pp2 *connect.Response[v1.RunBillingResponse], err error)) *BillingServiceClientMock {
	if mmRunBilling.defaultExpectation != nil {
		mmRunBilling.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.RunBilling method")
	}

	if len(mmRunBilling.expectations) > 0 {
		mmRunBilling.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.RunBilling method")
	}

	mmRunBilling.mock.funcRunBilling = f
	mmRunBilling.mock.funcRunBillingOrigin = minimock.CallerInfo(1)
	return mmRunBilling.mock
}

// When sets expectation for the BillingServiceClient.RunBilling which will trigger the result defined by the following
// Then helper
func (mmRunBilling *mBillingServiceClientMockRunBilling) When(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest]) *BillingServiceClientMockRunBillingExpectation {
	if mmRunBilling.mock.funcRunBilling != nil {
		mmRunBilling.mock.t.Fatalf("BillingServiceClientMock.RunBilling mock is already set by Set")
	}

	expectation := &BillingServiceClientMockRunBillingExpectation{
		mock:               mmRunBilling.mock,
		params:             &BillingServiceClientMockRunBillingParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockRunBillingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRunBilling.expectations = append(mmRunBilling.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.RunBilling return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockRunBillingExpectation) Then(pp2 *connect.Response[v1.RunBillingResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockRunBillingResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.RunBilling should be invoked
func (mmRunBilling *mBillingServiceClientMockRunBilling) Times(n uint64) *mBillingServiceClientMockRunBilling {
	if n == 0 {
		mmRunBilling.mock.t.Fatalf("Times of BillingServiceClientMock.RunBilling mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRunBilling.expectedInvocations, n)
	mmRunBilling.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRunBilling
}

func (mmRunBilling *mBillingServiceClientMockRunBilling) invocationsDone() bool {
	if len(mmRunBilling.expectations) == 0 && mmRunBilling.defaultExpectation == nil && mmRunBilling.mock.funcRunBilling == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRunBilling.mock.afterRunBillingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRunBilling.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RunBilling implements mm_billingv1connect.BillingServiceClient
func (mmRunBilling *BillingServiceClientMock) RunBilling(ctx context.Context, pp1 *connect.Request[v1.RunBillingRequest]) (pp2 *connect.Response[v1.RunBillingResponse], err error) {
	mm_atomic.AddUint64(&mmRunBilling.beforeRunBillingCounter, 1)
	defer mm_atomic.AddUint64(&mmRunBilling.afterRunBillingCounter, 1)

	mmRunBilling.t.Helper()

	if mmRunBilling.inspectFuncRunBilling != nil {
		mmRunBilling.inspectFuncRunBilling(ctx, pp1)
	}

	mm_params := BillingServiceClientMockRunBillingParams{ctx, pp1}

	// Record call args
	mmRunBilling.RunBillingMock.mutex.Lock()
	mmRunBilling.RunBillingMock.callArgs = append(mmRunBilling.RunBillingMock.callArgs, &mm_params)
	mmRunBilling.RunBillingMock.mutex.Unlock()

	for _, e := range mmRunBilling.RunBillingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRunBilling.RunBillingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunBilling.RunBillingMock.defaultExpectation.Counter, 1)
		mm_want := mmRunBilling.RunBillingMock.defaultExpectation.params
		mm_want_ptrs := mmRunBilling.RunBillingMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockRunBillingParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRunBilling.t.Errorf("BillingServiceClientMock.RunBilling got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRunBilling.RunBillingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRunBilling.t.Errorf("BillingServiceClientMock.RunBilling got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRunBilling.RunBillingMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunBilling.t.Errorf("BillingServiceClientMock.RunBilling got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRunBilling.RunBillingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunBilling.RunBillingMock.defaultExpectation.results
		if mm_results == nil {
			mmRunBilling.t.Fatal("No results are set for the BillingServiceClientMock.RunBilling")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRunBilling.funcRunBilling != nil {
		return mmRunBilling.funcRunBilling(ctx, pp1)
	}
	mmRunBilling.t.Fatalf("Unexpected call to BillingServiceClientMock.RunBilling. %v %v", ctx, pp1)
	return
}

// RunBillingAfterCounter returns a count of finished BillingServiceClientMock.RunBilling invocations
func (mmRunBilling *BillingServiceClientMock) RunBillingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunBilling.afterRunBillingCounter)
}

// RunBillingBeforeCounter returns a count of BillingServiceClientMock.RunBilling invocations
func (mmRunBilling *BillingServiceClientMock) RunBillingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunBilling.beforeRunBillingCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.RunBilling.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunBilling *mBillingServiceClientMockRunBilling) Calls() []*BillingServiceClientMockRunBillingParams {
	mmRunBilling.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockRunBillingParams, len(mmRunBilling.callArgs))
	copy(argCopy, mmRunBilling.callArgs)

	mmRunBilling.mutex.RUnlock()

	return argCopy
}

// MinimockRunBillingDone returns true if the count of the RunBilling invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockRunBillingDone() bool {
	if m.RunBillingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RunBillingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RunBillingMock.invocationsDone()
}

// MinimockRunBillingInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockRunBillingInspect() {
	for _, e := range m.RunBillingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.RunBilling at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRunBillingCounter := mm_atomic.LoadUint64(&m.afterRunBillingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RunBillingMock.defaultExpectation != nil && afterRunBillingCounter < 1 {
		if m.RunBillingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.RunBilling at\n%s", m.RunBillingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.RunBilling at\n%s with params: %#v", m.RunBillingMock.defaultExpectation.expectationOrigins.origin, *m.RunBillingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunBilling != nil && afterRunBillingCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.RunBilling at\n%s", m.funcRunBillingOrigin)
	}

	if !m.RunBillingMock.invocationsDone() && afterRunBillingCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.RunBilling at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RunBillingMock.expectedInvocations), m.RunBillingMock.expectedInvocationsOrigin, afterRunBillingCounter)
	}
}

type mBillingServiceClientMockSearchCatalogVersions struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockSearchCatalogVersionsExpectation
	expectations       []*BillingServiceClientMockSearchCatalogVersionsExpectation

	callArgs []*BillingServiceClientMockSearchCatalogVersionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockSearchCatalogVersionsExpectation specifies expectation struct of the BillingServiceClient.SearchCatalogVersions
type BillingServiceClientMockSearchCatalogVersionsExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockSearchCatalogVersionsParams
	paramPtrs          *BillingServiceClientMockSearchCatalogVersionsParamPtrs
	expectationOrigins BillingServiceClientMockSearchCatalogVersionsExpectationOrigins
	results            *BillingServiceClientMockSearchCatalogVersionsResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockSearchCatalogVersionsParams contains parameters of the BillingServiceClient.SearchCatalogVersions
type BillingServiceClientMockSearchCatalogVersionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchCatalogVersionsParamPtrs contains pointers to parameters of the BillingServiceClient.SearchCatalogVersions
type BillingServiceClientMockSearchCatalogVersionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchCatalogVersionsResults contains results of the BillingServiceClient.SearchCatalogVersions
type BillingServiceClientMockSearchCatalogVersionsResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchCatalogVersionsResponse]
	err error
}

// BillingServiceClientMockSearchCatalogVersionsOrigins contains origins of expectations of the BillingServiceClient.SearchCatalogVersions
type BillingServiceClientMockSearchCatalogVersionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Optional() *mBillingServiceClientMockSearchCatalogVersions {
	mmSearchCatalogVersions.optional = true
	return mmSearchCatalogVersions
}

// Expect sets up expected params for BillingServiceClient.SearchCatalogVersions
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchCatalogVersions {
	if mmSearchCatalogVersions.mock.funcSearchCatalogVersions != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Set")
	}

	if mmSearchCatalogVersions.defaultExpectation == nil {
		mmSearchCatalogVersions.defaultExpectation = &BillingServiceClientMockSearchCatalogVersionsExpectation{}
	}

	if mmSearchCatalogVersions.defaultExpectation.paramPtrs != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by ExpectParams functions")
	}

	mmSearchCatalogVersions.defaultExpectation.params = &BillingServiceClientMockSearchCatalogVersionsParams{ctx, pp1}
	mmSearchCatalogVersions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchCatalogVersions.expectations {
		if minimock.Equal(e.params, mmSearchCatalogVersions.defaultExpectation.params) {
			mmSearchCatalogVersions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchCatalogVersions.defaultExpectation.params)
		}
	}

	return mmSearchCatalogVersions
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.SearchCatalogVersions
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockSearchCatalogVersions {
	if mmSearchCatalogVersions.mock.funcSearchCatalogVersions != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Set")
	}

	if mmSearchCatalogVersions.defaultExpectation == nil {
		mmSearchCatalogVersions.defaultExpectation = &BillingServiceClientMockSearchCatalogVersionsExpectation{}
	}

	if mmSearchCatalogVersions.defaultExpectation.params != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Expect")
	}

	if mmSearchCatalogVersions.defaultExpectation.paramPtrs == nil {
		mmSearchCatalogVersions.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchCatalogVersionsParamPtrs{}
	}
	mmSearchCatalogVersions.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchCatalogVersions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchCatalogVersions
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.SearchCatalogVersions
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchCatalogVersions {
	if mmSearchCatalogVersions.mock.funcSearchCatalogVersions != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Set")
	}

	if mmSearchCatalogVersions.defaultExpectation == nil {
		mmSearchCatalogVersions.defaultExpectation = &BillingServiceClientMockSearchCatalogVersionsExpectation{}
	}

	if mmSearchCatalogVersions.defaultExpectation.params != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Expect")
	}

	if mmSearchCatalogVersions.defaultExpectation.paramPtrs == nil {
		mmSearchCatalogVersions.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchCatalogVersionsParamPtrs{}
	}
	mmSearchCatalogVersions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchCatalogVersions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchCatalogVersions
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.SearchCatalogVersions
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mBillingServiceClientMockSearchCatalogVersions {
	if mmSearchCatalogVersions.mock.inspectFuncSearchCatalogVersions != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.SearchCatalogVersions")
	}

	mmSearchCatalogVersions.mock.inspectFuncSearchCatalogVersions = f

	return mmSearchCatalogVersions
}

// Return sets up results that will be returned by BillingServiceClient.SearchCatalogVersions
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Return(pp2 *connect.ServerStreamForClient[v1.SearchCatalogVersionsResponse], err error) *BillingServiceClientMock {
	if mmSearchCatalogVersions.mock.funcSearchCatalogVersions != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Set")
	}

	if mmSearchCatalogVersions.defaultExpectation == nil {
		mmSearchCatalogVersions.defaultExpectation = &BillingServiceClientMockSearchCatalogVersionsExpectation{mock: mmSearchCatalogVersions.mock}
	}
	mmSearchCatalogVersions.defaultExpectation.results = &BillingServiceClientMockSearchCatalogVersionsResults{pp2, err}
	mmSearchCatalogVersions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchCatalogVersions.mock
}

// Set uses given function f to mock the BillingServiceClient.SearchCatalogVersions method
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchCatalogVersionsResponse], err error)) *BillingServiceClientMock {
	if mmSearchCatalogVersions.defaultExpectation != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.SearchCatalogVersions method")
	}

	if len(mmSearchCatalogVersions.expectations) > 0 {
		mmSearchCatalogVersions.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.SearchCatalogVersions method")
	}

	mmSearchCatalogVersions.mock.funcSearchCatalogVersions = f
	mmSearchCatalogVersions.mock.funcSearchCatalogVersionsOrigin = minimock.CallerInfo(1)
	return mmSearchCatalogVersions.mock
}

// When sets expectation for the BillingServiceClient.SearchCatalogVersions which will trigger the result defined by the following
// Then helper
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *BillingServiceClientMockSearchCatalogVersionsExpectation {
	if mmSearchCatalogVersions.mock.funcSearchCatalogVersions != nil {
		mmSearchCatalogVersions.mock.t.Fatalf("BillingServiceClientMock.SearchCatalogVersions mock is already set by Set")
	}

	expectation := &BillingServiceClientMockSearchCatalogVersionsExpectation{
		mock:               mmSearchCatalogVersions.mock,
		params:             &BillingServiceClientMockSearchCatalogVersionsParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockSearchCatalogVersionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchCatalogVersions.expectations = append(mmSearchCatalogVersions.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.SearchCatalogVersions return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockSearchCatalogVersionsExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchCatalogVersionsResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockSearchCatalogVersionsResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.SearchCatalogVersions should be invoked
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Times(n uint64) *mBillingServiceClientMockSearchCatalogVersions {
	if n == 0 {
		mmSearchCatalogVersions.mock.t.Fatalf("Times of BillingServiceClientMock.SearchCatalogVersions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchCatalogVersions.expectedInvocations, n)
	mmSearchCatalogVersions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchCatalogVersions
}

func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) invocationsDone() bool {
	if len(mmSearchCatalogVersions.expectations) == 0 && mmSearchCatalogVersions.defaultExpectation == nil && mmSearchCatalogVersions.mock.funcSearchCatalogVersions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchCatalogVersions.mock.afterSearchCatalogVersionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchCatalogVersions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchCatalogVersions implements mm_billingv1connect.BillingServiceClient
func (mmSearchCatalogVersions *BillingServiceClientMock) SearchCatalogVersions(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchCatalogVersionsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchCatalogVersions.beforeSearchCatalogVersionsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchCatalogVersions.afterSearchCatalogVersionsCounter, 1)

	mmSearchCatalogVersions.t.Helper()

	if mmSearchCatalogVersions.inspectFuncSearchCatalogVersions != nil {
		mmSearchCatalogVersions.inspectFuncSearchCatalogVersions(ctx, pp1)
	}

	mm_params := BillingServiceClientMockSearchCatalogVersionsParams{ctx, pp1}

	// Record call args
	mmSearchCatalogVersions.SearchCatalogVersionsMock.mutex.Lock()
	mmSearchCatalogVersions.SearchCatalogVersionsMock.callArgs = append(mmSearchCatalogVersions.SearchCatalogVersionsMock.callArgs, &mm_params)
	mmSearchCatalogVersions.SearchCatalogVersionsMock.mutex.Unlock()

	for _, e := range mmSearchCatalogVersions.SearchCatalogVersionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockSearchCatalogVersionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchCatalogVersions.t.Errorf("BillingServiceClientMock.SearchCatalogVersions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchCatalogVersions.t.Errorf("BillingServiceClientMock.SearchCatalogVersions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchCatalogVersions.t.Errorf("BillingServiceClientMock.SearchCatalogVersions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchCatalogVersions.SearchCatalogVersionsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchCatalogVersions.t.Fatal("No results are set for the BillingServiceClientMock.SearchCatalogVersions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchCatalogVersions.funcSearchCatalogVersions != nil {
		return mmSearchCatalogVersions.funcSearchCatalogVersions(ctx, pp1)
	}
	mmSearchCatalogVersions.t.Fatalf("Unexpected call to BillingServiceClientMock.SearchCatalogVersions. %v %v", ctx, pp1)
	return
}

// SearchCatalogVersionsAfterCounter returns a count of finished BillingServiceClientMock.SearchCatalogVersions invocations
func (mmSearchCatalogVersions *BillingServiceClientMock) SearchCatalogVersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchCatalogVersions.afterSearchCatalogVersionsCounter)
}

// SearchCatalogVersionsBeforeCounter returns a count of BillingServiceClientMock.SearchCatalogVersions invocations
func (mmSearchCatalogVersions *BillingServiceClientMock) SearchCatalogVersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchCatalogVersions.beforeSearchCatalogVersionsCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.SearchCatalogVersions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchCatalogVersions *mBillingServiceClientMockSearchCatalogVersions) Calls() []*BillingServiceClientMockSearchCatalogVersionsParams {
	mmSearchCatalogVersions.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockSearchCatalogVersionsParams, len(mmSearchCatalogVersions.callArgs))
	copy(argCopy, mmSearchCatalogVersions.callArgs)

	mmSearchCatalogVersions.mutex.RUnlock()

	return argCopy
}

// MinimockSearchCatalogVersionsDone returns true if the count of the SearchCatalogVersions invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockSearchCatalogVersionsDone() bool {
	if m.SearchCatalogVersionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchCatalogVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchCatalogVersionsMock.invocationsDone()
}

// MinimockSearchCatalogVersionsInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockSearchCatalogVersionsInspect() {
	for _, e := range m.SearchCatalogVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchCatalogVersions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCatalogVersionsCounter := mm_atomic.LoadUint64(&m.afterSearchCatalogVersionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchCatalogVersionsMock.defaultExpectation != nil && afterSearchCatalogVersionsCounter < 1 {
		if m.SearchCatalogVersionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchCatalogVersions at\n%s", m.SearchCatalogVersionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchCatalogVersions at\n%s with params: %#v", m.SearchCatalogVersionsMock.defaultExpectation.expectationOrigins.origin, *m.SearchCatalogVersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchCatalogVersions != nil && afterSearchCatalogVersionsCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.SearchCatalogVersions at\n%s", m.funcSearchCatalogVersionsOrigin)
	}

	if !m.SearchCatalogVersionsMock.invocationsDone() && afterSearchCatalogVersionsCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.SearchCatalogVersions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchCatalogVersionsMock.expectedInvocations), m.SearchCatalogVersionsMock.expectedInvocationsOrigin, afterSearchCatalogVersionsCounter)
	}
}

type mBillingServiceClientMockSearchDiscounts struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockSearchDiscountsExpectation
	expectations       []*BillingServiceClientMockSearchDiscountsExpectation

	callArgs []*BillingServiceClientMockSearchDiscountsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockSearchDiscountsExpectation specifies expectation struct of the BillingServiceClient.SearchDiscounts
type BillingServiceClientMockSearchDiscountsExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockSearchDiscountsParams
	paramPtrs          *BillingServiceClientMockSearchDiscountsParamPtrs
	expectationOrigins BillingServiceClientMockSearchDiscountsExpectationOrigins
	results            *BillingServiceClientMockSearchDiscountsResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockSearchDiscountsParams contains parameters of the BillingServiceClient.SearchDiscounts
type BillingServiceClientMockSearchDiscountsParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchDiscountsParamPtrs contains pointers to parameters of the BillingServiceClient.SearchDiscounts
type BillingServiceClientMockSearchDiscountsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchDiscountsResults contains results of the BillingServiceClient.SearchDiscounts
type BillingServiceClientMockSearchDiscountsResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchDiscountsResponse]
	err error
}

// BillingServiceClientMockSearchDiscountsOrigins contains origins of expectations of the BillingServiceClient.SearchDiscounts
type BillingServiceClientMockSearchDiscountsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Optional() *mBillingServiceClientMockSearchDiscounts {
	mmSearchDiscounts.optional = true
	return mmSearchDiscounts
}

// Expect sets up expected params for BillingServiceClient.SearchDiscounts
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchDiscounts {
	if mmSearchDiscounts.mock.funcSearchDiscounts != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Set")
	}

	if mmSearchDiscounts.defaultExpectation == nil {
		mmSearchDiscounts.defaultExpectation = &BillingServiceClientMockSearchDiscountsExpectation{}
	}

	if mmSearchDiscounts.defaultExpectation.paramPtrs != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by ExpectParams functions")
	}

	mmSearchDiscounts.defaultExpectation.params = &BillingServiceClientMockSearchDiscountsParams{ctx, pp1}
	mmSearchDiscounts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchDiscounts.expectations {
		if minimock.Equal(e.params, mmSearchDiscounts.defaultExpectation.params) {
			mmSearchDiscounts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchDiscounts.defaultExpectation.params)
		}
	}

	return mmSearchDiscounts
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.SearchDiscounts
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockSearchDiscounts {
	if mmSearchDiscounts.mock.funcSearchDiscounts != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Set")
	}

	if mmSearchDiscounts.defaultExpectation == nil {
		mmSearchDiscounts.defaultExpectation = &BillingServiceClientMockSearchDiscountsExpectation{}
	}

	if mmSearchDiscounts.defaultExpectation.params != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Expect")
	}

	if mmSearchDiscounts.defaultExpectation.paramPtrs == nil {
		mmSearchDiscounts.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchDiscountsParamPtrs{}
	}
	mmSearchDiscounts.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchDiscounts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchDiscounts
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.SearchDiscounts
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchDiscounts {
	if mmSearchDiscounts.mock.funcSearchDiscounts != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Set")
	}

	if mmSearchDiscounts.defaultExpectation == nil {
		mmSearchDiscounts.defaultExpectation = &BillingServiceClientMockSearchDiscountsExpectation{}
	}

	if mmSearchDiscounts.defaultExpectation.params != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Expect")
	}

	if mmSearchDiscounts.defaultExpectation.paramPtrs == nil {
		mmSearchDiscounts.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchDiscountsParamPtrs{}
	}
	mmSearchDiscounts.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchDiscounts.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchDiscounts
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.SearchDiscounts
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mBillingServiceClientMockSearchDiscounts {
	if mmSearchDiscounts.mock.inspectFuncSearchDiscounts != nil {
		mmSearchDiscounts.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.SearchDiscounts")
	}

	mmSearchDiscounts.mock.inspectFuncSearchDiscounts = f

	return mmSearchDiscounts
}

// Return sets up results that will be returned by BillingServiceClient.SearchDiscounts
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Return(pp2 *connect.ServerStreamForClient[v1.SearchDiscountsResponse], err error) *BillingServiceClientMock {
	if mmSearchDiscounts.mock.funcSearchDiscounts != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Set")
	}

	if mmSearchDiscounts.defaultExpectation == nil {
		mmSearchDiscounts.defaultExpectation = &BillingServiceClientMockSearchDiscountsExpectation{mock: mmSearchDiscounts.mock}
	}
	mmSearchDiscounts.defaultExpectation.results = &BillingServiceClientMockSearchDiscountsResults{pp2, err}
	mmSearchDiscounts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchDiscounts.mock
}

// Set uses given function f to mock the BillingServiceClient.SearchDiscounts method
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchDiscountsResponse], err error)) *BillingServiceClientMock {
	if mmSearchDiscounts.defaultExpectation != nil {
		mmSearchDiscounts.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.SearchDiscounts method")
	}

	if len(mmSearchDiscounts.expectations) > 0 {
		mmSearchDiscounts.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.SearchDiscounts method")
	}

	mmSearchDiscounts.mock.funcSearchDiscounts = f
	mmSearchDiscounts.mock.funcSearchDiscountsOrigin = minimock.CallerInfo(1)
	return mmSearchDiscounts.mock
}

// When sets expectation for the BillingServiceClient.SearchDiscounts which will trigger the result defined by the following
// Then helper
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *BillingServiceClientMockSearchDiscountsExpectation {
	if mmSearchDiscounts.mock.funcSearchDiscounts != nil {
		mmSearchDiscounts.mock.t.Fatalf("BillingServiceClientMock.SearchDiscounts mock is already set by Set")
	}

	expectation := &BillingServiceClientMockSearchDiscountsExpectation{
		mock:               mmSearchDiscounts.mock,
		params:             &BillingServiceClientMockSearchDiscountsParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockSearchDiscountsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchDiscounts.expectations = append(mmSearchDiscounts.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.SearchDiscounts return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockSearchDiscountsExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchDiscountsResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockSearchDiscountsResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.SearchDiscounts should be invoked
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Times(n uint64) *mBillingServiceClientMockSearchDiscounts {
	if n == 0 {
		mmSearchDiscounts.mock.t.Fatalf("Times of BillingServiceClientMock.SearchDiscounts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchDiscounts.expectedInvocations, n)
	mmSearchDiscounts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchDiscounts
}

func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) invocationsDone() bool {
	if len(mmSearchDiscounts.expectations) == 0 && mmSearchDiscounts.defaultExpectation == nil && mmSearchDiscounts.mock.funcSearchDiscounts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchDiscounts.mock.afterSearchDiscountsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchDiscounts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchDiscounts implements mm_billingv1connect.BillingServiceClient
func (mmSearchDiscounts *BillingServiceClientMock) SearchDiscounts(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchDiscountsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchDiscounts.beforeSearchDiscountsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchDiscounts.afterSearchDiscountsCounter, 1)

	mmSearchDiscounts.t.Helper()

	if mmSearchDiscounts.inspectFuncSearchDiscounts != nil {
		mmSearchDiscounts.inspectFuncSearchDiscounts(ctx, pp1)
	}

	mm_params := BillingServiceClientMockSearchDiscountsParams{ctx, pp1}

	// Record call args
	mmSearchDiscounts.SearchDiscountsMock.mutex.Lock()
	mmSearchDiscounts.SearchDiscountsMock.callArgs = append(mmSearchDiscounts.SearchDiscountsMock.callArgs, &mm_params)
	mmSearchDiscounts.SearchDiscountsMock.mutex.Unlock()

	for _, e := range mmSearchDiscounts.SearchDiscountsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchDiscounts.SearchDiscountsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockSearchDiscountsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchDiscounts.t.Errorf("BillingServiceClientMock.SearchDiscounts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchDiscounts.t.Errorf("BillingServiceClientMock.SearchDiscounts got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchDiscounts.t.Errorf("BillingServiceClientMock.SearchDiscounts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchDiscounts.SearchDiscountsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchDiscounts.t.Fatal("No results are set for the BillingServiceClientMock.SearchDiscounts")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchDiscounts.funcSearchDiscounts != nil {
		return mmSearchDiscounts.funcSearchDiscounts(ctx, pp1)
	}
	mmSearchDiscounts.t.Fatalf("Unexpected call to BillingServiceClientMock.SearchDiscounts. %v %v", ctx, pp1)
	return
}

// SearchDiscountsAfterCounter returns a count of finished BillingServiceClientMock.SearchDiscounts invocations
func (mmSearchDiscounts *BillingServiceClientMock) SearchDiscountsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchDiscounts.afterSearchDiscountsCounter)
}

// SearchDiscountsBeforeCounter returns a count of BillingServiceClientMock.SearchDiscounts invocations
func (mmSearchDiscounts *BillingServiceClientMock) SearchDiscountsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchDiscounts.beforeSearchDiscountsCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.SearchDiscounts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchDiscounts *mBillingServiceClientMockSearchDiscounts) Calls() []*BillingServiceClientMockSearchDiscountsParams {
	mmSearchDiscounts.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockSearchDiscountsParams, len(mmSearchDiscounts.callArgs))
	copy(argCopy, mmSearchDiscounts.callArgs)

	mmSearchDiscounts.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDiscountsDone returns true if the count of the SearchDiscounts invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockSearchDiscountsDone() bool {
	if m.SearchDiscountsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchDiscountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchDiscountsMock.invocationsDone()
}

// MinimockSearchDiscountsInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockSearchDiscountsInspect() {
	for _, e := range m.SearchDiscountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchDiscounts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchDiscountsCounter := mm_atomic.LoadUint64(&m.afterSearchDiscountsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchDiscountsMock.defaultExpectation != nil && afterSearchDiscountsCounter < 1 {
		if m.SearchDiscountsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchDiscounts at\n%s", m.SearchDiscountsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchDiscounts at\n%s with params: %#v", m.SearchDiscountsMock.defaultExpectation.expectationOrigins.origin, *m.SearchDiscountsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchDiscounts != nil && afterSearchDiscountsCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.SearchDiscounts at\n%s", m.funcSearchDiscountsOrigin)
	}

	if !m.SearchDiscountsMock.invocationsDone() && afterSearchDiscountsCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.SearchDiscounts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchDiscountsMock.expectedInvocations), m.SearchDiscountsMock.expectedInvocationsOrigin, afterSearchDiscountsCounter)
	}
}

type mBillingServiceClientMockSearchInvoices struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockSearchInvoicesExpectation
	expectations       []*BillingServiceClientMockSearchInvoicesExpectation

	callArgs []*BillingServiceClientMockSearchInvoicesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockSearchInvoicesExpectation specifies expectation struct of the BillingServiceClient.SearchInvoices
type BillingServiceClientMockSearchInvoicesExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockSearchInvoicesParams
	paramPtrs          *BillingServiceClientMockSearchInvoicesParamPtrs
	expectationOrigins BillingServiceClientMockSearchInvoicesExpectationOrigins
	results            *BillingServiceClientMockSearchInvoicesResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockSearchInvoicesParams contains parameters of the BillingServiceClient.SearchInvoices
type BillingServiceClientMockSearchInvoicesParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchInvoicesParamPtrs contains pointers to parameters of the BillingServiceClient.SearchInvoices
type BillingServiceClientMockSearchInvoicesParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchInvoicesResults contains results of the BillingServiceClient.SearchInvoices
type BillingServiceClientMockSearchInvoicesResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchInvoicesResponse]
	err error
}

// BillingServiceClientMockSearchInvoicesOrigins contains origins of expectations of the BillingServiceClient.SearchInvoices
type BillingServiceClientMockSearchInvoicesExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Optional() *mBillingServiceClientMockSearchInvoices {
	mmSearchInvoices.optional = true
	return mmSearchInvoices
}

// Expect sets up expected params for BillingServiceClient.SearchInvoices
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchInvoices {
	if mmSearchInvoices.mock.funcSearchInvoices != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Set")
	}

	if mmSearchInvoices.defaultExpectation == nil {
		mmSearchInvoices.defaultExpectation = &BillingServiceClientMockSearchInvoicesExpectation{}
	}

	if mmSearchInvoices.defaultExpectation.paramPtrs != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by ExpectParams functions")
	}

	mmSearchInvoices.defaultExpectation.params = &BillingServiceClientMockSearchInvoicesParams{ctx, pp1}
	mmSearchInvoices.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchInvoices.expectations {
		if minimock.Equal(e.params, mmSearchInvoices.defaultExpectation.params) {
			mmSearchInvoices.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchInvoices.defaultExpectation.params)
		}
	}

	return mmSearchInvoices
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.SearchInvoices
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockSearchInvoices {
	if mmSearchInvoices.mock.funcSearchInvoices != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Set")
	}

	if mmSearchInvoices.defaultExpectation == nil {
		mmSearchInvoices.defaultExpectation = &BillingServiceClientMockSearchInvoicesExpectation{}
	}

	if mmSearchInvoices.defaultExpectation.params != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Expect")
	}

	if mmSearchInvoices.defaultExpectation.paramPtrs == nil {
		mmSearchInvoices.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchInvoicesParamPtrs{}
	}
	mmSearchInvoices.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchInvoices.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchInvoices
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.SearchInvoices
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchInvoices {
	if mmSearchInvoices.mock.funcSearchInvoices != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Set")
	}

	if mmSearchInvoices.defaultExpectation == nil {
		mmSearchInvoices.defaultExpectation = &BillingServiceClientMockSearchInvoicesExpectation{}
	}

	if mmSearchInvoices.defaultExpectation.params != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Expect")
	}

	if mmSearchInvoices.defaultExpectation.paramPtrs == nil {
		mmSearchInvoices.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchInvoicesParamPtrs{}
	}
	mmSearchInvoices.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchInvoices.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchInvoices
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.SearchInvoices
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mBillingServiceClientMockSearchInvoices {
	if mmSearchInvoices.mock.inspectFuncSearchInvoices != nil {
		mmSearchInvoices.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.SearchInvoices")
	}

	mmSearchInvoices.mock.inspectFuncSearchInvoices = f

	return mmSearchInvoices
}

// Return sets up results that will be returned by BillingServiceClient.SearchInvoices
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Return(pp2 *connect.ServerStreamForClient[v1.SearchInvoicesResponse], err error) *BillingServiceClientMock {
	if mmSearchInvoices.mock.funcSearchInvoices != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Set")
	}

	if mmSearchInvoices.defaultExpectation == nil {
		mmSearchInvoices.defaultExpectation = &BillingServiceClientMockSearchInvoicesExpectation{mock: mmSearchInvoices.mock}
	}
	mmSearchInvoices.defaultExpectation.results = &BillingServiceClientMockSearchInvoicesResults{pp2, err}
	mmSearchInvoices.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchInvoices.mock
}

// Set uses given function f to mock the BillingServiceClient.SearchInvoices method
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchInvoicesResponse], err error)) *BillingServiceClientMock {
	if mmSearchInvoices.defaultExpectation != nil {
		mmSearchInvoices.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.SearchInvoices method")
	}

	if len(mmSearchInvoices.expectations) > 0 {
		mmSearchInvoices.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.SearchInvoices method")
	}

	mmSearchInvoices.mock.funcSearchInvoices = f
	mmSearchInvoices.mock.funcSearchInvoicesOrigin = minimock.CallerInfo(1)
	return mmSearchInvoices.mock
}

// When sets expectation for the BillingServiceClient.SearchInvoices which will trigger the result defined by the following
// Then helper
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *BillingServiceClientMockSearchInvoicesExpectation {
	if mmSearchInvoices.mock.funcSearchInvoices != nil {
		mmSearchInvoices.mock.t.Fatalf("BillingServiceClientMock.SearchInvoices mock is already set by Set")
	}

	expectation := &BillingServiceClientMockSearchInvoicesExpectation{
		mock:               mmSearchInvoices.mock,
		params:             &BillingServiceClientMockSearchInvoicesParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockSearchInvoicesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchInvoices.expectations = append(mmSearchInvoices.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.SearchInvoices return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockSearchInvoicesExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchInvoicesResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockSearchInvoicesResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.SearchInvoices should be invoked
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Times(n uint64) *mBillingServiceClientMockSearchInvoices {
	if n == 0 {
		mmSearchInvoices.mock.t.Fatalf("Times of BillingServiceClientMock.SearchInvoices mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchInvoices.expectedInvocations, n)
	mmSearchInvoices.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchInvoices
}

func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) invocationsDone() bool {
	if len(mmSearchInvoices.expectations) == 0 && mmSearchInvoices.defaultExpectation == nil && mmSearchInvoices.mock.funcSearchInvoices == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchInvoices.mock.afterSearchInvoicesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchInvoices.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchInvoices implements mm_billingv1connect.BillingServiceClient
func (mmSearchInvoices *BillingServiceClientMock) SearchInvoices(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchInvoicesResponse], err error) {
	mm_atomic.AddUint64(&mmSearchInvoices.beforeSearchInvoicesCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchInvoices.afterSearchInvoicesCounter, 1)

	mmSearchInvoices.t.Helper()

	if mmSearchInvoices.inspectFuncSearchInvoices != nil {
		mmSearchInvoices.inspectFuncSearchInvoices(ctx, pp1)
	}

	mm_params := BillingServiceClientMockSearchInvoicesParams{ctx, pp1}

	// Record call args
	mmSearchInvoices.SearchInvoicesMock.mutex.Lock()
	mmSearchInvoices.SearchInvoicesMock.callArgs = append(mmSearchInvoices.SearchInvoicesMock.callArgs, &mm_params)
	mmSearchInvoices.SearchInvoicesMock.mutex.Unlock()

	for _, e := range mmSearchInvoices.SearchInvoicesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchInvoices.SearchInvoicesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchInvoices.SearchInvoicesMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchInvoices.SearchInvoicesMock.defaultExpectation.params
		mm_want_ptrs := mmSearchInvoices.SearchInvoicesMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockSearchInvoicesParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchInvoices.t.Errorf("BillingServiceClientMock.SearchInvoices got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchInvoices.SearchInvoicesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchInvoices.t.Errorf("BillingServiceClientMock.SearchInvoices got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchInvoices.SearchInvoicesMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchInvoices.t.Errorf("BillingServiceClientMock.SearchInvoices got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchInvoices.SearchInvoicesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchInvoices.SearchInvoicesMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchInvoices.t.Fatal("No results are set for the BillingServiceClientMock.SearchInvoices")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchInvoices.funcSearchInvoices != nil {
		return mmSearchInvoices.funcSearchInvoices(ctx, pp1)
	}
	mmSearchInvoices.t.Fatalf("Unexpected call to BillingServiceClientMock.SearchInvoices. %v %v", ctx, pp1)
	return
}

// SearchInvoicesAfterCounter returns a count of finished BillingServiceClientMock.SearchInvoices invocations
func (mmSearchInvoices *BillingServiceClientMock) SearchInvoicesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchInvoices.afterSearchInvoicesCounter)
}

// SearchInvoicesBeforeCounter returns a count of BillingServiceClientMock.SearchInvoices invocations
func (mmSearchInvoices *BillingServiceClientMock) SearchInvoicesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchInvoices.beforeSearchInvoicesCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.SearchInvoices.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchInvoices *mBillingServiceClientMockSearchInvoices) Calls() []*BillingServiceClientMockSearchInvoicesParams {
	mmSearchInvoices.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockSearchInvoicesParams, len(mmSearchInvoices.callArgs))
	copy(argCopy, mmSearchInvoices.callArgs)

	mmSearchInvoices.mutex.RUnlock()

	return argCopy
}

// MinimockSearchInvoicesDone returns true if the count of the SearchInvoices invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockSearchInvoicesDone() bool {
	if m.SearchInvoicesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchInvoicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchInvoicesMock.invocationsDone()
}

// MinimockSearchInvoicesInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockSearchInvoicesInspect() {
	for _, e := range m.SearchInvoicesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchInvoices at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchInvoicesCounter := mm_atomic.LoadUint64(&m.afterSearchInvoicesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchInvoicesMock.defaultExpectation != nil && afterSearchInvoicesCounter < 1 {
		if m.SearchInvoicesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchInvoices at\n%s", m.SearchInvoicesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchInvoices at\n%s with params: %#v", m.SearchInvoicesMock.defaultExpectation.expectationOrigins.origin, *m.SearchInvoicesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchInvoices != nil && afterSearchInvoicesCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.SearchInvoices at\n%s", m.funcSearchInvoicesOrigin)
	}

	if !m.SearchInvoicesMock.invocationsDone() && afterSearchInvoicesCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.SearchInvoices at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchInvoicesMock.expectedInvocations), m.SearchInvoicesMock.expectedInvocationsOrigin, afterSearchInvoicesCounter)
	}
}

type mBillingServiceClientMockSearchUsageEvents struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockSearchUsageEventsExpectation
	expectations       []*BillingServiceClientMockSearchUsageEventsExpectation

	callArgs []*BillingServiceClientMockSearchUsageEventsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockSearchUsageEventsExpectation specifies expectation struct of the BillingServiceClient.SearchUsageEvents
type BillingServiceClientMockSearchUsageEventsExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockSearchUsageEventsParams
	paramPtrs          *BillingServiceClientMockSearchUsageEventsParamPtrs
	expectationOrigins BillingServiceClientMockSearchUsageEventsExpectationOrigins
	results            *BillingServiceClientMockSearchUsageEventsResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockSearchUsageEventsParams contains parameters of the BillingServiceClient.SearchUsageEvents
type BillingServiceClientMockSearchUsageEventsParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchUsageEventsParamPtrs contains pointers to parameters of the BillingServiceClient.SearchUsageEvents
type BillingServiceClientMockSearchUsageEventsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// BillingServiceClientMockSearchUsageEventsResults contains results of the BillingServiceClient.SearchUsageEvents
type BillingServiceClientMockSearchUsageEventsResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchUsageEventsResponse]
	err error
}

// BillingServiceClientMockSearchUsageEventsOrigins contains origins of expectations of the BillingServiceClient.SearchUsageEvents
type BillingServiceClientMockSearchUsageEventsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Optional() *mBillingServiceClientMockSearchUsageEvents {
	mmSearchUsageEvents.optional = true
	return mmSearchUsageEvents
}

// Expect sets up expected params for BillingServiceClient.SearchUsageEvents
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchUsageEvents {
	if mmSearchUsageEvents.mock.funcSearchUsageEvents != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Set")
	}

	if mmSearchUsageEvents.defaultExpectation == nil {
		mmSearchUsageEvents.defaultExpectation = &BillingServiceClientMockSearchUsageEventsExpectation{}
	}

	if mmSearchUsageEvents.defaultExpectation.paramPtrs != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by ExpectParams functions")
	}

	mmSearchUsageEvents.defaultExpectation.params = &BillingServiceClientMockSearchUsageEventsParams{ctx, pp1}
	mmSearchUsageEvents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchUsageEvents.expectations {
		if minimock.Equal(e.params, mmSearchUsageEvents.defaultExpectation.params) {
			mmSearchUsageEvents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchUsageEvents.defaultExpectation.params)
		}
	}

	return mmSearchUsageEvents
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.SearchUsageEvents
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockSearchUsageEvents {
	if mmSearchUsageEvents.mock.funcSearchUsageEvents != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Set")
	}

	if mmSearchUsageEvents.defaultExpectation == nil {
		mmSearchUsageEvents.defaultExpectation = &BillingServiceClientMockSearchUsageEventsExpectation{}
	}

	if mmSearchUsageEvents.defaultExpectation.params != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Expect")
	}

	if mmSearchUsageEvents.defaultExpectation.paramPtrs == nil {
		mmSearchUsageEvents.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchUsageEventsParamPtrs{}
	}
	mmSearchUsageEvents.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchUsageEvents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchUsageEvents
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.SearchUsageEvents
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mBillingServiceClientMockSearchUsageEvents {
	if mmSearchUsageEvents.mock.funcSearchUsageEvents != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Set")
	}

	if mmSearchUsageEvents.defaultExpectation == nil {
		mmSearchUsageEvents.defaultExpectation = &BillingServiceClientMockSearchUsageEventsExpectation{}
	}

	if mmSearchUsageEvents.defaultExpectation.params != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Expect")
	}

	if mmSearchUsageEvents.defaultExpectation.paramPtrs == nil {
		mmSearchUsageEvents.defaultExpectation.paramPtrs = &BillingServiceClientMockSearchUsageEventsParamPtrs{}
	}
	mmSearchUsageEvents.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchUsageEvents.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchUsageEvents
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.SearchUsageEvents
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mBillingServiceClientMockSearchUsageEvents {
	if mmSearchUsageEvents.mock.inspectFuncSearchUsageEvents != nil {
		mmSearchUsageEvents.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.SearchUsageEvents")
	}

	mmSearchUsageEvents.mock.inspectFuncSearchUsageEvents = f

	return mmSearchUsageEvents
}

// Return sets up results that will be returned by BillingServiceClient.SearchUsageEvents
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Return(pp2 *connect.ServerStreamForClient[v1.SearchUsageEventsResponse], err error) *BillingServiceClientMock {
	if mmSearchUsageEvents.mock.funcSearchUsageEvents != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Set")
	}

	if mmSearchUsageEvents.defaultExpectation == nil {
		mmSearchUsageEvents.defaultExpectation = &BillingServiceClientMockSearchUsageEventsExpectation{mock: mmSearchUsageEvents.mock}
	}
	mmSearchUsageEvents.defaultExpectation.results = &BillingServiceClientMockSearchUsageEventsResults{pp2, err}
	mmSearchUsageEvents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchUsageEvents.mock
}

// Set uses given function f to mock the BillingServiceClient.SearchUsageEvents method
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchUsageEventsResponse], err error)) *BillingServiceClientMock {
	if mmSearchUsageEvents.defaultExpectation != nil {
		mmSearchUsageEvents.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.SearchUsageEvents method")
	}

	if len(mmSearchUsageEvents.expectations) > 0 {
		mmSearchUsageEvents.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.SearchUsageEvents method")
	}

	mmSearchUsageEvents.mock.funcSearchUsageEvents = f
	mmSearchUsageEvents.mock.funcSearchUsageEventsOrigin = minimock.CallerInfo(1)
	return mmSearchUsageEvents.mock
}

// When sets expectation for the BillingServiceClient.SearchUsageEvents which will trigger the result defined by the following
// Then helper
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *BillingServiceClientMockSearchUsageEventsExpectation {
	if mmSearchUsageEvents.mock.funcSearchUsageEvents != nil {
		mmSearchUsageEvents.mock.t.Fatalf("BillingServiceClientMock.SearchUsageEvents mock is already set by Set")
	}

	expectation := &BillingServiceClientMockSearchUsageEventsExpectation{
		mock:               mmSearchUsageEvents.mock,
		params:             &BillingServiceClientMockSearchUsageEventsParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockSearchUsageEventsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchUsageEvents.expectations = append(mmSearchUsageEvents.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.SearchUsageEvents return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockSearchUsageEventsExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchUsageEventsResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockSearchUsageEventsResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.SearchUsageEvents should be invoked
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Times(n uint64) *mBillingServiceClientMockSearchUsageEvents {
	if n == 0 {
		mmSearchUsageEvents.mock.t.Fatalf("Times of BillingServiceClientMock.SearchUsageEvents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchUsageEvents.expectedInvocations, n)
	mmSearchUsageEvents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchUsageEvents
}

func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) invocationsDone() bool {
	if len(mmSearchUsageEvents.expectations) == 0 && mmSearchUsageEvents.defaultExpectation == nil && mmSearchUsageEvents.mock.funcSearchUsageEvents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchUsageEvents.mock.afterSearchUsageEventsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchUsageEvents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchUsageEvents implements mm_billingv1connect.BillingServiceClient
func (mmSearchUsageEvents *BillingServiceClientMock) SearchUsageEvents(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchUsageEventsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchUsageEvents.beforeSearchUsageEventsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchUsageEvents.afterSearchUsageEventsCounter, 1)

	mmSearchUsageEvents.t.Helper()

	if mmSearchUsageEvents.inspectFuncSearchUsageEvents != nil {
		mmSearchUsageEvents.inspectFuncSearchUsageEvents(ctx, pp1)
	}

	mm_params := BillingServiceClientMockSearchUsageEventsParams{ctx, pp1}

	// Record call args
	mmSearchUsageEvents.SearchUsageEventsMock.mutex.Lock()
	mmSearchUsageEvents.SearchUsageEventsMock.callArgs = append(mmSearchUsageEvents.SearchUsageEventsMock.callArgs, &mm_params)
	mmSearchUsageEvents.SearchUsageEventsMock.mutex.Unlock()

	for _, e := range mmSearchUsageEvents.SearchUsageEventsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockSearchUsageEventsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchUsageEvents.t.Errorf("BillingServiceClientMock.SearchUsageEvents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchUsageEvents.t.Errorf("BillingServiceClientMock.SearchUsageEvents got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchUsageEvents.t.Errorf("BillingServiceClientMock.SearchUsageEvents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchUsageEvents.SearchUsageEventsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchUsageEvents.t.Fatal("No results are set for the BillingServiceClientMock.SearchUsageEvents")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchUsageEvents.funcSearchUsageEvents != nil {
		return mmSearchUsageEvents.funcSearchUsageEvents(ctx, pp1)
	}
	mmSearchUsageEvents.t.Fatalf("Unexpected call to BillingServiceClientMock.SearchUsageEvents. %v %v", ctx, pp1)
	return
}

// SearchUsageEventsAfterCounter returns a count of finished BillingServiceClientMock.SearchUsageEvents invocations
func (mmSearchUsageEvents *BillingServiceClientMock) SearchUsageEventsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchUsageEvents.afterSearchUsageEventsCounter)
}

// SearchUsageEventsBeforeCounter returns a count of BillingServiceClientMock.SearchUsageEvents invocations
func (mmSearchUsageEvents *BillingServiceClientMock) SearchUsageEventsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchUsageEvents.beforeSearchUsageEventsCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.SearchUsageEvents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchUsageEvents *mBillingServiceClientMockSearchUsageEvents) Calls() []*BillingServiceClientMockSearchUsageEventsParams {
	mmSearchUsageEvents.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockSearchUsageEventsParams, len(mmSearchUsageEvents.callArgs))
	copy(argCopy, mmSearchUsageEvents.callArgs)

	mmSearchUsageEvents.mutex.RUnlock()

	return argCopy
}

// MinimockSearchUsageEventsDone returns true if the count of the SearchUsageEvents invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockSearchUsageEventsDone() bool {
	if m.SearchUsageEventsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchUsageEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchUsageEventsMock.invocationsDone()
}

// MinimockSearchUsageEventsInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockSearchUsageEventsInspect() {
	for _, e := range m.SearchUsageEventsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchUsageEvents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchUsageEventsCounter := mm_atomic.LoadUint64(&m.afterSearchUsageEventsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchUsageEventsMock.defaultExpectation != nil && afterSearchUsageEventsCounter < 1 {
		if m.SearchUsageEventsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchUsageEvents at\n%s", m.SearchUsageEventsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.SearchUsageEvents at\n%s with params: %#v", m.SearchUsageEventsMock.defaultExpectation.expectationOrigins.origin, *m.SearchUsageEventsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchUsageEvents != nil && afterSearchUsageEventsCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.SearchUsageEvents at\n%s", m.funcSearchUsageEventsOrigin)
	}

	if !m.SearchUsageEventsMock.invocationsDone() && afterSearchUsageEventsCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.SearchUsageEvents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchUsageEventsMock.expectedInvocations), m.SearchUsageEventsMock.expectedInvocationsOrigin, afterSearchUsageEventsCounter)
	}
}

type mBillingServiceClientMockVoidInvoice struct {
	optional           bool
	mock               *BillingServiceClientMock
	defaultExpectation *BillingServiceClientMockVoidInvoiceExpectation
	expectations       []*BillingServiceClientMockVoidInvoiceExpectation

	callArgs []*BillingServiceClientMockVoidInvoiceParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// BillingServiceClientMockVoidInvoiceExpectation specifies expectation struct of the BillingServiceClient.VoidInvoice
type BillingServiceClientMockVoidInvoiceExpectation struct {
	mock               *BillingServiceClientMock
	params             *BillingServiceClientMockVoidInvoiceParams
	paramPtrs          *BillingServiceClientMockVoidInvoiceParamPtrs
	expectationOrigins BillingServiceClientMockVoidInvoiceExpectationOrigins
	results            *BillingServiceClientMockVoidInvoiceResults
	returnOrigin       string
	Counter            uint64
}

// BillingServiceClientMockVoidInvoiceParams contains parameters of the BillingServiceClient.VoidInvoice
type BillingServiceClientMockVoidInvoiceParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.VoidInvoiceRequest]
}

// BillingServiceClientMockVoidInvoiceParamPtrs contains pointers to parameters of the BillingServiceClient.VoidInvoice
type BillingServiceClientMockVoidInvoiceParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.VoidInvoiceRequest]
}

// BillingServiceClientMockVoidInvoiceResults contains results of the BillingServiceClient.VoidInvoice
type BillingServiceClientMockVoidInvoiceResults struct {
	pp2 *connect.Response[v1.VoidInvoiceResponse]
	err error
}

// BillingServiceClientMockVoidInvoiceOrigins contains origins of expectations of the BillingServiceClient.VoidInvoice
type BillingServiceClientMockVoidInvoiceExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Optional() *mBillingServiceClientMockVoidInvoice {
	mmVoidInvoice.optional = true
	return mmVoidInvoice
}

// Expect sets up expected params for BillingServiceClient.VoidInvoice
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Expect(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest]) *mBillingServiceClientMockVoidInvoice {
	if mmVoidInvoice.mock.funcVoidInvoice != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Set")
	}

	if mmVoidInvoice.defaultExpectation == nil {
		mmVoidInvoice.defaultExpectation = &BillingServiceClientMockVoidInvoiceExpectation{}
	}

	if mmVoidInvoice.defaultExpectation.paramPtrs != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by ExpectParams functions")
	}

	mmVoidInvoice.defaultExpectation.params = &BillingServiceClientMockVoidInvoiceParams{ctx, pp1}
	mmVoidInvoice.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVoidInvoice.expectations {
		if minimock.Equal(e.params, mmVoidInvoice.defaultExpectation.params) {
			mmVoidInvoice.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVoidInvoice.defaultExpectation.params)
		}
	}

	return mmVoidInvoice
}

// ExpectCtxParam1 sets up expected param ctx for BillingServiceClient.VoidInvoice
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) ExpectCtxParam1(ctx context.Context) *mBillingServiceClientMockVoidInvoice {
	if mmVoidInvoice.mock.funcVoidInvoice != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Set")
	}

	if mmVoidInvoice.defaultExpectation == nil {
		mmVoidInvoice.defaultExpectation = &BillingServiceClientMockVoidInvoiceExpectation{}
	}

	if mmVoidInvoice.defaultExpectation.params != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Expect")
	}

	if mmVoidInvoice.defaultExpectation.paramPtrs == nil {
		mmVoidInvoice.defaultExpectation.paramPtrs = &BillingServiceClientMockVoidInvoiceParamPtrs{}
	}
	mmVoidInvoice.defaultExpectation.paramPtrs.ctx = &ctx
	mmVoidInvoice.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmVoidInvoice
}

// ExpectPp1Param2 sets up expected param pp1 for BillingServiceClient.VoidInvoice
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) ExpectPp1Param2(pp1 *connect.Request[v1.VoidInvoiceRequest]) *mBillingServiceClientMockVoidInvoice {
	if mmVoidInvoice.mock.funcVoidInvoice != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Set")
	}

	if mmVoidInvoice.defaultExpectation == nil {
		mmVoidInvoice.defaultExpectation = &BillingServiceClientMockVoidInvoiceExpectation{}
	}

	if mmVoidInvoice.defaultExpectation.params != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Expect")
	}

	if mmVoidInvoice.defaultExpectation.paramPtrs == nil {
		mmVoidInvoice.defaultExpectation.paramPtrs = &BillingServiceClientMockVoidInvoiceParamPtrs{}
	}
	mmVoidInvoice.defaultExpectation.paramPtrs.pp1 = &pp1
	mmVoidInvoice.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmVoidInvoice
}

// Inspect accepts an inspector function that has same arguments as the BillingServiceClient.VoidInvoice
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest])) *mBillingServiceClientMockVoidInvoice {
	if mmVoidInvoice.mock.inspectFuncVoidInvoice != nil {
		mmVoidInvoice.mock.t.Fatalf("Inspect function is already set for BillingServiceClientMock.VoidInvoice")
	}

	mmVoidInvoice.mock.inspectFuncVoidInvoice = f

	return mmVoidInvoice
}

// Return sets up results that will be returned by BillingServiceClient.VoidInvoice
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Return(pp2 *connect.Response[v1.VoidInvoiceResponse], err error) *BillingServiceClientMock {
	if mmVoidInvoice.mock.funcVoidInvoice != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Set")
	}

	if mmVoidInvoice.defaultExpectation == nil {
		mmVoidInvoice.defaultExpectation = &BillingServiceClientMockVoidInvoiceExpectation{mock: mmVoidInvoice.mock}
	}
	mmVoidInvoice.defaultExpectation.results = &BillingServiceClientMockVoidInvoiceResults{pp2, err}
	mmVoidInvoice.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVoidInvoice.mock
}

// Set uses given function f to mock the BillingServiceClient.VoidInvoice method
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Set(f func(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest]) (pp2 *connect.Response[v1.VoidInvoiceResponse], err error)) *BillingServiceClientMock {
	if mmVoidInvoice.defaultExpectation != nil {
		mmVoidInvoice.mock.t.Fatalf("Default expectation is already set for the BillingServiceClient.VoidInvoice method")
	}

	if len(mmVoidInvoice.expectations) > 0 {
		mmVoidInvoice.mock.t.Fatalf("Some expectations are already set for the BillingServiceClient.VoidInvoice method")
	}

	mmVoidInvoice.mock.funcVoidInvoice = f
	mmVoidInvoice.mock.funcVoidInvoiceOrigin = minimock.CallerInfo(1)
	return mmVoidInvoice.mock
}

// When sets expectation for the BillingServiceClient.VoidInvoice which will trigger the result defined by the following
// Then helper
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) When(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest]) *BillingServiceClientMockVoidInvoiceExpectation {
	if mmVoidInvoice.mock.funcVoidInvoice != nil {
		mmVoidInvoice.mock.t.Fatalf("BillingServiceClientMock.VoidInvoice mock is already set by Set")
	}

	expectation := &BillingServiceClientMockVoidInvoiceExpectation{
		mock:               mmVoidInvoice.mock,
		params:             &BillingServiceClientMockVoidInvoiceParams{ctx, pp1},
		expectationOrigins: BillingServiceClientMockVoidInvoiceExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVoidInvoice.expectations = append(mmVoidInvoice.expectations, expectation)
	return expectation
}

// Then sets up BillingServiceClient.VoidInvoice return parameters for the expectation previously defined by the When method
func (e *BillingServiceClientMockVoidInvoiceExpectation) Then(pp2 *connect.Response[v1.VoidInvoiceResponse], err error) *BillingServiceClientMock {
	e.results = &BillingServiceClientMockVoidInvoiceResults{pp2, err}
	return e.mock
}

// Times sets number of times BillingServiceClient.VoidInvoice should be invoked
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Times(n uint64) *mBillingServiceClientMockVoidInvoice {
	if n == 0 {
		mmVoidInvoice.mock.t.Fatalf("Times of BillingServiceClientMock.VoidInvoice mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVoidInvoice.expectedInvocations, n)
	mmVoidInvoice.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVoidInvoice
}

func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) invocationsDone() bool {
	if len(mmVoidInvoice.expectations) == 0 && mmVoidInvoice.defaultExpectation == nil && mmVoidInvoice.mock.funcVoidInvoice == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVoidInvoice.mock.afterVoidInvoiceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVoidInvoice.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VoidInvoice implements mm_billingv1connect.BillingServiceClient
func (mmVoidInvoice *BillingServiceClientMock) VoidInvoice(ctx context.Context, pp1 *connect.Request[v1.VoidInvoiceRequest]) (pp2 *connect.Response[v1.VoidInvoiceResponse], err error) {
	mm_atomic.AddUint64(&mmVoidInvoice.beforeVoidInvoiceCounter, 1)
	defer mm_atomic.AddUint64(&mmVoidInvoice.afterVoidInvoiceCounter, 1)

	mmVoidInvoice.t.Helper()

	if mmVoidInvoice.inspectFuncVoidInvoice != nil {
		mmVoidInvoice.inspectFuncVoidInvoice(ctx, pp1)
	}

	mm_params := BillingServiceClientMockVoidInvoiceParams{ctx, pp1}

	// Record call args
	mmVoidInvoice.VoidInvoiceMock.mutex.Lock()
	mmVoidInvoice.VoidInvoiceMock.callArgs = append(mmVoidInvoice.VoidInvoiceMock.callArgs, &mm_params)
	mmVoidInvoice.VoidInvoiceMock.mutex.Unlock()

	for _, e := range mmVoidInvoice.VoidInvoiceMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmVoidInvoice.VoidInvoiceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVoidInvoice.VoidInvoiceMock.defaultExpectation.Counter, 1)
		mm_want := mmVoidInvoice.VoidInvoiceMock.defaultExpectation.params
		mm_want_ptrs := mmVoidInvoice.VoidInvoiceMock.defaultExpectation.paramPtrs

		mm_got := BillingServiceClientMockVoidInvoiceParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmVoidInvoice.t.Errorf("BillingServiceClientMock.VoidInvoice got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVoidInvoice.VoidInvoiceMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmVoidInvoice.t.Errorf("BillingServiceClientMock.VoidInvoice got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVoidInvoice.VoidInvoiceMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVoidInvoice.t.Errorf("BillingServiceClientMock.VoidInvoice got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVoidInvoice.VoidInvoiceMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVoidInvoice.VoidInvoiceMock.defaultExpectation.results
		if mm_results == nil {
			mmVoidInvoice.t.Fatal("No results are set for the BillingServiceClientMock.VoidInvoice")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmVoidInvoice.funcVoidInvoice != nil {
		return mmVoidInvoice.funcVoidInvoice(ctx, pp1)
	}
	mmVoidInvoice.t.Fatalf("Unexpected call to BillingServiceClientMock.VoidInvoice. %v %v", ctx, pp1)
	return
}

// VoidInvoiceAfterCounter returns a count of finished BillingServiceClientMock.VoidInvoice invocations
func (mmVoidInvoice *BillingServiceClientMock) VoidInvoiceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVoidInvoice.afterVoidInvoiceCounter)
}

// VoidInvoiceBeforeCounter returns a count of BillingServiceClientMock.VoidInvoice invocations
func (mmVoidInvoice *BillingServiceClientMock) VoidInvoiceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVoidInvoice.beforeVoidInvoiceCounter)
}

// Calls returns a list of arguments used in each call to BillingServiceClientMock.VoidInvoice.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVoidInvoice *mBillingServiceClientMockVoidInvoice) Calls() []*BillingServiceClientMockVoidInvoiceParams {
	mmVoidInvoice.mutex.RLock()

	argCopy := make([]*BillingServiceClientMockVoidInvoiceParams, len(mmVoidInvoice.callArgs))
	copy(argCopy, mmVoidInvoice.callArgs)

	mmVoidInvoice.mutex.RUnlock()

	return argCopy
}

// MinimockVoidInvoiceDone returns true if the count of the VoidInvoice invocations corresponds
// the number of defined expectations
func (m *BillingServiceClientMock) MinimockVoidInvoiceDone() bool {
	if m.VoidInvoiceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VoidInvoiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VoidInvoiceMock.invocationsDone()
}

// MinimockVoidInvoiceInspect logs each unmet expectation
func (m *BillingServiceClientMock) MinimockVoidInvoiceInspect() {
	for _, e := range m.VoidInvoiceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BillingServiceClientMock.VoidInvoice at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVoidInvoiceCounter := mm_atomic.LoadUint64(&m.afterVoidInvoiceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VoidInvoiceMock.defaultExpectation != nil && afterVoidInvoiceCounter < 1 {
		if m.VoidInvoiceMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to BillingServiceClientMock.VoidInvoice at\n%s", m.VoidInvoiceMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to BillingServiceClientMock.VoidInvoice at\n%s with params: %#v", m.VoidInvoiceMock.defaultExpectation.expectationOrigins.origin, *m.VoidInvoiceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVoidInvoice != nil && afterVoidInvoiceCounter < 1 {
		m.t.Errorf("Expected call to BillingServiceClientMock.VoidInvoice at\n%s", m.funcVoidInvoiceOrigin)
	}

	if !m.VoidInvoiceMock.invocationsDone() && afterVoidInvoiceCounter > 0 {
		m.t.Errorf("Expected %d calls to BillingServiceClientMock.VoidInvoice at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VoidInvoiceMock.expectedInvocations), m.VoidInvoiceMock.expectedInvocationsOrigin, afterVoidInvoiceCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BillingServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelSubscriptionInspect()

			m.MinimockCreateCatalogVersionInspect()

			m.MinimockCreateComponentInspect()

			m.MinimockCreateDiscountInspect()

			m.MinimockCreatePlanInspect()

			m.MinimockCreateSubscriptionInspect()

			m.MinimockCreateTierInspect()

			m.MinimockGetBillingRunInspect()

			m.MinimockGetCatalogVersionInspect()

			m.MinimockGetCreditBalanceInspect()

			m.MinimockGetInvoiceInspect()

			m.MinimockGetSubscriptionInspect()

			m.MinimockGrantCreditInspect()

			m.MinimockIngestUsageBatchInspect()

			m.MinimockIngestUsageEventInspect()

			m.MinimockIssueInvoiceInspect()

			m.MinimockListSubscriptionsInspect()

			m.MinimockPublishCatalogVersionInspect()

			m.MinimockRecordPaymentInspect()

			m.MinimockRunBillingInspect()

			m.MinimockSearchCatalogVersionsInspect()

			m.MinimockSearchDiscountsInspect()

			m.MinimockSearchInvoicesInspect()

			m.MinimockSearchUsageEventsInspect()

			m.MinimockVoidInvoiceInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BillingServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BillingServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelSubscriptionDone() &&
		m.MinimockCreateCatalogVersionDone() &&
		m.MinimockCreateComponentDone() &&
		m.MinimockCreateDiscountDone() &&
		m.MinimockCreatePlanDone() &&
		m.MinimockCreateSubscriptionDone() &&
		m.MinimockCreateTierDone() &&
		m.MinimockGetBillingRunDone() &&
		m.MinimockGetCatalogVersionDone() &&
		m.MinimockGetCreditBalanceDone() &&
		m.MinimockGetInvoiceDone() &&
		m.MinimockGetSubscriptionDone() &&
		m.MinimockGrantCreditDone() &&
		m.MinimockIngestUsageBatchDone() &&
		m.MinimockIngestUsageEventDone() &&
		m.MinimockIssueInvoiceDone() &&
		m.MinimockListSubscriptionsDone() &&
		m.MinimockPublishCatalogVersionDone() &&
		m.MinimockRecordPaymentDone() &&
		m.MinimockRunBillingDone() &&
		m.MinimockSearchCatalogVersionsDone() &&
		m.MinimockSearchDiscountsDone() &&
		m.MinimockSearchInvoicesDone() &&
		m.MinimockSearchUsageEventsDone() &&
		m.MinimockVoidInvoiceDone()
}
