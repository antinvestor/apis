// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/notification/connectrpc/go/notification/v1/notificationv1connect.NotificationServiceClient -o notification_handler.gen.go -n NotificationServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v1 "buf.build/gen/go/antinvestor/notification/protocolbuffers/go/notification/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// NotificationServiceClientMock implements mm_notificationv1connect.NotificationServiceClient
type NotificationServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcReceive          func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.ServerStreamForClient[v1.ReceiveResponse], err error)
	funcReceiveOrigin    string
	inspectFuncReceive   func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest])
	afterReceiveCounter  uint64
	beforeReceiveCounter uint64
	ReceiveMock          mNotificationServiceClientMockReceive

	funcRelease          func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.ServerStreamForClient[v1.ReleaseResponse], err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest])
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mNotificationServiceClientMockRelease

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mNotificationServiceClientMockSearch

	funcSend          func(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.ServerStreamForClient[v1.SendResponse], err error)
	funcSendOrigin    string
	inspectFuncSend   func(ctx context.Context, pp1 *connect.Request[v1.SendRequest])
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mNotificationServiceClientMockSend

	funcStatus          func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)
	funcStatusOrigin    string
	inspectFuncStatus   func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])
	afterStatusCounter  uint64
	beforeStatusCounter uint64
	StatusMock          mNotificationServiceClientMockStatus

	funcStatusUpdate          func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)
	funcStatusUpdateOrigin    string
	inspectFuncStatusUpdate   func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])
	afterStatusUpdateCounter  uint64
	beforeStatusUpdateCounter uint64
	StatusUpdateMock          mNotificationServiceClientMockStatusUpdate

	funcTemplateSave          func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) (pp2 *connect.Response[v1.TemplateSaveResponse], err error)
	funcTemplateSaveOrigin    string
	inspectFuncTemplateSave   func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest])
	afterTemplateSaveCounter  uint64
	beforeTemplateSaveCounter uint64
	TemplateSaveMock          mNotificationServiceClientMockTemplateSave

	funcTemplateSearch          func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest]) (pp2 *connect.ServerStreamForClient[v1.TemplateSearchResponse], err error)
	funcTemplateSearchOrigin    string
	inspectFuncTemplateSearch   func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest])
	afterTemplateSearchCounter  uint64
	beforeTemplateSearchCounter uint64
	TemplateSearchMock          mNotificationServiceClientMockTemplateSearch
}

// NewNotificationServiceClientMock returns a mock for mm_notificationv1connect.NotificationServiceClient
func NewNotificationServiceClientMock(t minimock.Tester) *NotificationServiceClientMock {
	m := &NotificationServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ReceiveMock = mNotificationServiceClientMockReceive{mock: m}
	m.ReceiveMock.callArgs = []*NotificationServiceClientMockReceiveParams{}

	m.ReleaseMock = mNotificationServiceClientMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*NotificationServiceClientMockReleaseParams{}

	m.SearchMock = mNotificationServiceClientMockSearch{mock: m}
	m.SearchMock.callArgs = []*NotificationServiceClientMockSearchParams{}

	m.SendMock = mNotificationServiceClientMockSend{mock: m}
	m.SendMock.callArgs = []*NotificationServiceClientMockSendParams{}

	m.StatusMock = mNotificationServiceClientMockStatus{mock: m}
	m.StatusMock.callArgs = []*NotificationServiceClientMockStatusParams{}

	m.StatusUpdateMock = mNotificationServiceClientMockStatusUpdate{mock: m}
	m.StatusUpdateMock.callArgs = []*NotificationServiceClientMockStatusUpdateParams{}

	m.TemplateSaveMock = mNotificationServiceClientMockTemplateSave{mock: m}
	m.TemplateSaveMock.callArgs = []*NotificationServiceClientMockTemplateSaveParams{}

	m.TemplateSearchMock = mNotificationServiceClientMockTemplateSearch{mock: m}
	m.TemplateSearchMock.callArgs = []*NotificationServiceClientMockTemplateSearchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mNotificationServiceClientMockReceive struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockReceiveExpectation
	expectations       []*NotificationServiceClientMockReceiveExpectation

	callArgs []*NotificationServiceClientMockReceiveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockReceiveExpectation specifies expectation struct of the NotificationServiceClient.Receive
type NotificationServiceClientMockReceiveExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockReceiveParams
	paramPtrs          *NotificationServiceClientMockReceiveParamPtrs
	expectationOrigins NotificationServiceClientMockReceiveExpectationOrigins
	results            *NotificationServiceClientMockReceiveResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockReceiveParams contains parameters of the NotificationServiceClient.Receive
type NotificationServiceClientMockReceiveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReceiveRequest]
}

// NotificationServiceClientMockReceiveParamPtrs contains pointers to parameters of the NotificationServiceClient.Receive
type NotificationServiceClientMockReceiveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReceiveRequest]
}

// NotificationServiceClientMockReceiveResults contains results of the NotificationServiceClient.Receive
type NotificationServiceClientMockReceiveResults struct {
	pp2 *connect.ServerStreamForClient[v1.ReceiveResponse]
	err error
}

// NotificationServiceClientMockReceiveOrigins contains origins of expectations of the NotificationServiceClient.Receive
type NotificationServiceClientMockReceiveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReceive *mNotificationServiceClientMockReceive) Optional() *mNotificationServiceClientMockReceive {
	mmReceive.optional = true
	return mmReceive
}

// Expect sets up expected params for NotificationServiceClient.Receive
func (mmReceive *mNotificationServiceClientMockReceive) Expect(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) *mNotificationServiceClientMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceClientMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.paramPtrs != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by ExpectParams functions")
	}

	mmReceive.defaultExpectation.params = &NotificationServiceClientMockReceiveParams{ctx, pp1}
	mmReceive.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReceive.expectations {
		if minimock.Equal(e.params, mmReceive.defaultExpectation.params) {
			mmReceive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceive.defaultExpectation.params)
		}
	}

	return mmReceive
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.Receive
func (mmReceive *mNotificationServiceClientMockReceive) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceClientMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &NotificationServiceClientMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.ctx = &ctx
	mmReceive.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReceive
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.Receive
func (mmReceive *mNotificationServiceClientMockReceive) ExpectPp1Param2(pp1 *connect.Request[v1.ReceiveRequest]) *mNotificationServiceClientMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceClientMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &NotificationServiceClientMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReceive.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReceive
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.Receive
func (mmReceive *mNotificationServiceClientMockReceive) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest])) *mNotificationServiceClientMockReceive {
	if mmReceive.mock.inspectFuncReceive != nil {
		mmReceive.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.Receive")
	}

	mmReceive.mock.inspectFuncReceive = f

	return mmReceive
}

// Return sets up results that will be returned by NotificationServiceClient.Receive
func (mmReceive *mNotificationServiceClientMockReceive) Return(pp2 *connect.ServerStreamForClient[v1.ReceiveResponse], err error) *NotificationServiceClientMock {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceClientMockReceiveExpectation{mock: mmReceive.mock}
	}
	mmReceive.defaultExpectation.results = &NotificationServiceClientMockReceiveResults{pp2, err}
	mmReceive.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// Set uses given function f to mock the NotificationServiceClient.Receive method
func (mmReceive *mNotificationServiceClientMockReceive) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.ServerStreamForClient[v1.ReceiveResponse], err error)) *NotificationServiceClientMock {
	if mmReceive.defaultExpectation != nil {
		mmReceive.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.Receive method")
	}

	if len(mmReceive.expectations) > 0 {
		mmReceive.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.Receive method")
	}

	mmReceive.mock.funcReceive = f
	mmReceive.mock.funcReceiveOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// When sets expectation for the NotificationServiceClient.Receive which will trigger the result defined by the following
// Then helper
func (mmReceive *mNotificationServiceClientMockReceive) When(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) *NotificationServiceClientMockReceiveExpectation {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceClientMock.Receive mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockReceiveExpectation{
		mock:               mmReceive.mock,
		params:             &NotificationServiceClientMockReceiveParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockReceiveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReceive.expectations = append(mmReceive.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.Receive return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockReceiveExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ReceiveResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockReceiveResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.Receive should be invoked
func (mmReceive *mNotificationServiceClientMockReceive) Times(n uint64) *mNotificationServiceClientMockReceive {
	if n == 0 {
		mmReceive.mock.t.Fatalf("Times of NotificationServiceClientMock.Receive mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReceive.expectedInvocations, n)
	mmReceive.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReceive
}

func (mmReceive *mNotificationServiceClientMockReceive) invocationsDone() bool {
	if len(mmReceive.expectations) == 0 && mmReceive.defaultExpectation == nil && mmReceive.mock.funcReceive == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReceive.mock.afterReceiveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReceive.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Receive implements mm_notificationv1connect.NotificationServiceClient
func (mmReceive *NotificationServiceClientMock) Receive(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest]) (pp2 *connect.ServerStreamForClient[v1.ReceiveResponse], err error) {
	mm_atomic.AddUint64(&mmReceive.beforeReceiveCounter, 1)
	defer mm_atomic.AddUint64(&mmReceive.afterReceiveCounter, 1)

	mmReceive.t.Helper()

	if mmReceive.inspectFuncReceive != nil {
		mmReceive.inspectFuncReceive(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockReceiveParams{ctx, pp1}

	// Record call args
	mmReceive.ReceiveMock.mutex.Lock()
	mmReceive.ReceiveMock.callArgs = append(mmReceive.ReceiveMock.callArgs, &mm_params)
	mmReceive.ReceiveMock.mutex.Unlock()

	for _, e := range mmReceive.ReceiveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReceive.ReceiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceive.ReceiveMock.defaultExpectation.Counter, 1)
		mm_want := mmReceive.ReceiveMock.defaultExpectation.params
		mm_want_ptrs := mmReceive.ReceiveMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockReceiveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReceive.t.Errorf("NotificationServiceClientMock.Receive got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReceive.t.Errorf("NotificationServiceClientMock.Receive got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceive.t.Errorf("NotificationServiceClientMock.Receive got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReceive.ReceiveMock.defaultExpectation.results
		if mm_results == nil {
			mmReceive.t.Fatal("No results are set for the NotificationServiceClientMock.Receive")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReceive.funcReceive != nil {
		return mmReceive.funcReceive(ctx, pp1)
	}
	mmReceive.t.Fatalf("Unexpected call to NotificationServiceClientMock.Receive. %v %v", ctx, pp1)
	return
}

// ReceiveAfterCounter returns a count of finished NotificationServiceClientMock.Receive invocations
func (mmReceive *NotificationServiceClientMock) ReceiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.afterReceiveCounter)
}

// ReceiveBeforeCounter returns a count of NotificationServiceClientMock.Receive invocations
func (mmReceive *NotificationServiceClientMock) ReceiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.beforeReceiveCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.Receive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceive *mNotificationServiceClientMockReceive) Calls() []*NotificationServiceClientMockReceiveParams {
	mmReceive.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockReceiveParams, len(mmReceive.callArgs))
	copy(argCopy, mmReceive.callArgs)

	mmReceive.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveDone returns true if the count of the Receive invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockReceiveDone() bool {
	if m.ReceiveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReceiveMock.invocationsDone()
}

// MinimockReceiveInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockReceiveInspect() {
	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Receive at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReceiveCounter := mm_atomic.LoadUint64(&m.afterReceiveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveMock.defaultExpectation != nil && afterReceiveCounter < 1 {
		if m.ReceiveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Receive at\n%s", m.ReceiveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Receive at\n%s with params: %#v", m.ReceiveMock.defaultExpectation.expectationOrigins.origin, *m.ReceiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceive != nil && afterReceiveCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.Receive at\n%s", m.funcReceiveOrigin)
	}

	if !m.ReceiveMock.invocationsDone() && afterReceiveCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.Receive at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReceiveMock.expectedInvocations), m.ReceiveMock.expectedInvocationsOrigin, afterReceiveCounter)
	}
}

type mNotificationServiceClientMockRelease struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockReleaseExpectation
	expectations       []*NotificationServiceClientMockReleaseExpectation

	callArgs []*NotificationServiceClientMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockReleaseExpectation specifies expectation struct of the NotificationServiceClient.Release
type NotificationServiceClientMockReleaseExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockReleaseParams
	paramPtrs          *NotificationServiceClientMockReleaseParamPtrs
	expectationOrigins NotificationServiceClientMockReleaseExpectationOrigins
	results            *NotificationServiceClientMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockReleaseParams contains parameters of the NotificationServiceClient.Release
type NotificationServiceClientMockReleaseParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReleaseRequest]
}

// NotificationServiceClientMockReleaseParamPtrs contains pointers to parameters of the NotificationServiceClient.Release
type NotificationServiceClientMockReleaseParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReleaseRequest]
}

// NotificationServiceClientMockReleaseResults contains results of the NotificationServiceClient.Release
type NotificationServiceClientMockReleaseResults struct {
	pp2 *connect.ServerStreamForClient[v1.ReleaseResponse]
	err error
}

// NotificationServiceClientMockReleaseOrigins contains origins of expectations of the NotificationServiceClient.Release
type NotificationServiceClientMockReleaseExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mNotificationServiceClientMockRelease) Optional() *mNotificationServiceClientMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for NotificationServiceClient.Release
func (mmRelease *mNotificationServiceClientMockRelease) Expect(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) *mNotificationServiceClientMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceClientMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &NotificationServiceClientMockReleaseParams{ctx, pp1}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.Release
func (mmRelease *mNotificationServiceClientMockRelease) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceClientMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &NotificationServiceClientMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.Release
func (mmRelease *mNotificationServiceClientMockRelease) ExpectPp1Param2(pp1 *connect.Request[v1.ReleaseRequest]) *mNotificationServiceClientMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceClientMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &NotificationServiceClientMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRelease.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.Release
func (mmRelease *mNotificationServiceClientMockRelease) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest])) *mNotificationServiceClientMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by NotificationServiceClient.Release
func (mmRelease *mNotificationServiceClientMockRelease) Return(pp2 *connect.ServerStreamForClient[v1.ReleaseResponse], err error) *NotificationServiceClientMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceClientMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &NotificationServiceClientMockReleaseResults{pp2, err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the NotificationServiceClient.Release method
func (mmRelease *mNotificationServiceClientMockRelease) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.ServerStreamForClient[v1.ReleaseResponse], err error)) *NotificationServiceClientMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the NotificationServiceClient.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mNotificationServiceClientMockRelease) When(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) *NotificationServiceClientMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceClientMock.Release mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &NotificationServiceClientMockReleaseParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.Release return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockReleaseExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ReleaseResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockReleaseResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.Release should be invoked
func (mmRelease *mNotificationServiceClientMockRelease) Times(n uint64) *mNotificationServiceClientMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of NotificationServiceClientMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mNotificationServiceClientMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_notificationv1connect.NotificationServiceClient
func (mmRelease *NotificationServiceClientMock) Release(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest]) (pp2 *connect.ServerStreamForClient[v1.ReleaseResponse], err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockReleaseParams{ctx, pp1}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockReleaseParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("NotificationServiceClientMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRelease.t.Errorf("NotificationServiceClientMock.Release got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("NotificationServiceClientMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the NotificationServiceClientMock.Release")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, pp1)
	}
	mmRelease.t.Fatalf("Unexpected call to NotificationServiceClientMock.Release. %v %v", ctx, pp1)
	return
}

// ReleaseAfterCounter returns a count of finished NotificationServiceClientMock.Release invocations
func (mmRelease *NotificationServiceClientMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of NotificationServiceClientMock.Release invocations
func (mmRelease *NotificationServiceClientMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mNotificationServiceClientMockRelease) Calls() []*NotificationServiceClientMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mNotificationServiceClientMockSearch struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockSearchExpectation
	expectations       []*NotificationServiceClientMockSearchExpectation

	callArgs []*NotificationServiceClientMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockSearchExpectation specifies expectation struct of the NotificationServiceClient.Search
type NotificationServiceClientMockSearchExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockSearchParams
	paramPtrs          *NotificationServiceClientMockSearchParamPtrs
	expectationOrigins NotificationServiceClientMockSearchExpectationOrigins
	results            *NotificationServiceClientMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockSearchParams contains parameters of the NotificationServiceClient.Search
type NotificationServiceClientMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// NotificationServiceClientMockSearchParamPtrs contains pointers to parameters of the NotificationServiceClient.Search
type NotificationServiceClientMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// NotificationServiceClientMockSearchResults contains results of the NotificationServiceClient.Search
type NotificationServiceClientMockSearchResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchResponse]
	err error
}

// NotificationServiceClientMockSearchOrigins contains origins of expectations of the NotificationServiceClient.Search
type NotificationServiceClientMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mNotificationServiceClientMockSearch) Optional() *mNotificationServiceClientMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for NotificationServiceClient.Search
func (mmSearch *mNotificationServiceClientMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mNotificationServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &NotificationServiceClientMockSearchParams{ctx, pp1}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.Search
func (mmSearch *mNotificationServiceClientMockSearch) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &NotificationServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.Search
func (mmSearch *mNotificationServiceClientMockSearch) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mNotificationServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &NotificationServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.Search
func (mmSearch *mNotificationServiceClientMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mNotificationServiceClientMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by NotificationServiceClient.Search
func (mmSearch *mNotificationServiceClientMockSearch) Return(pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) *NotificationServiceClientMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceClientMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &NotificationServiceClientMockSearchResults{pp2, err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the NotificationServiceClient.Search method
func (mmSearch *mNotificationServiceClientMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error)) *NotificationServiceClientMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the NotificationServiceClient.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mNotificationServiceClientMockSearch) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *NotificationServiceClientMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceClientMock.Search mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &NotificationServiceClientMockSearchParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.Search return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockSearchExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.Search should be invoked
func (mmSearch *mNotificationServiceClientMockSearch) Times(n uint64) *mNotificationServiceClientMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of NotificationServiceClientMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mNotificationServiceClientMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_notificationv1connect.NotificationServiceClient
func (mmSearch *NotificationServiceClientMock) Search(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchResponse], err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockSearchParams{ctx, pp1}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("NotificationServiceClientMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("NotificationServiceClientMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("NotificationServiceClientMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the NotificationServiceClientMock.Search")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1)
	}
	mmSearch.t.Fatalf("Unexpected call to NotificationServiceClientMock.Search. %v %v", ctx, pp1)
	return
}

// SearchAfterCounter returns a count of finished NotificationServiceClientMock.Search invocations
func (mmSearch *NotificationServiceClientMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of NotificationServiceClientMock.Search invocations
func (mmSearch *NotificationServiceClientMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mNotificationServiceClientMockSearch) Calls() []*NotificationServiceClientMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

type mNotificationServiceClientMockSend struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockSendExpectation
	expectations       []*NotificationServiceClientMockSendExpectation

	callArgs []*NotificationServiceClientMockSendParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockSendExpectation specifies expectation struct of the NotificationServiceClient.Send
type NotificationServiceClientMockSendExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockSendParams
	paramPtrs          *NotificationServiceClientMockSendParamPtrs
	expectationOrigins NotificationServiceClientMockSendExpectationOrigins
	results            *NotificationServiceClientMockSendResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockSendParams contains parameters of the NotificationServiceClient.Send
type NotificationServiceClientMockSendParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SendRequest]
}

// NotificationServiceClientMockSendParamPtrs contains pointers to parameters of the NotificationServiceClient.Send
type NotificationServiceClientMockSendParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SendRequest]
}

// NotificationServiceClientMockSendResults contains results of the NotificationServiceClient.Send
type NotificationServiceClientMockSendResults struct {
	pp2 *connect.ServerStreamForClient[v1.SendResponse]
	err error
}

// NotificationServiceClientMockSendOrigins contains origins of expectations of the NotificationServiceClient.Send
type NotificationServiceClientMockSendExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSend *mNotificationServiceClientMockSend) Optional() *mNotificationServiceClientMockSend {
	mmSend.optional = true
	return mmSend
}

// Expect sets up expected params for NotificationServiceClient.Send
func (mmSend *mNotificationServiceClientMockSend) Expect(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) *mNotificationServiceClientMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceClientMockSendExpectation{}
	}

	if mmSend.defaultExpectation.paramPtrs != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by ExpectParams functions")
	}

	mmSend.defaultExpectation.params = &NotificationServiceClientMockSendParams{ctx, pp1}
	mmSend.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.Send
func (mmSend *mNotificationServiceClientMockSend) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceClientMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &NotificationServiceClientMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.ctx = &ctx
	mmSend.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSend
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.Send
func (mmSend *mNotificationServiceClientMockSend) ExpectPp1Param2(pp1 *connect.Request[v1.SendRequest]) *mNotificationServiceClientMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceClientMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &NotificationServiceClientMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSend.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.Send
func (mmSend *mNotificationServiceClientMockSend) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest])) *mNotificationServiceClientMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by NotificationServiceClient.Send
func (mmSend *mNotificationServiceClientMockSend) Return(pp2 *connect.ServerStreamForClient[v1.SendResponse], err error) *NotificationServiceClientMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceClientMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &NotificationServiceClientMockSendResults{pp2, err}
	mmSend.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// Set uses given function f to mock the NotificationServiceClient.Send method
func (mmSend *mNotificationServiceClientMockSend) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.ServerStreamForClient[v1.SendResponse], err error)) *NotificationServiceClientMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.Send method")
	}

	mmSend.mock.funcSend = f
	mmSend.mock.funcSendOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// When sets expectation for the NotificationServiceClient.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mNotificationServiceClientMockSend) When(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) *NotificationServiceClientMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceClientMock.Send mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockSendExpectation{
		mock:               mmSend.mock,
		params:             &NotificationServiceClientMockSendParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockSendExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.Send return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockSendExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SendResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockSendResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.Send should be invoked
func (mmSend *mNotificationServiceClientMockSend) Times(n uint64) *mNotificationServiceClientMockSend {
	if n == 0 {
		mmSend.mock.t.Fatalf("Times of NotificationServiceClientMock.Send mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSend.expectedInvocations, n)
	mmSend.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSend
}

func (mmSend *mNotificationServiceClientMockSend) invocationsDone() bool {
	if len(mmSend.expectations) == 0 && mmSend.defaultExpectation == nil && mmSend.mock.funcSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSend.mock.afterSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Send implements mm_notificationv1connect.NotificationServiceClient
func (mmSend *NotificationServiceClientMock) Send(ctx context.Context, pp1 *connect.Request[v1.SendRequest]) (pp2 *connect.ServerStreamForClient[v1.SendResponse], err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	mmSend.t.Helper()

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockSendParams{ctx, pp1}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, &mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_want_ptrs := mmSend.SendMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockSendParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSend.t.Errorf("NotificationServiceClientMock.Send got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSend.t.Errorf("NotificationServiceClientMock.Send got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("NotificationServiceClientMock.Send got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSend.SendMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the NotificationServiceClientMock.Send")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(ctx, pp1)
	}
	mmSend.t.Fatalf("Unexpected call to NotificationServiceClientMock.Send. %v %v", ctx, pp1)
	return
}

// SendAfterCounter returns a count of finished NotificationServiceClientMock.Send invocations
func (mmSend *NotificationServiceClientMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of NotificationServiceClientMock.Send invocations
func (mmSend *NotificationServiceClientMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mNotificationServiceClientMockSend) Calls() []*NotificationServiceClientMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockSendDone() bool {
	if m.SendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMock.invocationsDone()
}

// MinimockSendInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Send at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCounter := mm_atomic.LoadUint64(&m.afterSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && afterSendCounter < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Send at\n%s", m.SendMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Send at\n%s with params: %#v", m.SendMock.defaultExpectation.expectationOrigins.origin, *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && afterSendCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.Send at\n%s", m.funcSendOrigin)
	}

	if !m.SendMock.invocationsDone() && afterSendCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.Send at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMock.expectedInvocations), m.SendMock.expectedInvocationsOrigin, afterSendCounter)
	}
}

type mNotificationServiceClientMockStatus struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockStatusExpectation
	expectations       []*NotificationServiceClientMockStatusExpectation

	callArgs []*NotificationServiceClientMockStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockStatusExpectation specifies expectation struct of the NotificationServiceClient.Status
type NotificationServiceClientMockStatusExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockStatusParams
	paramPtrs          *NotificationServiceClientMockStatusParamPtrs
	expectationOrigins NotificationServiceClientMockStatusExpectationOrigins
	results            *NotificationServiceClientMockStatusResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockStatusParams contains parameters of the NotificationServiceClient.Status
type NotificationServiceClientMockStatusParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusRequest]
}

// NotificationServiceClientMockStatusParamPtrs contains pointers to parameters of the NotificationServiceClient.Status
type NotificationServiceClientMockStatusParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusRequest]
}

// NotificationServiceClientMockStatusResults contains results of the NotificationServiceClient.Status
type NotificationServiceClientMockStatusResults struct {
	pp2 *connect.Response[v11.StatusResponse]
	err error
}

// NotificationServiceClientMockStatusOrigins contains origins of expectations of the NotificationServiceClient.Status
type NotificationServiceClientMockStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatus *mNotificationServiceClientMockStatus) Optional() *mNotificationServiceClientMockStatus {
	mmStatus.optional = true
	return mmStatus
}

// Expect sets up expected params for NotificationServiceClient.Status
func (mmStatus *mNotificationServiceClientMockStatus) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *mNotificationServiceClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceClientMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.paramPtrs != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by ExpectParams functions")
	}

	mmStatus.defaultExpectation.params = &NotificationServiceClientMockStatusParams{ctx, pp1}
	mmStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatus.expectations {
		if minimock.Equal(e.params, mmStatus.defaultExpectation.params) {
			mmStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatus.defaultExpectation.params)
		}
	}

	return mmStatus
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.Status
func (mmStatus *mNotificationServiceClientMockStatus) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceClientMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &NotificationServiceClientMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatus
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.Status
func (mmStatus *mNotificationServiceClientMockStatus) ExpectPp1Param2(pp1 *connect.Request[v11.StatusRequest]) *mNotificationServiceClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceClientMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &NotificationServiceClientMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatus.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatus
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.Status
func (mmStatus *mNotificationServiceClientMockStatus) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])) *mNotificationServiceClientMockStatus {
	if mmStatus.mock.inspectFuncStatus != nil {
		mmStatus.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.Status")
	}

	mmStatus.mock.inspectFuncStatus = f

	return mmStatus
}

// Return sets up results that will be returned by NotificationServiceClient.Status
func (mmStatus *mNotificationServiceClientMockStatus) Return(pp2 *connect.Response[v11.StatusResponse], err error) *NotificationServiceClientMock {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceClientMockStatusExpectation{mock: mmStatus.mock}
	}
	mmStatus.defaultExpectation.results = &NotificationServiceClientMockStatusResults{pp2, err}
	mmStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// Set uses given function f to mock the NotificationServiceClient.Status method
func (mmStatus *mNotificationServiceClientMockStatus) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)) *NotificationServiceClientMock {
	if mmStatus.defaultExpectation != nil {
		mmStatus.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.Status method")
	}

	if len(mmStatus.expectations) > 0 {
		mmStatus.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.Status method")
	}

	mmStatus.mock.funcStatus = f
	mmStatus.mock.funcStatusOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// When sets expectation for the NotificationServiceClient.Status which will trigger the result defined by the following
// Then helper
func (mmStatus *mNotificationServiceClientMockStatus) When(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *NotificationServiceClientMockStatusExpectation {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceClientMock.Status mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockStatusExpectation{
		mock:               mmStatus.mock,
		params:             &NotificationServiceClientMockStatusParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatus.expectations = append(mmStatus.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.Status return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockStatusExpectation) Then(pp2 *connect.Response[v11.StatusResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockStatusResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.Status should be invoked
func (mmStatus *mNotificationServiceClientMockStatus) Times(n uint64) *mNotificationServiceClientMockStatus {
	if n == 0 {
		mmStatus.mock.t.Fatalf("Times of NotificationServiceClientMock.Status mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatus.expectedInvocations, n)
	mmStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatus
}

func (mmStatus *mNotificationServiceClientMockStatus) invocationsDone() bool {
	if len(mmStatus.expectations) == 0 && mmStatus.defaultExpectation == nil && mmStatus.mock.funcStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatus.mock.afterStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Status implements mm_notificationv1connect.NotificationServiceClient
func (mmStatus *NotificationServiceClientMock) Status(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error) {
	mm_atomic.AddUint64(&mmStatus.beforeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmStatus.afterStatusCounter, 1)

	mmStatus.t.Helper()

	if mmStatus.inspectFuncStatus != nil {
		mmStatus.inspectFuncStatus(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockStatusParams{ctx, pp1}

	// Record call args
	mmStatus.StatusMock.mutex.Lock()
	mmStatus.StatusMock.callArgs = append(mmStatus.StatusMock.callArgs, &mm_params)
	mmStatus.StatusMock.mutex.Unlock()

	for _, e := range mmStatus.StatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatus.StatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatus.StatusMock.defaultExpectation.Counter, 1)
		mm_want := mmStatus.StatusMock.defaultExpectation.params
		mm_want_ptrs := mmStatus.StatusMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockStatusParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatus.t.Errorf("NotificationServiceClientMock.Status got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatus.t.Errorf("NotificationServiceClientMock.Status got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatus.t.Errorf("NotificationServiceClientMock.Status got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatus.StatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatus.StatusMock.defaultExpectation.results
		if mm_results == nil {
			mmStatus.t.Fatal("No results are set for the NotificationServiceClientMock.Status")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatus.funcStatus != nil {
		return mmStatus.funcStatus(ctx, pp1)
	}
	mmStatus.t.Fatalf("Unexpected call to NotificationServiceClientMock.Status. %v %v", ctx, pp1)
	return
}

// StatusAfterCounter returns a count of finished NotificationServiceClientMock.Status invocations
func (mmStatus *NotificationServiceClientMock) StatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.afterStatusCounter)
}

// StatusBeforeCounter returns a count of NotificationServiceClientMock.Status invocations
func (mmStatus *NotificationServiceClientMock) StatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.beforeStatusCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.Status.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatus *mNotificationServiceClientMockStatus) Calls() []*NotificationServiceClientMockStatusParams {
	mmStatus.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockStatusParams, len(mmStatus.callArgs))
	copy(argCopy, mmStatus.callArgs)

	mmStatus.mutex.RUnlock()

	return argCopy
}

// MinimockStatusDone returns true if the count of the Status invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockStatusDone() bool {
	if m.StatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusMock.invocationsDone()
}

// MinimockStatusInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockStatusInspect() {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Status at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusCounter := mm_atomic.LoadUint64(&m.afterStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && afterStatusCounter < 1 {
		if m.StatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Status at\n%s", m.StatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.Status at\n%s with params: %#v", m.StatusMock.defaultExpectation.expectationOrigins.origin, *m.StatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && afterStatusCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.Status at\n%s", m.funcStatusOrigin)
	}

	if !m.StatusMock.invocationsDone() && afterStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.Status at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusMock.expectedInvocations), m.StatusMock.expectedInvocationsOrigin, afterStatusCounter)
	}
}

type mNotificationServiceClientMockStatusUpdate struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockStatusUpdateExpectation
	expectations       []*NotificationServiceClientMockStatusUpdateExpectation

	callArgs []*NotificationServiceClientMockStatusUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockStatusUpdateExpectation specifies expectation struct of the NotificationServiceClient.StatusUpdate
type NotificationServiceClientMockStatusUpdateExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockStatusUpdateParams
	paramPtrs          *NotificationServiceClientMockStatusUpdateParamPtrs
	expectationOrigins NotificationServiceClientMockStatusUpdateExpectationOrigins
	results            *NotificationServiceClientMockStatusUpdateResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockStatusUpdateParams contains parameters of the NotificationServiceClient.StatusUpdate
type NotificationServiceClientMockStatusUpdateParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusUpdateRequest]
}

// NotificationServiceClientMockStatusUpdateParamPtrs contains pointers to parameters of the NotificationServiceClient.StatusUpdate
type NotificationServiceClientMockStatusUpdateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusUpdateRequest]
}

// NotificationServiceClientMockStatusUpdateResults contains results of the NotificationServiceClient.StatusUpdate
type NotificationServiceClientMockStatusUpdateResults struct {
	pp2 *connect.Response[v11.StatusUpdateResponse]
	err error
}

// NotificationServiceClientMockStatusUpdateOrigins contains origins of expectations of the NotificationServiceClient.StatusUpdate
type NotificationServiceClientMockStatusUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Optional() *mNotificationServiceClientMockStatusUpdate {
	mmStatusUpdate.optional = true
	return mmStatusUpdate
}

// Expect sets up expected params for NotificationServiceClient.StatusUpdate
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *mNotificationServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceClientMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by ExpectParams functions")
	}

	mmStatusUpdate.defaultExpectation.params = &NotificationServiceClientMockStatusUpdateParams{ctx, pp1}
	mmStatusUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatusUpdate.expectations {
		if minimock.Equal(e.params, mmStatusUpdate.defaultExpectation.params) {
			mmStatusUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatusUpdate.defaultExpectation.params)
		}
	}

	return mmStatusUpdate
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.StatusUpdate
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceClientMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &NotificationServiceClientMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatusUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.StatusUpdate
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) ExpectPp1Param2(pp1 *connect.Request[v11.StatusUpdateRequest]) *mNotificationServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceClientMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &NotificationServiceClientMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatusUpdate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.StatusUpdate
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])) *mNotificationServiceClientMockStatusUpdate {
	if mmStatusUpdate.mock.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.StatusUpdate")
	}

	mmStatusUpdate.mock.inspectFuncStatusUpdate = f

	return mmStatusUpdate
}

// Return sets up results that will be returned by NotificationServiceClient.StatusUpdate
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Return(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *NotificationServiceClientMock {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceClientMockStatusUpdateExpectation{mock: mmStatusUpdate.mock}
	}
	mmStatusUpdate.defaultExpectation.results = &NotificationServiceClientMockStatusUpdateResults{pp2, err}
	mmStatusUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// Set uses given function f to mock the NotificationServiceClient.StatusUpdate method
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)) *NotificationServiceClientMock {
	if mmStatusUpdate.defaultExpectation != nil {
		mmStatusUpdate.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.StatusUpdate method")
	}

	if len(mmStatusUpdate.expectations) > 0 {
		mmStatusUpdate.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.StatusUpdate method")
	}

	mmStatusUpdate.mock.funcStatusUpdate = f
	mmStatusUpdate.mock.funcStatusUpdateOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// When sets expectation for the NotificationServiceClient.StatusUpdate which will trigger the result defined by the following
// Then helper
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) When(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *NotificationServiceClientMockStatusUpdateExpectation {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceClientMock.StatusUpdate mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockStatusUpdateExpectation{
		mock:               mmStatusUpdate.mock,
		params:             &NotificationServiceClientMockStatusUpdateParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockStatusUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatusUpdate.expectations = append(mmStatusUpdate.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.StatusUpdate return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockStatusUpdateExpectation) Then(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockStatusUpdateResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.StatusUpdate should be invoked
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Times(n uint64) *mNotificationServiceClientMockStatusUpdate {
	if n == 0 {
		mmStatusUpdate.mock.t.Fatalf("Times of NotificationServiceClientMock.StatusUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatusUpdate.expectedInvocations, n)
	mmStatusUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate
}

func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) invocationsDone() bool {
	if len(mmStatusUpdate.expectations) == 0 && mmStatusUpdate.defaultExpectation == nil && mmStatusUpdate.mock.funcStatusUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.mock.afterStatusUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StatusUpdate implements mm_notificationv1connect.NotificationServiceClient
func (mmStatusUpdate *NotificationServiceClientMock) StatusUpdate(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error) {
	mm_atomic.AddUint64(&mmStatusUpdate.beforeStatusUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmStatusUpdate.afterStatusUpdateCounter, 1)

	mmStatusUpdate.t.Helper()

	if mmStatusUpdate.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.inspectFuncStatusUpdate(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockStatusUpdateParams{ctx, pp1}

	// Record call args
	mmStatusUpdate.StatusUpdateMock.mutex.Lock()
	mmStatusUpdate.StatusUpdateMock.callArgs = append(mmStatusUpdate.StatusUpdateMock.callArgs, &mm_params)
	mmStatusUpdate.StatusUpdateMock.mutex.Unlock()

	for _, e := range mmStatusUpdate.StatusUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatusUpdate.StatusUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatusUpdate.StatusUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmStatusUpdate.StatusUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmStatusUpdate.StatusUpdateMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockStatusUpdateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatusUpdate.t.Errorf("NotificationServiceClientMock.StatusUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatusUpdate.t.Errorf("NotificationServiceClientMock.StatusUpdate got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatusUpdate.t.Errorf("NotificationServiceClientMock.StatusUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatusUpdate.StatusUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmStatusUpdate.t.Fatal("No results are set for the NotificationServiceClientMock.StatusUpdate")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatusUpdate.funcStatusUpdate != nil {
		return mmStatusUpdate.funcStatusUpdate(ctx, pp1)
	}
	mmStatusUpdate.t.Fatalf("Unexpected call to NotificationServiceClientMock.StatusUpdate. %v %v", ctx, pp1)
	return
}

// StatusUpdateAfterCounter returns a count of finished NotificationServiceClientMock.StatusUpdate invocations
func (mmStatusUpdate *NotificationServiceClientMock) StatusUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.afterStatusUpdateCounter)
}

// StatusUpdateBeforeCounter returns a count of NotificationServiceClientMock.StatusUpdate invocations
func (mmStatusUpdate *NotificationServiceClientMock) StatusUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.beforeStatusUpdateCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.StatusUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatusUpdate *mNotificationServiceClientMockStatusUpdate) Calls() []*NotificationServiceClientMockStatusUpdateParams {
	mmStatusUpdate.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockStatusUpdateParams, len(mmStatusUpdate.callArgs))
	copy(argCopy, mmStatusUpdate.callArgs)

	mmStatusUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockStatusUpdateDone returns true if the count of the StatusUpdate invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockStatusUpdateDone() bool {
	if m.StatusUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusUpdateMock.invocationsDone()
}

// MinimockStatusUpdateInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockStatusUpdateInspect() {
	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.StatusUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusUpdateCounter := mm_atomic.LoadUint64(&m.afterStatusUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusUpdateMock.defaultExpectation != nil && afterStatusUpdateCounter < 1 {
		if m.StatusUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.StatusUpdate at\n%s", m.StatusUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.StatusUpdate at\n%s with params: %#v", m.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *m.StatusUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatusUpdate != nil && afterStatusUpdateCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.StatusUpdate at\n%s", m.funcStatusUpdateOrigin)
	}

	if !m.StatusUpdateMock.invocationsDone() && afterStatusUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.StatusUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusUpdateMock.expectedInvocations), m.StatusUpdateMock.expectedInvocationsOrigin, afterStatusUpdateCounter)
	}
}

type mNotificationServiceClientMockTemplateSave struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockTemplateSaveExpectation
	expectations       []*NotificationServiceClientMockTemplateSaveExpectation

	callArgs []*NotificationServiceClientMockTemplateSaveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockTemplateSaveExpectation specifies expectation struct of the NotificationServiceClient.TemplateSave
type NotificationServiceClientMockTemplateSaveExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockTemplateSaveParams
	paramPtrs          *NotificationServiceClientMockTemplateSaveParamPtrs
	expectationOrigins NotificationServiceClientMockTemplateSaveExpectationOrigins
	results            *NotificationServiceClientMockTemplateSaveResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockTemplateSaveParams contains parameters of the NotificationServiceClient.TemplateSave
type NotificationServiceClientMockTemplateSaveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.TemplateSaveRequest]
}

// NotificationServiceClientMockTemplateSaveParamPtrs contains pointers to parameters of the NotificationServiceClient.TemplateSave
type NotificationServiceClientMockTemplateSaveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.TemplateSaveRequest]
}

// NotificationServiceClientMockTemplateSaveResults contains results of the NotificationServiceClient.TemplateSave
type NotificationServiceClientMockTemplateSaveResults struct {
	pp2 *connect.Response[v1.TemplateSaveResponse]
	err error
}

// NotificationServiceClientMockTemplateSaveOrigins contains origins of expectations of the NotificationServiceClient.TemplateSave
type NotificationServiceClientMockTemplateSaveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Optional() *mNotificationServiceClientMockTemplateSave {
	mmTemplateSave.optional = true
	return mmTemplateSave
}

// Expect sets up expected params for NotificationServiceClient.TemplateSave
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Expect(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) *mNotificationServiceClientMockTemplateSave {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceClientMockTemplateSaveExpectation{}
	}

	if mmTemplateSave.defaultExpectation.paramPtrs != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by ExpectParams functions")
	}

	mmTemplateSave.defaultExpectation.params = &NotificationServiceClientMockTemplateSaveParams{ctx, pp1}
	mmTemplateSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTemplateSave.expectations {
		if minimock.Equal(e.params, mmTemplateSave.defaultExpectation.params) {
			mmTemplateSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTemplateSave.defaultExpectation.params)
		}
	}

	return mmTemplateSave
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.TemplateSave
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockTemplateSave {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceClientMockTemplateSaveExpectation{}
	}

	if mmTemplateSave.defaultExpectation.params != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Expect")
	}

	if mmTemplateSave.defaultExpectation.paramPtrs == nil {
		mmTemplateSave.defaultExpectation.paramPtrs = &NotificationServiceClientMockTemplateSaveParamPtrs{}
	}
	mmTemplateSave.defaultExpectation.paramPtrs.ctx = &ctx
	mmTemplateSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTemplateSave
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.TemplateSave
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) ExpectPp1Param2(pp1 *connect.Request[v1.TemplateSaveRequest]) *mNotificationServiceClientMockTemplateSave {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceClientMockTemplateSaveExpectation{}
	}

	if mmTemplateSave.defaultExpectation.params != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Expect")
	}

	if mmTemplateSave.defaultExpectation.paramPtrs == nil {
		mmTemplateSave.defaultExpectation.paramPtrs = &NotificationServiceClientMockTemplateSaveParamPtrs{}
	}
	mmTemplateSave.defaultExpectation.paramPtrs.pp1 = &pp1
	mmTemplateSave.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmTemplateSave
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.TemplateSave
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest])) *mNotificationServiceClientMockTemplateSave {
	if mmTemplateSave.mock.inspectFuncTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.TemplateSave")
	}

	mmTemplateSave.mock.inspectFuncTemplateSave = f

	return mmTemplateSave
}

// Return sets up results that will be returned by NotificationServiceClient.TemplateSave
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Return(pp2 *connect.Response[v1.TemplateSaveResponse], err error) *NotificationServiceClientMock {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceClientMockTemplateSaveExpectation{mock: mmTemplateSave.mock}
	}
	mmTemplateSave.defaultExpectation.results = &NotificationServiceClientMockTemplateSaveResults{pp2, err}
	mmTemplateSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTemplateSave.mock
}

// Set uses given function f to mock the NotificationServiceClient.TemplateSave method
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Set(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) (pp2 *connect.Response[v1.TemplateSaveResponse], err error)) *NotificationServiceClientMock {
	if mmTemplateSave.defaultExpectation != nil {
		mmTemplateSave.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.TemplateSave method")
	}

	if len(mmTemplateSave.expectations) > 0 {
		mmTemplateSave.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.TemplateSave method")
	}

	mmTemplateSave.mock.funcTemplateSave = f
	mmTemplateSave.mock.funcTemplateSaveOrigin = minimock.CallerInfo(1)
	return mmTemplateSave.mock
}

// When sets expectation for the NotificationServiceClient.TemplateSave which will trigger the result defined by the following
// Then helper
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) When(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) *NotificationServiceClientMockTemplateSaveExpectation {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceClientMock.TemplateSave mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockTemplateSaveExpectation{
		mock:               mmTemplateSave.mock,
		params:             &NotificationServiceClientMockTemplateSaveParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockTemplateSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTemplateSave.expectations = append(mmTemplateSave.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.TemplateSave return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockTemplateSaveExpectation) Then(pp2 *connect.Response[v1.TemplateSaveResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockTemplateSaveResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.TemplateSave should be invoked
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Times(n uint64) *mNotificationServiceClientMockTemplateSave {
	if n == 0 {
		mmTemplateSave.mock.t.Fatalf("Times of NotificationServiceClientMock.TemplateSave mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTemplateSave.expectedInvocations, n)
	mmTemplateSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTemplateSave
}

func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) invocationsDone() bool {
	if len(mmTemplateSave.expectations) == 0 && mmTemplateSave.defaultExpectation == nil && mmTemplateSave.mock.funcTemplateSave == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTemplateSave.mock.afterTemplateSaveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTemplateSave.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TemplateSave implements mm_notificationv1connect.NotificationServiceClient
func (mmTemplateSave *NotificationServiceClientMock) TemplateSave(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) (pp2 *connect.Response[v1.TemplateSaveResponse], err error) {
	mm_atomic.AddUint64(&mmTemplateSave.beforeTemplateSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmTemplateSave.afterTemplateSaveCounter, 1)

	mmTemplateSave.t.Helper()

	if mmTemplateSave.inspectFuncTemplateSave != nil {
		mmTemplateSave.inspectFuncTemplateSave(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockTemplateSaveParams{ctx, pp1}

	// Record call args
	mmTemplateSave.TemplateSaveMock.mutex.Lock()
	mmTemplateSave.TemplateSaveMock.callArgs = append(mmTemplateSave.TemplateSaveMock.callArgs, &mm_params)
	mmTemplateSave.TemplateSaveMock.mutex.Unlock()

	for _, e := range mmTemplateSave.TemplateSaveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmTemplateSave.TemplateSaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTemplateSave.TemplateSaveMock.defaultExpectation.Counter, 1)
		mm_want := mmTemplateSave.TemplateSaveMock.defaultExpectation.params
		mm_want_ptrs := mmTemplateSave.TemplateSaveMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockTemplateSaveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTemplateSave.t.Errorf("NotificationServiceClientMock.TemplateSave got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSave.TemplateSaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmTemplateSave.t.Errorf("NotificationServiceClientMock.TemplateSave got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSave.TemplateSaveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTemplateSave.t.Errorf("NotificationServiceClientMock.TemplateSave got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTemplateSave.TemplateSaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTemplateSave.TemplateSaveMock.defaultExpectation.results
		if mm_results == nil {
			mmTemplateSave.t.Fatal("No results are set for the NotificationServiceClientMock.TemplateSave")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmTemplateSave.funcTemplateSave != nil {
		return mmTemplateSave.funcTemplateSave(ctx, pp1)
	}
	mmTemplateSave.t.Fatalf("Unexpected call to NotificationServiceClientMock.TemplateSave. %v %v", ctx, pp1)
	return
}

// TemplateSaveAfterCounter returns a count of finished NotificationServiceClientMock.TemplateSave invocations
func (mmTemplateSave *NotificationServiceClientMock) TemplateSaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSave.afterTemplateSaveCounter)
}

// TemplateSaveBeforeCounter returns a count of NotificationServiceClientMock.TemplateSave invocations
func (mmTemplateSave *NotificationServiceClientMock) TemplateSaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSave.beforeTemplateSaveCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.TemplateSave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTemplateSave *mNotificationServiceClientMockTemplateSave) Calls() []*NotificationServiceClientMockTemplateSaveParams {
	mmTemplateSave.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockTemplateSaveParams, len(mmTemplateSave.callArgs))
	copy(argCopy, mmTemplateSave.callArgs)

	mmTemplateSave.mutex.RUnlock()

	return argCopy
}

// MinimockTemplateSaveDone returns true if the count of the TemplateSave invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockTemplateSaveDone() bool {
	if m.TemplateSaveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TemplateSaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TemplateSaveMock.invocationsDone()
}

// MinimockTemplateSaveInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockTemplateSaveInspect() {
	for _, e := range m.TemplateSaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSave at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTemplateSaveCounter := mm_atomic.LoadUint64(&m.afterTemplateSaveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TemplateSaveMock.defaultExpectation != nil && afterTemplateSaveCounter < 1 {
		if m.TemplateSaveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSave at\n%s", m.TemplateSaveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSave at\n%s with params: %#v", m.TemplateSaveMock.defaultExpectation.expectationOrigins.origin, *m.TemplateSaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTemplateSave != nil && afterTemplateSaveCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSave at\n%s", m.funcTemplateSaveOrigin)
	}

	if !m.TemplateSaveMock.invocationsDone() && afterTemplateSaveCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.TemplateSave at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TemplateSaveMock.expectedInvocations), m.TemplateSaveMock.expectedInvocationsOrigin, afterTemplateSaveCounter)
	}
}

type mNotificationServiceClientMockTemplateSearch struct {
	optional           bool
	mock               *NotificationServiceClientMock
	defaultExpectation *NotificationServiceClientMockTemplateSearchExpectation
	expectations       []*NotificationServiceClientMockTemplateSearchExpectation

	callArgs []*NotificationServiceClientMockTemplateSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceClientMockTemplateSearchExpectation specifies expectation struct of the NotificationServiceClient.TemplateSearch
type NotificationServiceClientMockTemplateSearchExpectation struct {
	mock               *NotificationServiceClientMock
	params             *NotificationServiceClientMockTemplateSearchParams
	paramPtrs          *NotificationServiceClientMockTemplateSearchParamPtrs
	expectationOrigins NotificationServiceClientMockTemplateSearchExpectationOrigins
	results            *NotificationServiceClientMockTemplateSearchResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceClientMockTemplateSearchParams contains parameters of the NotificationServiceClient.TemplateSearch
type NotificationServiceClientMockTemplateSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.TemplateSearchRequest]
}

// NotificationServiceClientMockTemplateSearchParamPtrs contains pointers to parameters of the NotificationServiceClient.TemplateSearch
type NotificationServiceClientMockTemplateSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.TemplateSearchRequest]
}

// NotificationServiceClientMockTemplateSearchResults contains results of the NotificationServiceClient.TemplateSearch
type NotificationServiceClientMockTemplateSearchResults struct {
	pp2 *connect.ServerStreamForClient[v1.TemplateSearchResponse]
	err error
}

// NotificationServiceClientMockTemplateSearchOrigins contains origins of expectations of the NotificationServiceClient.TemplateSearch
type NotificationServiceClientMockTemplateSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Optional() *mNotificationServiceClientMockTemplateSearch {
	mmTemplateSearch.optional = true
	return mmTemplateSearch
}

// Expect sets up expected params for NotificationServiceClient.TemplateSearch
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Expect(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest]) *mNotificationServiceClientMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceClientMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by ExpectParams functions")
	}

	mmTemplateSearch.defaultExpectation.params = &NotificationServiceClientMockTemplateSearchParams{ctx, pp1}
	mmTemplateSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTemplateSearch.expectations {
		if minimock.Equal(e.params, mmTemplateSearch.defaultExpectation.params) {
			mmTemplateSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTemplateSearch.defaultExpectation.params)
		}
	}

	return mmTemplateSearch
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceClient.TemplateSearch
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) ExpectCtxParam1(ctx context.Context) *mNotificationServiceClientMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceClientMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.params != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Expect")
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs == nil {
		mmTemplateSearch.defaultExpectation.paramPtrs = &NotificationServiceClientMockTemplateSearchParamPtrs{}
	}
	mmTemplateSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmTemplateSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTemplateSearch
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceClient.TemplateSearch
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) ExpectPp1Param2(pp1 *connect.Request[v1.TemplateSearchRequest]) *mNotificationServiceClientMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceClientMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.params != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Expect")
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs == nil {
		mmTemplateSearch.defaultExpectation.paramPtrs = &NotificationServiceClientMockTemplateSearchParamPtrs{}
	}
	mmTemplateSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmTemplateSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmTemplateSearch
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceClient.TemplateSearch
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest])) *mNotificationServiceClientMockTemplateSearch {
	if mmTemplateSearch.mock.inspectFuncTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("Inspect function is already set for NotificationServiceClientMock.TemplateSearch")
	}

	mmTemplateSearch.mock.inspectFuncTemplateSearch = f

	return mmTemplateSearch
}

// Return sets up results that will be returned by NotificationServiceClient.TemplateSearch
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Return(pp2 *connect.ServerStreamForClient[v1.TemplateSearchResponse], err error) *NotificationServiceClientMock {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceClientMockTemplateSearchExpectation{mock: mmTemplateSearch.mock}
	}
	mmTemplateSearch.defaultExpectation.results = &NotificationServiceClientMockTemplateSearchResults{pp2, err}
	mmTemplateSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTemplateSearch.mock
}

// Set uses given function f to mock the NotificationServiceClient.TemplateSearch method
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest]) (pp2 *connect.ServerStreamForClient[v1.TemplateSearchResponse], err error)) *NotificationServiceClientMock {
	if mmTemplateSearch.defaultExpectation != nil {
		mmTemplateSearch.mock.t.Fatalf("Default expectation is already set for the NotificationServiceClient.TemplateSearch method")
	}

	if len(mmTemplateSearch.expectations) > 0 {
		mmTemplateSearch.mock.t.Fatalf("Some expectations are already set for the NotificationServiceClient.TemplateSearch method")
	}

	mmTemplateSearch.mock.funcTemplateSearch = f
	mmTemplateSearch.mock.funcTemplateSearchOrigin = minimock.CallerInfo(1)
	return mmTemplateSearch.mock
}

// When sets expectation for the NotificationServiceClient.TemplateSearch which will trigger the result defined by the following
// Then helper
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) When(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest]) *NotificationServiceClientMockTemplateSearchExpectation {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceClientMock.TemplateSearch mock is already set by Set")
	}

	expectation := &NotificationServiceClientMockTemplateSearchExpectation{
		mock:               mmTemplateSearch.mock,
		params:             &NotificationServiceClientMockTemplateSearchParams{ctx, pp1},
		expectationOrigins: NotificationServiceClientMockTemplateSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTemplateSearch.expectations = append(mmTemplateSearch.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceClient.TemplateSearch return parameters for the expectation previously defined by the When method
func (e *NotificationServiceClientMockTemplateSearchExpectation) Then(pp2 *connect.ServerStreamForClient[v1.TemplateSearchResponse], err error) *NotificationServiceClientMock {
	e.results = &NotificationServiceClientMockTemplateSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceClient.TemplateSearch should be invoked
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Times(n uint64) *mNotificationServiceClientMockTemplateSearch {
	if n == 0 {
		mmTemplateSearch.mock.t.Fatalf("Times of NotificationServiceClientMock.TemplateSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTemplateSearch.expectedInvocations, n)
	mmTemplateSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTemplateSearch
}

func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) invocationsDone() bool {
	if len(mmTemplateSearch.expectations) == 0 && mmTemplateSearch.defaultExpectation == nil && mmTemplateSearch.mock.funcTemplateSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTemplateSearch.mock.afterTemplateSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTemplateSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TemplateSearch implements mm_notificationv1connect.NotificationServiceClient
func (mmTemplateSearch *NotificationServiceClientMock) TemplateSearch(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest]) (pp2 *connect.ServerStreamForClient[v1.TemplateSearchResponse], err error) {
	mm_atomic.AddUint64(&mmTemplateSearch.beforeTemplateSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmTemplateSearch.afterTemplateSearchCounter, 1)

	mmTemplateSearch.t.Helper()

	if mmTemplateSearch.inspectFuncTemplateSearch != nil {
		mmTemplateSearch.inspectFuncTemplateSearch(ctx, pp1)
	}

	mm_params := NotificationServiceClientMockTemplateSearchParams{ctx, pp1}

	// Record call args
	mmTemplateSearch.TemplateSearchMock.mutex.Lock()
	mmTemplateSearch.TemplateSearchMock.callArgs = append(mmTemplateSearch.TemplateSearchMock.callArgs, &mm_params)
	mmTemplateSearch.TemplateSearchMock.mutex.Unlock()

	for _, e := range mmTemplateSearch.TemplateSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmTemplateSearch.TemplateSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTemplateSearch.TemplateSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmTemplateSearch.TemplateSearchMock.defaultExpectation.params
		mm_want_ptrs := mmTemplateSearch.TemplateSearchMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceClientMockTemplateSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTemplateSearch.t.Errorf("NotificationServiceClientMock.TemplateSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmTemplateSearch.t.Errorf("NotificationServiceClientMock.TemplateSearch got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTemplateSearch.t.Errorf("NotificationServiceClientMock.TemplateSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTemplateSearch.TemplateSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmTemplateSearch.t.Fatal("No results are set for the NotificationServiceClientMock.TemplateSearch")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmTemplateSearch.funcTemplateSearch != nil {
		return mmTemplateSearch.funcTemplateSearch(ctx, pp1)
	}
	mmTemplateSearch.t.Fatalf("Unexpected call to NotificationServiceClientMock.TemplateSearch. %v %v", ctx, pp1)
	return
}

// TemplateSearchAfterCounter returns a count of finished NotificationServiceClientMock.TemplateSearch invocations
func (mmTemplateSearch *NotificationServiceClientMock) TemplateSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSearch.afterTemplateSearchCounter)
}

// TemplateSearchBeforeCounter returns a count of NotificationServiceClientMock.TemplateSearch invocations
func (mmTemplateSearch *NotificationServiceClientMock) TemplateSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSearch.beforeTemplateSearchCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceClientMock.TemplateSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTemplateSearch *mNotificationServiceClientMockTemplateSearch) Calls() []*NotificationServiceClientMockTemplateSearchParams {
	mmTemplateSearch.mutex.RLock()

	argCopy := make([]*NotificationServiceClientMockTemplateSearchParams, len(mmTemplateSearch.callArgs))
	copy(argCopy, mmTemplateSearch.callArgs)

	mmTemplateSearch.mutex.RUnlock()

	return argCopy
}

// MinimockTemplateSearchDone returns true if the count of the TemplateSearch invocations corresponds
// the number of defined expectations
func (m *NotificationServiceClientMock) MinimockTemplateSearchDone() bool {
	if m.TemplateSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TemplateSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TemplateSearchMock.invocationsDone()
}

// MinimockTemplateSearchInspect logs each unmet expectation
func (m *NotificationServiceClientMock) MinimockTemplateSearchInspect() {
	for _, e := range m.TemplateSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTemplateSearchCounter := mm_atomic.LoadUint64(&m.afterTemplateSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TemplateSearchMock.defaultExpectation != nil && afterTemplateSearchCounter < 1 {
		if m.TemplateSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSearch at\n%s", m.TemplateSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSearch at\n%s with params: %#v", m.TemplateSearchMock.defaultExpectation.expectationOrigins.origin, *m.TemplateSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTemplateSearch != nil && afterTemplateSearchCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceClientMock.TemplateSearch at\n%s", m.funcTemplateSearchOrigin)
	}

	if !m.TemplateSearchMock.invocationsDone() && afterTemplateSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceClientMock.TemplateSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TemplateSearchMock.expectedInvocations), m.TemplateSearchMock.expectedInvocationsOrigin, afterTemplateSearchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NotificationServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockReceiveInspect()

			m.MinimockReleaseInspect()

			m.MinimockSearchInspect()

			m.MinimockSendInspect()

			m.MinimockStatusInspect()

			m.MinimockStatusUpdateInspect()

			m.MinimockTemplateSaveInspect()

			m.MinimockTemplateSearchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NotificationServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NotificationServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockReceiveDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockSearchDone() &&
		m.MinimockSendDone() &&
		m.MinimockStatusDone() &&
		m.MinimockStatusUpdateDone() &&
		m.MinimockTemplateSaveDone() &&
		m.MinimockTemplateSearchDone()
}
