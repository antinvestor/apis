// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/notification/connectrpc/go/notification/v1/notificationv1connect.NotificationServiceHandler -o notification_handler.gen.go -n NotificationServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v1 "buf.build/gen/go/antinvestor/notification/protocolbuffers/go/notification/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// NotificationServiceHandlerMock implements mm_notificationv1connect.NotificationServiceHandler
type NotificationServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcReceive          func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse]) (err error)
	funcReceiveOrigin    string
	inspectFuncReceive   func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse])
	afterReceiveCounter  uint64
	beforeReceiveCounter uint64
	ReceiveMock          mNotificationServiceHandlerMockReceive

	funcRelease          func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse]) (err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse])
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mNotificationServiceHandlerMockRelease

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mNotificationServiceHandlerMockSearch

	funcSend          func(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse]) (err error)
	funcSendOrigin    string
	inspectFuncSend   func(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse])
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mNotificationServiceHandlerMockSend

	funcStatus          func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)
	funcStatusOrigin    string
	inspectFuncStatus   func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])
	afterStatusCounter  uint64
	beforeStatusCounter uint64
	StatusMock          mNotificationServiceHandlerMockStatus

	funcStatusUpdate          func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)
	funcStatusUpdateOrigin    string
	inspectFuncStatusUpdate   func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])
	afterStatusUpdateCounter  uint64
	beforeStatusUpdateCounter uint64
	StatusUpdateMock          mNotificationServiceHandlerMockStatusUpdate

	funcTemplateSave          func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) (pp2 *connect.Response[v1.TemplateSaveResponse], err error)
	funcTemplateSaveOrigin    string
	inspectFuncTemplateSave   func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest])
	afterTemplateSaveCounter  uint64
	beforeTemplateSaveCounter uint64
	TemplateSaveMock          mNotificationServiceHandlerMockTemplateSave

	funcTemplateSearch          func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse]) (err error)
	funcTemplateSearchOrigin    string
	inspectFuncTemplateSearch   func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse])
	afterTemplateSearchCounter  uint64
	beforeTemplateSearchCounter uint64
	TemplateSearchMock          mNotificationServiceHandlerMockTemplateSearch
}

// NewNotificationServiceHandlerMock returns a mock for mm_notificationv1connect.NotificationServiceHandler
func NewNotificationServiceHandlerMock(t minimock.Tester) *NotificationServiceHandlerMock {
	m := &NotificationServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ReceiveMock = mNotificationServiceHandlerMockReceive{mock: m}
	m.ReceiveMock.callArgs = []*NotificationServiceHandlerMockReceiveParams{}

	m.ReleaseMock = mNotificationServiceHandlerMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*NotificationServiceHandlerMockReleaseParams{}

	m.SearchMock = mNotificationServiceHandlerMockSearch{mock: m}
	m.SearchMock.callArgs = []*NotificationServiceHandlerMockSearchParams{}

	m.SendMock = mNotificationServiceHandlerMockSend{mock: m}
	m.SendMock.callArgs = []*NotificationServiceHandlerMockSendParams{}

	m.StatusMock = mNotificationServiceHandlerMockStatus{mock: m}
	m.StatusMock.callArgs = []*NotificationServiceHandlerMockStatusParams{}

	m.StatusUpdateMock = mNotificationServiceHandlerMockStatusUpdate{mock: m}
	m.StatusUpdateMock.callArgs = []*NotificationServiceHandlerMockStatusUpdateParams{}

	m.TemplateSaveMock = mNotificationServiceHandlerMockTemplateSave{mock: m}
	m.TemplateSaveMock.callArgs = []*NotificationServiceHandlerMockTemplateSaveParams{}

	m.TemplateSearchMock = mNotificationServiceHandlerMockTemplateSearch{mock: m}
	m.TemplateSearchMock.callArgs = []*NotificationServiceHandlerMockTemplateSearchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mNotificationServiceHandlerMockReceive struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockReceiveExpectation
	expectations       []*NotificationServiceHandlerMockReceiveExpectation

	callArgs []*NotificationServiceHandlerMockReceiveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockReceiveExpectation specifies expectation struct of the NotificationServiceHandler.Receive
type NotificationServiceHandlerMockReceiveExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockReceiveParams
	paramPtrs          *NotificationServiceHandlerMockReceiveParamPtrs
	expectationOrigins NotificationServiceHandlerMockReceiveExpectationOrigins
	results            *NotificationServiceHandlerMockReceiveResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockReceiveParams contains parameters of the NotificationServiceHandler.Receive
type NotificationServiceHandlerMockReceiveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReceiveRequest]
	pp2 *connect.ServerStream[v1.ReceiveResponse]
}

// NotificationServiceHandlerMockReceiveParamPtrs contains pointers to parameters of the NotificationServiceHandler.Receive
type NotificationServiceHandlerMockReceiveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReceiveRequest]
	pp2 **connect.ServerStream[v1.ReceiveResponse]
}

// NotificationServiceHandlerMockReceiveResults contains results of the NotificationServiceHandler.Receive
type NotificationServiceHandlerMockReceiveResults struct {
	err error
}

// NotificationServiceHandlerMockReceiveOrigins contains origins of expectations of the NotificationServiceHandler.Receive
type NotificationServiceHandlerMockReceiveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReceive *mNotificationServiceHandlerMockReceive) Optional() *mNotificationServiceHandlerMockReceive {
	mmReceive.optional = true
	return mmReceive
}

// Expect sets up expected params for NotificationServiceHandler.Receive
func (mmReceive *mNotificationServiceHandlerMockReceive) Expect(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse]) *mNotificationServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.paramPtrs != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by ExpectParams functions")
	}

	mmReceive.defaultExpectation.params = &NotificationServiceHandlerMockReceiveParams{ctx, pp1, pp2}
	mmReceive.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReceive.expectations {
		if minimock.Equal(e.params, mmReceive.defaultExpectation.params) {
			mmReceive.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReceive.defaultExpectation.params)
		}
	}

	return mmReceive
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.Receive
func (mmReceive *mNotificationServiceHandlerMockReceive) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.ctx = &ctx
	mmReceive.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReceive
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.Receive
func (mmReceive *mNotificationServiceHandlerMockReceive) ExpectPp1Param2(pp1 *connect.Request[v1.ReceiveRequest]) *mNotificationServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReceive.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReceive
}

// ExpectPp2Param3 sets up expected param pp2 for NotificationServiceHandler.Receive
func (mmReceive *mNotificationServiceHandlerMockReceive) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ReceiveResponse]) *mNotificationServiceHandlerMockReceive {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceHandlerMockReceiveExpectation{}
	}

	if mmReceive.defaultExpectation.params != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Expect")
	}

	if mmReceive.defaultExpectation.paramPtrs == nil {
		mmReceive.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockReceiveParamPtrs{}
	}
	mmReceive.defaultExpectation.paramPtrs.pp2 = &pp2
	mmReceive.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmReceive
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.Receive
func (mmReceive *mNotificationServiceHandlerMockReceive) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse])) *mNotificationServiceHandlerMockReceive {
	if mmReceive.mock.inspectFuncReceive != nil {
		mmReceive.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.Receive")
	}

	mmReceive.mock.inspectFuncReceive = f

	return mmReceive
}

// Return sets up results that will be returned by NotificationServiceHandler.Receive
func (mmReceive *mNotificationServiceHandlerMockReceive) Return(err error) *NotificationServiceHandlerMock {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Set")
	}

	if mmReceive.defaultExpectation == nil {
		mmReceive.defaultExpectation = &NotificationServiceHandlerMockReceiveExpectation{mock: mmReceive.mock}
	}
	mmReceive.defaultExpectation.results = &NotificationServiceHandlerMockReceiveResults{err}
	mmReceive.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// Set uses given function f to mock the NotificationServiceHandler.Receive method
func (mmReceive *mNotificationServiceHandlerMockReceive) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse]) (err error)) *NotificationServiceHandlerMock {
	if mmReceive.defaultExpectation != nil {
		mmReceive.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.Receive method")
	}

	if len(mmReceive.expectations) > 0 {
		mmReceive.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.Receive method")
	}

	mmReceive.mock.funcReceive = f
	mmReceive.mock.funcReceiveOrigin = minimock.CallerInfo(1)
	return mmReceive.mock
}

// When sets expectation for the NotificationServiceHandler.Receive which will trigger the result defined by the following
// Then helper
func (mmReceive *mNotificationServiceHandlerMockReceive) When(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse]) *NotificationServiceHandlerMockReceiveExpectation {
	if mmReceive.mock.funcReceive != nil {
		mmReceive.mock.t.Fatalf("NotificationServiceHandlerMock.Receive mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockReceiveExpectation{
		mock:               mmReceive.mock,
		params:             &NotificationServiceHandlerMockReceiveParams{ctx, pp1, pp2},
		expectationOrigins: NotificationServiceHandlerMockReceiveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReceive.expectations = append(mmReceive.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.Receive return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockReceiveExpectation) Then(err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockReceiveResults{err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.Receive should be invoked
func (mmReceive *mNotificationServiceHandlerMockReceive) Times(n uint64) *mNotificationServiceHandlerMockReceive {
	if n == 0 {
		mmReceive.mock.t.Fatalf("Times of NotificationServiceHandlerMock.Receive mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReceive.expectedInvocations, n)
	mmReceive.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReceive
}

func (mmReceive *mNotificationServiceHandlerMockReceive) invocationsDone() bool {
	if len(mmReceive.expectations) == 0 && mmReceive.defaultExpectation == nil && mmReceive.mock.funcReceive == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReceive.mock.afterReceiveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReceive.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Receive implements mm_notificationv1connect.NotificationServiceHandler
func (mmReceive *NotificationServiceHandlerMock) Receive(ctx context.Context, pp1 *connect.Request[v1.ReceiveRequest], pp2 *connect.ServerStream[v1.ReceiveResponse]) (err error) {
	mm_atomic.AddUint64(&mmReceive.beforeReceiveCounter, 1)
	defer mm_atomic.AddUint64(&mmReceive.afterReceiveCounter, 1)

	mmReceive.t.Helper()

	if mmReceive.inspectFuncReceive != nil {
		mmReceive.inspectFuncReceive(ctx, pp1, pp2)
	}

	mm_params := NotificationServiceHandlerMockReceiveParams{ctx, pp1, pp2}

	// Record call args
	mmReceive.ReceiveMock.mutex.Lock()
	mmReceive.ReceiveMock.callArgs = append(mmReceive.ReceiveMock.callArgs, &mm_params)
	mmReceive.ReceiveMock.mutex.Unlock()

	for _, e := range mmReceive.ReceiveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReceive.ReceiveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReceive.ReceiveMock.defaultExpectation.Counter, 1)
		mm_want := mmReceive.ReceiveMock.defaultExpectation.params
		mm_want_ptrs := mmReceive.ReceiveMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockReceiveParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReceive.t.Errorf("NotificationServiceHandlerMock.Receive got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReceive.t.Errorf("NotificationServiceHandlerMock.Receive got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmReceive.t.Errorf("NotificationServiceHandlerMock.Receive got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReceive.t.Errorf("NotificationServiceHandlerMock.Receive got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReceive.ReceiveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReceive.ReceiveMock.defaultExpectation.results
		if mm_results == nil {
			mmReceive.t.Fatal("No results are set for the NotificationServiceHandlerMock.Receive")
		}
		return (*mm_results).err
	}
	if mmReceive.funcReceive != nil {
		return mmReceive.funcReceive(ctx, pp1, pp2)
	}
	mmReceive.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.Receive. %v %v %v", ctx, pp1, pp2)
	return
}

// ReceiveAfterCounter returns a count of finished NotificationServiceHandlerMock.Receive invocations
func (mmReceive *NotificationServiceHandlerMock) ReceiveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.afterReceiveCounter)
}

// ReceiveBeforeCounter returns a count of NotificationServiceHandlerMock.Receive invocations
func (mmReceive *NotificationServiceHandlerMock) ReceiveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReceive.beforeReceiveCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.Receive.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReceive *mNotificationServiceHandlerMockReceive) Calls() []*NotificationServiceHandlerMockReceiveParams {
	mmReceive.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockReceiveParams, len(mmReceive.callArgs))
	copy(argCopy, mmReceive.callArgs)

	mmReceive.mutex.RUnlock()

	return argCopy
}

// MinimockReceiveDone returns true if the count of the Receive invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockReceiveDone() bool {
	if m.ReceiveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReceiveMock.invocationsDone()
}

// MinimockReceiveInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockReceiveInspect() {
	for _, e := range m.ReceiveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Receive at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReceiveCounter := mm_atomic.LoadUint64(&m.afterReceiveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReceiveMock.defaultExpectation != nil && afterReceiveCounter < 1 {
		if m.ReceiveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Receive at\n%s", m.ReceiveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Receive at\n%s with params: %#v", m.ReceiveMock.defaultExpectation.expectationOrigins.origin, *m.ReceiveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReceive != nil && afterReceiveCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.Receive at\n%s", m.funcReceiveOrigin)
	}

	if !m.ReceiveMock.invocationsDone() && afterReceiveCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.Receive at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReceiveMock.expectedInvocations), m.ReceiveMock.expectedInvocationsOrigin, afterReceiveCounter)
	}
}

type mNotificationServiceHandlerMockRelease struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockReleaseExpectation
	expectations       []*NotificationServiceHandlerMockReleaseExpectation

	callArgs []*NotificationServiceHandlerMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockReleaseExpectation specifies expectation struct of the NotificationServiceHandler.Release
type NotificationServiceHandlerMockReleaseExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockReleaseParams
	paramPtrs          *NotificationServiceHandlerMockReleaseParamPtrs
	expectationOrigins NotificationServiceHandlerMockReleaseExpectationOrigins
	results            *NotificationServiceHandlerMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockReleaseParams contains parameters of the NotificationServiceHandler.Release
type NotificationServiceHandlerMockReleaseParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ReleaseRequest]
	pp2 *connect.ServerStream[v1.ReleaseResponse]
}

// NotificationServiceHandlerMockReleaseParamPtrs contains pointers to parameters of the NotificationServiceHandler.Release
type NotificationServiceHandlerMockReleaseParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ReleaseRequest]
	pp2 **connect.ServerStream[v1.ReleaseResponse]
}

// NotificationServiceHandlerMockReleaseResults contains results of the NotificationServiceHandler.Release
type NotificationServiceHandlerMockReleaseResults struct {
	err error
}

// NotificationServiceHandlerMockReleaseOrigins contains origins of expectations of the NotificationServiceHandler.Release
type NotificationServiceHandlerMockReleaseExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mNotificationServiceHandlerMockRelease) Optional() *mNotificationServiceHandlerMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for NotificationServiceHandler.Release
func (mmRelease *mNotificationServiceHandlerMockRelease) Expect(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse]) *mNotificationServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &NotificationServiceHandlerMockReleaseParams{ctx, pp1, pp2}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.Release
func (mmRelease *mNotificationServiceHandlerMockRelease) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.Release
func (mmRelease *mNotificationServiceHandlerMockRelease) ExpectPp1Param2(pp1 *connect.Request[v1.ReleaseRequest]) *mNotificationServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRelease.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectPp2Param3 sets up expected param pp2 for NotificationServiceHandler.Release
func (mmRelease *mNotificationServiceHandlerMockRelease) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ReleaseResponse]) *mNotificationServiceHandlerMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceHandlerMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.pp2 = &pp2
	mmRelease.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.Release
func (mmRelease *mNotificationServiceHandlerMockRelease) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse])) *mNotificationServiceHandlerMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by NotificationServiceHandler.Release
func (mmRelease *mNotificationServiceHandlerMockRelease) Return(err error) *NotificationServiceHandlerMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &NotificationServiceHandlerMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &NotificationServiceHandlerMockReleaseResults{err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the NotificationServiceHandler.Release method
func (mmRelease *mNotificationServiceHandlerMockRelease) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse]) (err error)) *NotificationServiceHandlerMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the NotificationServiceHandler.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mNotificationServiceHandlerMockRelease) When(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse]) *NotificationServiceHandlerMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("NotificationServiceHandlerMock.Release mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &NotificationServiceHandlerMockReleaseParams{ctx, pp1, pp2},
		expectationOrigins: NotificationServiceHandlerMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.Release return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockReleaseExpectation) Then(err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockReleaseResults{err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.Release should be invoked
func (mmRelease *mNotificationServiceHandlerMockRelease) Times(n uint64) *mNotificationServiceHandlerMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of NotificationServiceHandlerMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mNotificationServiceHandlerMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_notificationv1connect.NotificationServiceHandler
func (mmRelease *NotificationServiceHandlerMock) Release(ctx context.Context, pp1 *connect.Request[v1.ReleaseRequest], pp2 *connect.ServerStream[v1.ReleaseResponse]) (err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, pp1, pp2)
	}

	mm_params := NotificationServiceHandlerMockReleaseParams{ctx, pp1, pp2}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockReleaseParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("NotificationServiceHandlerMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRelease.t.Errorf("NotificationServiceHandlerMock.Release got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmRelease.t.Errorf("NotificationServiceHandlerMock.Release got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("NotificationServiceHandlerMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the NotificationServiceHandlerMock.Release")
		}
		return (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, pp1, pp2)
	}
	mmRelease.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.Release. %v %v %v", ctx, pp1, pp2)
	return
}

// ReleaseAfterCounter returns a count of finished NotificationServiceHandlerMock.Release invocations
func (mmRelease *NotificationServiceHandlerMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of NotificationServiceHandlerMock.Release invocations
func (mmRelease *NotificationServiceHandlerMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mNotificationServiceHandlerMockRelease) Calls() []*NotificationServiceHandlerMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mNotificationServiceHandlerMockSearch struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockSearchExpectation
	expectations       []*NotificationServiceHandlerMockSearchExpectation

	callArgs []*NotificationServiceHandlerMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockSearchExpectation specifies expectation struct of the NotificationServiceHandler.Search
type NotificationServiceHandlerMockSearchExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockSearchParams
	paramPtrs          *NotificationServiceHandlerMockSearchParamPtrs
	expectationOrigins NotificationServiceHandlerMockSearchExpectationOrigins
	results            *NotificationServiceHandlerMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockSearchParams contains parameters of the NotificationServiceHandler.Search
type NotificationServiceHandlerMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
	pp2 *connect.ServerStream[v1.SearchResponse]
}

// NotificationServiceHandlerMockSearchParamPtrs contains pointers to parameters of the NotificationServiceHandler.Search
type NotificationServiceHandlerMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
	pp2 **connect.ServerStream[v1.SearchResponse]
}

// NotificationServiceHandlerMockSearchResults contains results of the NotificationServiceHandler.Search
type NotificationServiceHandlerMockSearchResults struct {
	err error
}

// NotificationServiceHandlerMockSearchOrigins contains origins of expectations of the NotificationServiceHandler.Search
type NotificationServiceHandlerMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mNotificationServiceHandlerMockSearch) Optional() *mNotificationServiceHandlerMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for NotificationServiceHandler.Search
func (mmSearch *mNotificationServiceHandlerMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) *mNotificationServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &NotificationServiceHandlerMockSearchParams{ctx, pp1, pp2}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.Search
func (mmSearch *mNotificationServiceHandlerMockSearch) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.Search
func (mmSearch *mNotificationServiceHandlerMockSearch) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mNotificationServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp2Param3 sets up expected param pp2 for NotificationServiceHandler.Search
func (mmSearch *mNotificationServiceHandlerMockSearch) ExpectPp2Param3(pp2 *connect.ServerStream[v1.SearchResponse]) *mNotificationServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearch.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.Search
func (mmSearch *mNotificationServiceHandlerMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse])) *mNotificationServiceHandlerMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by NotificationServiceHandler.Search
func (mmSearch *mNotificationServiceHandlerMockSearch) Return(err error) *NotificationServiceHandlerMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &NotificationServiceHandlerMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &NotificationServiceHandlerMockSearchResults{err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the NotificationServiceHandler.Search method
func (mmSearch *mNotificationServiceHandlerMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error)) *NotificationServiceHandlerMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the NotificationServiceHandler.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mNotificationServiceHandlerMockSearch) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) *NotificationServiceHandlerMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("NotificationServiceHandlerMock.Search mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &NotificationServiceHandlerMockSearchParams{ctx, pp1, pp2},
		expectationOrigins: NotificationServiceHandlerMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.Search return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockSearchExpectation) Then(err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockSearchResults{err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.Search should be invoked
func (mmSearch *mNotificationServiceHandlerMockSearch) Times(n uint64) *mNotificationServiceHandlerMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of NotificationServiceHandlerMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mNotificationServiceHandlerMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_notificationv1connect.NotificationServiceHandler
func (mmSearch *NotificationServiceHandlerMock) Search(ctx context.Context, pp1 *connect.Request[v11.SearchRequest], pp2 *connect.ServerStream[v1.SearchResponse]) (err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1, pp2)
	}

	mm_params := NotificationServiceHandlerMockSearchParams{ctx, pp1, pp2}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockSearchParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("NotificationServiceHandlerMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("NotificationServiceHandlerMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearch.t.Errorf("NotificationServiceHandlerMock.Search got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("NotificationServiceHandlerMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the NotificationServiceHandlerMock.Search")
		}
		return (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1, pp2)
	}
	mmSearch.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.Search. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchAfterCounter returns a count of finished NotificationServiceHandlerMock.Search invocations
func (mmSearch *NotificationServiceHandlerMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of NotificationServiceHandlerMock.Search invocations
func (mmSearch *NotificationServiceHandlerMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mNotificationServiceHandlerMockSearch) Calls() []*NotificationServiceHandlerMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

type mNotificationServiceHandlerMockSend struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockSendExpectation
	expectations       []*NotificationServiceHandlerMockSendExpectation

	callArgs []*NotificationServiceHandlerMockSendParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockSendExpectation specifies expectation struct of the NotificationServiceHandler.Send
type NotificationServiceHandlerMockSendExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockSendParams
	paramPtrs          *NotificationServiceHandlerMockSendParamPtrs
	expectationOrigins NotificationServiceHandlerMockSendExpectationOrigins
	results            *NotificationServiceHandlerMockSendResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockSendParams contains parameters of the NotificationServiceHandler.Send
type NotificationServiceHandlerMockSendParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SendRequest]
	pp2 *connect.ServerStream[v1.SendResponse]
}

// NotificationServiceHandlerMockSendParamPtrs contains pointers to parameters of the NotificationServiceHandler.Send
type NotificationServiceHandlerMockSendParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SendRequest]
	pp2 **connect.ServerStream[v1.SendResponse]
}

// NotificationServiceHandlerMockSendResults contains results of the NotificationServiceHandler.Send
type NotificationServiceHandlerMockSendResults struct {
	err error
}

// NotificationServiceHandlerMockSendOrigins contains origins of expectations of the NotificationServiceHandler.Send
type NotificationServiceHandlerMockSendExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSend *mNotificationServiceHandlerMockSend) Optional() *mNotificationServiceHandlerMockSend {
	mmSend.optional = true
	return mmSend
}

// Expect sets up expected params for NotificationServiceHandler.Send
func (mmSend *mNotificationServiceHandlerMockSend) Expect(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse]) *mNotificationServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.paramPtrs != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by ExpectParams functions")
	}

	mmSend.defaultExpectation.params = &NotificationServiceHandlerMockSendParams{ctx, pp1, pp2}
	mmSend.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.Send
func (mmSend *mNotificationServiceHandlerMockSend) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.ctx = &ctx
	mmSend.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSend
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.Send
func (mmSend *mNotificationServiceHandlerMockSend) ExpectPp1Param2(pp1 *connect.Request[v1.SendRequest]) *mNotificationServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSend.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSend
}

// ExpectPp2Param3 sets up expected param pp2 for NotificationServiceHandler.Send
func (mmSend *mNotificationServiceHandlerMockSend) ExpectPp2Param3(pp2 *connect.ServerStream[v1.SendResponse]) *mNotificationServiceHandlerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceHandlerMockSendExpectation{}
	}

	if mmSend.defaultExpectation.params != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Expect")
	}

	if mmSend.defaultExpectation.paramPtrs == nil {
		mmSend.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockSendParamPtrs{}
	}
	mmSend.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSend.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.Send
func (mmSend *mNotificationServiceHandlerMockSend) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse])) *mNotificationServiceHandlerMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by NotificationServiceHandler.Send
func (mmSend *mNotificationServiceHandlerMockSend) Return(err error) *NotificationServiceHandlerMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &NotificationServiceHandlerMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &NotificationServiceHandlerMockSendResults{err}
	mmSend.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// Set uses given function f to mock the NotificationServiceHandler.Send method
func (mmSend *mNotificationServiceHandlerMockSend) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse]) (err error)) *NotificationServiceHandlerMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.Send method")
	}

	mmSend.mock.funcSend = f
	mmSend.mock.funcSendOrigin = minimock.CallerInfo(1)
	return mmSend.mock
}

// When sets expectation for the NotificationServiceHandler.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mNotificationServiceHandlerMockSend) When(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse]) *NotificationServiceHandlerMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("NotificationServiceHandlerMock.Send mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockSendExpectation{
		mock:               mmSend.mock,
		params:             &NotificationServiceHandlerMockSendParams{ctx, pp1, pp2},
		expectationOrigins: NotificationServiceHandlerMockSendExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.Send return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockSendExpectation) Then(err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockSendResults{err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.Send should be invoked
func (mmSend *mNotificationServiceHandlerMockSend) Times(n uint64) *mNotificationServiceHandlerMockSend {
	if n == 0 {
		mmSend.mock.t.Fatalf("Times of NotificationServiceHandlerMock.Send mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSend.expectedInvocations, n)
	mmSend.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSend
}

func (mmSend *mNotificationServiceHandlerMockSend) invocationsDone() bool {
	if len(mmSend.expectations) == 0 && mmSend.defaultExpectation == nil && mmSend.mock.funcSend == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSend.mock.afterSendCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSend.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Send implements mm_notificationv1connect.NotificationServiceHandler
func (mmSend *NotificationServiceHandlerMock) Send(ctx context.Context, pp1 *connect.Request[v1.SendRequest], pp2 *connect.ServerStream[v1.SendResponse]) (err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	mmSend.t.Helper()

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(ctx, pp1, pp2)
	}

	mm_params := NotificationServiceHandlerMockSendParams{ctx, pp1, pp2}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, &mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_want_ptrs := mmSend.SendMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockSendParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSend.t.Errorf("NotificationServiceHandlerMock.Send got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSend.t.Errorf("NotificationServiceHandlerMock.Send got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSend.t.Errorf("NotificationServiceHandlerMock.Send got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSend.SendMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("NotificationServiceHandlerMock.Send got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSend.SendMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the NotificationServiceHandlerMock.Send")
		}
		return (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(ctx, pp1, pp2)
	}
	mmSend.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.Send. %v %v %v", ctx, pp1, pp2)
	return
}

// SendAfterCounter returns a count of finished NotificationServiceHandlerMock.Send invocations
func (mmSend *NotificationServiceHandlerMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of NotificationServiceHandlerMock.Send invocations
func (mmSend *NotificationServiceHandlerMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mNotificationServiceHandlerMockSend) Calls() []*NotificationServiceHandlerMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockSendDone() bool {
	if m.SendMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMock.invocationsDone()
}

// MinimockSendInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Send at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendCounter := mm_atomic.LoadUint64(&m.afterSendCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && afterSendCounter < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Send at\n%s", m.SendMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Send at\n%s with params: %#v", m.SendMock.defaultExpectation.expectationOrigins.origin, *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && afterSendCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.Send at\n%s", m.funcSendOrigin)
	}

	if !m.SendMock.invocationsDone() && afterSendCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.Send at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMock.expectedInvocations), m.SendMock.expectedInvocationsOrigin, afterSendCounter)
	}
}

type mNotificationServiceHandlerMockStatus struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockStatusExpectation
	expectations       []*NotificationServiceHandlerMockStatusExpectation

	callArgs []*NotificationServiceHandlerMockStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockStatusExpectation specifies expectation struct of the NotificationServiceHandler.Status
type NotificationServiceHandlerMockStatusExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockStatusParams
	paramPtrs          *NotificationServiceHandlerMockStatusParamPtrs
	expectationOrigins NotificationServiceHandlerMockStatusExpectationOrigins
	results            *NotificationServiceHandlerMockStatusResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockStatusParams contains parameters of the NotificationServiceHandler.Status
type NotificationServiceHandlerMockStatusParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusRequest]
}

// NotificationServiceHandlerMockStatusParamPtrs contains pointers to parameters of the NotificationServiceHandler.Status
type NotificationServiceHandlerMockStatusParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusRequest]
}

// NotificationServiceHandlerMockStatusResults contains results of the NotificationServiceHandler.Status
type NotificationServiceHandlerMockStatusResults struct {
	pp2 *connect.Response[v11.StatusResponse]
	err error
}

// NotificationServiceHandlerMockStatusOrigins contains origins of expectations of the NotificationServiceHandler.Status
type NotificationServiceHandlerMockStatusExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatus *mNotificationServiceHandlerMockStatus) Optional() *mNotificationServiceHandlerMockStatus {
	mmStatus.optional = true
	return mmStatus
}

// Expect sets up expected params for NotificationServiceHandler.Status
func (mmStatus *mNotificationServiceHandlerMockStatus) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *mNotificationServiceHandlerMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceHandlerMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.paramPtrs != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by ExpectParams functions")
	}

	mmStatus.defaultExpectation.params = &NotificationServiceHandlerMockStatusParams{ctx, pp1}
	mmStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatus.expectations {
		if minimock.Equal(e.params, mmStatus.defaultExpectation.params) {
			mmStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatus.defaultExpectation.params)
		}
	}

	return mmStatus
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.Status
func (mmStatus *mNotificationServiceHandlerMockStatus) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceHandlerMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatus
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.Status
func (mmStatus *mNotificationServiceHandlerMockStatus) ExpectPp1Param2(pp1 *connect.Request[v11.StatusRequest]) *mNotificationServiceHandlerMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceHandlerMockStatusExpectation{}
	}

	if mmStatus.defaultExpectation.params != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Expect")
	}

	if mmStatus.defaultExpectation.paramPtrs == nil {
		mmStatus.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockStatusParamPtrs{}
	}
	mmStatus.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatus.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatus
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.Status
func (mmStatus *mNotificationServiceHandlerMockStatus) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest])) *mNotificationServiceHandlerMockStatus {
	if mmStatus.mock.inspectFuncStatus != nil {
		mmStatus.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.Status")
	}

	mmStatus.mock.inspectFuncStatus = f

	return mmStatus
}

// Return sets up results that will be returned by NotificationServiceHandler.Status
func (mmStatus *mNotificationServiceHandlerMockStatus) Return(pp2 *connect.Response[v11.StatusResponse], err error) *NotificationServiceHandlerMock {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &NotificationServiceHandlerMockStatusExpectation{mock: mmStatus.mock}
	}
	mmStatus.defaultExpectation.results = &NotificationServiceHandlerMockStatusResults{pp2, err}
	mmStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// Set uses given function f to mock the NotificationServiceHandler.Status method
func (mmStatus *mNotificationServiceHandlerMockStatus) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error)) *NotificationServiceHandlerMock {
	if mmStatus.defaultExpectation != nil {
		mmStatus.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.Status method")
	}

	if len(mmStatus.expectations) > 0 {
		mmStatus.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.Status method")
	}

	mmStatus.mock.funcStatus = f
	mmStatus.mock.funcStatusOrigin = minimock.CallerInfo(1)
	return mmStatus.mock
}

// When sets expectation for the NotificationServiceHandler.Status which will trigger the result defined by the following
// Then helper
func (mmStatus *mNotificationServiceHandlerMockStatus) When(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) *NotificationServiceHandlerMockStatusExpectation {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("NotificationServiceHandlerMock.Status mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockStatusExpectation{
		mock:               mmStatus.mock,
		params:             &NotificationServiceHandlerMockStatusParams{ctx, pp1},
		expectationOrigins: NotificationServiceHandlerMockStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatus.expectations = append(mmStatus.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.Status return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockStatusExpectation) Then(pp2 *connect.Response[v11.StatusResponse], err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockStatusResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.Status should be invoked
func (mmStatus *mNotificationServiceHandlerMockStatus) Times(n uint64) *mNotificationServiceHandlerMockStatus {
	if n == 0 {
		mmStatus.mock.t.Fatalf("Times of NotificationServiceHandlerMock.Status mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatus.expectedInvocations, n)
	mmStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatus
}

func (mmStatus *mNotificationServiceHandlerMockStatus) invocationsDone() bool {
	if len(mmStatus.expectations) == 0 && mmStatus.defaultExpectation == nil && mmStatus.mock.funcStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatus.mock.afterStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Status implements mm_notificationv1connect.NotificationServiceHandler
func (mmStatus *NotificationServiceHandlerMock) Status(ctx context.Context, pp1 *connect.Request[v11.StatusRequest]) (pp2 *connect.Response[v11.StatusResponse], err error) {
	mm_atomic.AddUint64(&mmStatus.beforeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmStatus.afterStatusCounter, 1)

	mmStatus.t.Helper()

	if mmStatus.inspectFuncStatus != nil {
		mmStatus.inspectFuncStatus(ctx, pp1)
	}

	mm_params := NotificationServiceHandlerMockStatusParams{ctx, pp1}

	// Record call args
	mmStatus.StatusMock.mutex.Lock()
	mmStatus.StatusMock.callArgs = append(mmStatus.StatusMock.callArgs, &mm_params)
	mmStatus.StatusMock.mutex.Unlock()

	for _, e := range mmStatus.StatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatus.StatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatus.StatusMock.defaultExpectation.Counter, 1)
		mm_want := mmStatus.StatusMock.defaultExpectation.params
		mm_want_ptrs := mmStatus.StatusMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockStatusParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatus.t.Errorf("NotificationServiceHandlerMock.Status got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatus.t.Errorf("NotificationServiceHandlerMock.Status got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatus.StatusMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatus.t.Errorf("NotificationServiceHandlerMock.Status got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatus.StatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatus.StatusMock.defaultExpectation.results
		if mm_results == nil {
			mmStatus.t.Fatal("No results are set for the NotificationServiceHandlerMock.Status")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatus.funcStatus != nil {
		return mmStatus.funcStatus(ctx, pp1)
	}
	mmStatus.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.Status. %v %v", ctx, pp1)
	return
}

// StatusAfterCounter returns a count of finished NotificationServiceHandlerMock.Status invocations
func (mmStatus *NotificationServiceHandlerMock) StatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.afterStatusCounter)
}

// StatusBeforeCounter returns a count of NotificationServiceHandlerMock.Status invocations
func (mmStatus *NotificationServiceHandlerMock) StatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.beforeStatusCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.Status.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatus *mNotificationServiceHandlerMockStatus) Calls() []*NotificationServiceHandlerMockStatusParams {
	mmStatus.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockStatusParams, len(mmStatus.callArgs))
	copy(argCopy, mmStatus.callArgs)

	mmStatus.mutex.RUnlock()

	return argCopy
}

// MinimockStatusDone returns true if the count of the Status invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockStatusDone() bool {
	if m.StatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusMock.invocationsDone()
}

// MinimockStatusInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockStatusInspect() {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Status at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusCounter := mm_atomic.LoadUint64(&m.afterStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && afterStatusCounter < 1 {
		if m.StatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Status at\n%s", m.StatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.Status at\n%s with params: %#v", m.StatusMock.defaultExpectation.expectationOrigins.origin, *m.StatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && afterStatusCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.Status at\n%s", m.funcStatusOrigin)
	}

	if !m.StatusMock.invocationsDone() && afterStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.Status at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusMock.expectedInvocations), m.StatusMock.expectedInvocationsOrigin, afterStatusCounter)
	}
}

type mNotificationServiceHandlerMockStatusUpdate struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockStatusUpdateExpectation
	expectations       []*NotificationServiceHandlerMockStatusUpdateExpectation

	callArgs []*NotificationServiceHandlerMockStatusUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockStatusUpdateExpectation specifies expectation struct of the NotificationServiceHandler.StatusUpdate
type NotificationServiceHandlerMockStatusUpdateExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockStatusUpdateParams
	paramPtrs          *NotificationServiceHandlerMockStatusUpdateParamPtrs
	expectationOrigins NotificationServiceHandlerMockStatusUpdateExpectationOrigins
	results            *NotificationServiceHandlerMockStatusUpdateResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockStatusUpdateParams contains parameters of the NotificationServiceHandler.StatusUpdate
type NotificationServiceHandlerMockStatusUpdateParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.StatusUpdateRequest]
}

// NotificationServiceHandlerMockStatusUpdateParamPtrs contains pointers to parameters of the NotificationServiceHandler.StatusUpdate
type NotificationServiceHandlerMockStatusUpdateParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.StatusUpdateRequest]
}

// NotificationServiceHandlerMockStatusUpdateResults contains results of the NotificationServiceHandler.StatusUpdate
type NotificationServiceHandlerMockStatusUpdateResults struct {
	pp2 *connect.Response[v11.StatusUpdateResponse]
	err error
}

// NotificationServiceHandlerMockStatusUpdateOrigins contains origins of expectations of the NotificationServiceHandler.StatusUpdate
type NotificationServiceHandlerMockStatusUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Optional() *mNotificationServiceHandlerMockStatusUpdate {
	mmStatusUpdate.optional = true
	return mmStatusUpdate
}

// Expect sets up expected params for NotificationServiceHandler.StatusUpdate
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Expect(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *mNotificationServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceHandlerMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by ExpectParams functions")
	}

	mmStatusUpdate.defaultExpectation.params = &NotificationServiceHandlerMockStatusUpdateParams{ctx, pp1}
	mmStatusUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStatusUpdate.expectations {
		if minimock.Equal(e.params, mmStatusUpdate.defaultExpectation.params) {
			mmStatusUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatusUpdate.defaultExpectation.params)
		}
	}

	return mmStatusUpdate
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.StatusUpdate
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceHandlerMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmStatusUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.StatusUpdate
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) ExpectPp1Param2(pp1 *connect.Request[v11.StatusUpdateRequest]) *mNotificationServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceHandlerMockStatusUpdateExpectation{}
	}

	if mmStatusUpdate.defaultExpectation.params != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Expect")
	}

	if mmStatusUpdate.defaultExpectation.paramPtrs == nil {
		mmStatusUpdate.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockStatusUpdateParamPtrs{}
	}
	mmStatusUpdate.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStatusUpdate.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStatusUpdate
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.StatusUpdate
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest])) *mNotificationServiceHandlerMockStatusUpdate {
	if mmStatusUpdate.mock.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.StatusUpdate")
	}

	mmStatusUpdate.mock.inspectFuncStatusUpdate = f

	return mmStatusUpdate
}

// Return sets up results that will be returned by NotificationServiceHandler.StatusUpdate
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Return(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *NotificationServiceHandlerMock {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	if mmStatusUpdate.defaultExpectation == nil {
		mmStatusUpdate.defaultExpectation = &NotificationServiceHandlerMockStatusUpdateExpectation{mock: mmStatusUpdate.mock}
	}
	mmStatusUpdate.defaultExpectation.results = &NotificationServiceHandlerMockStatusUpdateResults{pp2, err}
	mmStatusUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// Set uses given function f to mock the NotificationServiceHandler.StatusUpdate method
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Set(f func(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error)) *NotificationServiceHandlerMock {
	if mmStatusUpdate.defaultExpectation != nil {
		mmStatusUpdate.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.StatusUpdate method")
	}

	if len(mmStatusUpdate.expectations) > 0 {
		mmStatusUpdate.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.StatusUpdate method")
	}

	mmStatusUpdate.mock.funcStatusUpdate = f
	mmStatusUpdate.mock.funcStatusUpdateOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate.mock
}

// When sets expectation for the NotificationServiceHandler.StatusUpdate which will trigger the result defined by the following
// Then helper
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) When(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) *NotificationServiceHandlerMockStatusUpdateExpectation {
	if mmStatusUpdate.mock.funcStatusUpdate != nil {
		mmStatusUpdate.mock.t.Fatalf("NotificationServiceHandlerMock.StatusUpdate mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockStatusUpdateExpectation{
		mock:               mmStatusUpdate.mock,
		params:             &NotificationServiceHandlerMockStatusUpdateParams{ctx, pp1},
		expectationOrigins: NotificationServiceHandlerMockStatusUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStatusUpdate.expectations = append(mmStatusUpdate.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.StatusUpdate return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockStatusUpdateExpectation) Then(pp2 *connect.Response[v11.StatusUpdateResponse], err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockStatusUpdateResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.StatusUpdate should be invoked
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Times(n uint64) *mNotificationServiceHandlerMockStatusUpdate {
	if n == 0 {
		mmStatusUpdate.mock.t.Fatalf("Times of NotificationServiceHandlerMock.StatusUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStatusUpdate.expectedInvocations, n)
	mmStatusUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStatusUpdate
}

func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) invocationsDone() bool {
	if len(mmStatusUpdate.expectations) == 0 && mmStatusUpdate.defaultExpectation == nil && mmStatusUpdate.mock.funcStatusUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.mock.afterStatusUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStatusUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StatusUpdate implements mm_notificationv1connect.NotificationServiceHandler
func (mmStatusUpdate *NotificationServiceHandlerMock) StatusUpdate(ctx context.Context, pp1 *connect.Request[v11.StatusUpdateRequest]) (pp2 *connect.Response[v11.StatusUpdateResponse], err error) {
	mm_atomic.AddUint64(&mmStatusUpdate.beforeStatusUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmStatusUpdate.afterStatusUpdateCounter, 1)

	mmStatusUpdate.t.Helper()

	if mmStatusUpdate.inspectFuncStatusUpdate != nil {
		mmStatusUpdate.inspectFuncStatusUpdate(ctx, pp1)
	}

	mm_params := NotificationServiceHandlerMockStatusUpdateParams{ctx, pp1}

	// Record call args
	mmStatusUpdate.StatusUpdateMock.mutex.Lock()
	mmStatusUpdate.StatusUpdateMock.callArgs = append(mmStatusUpdate.StatusUpdateMock.callArgs, &mm_params)
	mmStatusUpdate.StatusUpdateMock.mutex.Unlock()

	for _, e := range mmStatusUpdate.StatusUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStatusUpdate.StatusUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatusUpdate.StatusUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmStatusUpdate.StatusUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmStatusUpdate.StatusUpdateMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockStatusUpdateParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStatusUpdate.t.Errorf("NotificationServiceHandlerMock.StatusUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStatusUpdate.t.Errorf("NotificationServiceHandlerMock.StatusUpdate got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatusUpdate.t.Errorf("NotificationServiceHandlerMock.StatusUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStatusUpdate.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatusUpdate.StatusUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmStatusUpdate.t.Fatal("No results are set for the NotificationServiceHandlerMock.StatusUpdate")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStatusUpdate.funcStatusUpdate != nil {
		return mmStatusUpdate.funcStatusUpdate(ctx, pp1)
	}
	mmStatusUpdate.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.StatusUpdate. %v %v", ctx, pp1)
	return
}

// StatusUpdateAfterCounter returns a count of finished NotificationServiceHandlerMock.StatusUpdate invocations
func (mmStatusUpdate *NotificationServiceHandlerMock) StatusUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.afterStatusUpdateCounter)
}

// StatusUpdateBeforeCounter returns a count of NotificationServiceHandlerMock.StatusUpdate invocations
func (mmStatusUpdate *NotificationServiceHandlerMock) StatusUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatusUpdate.beforeStatusUpdateCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.StatusUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatusUpdate *mNotificationServiceHandlerMockStatusUpdate) Calls() []*NotificationServiceHandlerMockStatusUpdateParams {
	mmStatusUpdate.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockStatusUpdateParams, len(mmStatusUpdate.callArgs))
	copy(argCopy, mmStatusUpdate.callArgs)

	mmStatusUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockStatusUpdateDone returns true if the count of the StatusUpdate invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockStatusUpdateDone() bool {
	if m.StatusUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StatusUpdateMock.invocationsDone()
}

// MinimockStatusUpdateInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockStatusUpdateInspect() {
	for _, e := range m.StatusUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.StatusUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStatusUpdateCounter := mm_atomic.LoadUint64(&m.afterStatusUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StatusUpdateMock.defaultExpectation != nil && afterStatusUpdateCounter < 1 {
		if m.StatusUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.StatusUpdate at\n%s", m.StatusUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.StatusUpdate at\n%s with params: %#v", m.StatusUpdateMock.defaultExpectation.expectationOrigins.origin, *m.StatusUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatusUpdate != nil && afterStatusUpdateCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.StatusUpdate at\n%s", m.funcStatusUpdateOrigin)
	}

	if !m.StatusUpdateMock.invocationsDone() && afterStatusUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.StatusUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StatusUpdateMock.expectedInvocations), m.StatusUpdateMock.expectedInvocationsOrigin, afterStatusUpdateCounter)
	}
}

type mNotificationServiceHandlerMockTemplateSave struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockTemplateSaveExpectation
	expectations       []*NotificationServiceHandlerMockTemplateSaveExpectation

	callArgs []*NotificationServiceHandlerMockTemplateSaveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockTemplateSaveExpectation specifies expectation struct of the NotificationServiceHandler.TemplateSave
type NotificationServiceHandlerMockTemplateSaveExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockTemplateSaveParams
	paramPtrs          *NotificationServiceHandlerMockTemplateSaveParamPtrs
	expectationOrigins NotificationServiceHandlerMockTemplateSaveExpectationOrigins
	results            *NotificationServiceHandlerMockTemplateSaveResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockTemplateSaveParams contains parameters of the NotificationServiceHandler.TemplateSave
type NotificationServiceHandlerMockTemplateSaveParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.TemplateSaveRequest]
}

// NotificationServiceHandlerMockTemplateSaveParamPtrs contains pointers to parameters of the NotificationServiceHandler.TemplateSave
type NotificationServiceHandlerMockTemplateSaveParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.TemplateSaveRequest]
}

// NotificationServiceHandlerMockTemplateSaveResults contains results of the NotificationServiceHandler.TemplateSave
type NotificationServiceHandlerMockTemplateSaveResults struct {
	pp2 *connect.Response[v1.TemplateSaveResponse]
	err error
}

// NotificationServiceHandlerMockTemplateSaveOrigins contains origins of expectations of the NotificationServiceHandler.TemplateSave
type NotificationServiceHandlerMockTemplateSaveExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Optional() *mNotificationServiceHandlerMockTemplateSave {
	mmTemplateSave.optional = true
	return mmTemplateSave
}

// Expect sets up expected params for NotificationServiceHandler.TemplateSave
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Expect(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) *mNotificationServiceHandlerMockTemplateSave {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceHandlerMockTemplateSaveExpectation{}
	}

	if mmTemplateSave.defaultExpectation.paramPtrs != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by ExpectParams functions")
	}

	mmTemplateSave.defaultExpectation.params = &NotificationServiceHandlerMockTemplateSaveParams{ctx, pp1}
	mmTemplateSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTemplateSave.expectations {
		if minimock.Equal(e.params, mmTemplateSave.defaultExpectation.params) {
			mmTemplateSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTemplateSave.defaultExpectation.params)
		}
	}

	return mmTemplateSave
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.TemplateSave
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockTemplateSave {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceHandlerMockTemplateSaveExpectation{}
	}

	if mmTemplateSave.defaultExpectation.params != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Expect")
	}

	if mmTemplateSave.defaultExpectation.paramPtrs == nil {
		mmTemplateSave.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockTemplateSaveParamPtrs{}
	}
	mmTemplateSave.defaultExpectation.paramPtrs.ctx = &ctx
	mmTemplateSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTemplateSave
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.TemplateSave
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) ExpectPp1Param2(pp1 *connect.Request[v1.TemplateSaveRequest]) *mNotificationServiceHandlerMockTemplateSave {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceHandlerMockTemplateSaveExpectation{}
	}

	if mmTemplateSave.defaultExpectation.params != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Expect")
	}

	if mmTemplateSave.defaultExpectation.paramPtrs == nil {
		mmTemplateSave.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockTemplateSaveParamPtrs{}
	}
	mmTemplateSave.defaultExpectation.paramPtrs.pp1 = &pp1
	mmTemplateSave.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmTemplateSave
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.TemplateSave
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest])) *mNotificationServiceHandlerMockTemplateSave {
	if mmTemplateSave.mock.inspectFuncTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.TemplateSave")
	}

	mmTemplateSave.mock.inspectFuncTemplateSave = f

	return mmTemplateSave
}

// Return sets up results that will be returned by NotificationServiceHandler.TemplateSave
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Return(pp2 *connect.Response[v1.TemplateSaveResponse], err error) *NotificationServiceHandlerMock {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Set")
	}

	if mmTemplateSave.defaultExpectation == nil {
		mmTemplateSave.defaultExpectation = &NotificationServiceHandlerMockTemplateSaveExpectation{mock: mmTemplateSave.mock}
	}
	mmTemplateSave.defaultExpectation.results = &NotificationServiceHandlerMockTemplateSaveResults{pp2, err}
	mmTemplateSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTemplateSave.mock
}

// Set uses given function f to mock the NotificationServiceHandler.TemplateSave method
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Set(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) (pp2 *connect.Response[v1.TemplateSaveResponse], err error)) *NotificationServiceHandlerMock {
	if mmTemplateSave.defaultExpectation != nil {
		mmTemplateSave.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.TemplateSave method")
	}

	if len(mmTemplateSave.expectations) > 0 {
		mmTemplateSave.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.TemplateSave method")
	}

	mmTemplateSave.mock.funcTemplateSave = f
	mmTemplateSave.mock.funcTemplateSaveOrigin = minimock.CallerInfo(1)
	return mmTemplateSave.mock
}

// When sets expectation for the NotificationServiceHandler.TemplateSave which will trigger the result defined by the following
// Then helper
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) When(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) *NotificationServiceHandlerMockTemplateSaveExpectation {
	if mmTemplateSave.mock.funcTemplateSave != nil {
		mmTemplateSave.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSave mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockTemplateSaveExpectation{
		mock:               mmTemplateSave.mock,
		params:             &NotificationServiceHandlerMockTemplateSaveParams{ctx, pp1},
		expectationOrigins: NotificationServiceHandlerMockTemplateSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTemplateSave.expectations = append(mmTemplateSave.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.TemplateSave return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockTemplateSaveExpectation) Then(pp2 *connect.Response[v1.TemplateSaveResponse], err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockTemplateSaveResults{pp2, err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.TemplateSave should be invoked
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Times(n uint64) *mNotificationServiceHandlerMockTemplateSave {
	if n == 0 {
		mmTemplateSave.mock.t.Fatalf("Times of NotificationServiceHandlerMock.TemplateSave mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTemplateSave.expectedInvocations, n)
	mmTemplateSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTemplateSave
}

func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) invocationsDone() bool {
	if len(mmTemplateSave.expectations) == 0 && mmTemplateSave.defaultExpectation == nil && mmTemplateSave.mock.funcTemplateSave == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTemplateSave.mock.afterTemplateSaveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTemplateSave.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TemplateSave implements mm_notificationv1connect.NotificationServiceHandler
func (mmTemplateSave *NotificationServiceHandlerMock) TemplateSave(ctx context.Context, pp1 *connect.Request[v1.TemplateSaveRequest]) (pp2 *connect.Response[v1.TemplateSaveResponse], err error) {
	mm_atomic.AddUint64(&mmTemplateSave.beforeTemplateSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmTemplateSave.afterTemplateSaveCounter, 1)

	mmTemplateSave.t.Helper()

	if mmTemplateSave.inspectFuncTemplateSave != nil {
		mmTemplateSave.inspectFuncTemplateSave(ctx, pp1)
	}

	mm_params := NotificationServiceHandlerMockTemplateSaveParams{ctx, pp1}

	// Record call args
	mmTemplateSave.TemplateSaveMock.mutex.Lock()
	mmTemplateSave.TemplateSaveMock.callArgs = append(mmTemplateSave.TemplateSaveMock.callArgs, &mm_params)
	mmTemplateSave.TemplateSaveMock.mutex.Unlock()

	for _, e := range mmTemplateSave.TemplateSaveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmTemplateSave.TemplateSaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTemplateSave.TemplateSaveMock.defaultExpectation.Counter, 1)
		mm_want := mmTemplateSave.TemplateSaveMock.defaultExpectation.params
		mm_want_ptrs := mmTemplateSave.TemplateSaveMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockTemplateSaveParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTemplateSave.t.Errorf("NotificationServiceHandlerMock.TemplateSave got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSave.TemplateSaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmTemplateSave.t.Errorf("NotificationServiceHandlerMock.TemplateSave got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSave.TemplateSaveMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTemplateSave.t.Errorf("NotificationServiceHandlerMock.TemplateSave got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTemplateSave.TemplateSaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTemplateSave.TemplateSaveMock.defaultExpectation.results
		if mm_results == nil {
			mmTemplateSave.t.Fatal("No results are set for the NotificationServiceHandlerMock.TemplateSave")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmTemplateSave.funcTemplateSave != nil {
		return mmTemplateSave.funcTemplateSave(ctx, pp1)
	}
	mmTemplateSave.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.TemplateSave. %v %v", ctx, pp1)
	return
}

// TemplateSaveAfterCounter returns a count of finished NotificationServiceHandlerMock.TemplateSave invocations
func (mmTemplateSave *NotificationServiceHandlerMock) TemplateSaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSave.afterTemplateSaveCounter)
}

// TemplateSaveBeforeCounter returns a count of NotificationServiceHandlerMock.TemplateSave invocations
func (mmTemplateSave *NotificationServiceHandlerMock) TemplateSaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSave.beforeTemplateSaveCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.TemplateSave.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTemplateSave *mNotificationServiceHandlerMockTemplateSave) Calls() []*NotificationServiceHandlerMockTemplateSaveParams {
	mmTemplateSave.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockTemplateSaveParams, len(mmTemplateSave.callArgs))
	copy(argCopy, mmTemplateSave.callArgs)

	mmTemplateSave.mutex.RUnlock()

	return argCopy
}

// MinimockTemplateSaveDone returns true if the count of the TemplateSave invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockTemplateSaveDone() bool {
	if m.TemplateSaveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TemplateSaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TemplateSaveMock.invocationsDone()
}

// MinimockTemplateSaveInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockTemplateSaveInspect() {
	for _, e := range m.TemplateSaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSave at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTemplateSaveCounter := mm_atomic.LoadUint64(&m.afterTemplateSaveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TemplateSaveMock.defaultExpectation != nil && afterTemplateSaveCounter < 1 {
		if m.TemplateSaveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSave at\n%s", m.TemplateSaveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSave at\n%s with params: %#v", m.TemplateSaveMock.defaultExpectation.expectationOrigins.origin, *m.TemplateSaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTemplateSave != nil && afterTemplateSaveCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSave at\n%s", m.funcTemplateSaveOrigin)
	}

	if !m.TemplateSaveMock.invocationsDone() && afterTemplateSaveCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.TemplateSave at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TemplateSaveMock.expectedInvocations), m.TemplateSaveMock.expectedInvocationsOrigin, afterTemplateSaveCounter)
	}
}

type mNotificationServiceHandlerMockTemplateSearch struct {
	optional           bool
	mock               *NotificationServiceHandlerMock
	defaultExpectation *NotificationServiceHandlerMockTemplateSearchExpectation
	expectations       []*NotificationServiceHandlerMockTemplateSearchExpectation

	callArgs []*NotificationServiceHandlerMockTemplateSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// NotificationServiceHandlerMockTemplateSearchExpectation specifies expectation struct of the NotificationServiceHandler.TemplateSearch
type NotificationServiceHandlerMockTemplateSearchExpectation struct {
	mock               *NotificationServiceHandlerMock
	params             *NotificationServiceHandlerMockTemplateSearchParams
	paramPtrs          *NotificationServiceHandlerMockTemplateSearchParamPtrs
	expectationOrigins NotificationServiceHandlerMockTemplateSearchExpectationOrigins
	results            *NotificationServiceHandlerMockTemplateSearchResults
	returnOrigin       string
	Counter            uint64
}

// NotificationServiceHandlerMockTemplateSearchParams contains parameters of the NotificationServiceHandler.TemplateSearch
type NotificationServiceHandlerMockTemplateSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.TemplateSearchRequest]
	pp2 *connect.ServerStream[v1.TemplateSearchResponse]
}

// NotificationServiceHandlerMockTemplateSearchParamPtrs contains pointers to parameters of the NotificationServiceHandler.TemplateSearch
type NotificationServiceHandlerMockTemplateSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.TemplateSearchRequest]
	pp2 **connect.ServerStream[v1.TemplateSearchResponse]
}

// NotificationServiceHandlerMockTemplateSearchResults contains results of the NotificationServiceHandler.TemplateSearch
type NotificationServiceHandlerMockTemplateSearchResults struct {
	err error
}

// NotificationServiceHandlerMockTemplateSearchOrigins contains origins of expectations of the NotificationServiceHandler.TemplateSearch
type NotificationServiceHandlerMockTemplateSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Optional() *mNotificationServiceHandlerMockTemplateSearch {
	mmTemplateSearch.optional = true
	return mmTemplateSearch
}

// Expect sets up expected params for NotificationServiceHandler.TemplateSearch
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Expect(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse]) *mNotificationServiceHandlerMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceHandlerMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by ExpectParams functions")
	}

	mmTemplateSearch.defaultExpectation.params = &NotificationServiceHandlerMockTemplateSearchParams{ctx, pp1, pp2}
	mmTemplateSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmTemplateSearch.expectations {
		if minimock.Equal(e.params, mmTemplateSearch.defaultExpectation.params) {
			mmTemplateSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTemplateSearch.defaultExpectation.params)
		}
	}

	return mmTemplateSearch
}

// ExpectCtxParam1 sets up expected param ctx for NotificationServiceHandler.TemplateSearch
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) ExpectCtxParam1(ctx context.Context) *mNotificationServiceHandlerMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceHandlerMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.params != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Expect")
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs == nil {
		mmTemplateSearch.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockTemplateSearchParamPtrs{}
	}
	mmTemplateSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmTemplateSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmTemplateSearch
}

// ExpectPp1Param2 sets up expected param pp1 for NotificationServiceHandler.TemplateSearch
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) ExpectPp1Param2(pp1 *connect.Request[v1.TemplateSearchRequest]) *mNotificationServiceHandlerMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceHandlerMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.params != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Expect")
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs == nil {
		mmTemplateSearch.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockTemplateSearchParamPtrs{}
	}
	mmTemplateSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmTemplateSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmTemplateSearch
}

// ExpectPp2Param3 sets up expected param pp2 for NotificationServiceHandler.TemplateSearch
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) ExpectPp2Param3(pp2 *connect.ServerStream[v1.TemplateSearchResponse]) *mNotificationServiceHandlerMockTemplateSearch {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceHandlerMockTemplateSearchExpectation{}
	}

	if mmTemplateSearch.defaultExpectation.params != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Expect")
	}

	if mmTemplateSearch.defaultExpectation.paramPtrs == nil {
		mmTemplateSearch.defaultExpectation.paramPtrs = &NotificationServiceHandlerMockTemplateSearchParamPtrs{}
	}
	mmTemplateSearch.defaultExpectation.paramPtrs.pp2 = &pp2
	mmTemplateSearch.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmTemplateSearch
}

// Inspect accepts an inspector function that has same arguments as the NotificationServiceHandler.TemplateSearch
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse])) *mNotificationServiceHandlerMockTemplateSearch {
	if mmTemplateSearch.mock.inspectFuncTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("Inspect function is already set for NotificationServiceHandlerMock.TemplateSearch")
	}

	mmTemplateSearch.mock.inspectFuncTemplateSearch = f

	return mmTemplateSearch
}

// Return sets up results that will be returned by NotificationServiceHandler.TemplateSearch
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Return(err error) *NotificationServiceHandlerMock {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Set")
	}

	if mmTemplateSearch.defaultExpectation == nil {
		mmTemplateSearch.defaultExpectation = &NotificationServiceHandlerMockTemplateSearchExpectation{mock: mmTemplateSearch.mock}
	}
	mmTemplateSearch.defaultExpectation.results = &NotificationServiceHandlerMockTemplateSearchResults{err}
	mmTemplateSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTemplateSearch.mock
}

// Set uses given function f to mock the NotificationServiceHandler.TemplateSearch method
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse]) (err error)) *NotificationServiceHandlerMock {
	if mmTemplateSearch.defaultExpectation != nil {
		mmTemplateSearch.mock.t.Fatalf("Default expectation is already set for the NotificationServiceHandler.TemplateSearch method")
	}

	if len(mmTemplateSearch.expectations) > 0 {
		mmTemplateSearch.mock.t.Fatalf("Some expectations are already set for the NotificationServiceHandler.TemplateSearch method")
	}

	mmTemplateSearch.mock.funcTemplateSearch = f
	mmTemplateSearch.mock.funcTemplateSearchOrigin = minimock.CallerInfo(1)
	return mmTemplateSearch.mock
}

// When sets expectation for the NotificationServiceHandler.TemplateSearch which will trigger the result defined by the following
// Then helper
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) When(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse]) *NotificationServiceHandlerMockTemplateSearchExpectation {
	if mmTemplateSearch.mock.funcTemplateSearch != nil {
		mmTemplateSearch.mock.t.Fatalf("NotificationServiceHandlerMock.TemplateSearch mock is already set by Set")
	}

	expectation := &NotificationServiceHandlerMockTemplateSearchExpectation{
		mock:               mmTemplateSearch.mock,
		params:             &NotificationServiceHandlerMockTemplateSearchParams{ctx, pp1, pp2},
		expectationOrigins: NotificationServiceHandlerMockTemplateSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmTemplateSearch.expectations = append(mmTemplateSearch.expectations, expectation)
	return expectation
}

// Then sets up NotificationServiceHandler.TemplateSearch return parameters for the expectation previously defined by the When method
func (e *NotificationServiceHandlerMockTemplateSearchExpectation) Then(err error) *NotificationServiceHandlerMock {
	e.results = &NotificationServiceHandlerMockTemplateSearchResults{err}
	return e.mock
}

// Times sets number of times NotificationServiceHandler.TemplateSearch should be invoked
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Times(n uint64) *mNotificationServiceHandlerMockTemplateSearch {
	if n == 0 {
		mmTemplateSearch.mock.t.Fatalf("Times of NotificationServiceHandlerMock.TemplateSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTemplateSearch.expectedInvocations, n)
	mmTemplateSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTemplateSearch
}

func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) invocationsDone() bool {
	if len(mmTemplateSearch.expectations) == 0 && mmTemplateSearch.defaultExpectation == nil && mmTemplateSearch.mock.funcTemplateSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTemplateSearch.mock.afterTemplateSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTemplateSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TemplateSearch implements mm_notificationv1connect.NotificationServiceHandler
func (mmTemplateSearch *NotificationServiceHandlerMock) TemplateSearch(ctx context.Context, pp1 *connect.Request[v1.TemplateSearchRequest], pp2 *connect.ServerStream[v1.TemplateSearchResponse]) (err error) {
	mm_atomic.AddUint64(&mmTemplateSearch.beforeTemplateSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmTemplateSearch.afterTemplateSearchCounter, 1)

	mmTemplateSearch.t.Helper()

	if mmTemplateSearch.inspectFuncTemplateSearch != nil {
		mmTemplateSearch.inspectFuncTemplateSearch(ctx, pp1, pp2)
	}

	mm_params := NotificationServiceHandlerMockTemplateSearchParams{ctx, pp1, pp2}

	// Record call args
	mmTemplateSearch.TemplateSearchMock.mutex.Lock()
	mmTemplateSearch.TemplateSearchMock.callArgs = append(mmTemplateSearch.TemplateSearchMock.callArgs, &mm_params)
	mmTemplateSearch.TemplateSearchMock.mutex.Unlock()

	for _, e := range mmTemplateSearch.TemplateSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTemplateSearch.TemplateSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTemplateSearch.TemplateSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmTemplateSearch.TemplateSearchMock.defaultExpectation.params
		mm_want_ptrs := mmTemplateSearch.TemplateSearchMock.defaultExpectation.paramPtrs

		mm_got := NotificationServiceHandlerMockTemplateSearchParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmTemplateSearch.t.Errorf("NotificationServiceHandlerMock.TemplateSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmTemplateSearch.t.Errorf("NotificationServiceHandlerMock.TemplateSearch got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmTemplateSearch.t.Errorf("NotificationServiceHandlerMock.TemplateSearch got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTemplateSearch.t.Errorf("NotificationServiceHandlerMock.TemplateSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmTemplateSearch.TemplateSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTemplateSearch.TemplateSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmTemplateSearch.t.Fatal("No results are set for the NotificationServiceHandlerMock.TemplateSearch")
		}
		return (*mm_results).err
	}
	if mmTemplateSearch.funcTemplateSearch != nil {
		return mmTemplateSearch.funcTemplateSearch(ctx, pp1, pp2)
	}
	mmTemplateSearch.t.Fatalf("Unexpected call to NotificationServiceHandlerMock.TemplateSearch. %v %v %v", ctx, pp1, pp2)
	return
}

// TemplateSearchAfterCounter returns a count of finished NotificationServiceHandlerMock.TemplateSearch invocations
func (mmTemplateSearch *NotificationServiceHandlerMock) TemplateSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSearch.afterTemplateSearchCounter)
}

// TemplateSearchBeforeCounter returns a count of NotificationServiceHandlerMock.TemplateSearch invocations
func (mmTemplateSearch *NotificationServiceHandlerMock) TemplateSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTemplateSearch.beforeTemplateSearchCounter)
}

// Calls returns a list of arguments used in each call to NotificationServiceHandlerMock.TemplateSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTemplateSearch *mNotificationServiceHandlerMockTemplateSearch) Calls() []*NotificationServiceHandlerMockTemplateSearchParams {
	mmTemplateSearch.mutex.RLock()

	argCopy := make([]*NotificationServiceHandlerMockTemplateSearchParams, len(mmTemplateSearch.callArgs))
	copy(argCopy, mmTemplateSearch.callArgs)

	mmTemplateSearch.mutex.RUnlock()

	return argCopy
}

// MinimockTemplateSearchDone returns true if the count of the TemplateSearch invocations corresponds
// the number of defined expectations
func (m *NotificationServiceHandlerMock) MinimockTemplateSearchDone() bool {
	if m.TemplateSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TemplateSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TemplateSearchMock.invocationsDone()
}

// MinimockTemplateSearchInspect logs each unmet expectation
func (m *NotificationServiceHandlerMock) MinimockTemplateSearchInspect() {
	for _, e := range m.TemplateSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterTemplateSearchCounter := mm_atomic.LoadUint64(&m.afterTemplateSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TemplateSearchMock.defaultExpectation != nil && afterTemplateSearchCounter < 1 {
		if m.TemplateSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSearch at\n%s", m.TemplateSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSearch at\n%s with params: %#v", m.TemplateSearchMock.defaultExpectation.expectationOrigins.origin, *m.TemplateSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTemplateSearch != nil && afterTemplateSearchCounter < 1 {
		m.t.Errorf("Expected call to NotificationServiceHandlerMock.TemplateSearch at\n%s", m.funcTemplateSearchOrigin)
	}

	if !m.TemplateSearchMock.invocationsDone() && afterTemplateSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to NotificationServiceHandlerMock.TemplateSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TemplateSearchMock.expectedInvocations), m.TemplateSearchMock.expectedInvocationsOrigin, afterTemplateSearchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NotificationServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockReceiveInspect()

			m.MinimockReleaseInspect()

			m.MinimockSearchInspect()

			m.MinimockSendInspect()

			m.MinimockStatusInspect()

			m.MinimockStatusUpdateInspect()

			m.MinimockTemplateSaveInspect()

			m.MinimockTemplateSearchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NotificationServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NotificationServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockReceiveDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockSearchDone() &&
		m.MinimockSendDone() &&
		m.MinimockStatusDone() &&
		m.MinimockStatusUpdateDone() &&
		m.MinimockTemplateSaveDone() &&
		m.MinimockTemplateSearchDone()
}
