// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	commonv1 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	"buf.build/gen/go/antinvestor/notification/connectrpc/go/notification/v1/notificationv1connect"
	notificationv1 "buf.build/gen/go/antinvestor/notification/protocolbuffers/go/notification/v1"
	"connectrpc.com/connect"
)

type FakeNotificationServiceHandler struct {
	ReceiveStub        func(context.Context, *connect.Request[notificationv1.ReceiveRequest], *connect.ServerStream[notificationv1.ReceiveResponse]) error
	receiveMutex       sync.RWMutex
	receiveArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.ReceiveRequest]
		arg3 *connect.ServerStream[notificationv1.ReceiveResponse]
	}
	receiveReturns struct {
		result1 error
	}
	receiveReturnsOnCall map[int]struct {
		result1 error
	}
	ReleaseStub        func(context.Context, *connect.Request[notificationv1.ReleaseRequest], *connect.ServerStream[notificationv1.ReleaseResponse]) error
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.ReleaseRequest]
		arg3 *connect.ServerStream[notificationv1.ReleaseResponse]
	}
	releaseReturns struct {
		result1 error
	}
	releaseReturnsOnCall map[int]struct {
		result1 error
	}
	SearchStub        func(context.Context, *connect.Request[commonv1.SearchRequest], *connect.ServerStream[notificationv1.SearchResponse]) error
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.SearchRequest]
		arg3 *connect.ServerStream[notificationv1.SearchResponse]
	}
	searchReturns struct {
		result1 error
	}
	searchReturnsOnCall map[int]struct {
		result1 error
	}
	SendStub        func(context.Context, *connect.Request[notificationv1.SendRequest], *connect.ServerStream[notificationv1.SendResponse]) error
	sendMutex       sync.RWMutex
	sendArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.SendRequest]
		arg3 *connect.ServerStream[notificationv1.SendResponse]
	}
	sendReturns struct {
		result1 error
	}
	sendReturnsOnCall map[int]struct {
		result1 error
	}
	StatusStub        func(context.Context, *connect.Request[commonv1.StatusRequest]) (*connect.Response[commonv1.StatusResponse], error)
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusRequest]
	}
	statusReturns struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}
	statusReturnsOnCall map[int]struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}
	StatusUpdateStub        func(context.Context, *connect.Request[commonv1.StatusUpdateRequest]) (*connect.Response[commonv1.StatusUpdateResponse], error)
	statusUpdateMutex       sync.RWMutex
	statusUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusUpdateRequest]
	}
	statusUpdateReturns struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}
	statusUpdateReturnsOnCall map[int]struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}
	TemplateSaveStub        func(context.Context, *connect.Request[notificationv1.TemplateSaveRequest]) (*connect.Response[notificationv1.TemplateSaveResponse], error)
	templateSaveMutex       sync.RWMutex
	templateSaveArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.TemplateSaveRequest]
	}
	templateSaveReturns struct {
		result1 *connect.Response[notificationv1.TemplateSaveResponse]
		result2 error
	}
	templateSaveReturnsOnCall map[int]struct {
		result1 *connect.Response[notificationv1.TemplateSaveResponse]
		result2 error
	}
	TemplateSearchStub        func(context.Context, *connect.Request[notificationv1.TemplateSearchRequest], *connect.ServerStream[notificationv1.TemplateSearchResponse]) error
	templateSearchMutex       sync.RWMutex
	templateSearchArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.TemplateSearchRequest]
		arg3 *connect.ServerStream[notificationv1.TemplateSearchResponse]
	}
	templateSearchReturns struct {
		result1 error
	}
	templateSearchReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNotificationServiceHandler) Receive(arg1 context.Context, arg2 *connect.Request[notificationv1.ReceiveRequest], arg3 *connect.ServerStream[notificationv1.ReceiveResponse]) error {
	fake.receiveMutex.Lock()
	ret, specificReturn := fake.receiveReturnsOnCall[len(fake.receiveArgsForCall)]
	fake.receiveArgsForCall = append(fake.receiveArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.ReceiveRequest]
		arg3 *connect.ServerStream[notificationv1.ReceiveResponse]
	}{arg1, arg2, arg3})
	stub := fake.ReceiveStub
	fakeReturns := fake.receiveReturns
	fake.recordInvocation("Receive", []interface{}{arg1, arg2, arg3})
	fake.receiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNotificationServiceHandler) ReceiveCallCount() int {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	return len(fake.receiveArgsForCall)
}

func (fake *FakeNotificationServiceHandler) ReceiveCalls(stub func(context.Context, *connect.Request[notificationv1.ReceiveRequest], *connect.ServerStream[notificationv1.ReceiveResponse]) error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = stub
}

func (fake *FakeNotificationServiceHandler) ReceiveArgsForCall(i int) (context.Context, *connect.Request[notificationv1.ReceiveRequest], *connect.ServerStream[notificationv1.ReceiveResponse]) {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	argsForCall := fake.receiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationServiceHandler) ReceiveReturns(result1 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	fake.receiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) ReceiveReturnsOnCall(i int, result1 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	if fake.receiveReturnsOnCall == nil {
		fake.receiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.receiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) Release(arg1 context.Context, arg2 *connect.Request[notificationv1.ReleaseRequest], arg3 *connect.ServerStream[notificationv1.ReleaseResponse]) error {
	fake.releaseMutex.Lock()
	ret, specificReturn := fake.releaseReturnsOnCall[len(fake.releaseArgsForCall)]
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.ReleaseRequest]
		arg3 *connect.ServerStream[notificationv1.ReleaseResponse]
	}{arg1, arg2, arg3})
	stub := fake.ReleaseStub
	fakeReturns := fake.releaseReturns
	fake.recordInvocation("Release", []interface{}{arg1, arg2, arg3})
	fake.releaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNotificationServiceHandler) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

func (fake *FakeNotificationServiceHandler) ReleaseCalls(stub func(context.Context, *connect.Request[notificationv1.ReleaseRequest], *connect.ServerStream[notificationv1.ReleaseResponse]) error) {
	fake.releaseMutex.Lock()
	defer fake.releaseMutex.Unlock()
	fake.ReleaseStub = stub
}

func (fake *FakeNotificationServiceHandler) ReleaseArgsForCall(i int) (context.Context, *connect.Request[notificationv1.ReleaseRequest], *connect.ServerStream[notificationv1.ReleaseResponse]) {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	argsForCall := fake.releaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationServiceHandler) ReleaseReturns(result1 error) {
	fake.releaseMutex.Lock()
	defer fake.releaseMutex.Unlock()
	fake.ReleaseStub = nil
	fake.releaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) ReleaseReturnsOnCall(i int, result1 error) {
	fake.releaseMutex.Lock()
	defer fake.releaseMutex.Unlock()
	fake.ReleaseStub = nil
	if fake.releaseReturnsOnCall == nil {
		fake.releaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.releaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) Search(arg1 context.Context, arg2 *connect.Request[commonv1.SearchRequest], arg3 *connect.ServerStream[notificationv1.SearchResponse]) error {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.SearchRequest]
		arg3 *connect.ServerStream[notificationv1.SearchResponse]
	}{arg1, arg2, arg3})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1, arg2, arg3})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNotificationServiceHandler) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *FakeNotificationServiceHandler) SearchCalls(stub func(context.Context, *connect.Request[commonv1.SearchRequest], *connect.ServerStream[notificationv1.SearchResponse]) error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *FakeNotificationServiceHandler) SearchArgsForCall(i int) (context.Context, *connect.Request[commonv1.SearchRequest], *connect.ServerStream[notificationv1.SearchResponse]) {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationServiceHandler) SearchReturns(result1 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) SearchReturnsOnCall(i int, result1 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) Send(arg1 context.Context, arg2 *connect.Request[notificationv1.SendRequest], arg3 *connect.ServerStream[notificationv1.SendResponse]) error {
	fake.sendMutex.Lock()
	ret, specificReturn := fake.sendReturnsOnCall[len(fake.sendArgsForCall)]
	fake.sendArgsForCall = append(fake.sendArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.SendRequest]
		arg3 *connect.ServerStream[notificationv1.SendResponse]
	}{arg1, arg2, arg3})
	stub := fake.SendStub
	fakeReturns := fake.sendReturns
	fake.recordInvocation("Send", []interface{}{arg1, arg2, arg3})
	fake.sendMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNotificationServiceHandler) SendCallCount() int {
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	return len(fake.sendArgsForCall)
}

func (fake *FakeNotificationServiceHandler) SendCalls(stub func(context.Context, *connect.Request[notificationv1.SendRequest], *connect.ServerStream[notificationv1.SendResponse]) error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = stub
}

func (fake *FakeNotificationServiceHandler) SendArgsForCall(i int) (context.Context, *connect.Request[notificationv1.SendRequest], *connect.ServerStream[notificationv1.SendResponse]) {
	fake.sendMutex.RLock()
	defer fake.sendMutex.RUnlock()
	argsForCall := fake.sendArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationServiceHandler) SendReturns(result1 error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = nil
	fake.sendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) SendReturnsOnCall(i int, result1 error) {
	fake.sendMutex.Lock()
	defer fake.sendMutex.Unlock()
	fake.SendStub = nil
	if fake.sendReturnsOnCall == nil {
		fake.sendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) Status(arg1 context.Context, arg2 *connect.Request[commonv1.StatusRequest]) (*connect.Response[commonv1.StatusResponse], error) {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusRequest]
	}{arg1, arg2})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{arg1, arg2})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationServiceHandler) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeNotificationServiceHandler) StatusCalls(stub func(context.Context, *connect.Request[commonv1.StatusRequest]) (*connect.Response[commonv1.StatusResponse], error)) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeNotificationServiceHandler) StatusArgsForCall(i int) (context.Context, *connect.Request[commonv1.StatusRequest]) {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	argsForCall := fake.statusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNotificationServiceHandler) StatusReturns(result1 *connect.Response[commonv1.StatusResponse], result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationServiceHandler) StatusReturnsOnCall(i int, result1 *connect.Response[commonv1.StatusResponse], result2 error) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[commonv1.StatusResponse]
			result2 error
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 *connect.Response[commonv1.StatusResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationServiceHandler) StatusUpdate(arg1 context.Context, arg2 *connect.Request[commonv1.StatusUpdateRequest]) (*connect.Response[commonv1.StatusUpdateResponse], error) {
	fake.statusUpdateMutex.Lock()
	ret, specificReturn := fake.statusUpdateReturnsOnCall[len(fake.statusUpdateArgsForCall)]
	fake.statusUpdateArgsForCall = append(fake.statusUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.StatusUpdateRequest]
	}{arg1, arg2})
	stub := fake.StatusUpdateStub
	fakeReturns := fake.statusUpdateReturns
	fake.recordInvocation("StatusUpdate", []interface{}{arg1, arg2})
	fake.statusUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationServiceHandler) StatusUpdateCallCount() int {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	return len(fake.statusUpdateArgsForCall)
}

func (fake *FakeNotificationServiceHandler) StatusUpdateCalls(stub func(context.Context, *connect.Request[commonv1.StatusUpdateRequest]) (*connect.Response[commonv1.StatusUpdateResponse], error)) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = stub
}

func (fake *FakeNotificationServiceHandler) StatusUpdateArgsForCall(i int) (context.Context, *connect.Request[commonv1.StatusUpdateRequest]) {
	fake.statusUpdateMutex.RLock()
	defer fake.statusUpdateMutex.RUnlock()
	argsForCall := fake.statusUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNotificationServiceHandler) StatusUpdateReturns(result1 *connect.Response[commonv1.StatusUpdateResponse], result2 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	fake.statusUpdateReturns = struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationServiceHandler) StatusUpdateReturnsOnCall(i int, result1 *connect.Response[commonv1.StatusUpdateResponse], result2 error) {
	fake.statusUpdateMutex.Lock()
	defer fake.statusUpdateMutex.Unlock()
	fake.StatusUpdateStub = nil
	if fake.statusUpdateReturnsOnCall == nil {
		fake.statusUpdateReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[commonv1.StatusUpdateResponse]
			result2 error
		})
	}
	fake.statusUpdateReturnsOnCall[i] = struct {
		result1 *connect.Response[commonv1.StatusUpdateResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationServiceHandler) TemplateSave(arg1 context.Context, arg2 *connect.Request[notificationv1.TemplateSaveRequest]) (*connect.Response[notificationv1.TemplateSaveResponse], error) {
	fake.templateSaveMutex.Lock()
	ret, specificReturn := fake.templateSaveReturnsOnCall[len(fake.templateSaveArgsForCall)]
	fake.templateSaveArgsForCall = append(fake.templateSaveArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.TemplateSaveRequest]
	}{arg1, arg2})
	stub := fake.TemplateSaveStub
	fakeReturns := fake.templateSaveReturns
	fake.recordInvocation("TemplateSave", []interface{}{arg1, arg2})
	fake.templateSaveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNotificationServiceHandler) TemplateSaveCallCount() int {
	fake.templateSaveMutex.RLock()
	defer fake.templateSaveMutex.RUnlock()
	return len(fake.templateSaveArgsForCall)
}

func (fake *FakeNotificationServiceHandler) TemplateSaveCalls(stub func(context.Context, *connect.Request[notificationv1.TemplateSaveRequest]) (*connect.Response[notificationv1.TemplateSaveResponse], error)) {
	fake.templateSaveMutex.Lock()
	defer fake.templateSaveMutex.Unlock()
	fake.TemplateSaveStub = stub
}

func (fake *FakeNotificationServiceHandler) TemplateSaveArgsForCall(i int) (context.Context, *connect.Request[notificationv1.TemplateSaveRequest]) {
	fake.templateSaveMutex.RLock()
	defer fake.templateSaveMutex.RUnlock()
	argsForCall := fake.templateSaveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNotificationServiceHandler) TemplateSaveReturns(result1 *connect.Response[notificationv1.TemplateSaveResponse], result2 error) {
	fake.templateSaveMutex.Lock()
	defer fake.templateSaveMutex.Unlock()
	fake.TemplateSaveStub = nil
	fake.templateSaveReturns = struct {
		result1 *connect.Response[notificationv1.TemplateSaveResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationServiceHandler) TemplateSaveReturnsOnCall(i int, result1 *connect.Response[notificationv1.TemplateSaveResponse], result2 error) {
	fake.templateSaveMutex.Lock()
	defer fake.templateSaveMutex.Unlock()
	fake.TemplateSaveStub = nil
	if fake.templateSaveReturnsOnCall == nil {
		fake.templateSaveReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[notificationv1.TemplateSaveResponse]
			result2 error
		})
	}
	fake.templateSaveReturnsOnCall[i] = struct {
		result1 *connect.Response[notificationv1.TemplateSaveResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeNotificationServiceHandler) TemplateSearch(arg1 context.Context, arg2 *connect.Request[notificationv1.TemplateSearchRequest], arg3 *connect.ServerStream[notificationv1.TemplateSearchResponse]) error {
	fake.templateSearchMutex.Lock()
	ret, specificReturn := fake.templateSearchReturnsOnCall[len(fake.templateSearchArgsForCall)]
	fake.templateSearchArgsForCall = append(fake.templateSearchArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[notificationv1.TemplateSearchRequest]
		arg3 *connect.ServerStream[notificationv1.TemplateSearchResponse]
	}{arg1, arg2, arg3})
	stub := fake.TemplateSearchStub
	fakeReturns := fake.templateSearchReturns
	fake.recordInvocation("TemplateSearch", []interface{}{arg1, arg2, arg3})
	fake.templateSearchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNotificationServiceHandler) TemplateSearchCallCount() int {
	fake.templateSearchMutex.RLock()
	defer fake.templateSearchMutex.RUnlock()
	return len(fake.templateSearchArgsForCall)
}

func (fake *FakeNotificationServiceHandler) TemplateSearchCalls(stub func(context.Context, *connect.Request[notificationv1.TemplateSearchRequest], *connect.ServerStream[notificationv1.TemplateSearchResponse]) error) {
	fake.templateSearchMutex.Lock()
	defer fake.templateSearchMutex.Unlock()
	fake.TemplateSearchStub = stub
}

func (fake *FakeNotificationServiceHandler) TemplateSearchArgsForCall(i int) (context.Context, *connect.Request[notificationv1.TemplateSearchRequest], *connect.ServerStream[notificationv1.TemplateSearchResponse]) {
	fake.templateSearchMutex.RLock()
	defer fake.templateSearchMutex.RUnlock()
	argsForCall := fake.templateSearchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeNotificationServiceHandler) TemplateSearchReturns(result1 error) {
	fake.templateSearchMutex.Lock()
	defer fake.templateSearchMutex.Unlock()
	fake.TemplateSearchStub = nil
	fake.templateSearchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) TemplateSearchReturnsOnCall(i int, result1 error) {
	fake.templateSearchMutex.Lock()
	defer fake.templateSearchMutex.Unlock()
	fake.TemplateSearchStub = nil
	if fake.templateSearchReturnsOnCall == nil {
		fake.templateSearchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.templateSearchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNotificationServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNotificationServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ notificationv1connect.NotificationServiceHandler = new(FakeNotificationServiceHandler)
