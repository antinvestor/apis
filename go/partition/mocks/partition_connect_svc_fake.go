// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"buf.build/gen/go/antinvestor/partition/connectrpc/go/partition/v1/partitionv1connect"
	partitionv1 "buf.build/gen/go/antinvestor/partition/protocolbuffers/go/partition/v1"
	"connectrpc.com/connect"
)

type FakePartitionServiceHandler struct {
	CreateAccessStub        func(context.Context, *connect.Request[partitionv1.CreateAccessRequest]) (*connect.Response[partitionv1.CreateAccessResponse], error)
	createAccessMutex       sync.RWMutex
	createAccessArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreateAccessRequest]
	}
	createAccessReturns struct {
		result1 *connect.Response[partitionv1.CreateAccessResponse]
		result2 error
	}
	createAccessReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.CreateAccessResponse]
		result2 error
	}
	CreateAccessRoleStub        func(context.Context, *connect.Request[partitionv1.CreateAccessRoleRequest]) (*connect.Response[partitionv1.CreateAccessRoleResponse], error)
	createAccessRoleMutex       sync.RWMutex
	createAccessRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreateAccessRoleRequest]
	}
	createAccessRoleReturns struct {
		result1 *connect.Response[partitionv1.CreateAccessRoleResponse]
		result2 error
	}
	createAccessRoleReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.CreateAccessRoleResponse]
		result2 error
	}
	CreatePageStub        func(context.Context, *connect.Request[partitionv1.CreatePageRequest]) (*connect.Response[partitionv1.CreatePageResponse], error)
	createPageMutex       sync.RWMutex
	createPageArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreatePageRequest]
	}
	createPageReturns struct {
		result1 *connect.Response[partitionv1.CreatePageResponse]
		result2 error
	}
	createPageReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.CreatePageResponse]
		result2 error
	}
	CreatePartitionStub        func(context.Context, *connect.Request[partitionv1.CreatePartitionRequest]) (*connect.Response[partitionv1.CreatePartitionResponse], error)
	createPartitionMutex       sync.RWMutex
	createPartitionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreatePartitionRequest]
	}
	createPartitionReturns struct {
		result1 *connect.Response[partitionv1.CreatePartitionResponse]
		result2 error
	}
	createPartitionReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.CreatePartitionResponse]
		result2 error
	}
	CreatePartitionRoleStub        func(context.Context, *connect.Request[partitionv1.CreatePartitionRoleRequest]) (*connect.Response[partitionv1.CreatePartitionRoleResponse], error)
	createPartitionRoleMutex       sync.RWMutex
	createPartitionRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreatePartitionRoleRequest]
	}
	createPartitionRoleReturns struct {
		result1 *connect.Response[partitionv1.CreatePartitionRoleResponse]
		result2 error
	}
	createPartitionRoleReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.CreatePartitionRoleResponse]
		result2 error
	}
	CreateTenantStub        func(context.Context, *connect.Request[partitionv1.CreateTenantRequest]) (*connect.Response[partitionv1.CreateTenantResponse], error)
	createTenantMutex       sync.RWMutex
	createTenantArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreateTenantRequest]
	}
	createTenantReturns struct {
		result1 *connect.Response[partitionv1.CreateTenantResponse]
		result2 error
	}
	createTenantReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.CreateTenantResponse]
		result2 error
	}
	GetAccessStub        func(context.Context, *connect.Request[partitionv1.GetAccessRequest]) (*connect.Response[partitionv1.GetAccessResponse], error)
	getAccessMutex       sync.RWMutex
	getAccessArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetAccessRequest]
	}
	getAccessReturns struct {
		result1 *connect.Response[partitionv1.GetAccessResponse]
		result2 error
	}
	getAccessReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.GetAccessResponse]
		result2 error
	}
	GetPageStub        func(context.Context, *connect.Request[partitionv1.GetPageRequest]) (*connect.Response[partitionv1.GetPageResponse], error)
	getPageMutex       sync.RWMutex
	getPageArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetPageRequest]
	}
	getPageReturns struct {
		result1 *connect.Response[partitionv1.GetPageResponse]
		result2 error
	}
	getPageReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.GetPageResponse]
		result2 error
	}
	GetPartitionStub        func(context.Context, *connect.Request[partitionv1.GetPartitionRequest]) (*connect.Response[partitionv1.GetPartitionResponse], error)
	getPartitionMutex       sync.RWMutex
	getPartitionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetPartitionRequest]
	}
	getPartitionReturns struct {
		result1 *connect.Response[partitionv1.GetPartitionResponse]
		result2 error
	}
	getPartitionReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.GetPartitionResponse]
		result2 error
	}
	GetPartitionParentsStub        func(context.Context, *connect.Request[partitionv1.GetPartitionParentsRequest]) (*connect.Response[partitionv1.GetPartitionParentsResponse], error)
	getPartitionParentsMutex       sync.RWMutex
	getPartitionParentsArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetPartitionParentsRequest]
	}
	getPartitionParentsReturns struct {
		result1 *connect.Response[partitionv1.GetPartitionParentsResponse]
		result2 error
	}
	getPartitionParentsReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.GetPartitionParentsResponse]
		result2 error
	}
	GetTenantStub        func(context.Context, *connect.Request[partitionv1.GetTenantRequest]) (*connect.Response[partitionv1.GetTenantResponse], error)
	getTenantMutex       sync.RWMutex
	getTenantArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetTenantRequest]
	}
	getTenantReturns struct {
		result1 *connect.Response[partitionv1.GetTenantResponse]
		result2 error
	}
	getTenantReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.GetTenantResponse]
		result2 error
	}
	ListAccessRoleStub        func(context.Context, *connect.Request[partitionv1.ListAccessRoleRequest], *connect.ServerStream[partitionv1.ListAccessRoleResponse]) error
	listAccessRoleMutex       sync.RWMutex
	listAccessRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListAccessRoleRequest]
		arg3 *connect.ServerStream[partitionv1.ListAccessRoleResponse]
	}
	listAccessRoleReturns struct {
		result1 error
	}
	listAccessRoleReturnsOnCall map[int]struct {
		result1 error
	}
	ListPartitionStub        func(context.Context, *connect.Request[partitionv1.ListPartitionRequest], *connect.ServerStream[partitionv1.ListPartitionResponse]) error
	listPartitionMutex       sync.RWMutex
	listPartitionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListPartitionRequest]
		arg3 *connect.ServerStream[partitionv1.ListPartitionResponse]
	}
	listPartitionReturns struct {
		result1 error
	}
	listPartitionReturnsOnCall map[int]struct {
		result1 error
	}
	ListPartitionRoleStub        func(context.Context, *connect.Request[partitionv1.ListPartitionRoleRequest], *connect.ServerStream[partitionv1.ListPartitionRoleResponse]) error
	listPartitionRoleMutex       sync.RWMutex
	listPartitionRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListPartitionRoleRequest]
		arg3 *connect.ServerStream[partitionv1.ListPartitionRoleResponse]
	}
	listPartitionRoleReturns struct {
		result1 error
	}
	listPartitionRoleReturnsOnCall map[int]struct {
		result1 error
	}
	ListTenantStub        func(context.Context, *connect.Request[partitionv1.ListTenantRequest], *connect.ServerStream[partitionv1.ListTenantResponse]) error
	listTenantMutex       sync.RWMutex
	listTenantArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListTenantRequest]
		arg3 *connect.ServerStream[partitionv1.ListTenantResponse]
	}
	listTenantReturns struct {
		result1 error
	}
	listTenantReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAccessStub        func(context.Context, *connect.Request[partitionv1.RemoveAccessRequest]) (*connect.Response[partitionv1.RemoveAccessResponse], error)
	removeAccessMutex       sync.RWMutex
	removeAccessArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemoveAccessRequest]
	}
	removeAccessReturns struct {
		result1 *connect.Response[partitionv1.RemoveAccessResponse]
		result2 error
	}
	removeAccessReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.RemoveAccessResponse]
		result2 error
	}
	RemoveAccessRoleStub        func(context.Context, *connect.Request[partitionv1.RemoveAccessRoleRequest]) (*connect.Response[partitionv1.RemoveAccessRoleResponse], error)
	removeAccessRoleMutex       sync.RWMutex
	removeAccessRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemoveAccessRoleRequest]
	}
	removeAccessRoleReturns struct {
		result1 *connect.Response[partitionv1.RemoveAccessRoleResponse]
		result2 error
	}
	removeAccessRoleReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.RemoveAccessRoleResponse]
		result2 error
	}
	RemovePageStub        func(context.Context, *connect.Request[partitionv1.RemovePageRequest]) (*connect.Response[partitionv1.RemovePageResponse], error)
	removePageMutex       sync.RWMutex
	removePageArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemovePageRequest]
	}
	removePageReturns struct {
		result1 *connect.Response[partitionv1.RemovePageResponse]
		result2 error
	}
	removePageReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.RemovePageResponse]
		result2 error
	}
	RemovePartitionRoleStub        func(context.Context, *connect.Request[partitionv1.RemovePartitionRoleRequest]) (*connect.Response[partitionv1.RemovePartitionRoleResponse], error)
	removePartitionRoleMutex       sync.RWMutex
	removePartitionRoleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemovePartitionRoleRequest]
	}
	removePartitionRoleReturns struct {
		result1 *connect.Response[partitionv1.RemovePartitionRoleResponse]
		result2 error
	}
	removePartitionRoleReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.RemovePartitionRoleResponse]
		result2 error
	}
	UpdatePartitionStub        func(context.Context, *connect.Request[partitionv1.UpdatePartitionRequest]) (*connect.Response[partitionv1.UpdatePartitionResponse], error)
	updatePartitionMutex       sync.RWMutex
	updatePartitionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.UpdatePartitionRequest]
	}
	updatePartitionReturns struct {
		result1 *connect.Response[partitionv1.UpdatePartitionResponse]
		result2 error
	}
	updatePartitionReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.UpdatePartitionResponse]
		result2 error
	}
	UpdateTenantStub        func(context.Context, *connect.Request[partitionv1.UpdateTenantRequest]) (*connect.Response[partitionv1.UpdateTenantResponse], error)
	updateTenantMutex       sync.RWMutex
	updateTenantArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.UpdateTenantRequest]
	}
	updateTenantReturns struct {
		result1 *connect.Response[partitionv1.UpdateTenantResponse]
		result2 error
	}
	updateTenantReturnsOnCall map[int]struct {
		result1 *connect.Response[partitionv1.UpdateTenantResponse]
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePartitionServiceHandler) CreateAccess(arg1 context.Context, arg2 *connect.Request[partitionv1.CreateAccessRequest]) (*connect.Response[partitionv1.CreateAccessResponse], error) {
	fake.createAccessMutex.Lock()
	ret, specificReturn := fake.createAccessReturnsOnCall[len(fake.createAccessArgsForCall)]
	fake.createAccessArgsForCall = append(fake.createAccessArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreateAccessRequest]
	}{arg1, arg2})
	stub := fake.CreateAccessStub
	fakeReturns := fake.createAccessReturns
	fake.recordInvocation("CreateAccess", []interface{}{arg1, arg2})
	fake.createAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) CreateAccessCallCount() int {
	fake.createAccessMutex.RLock()
	defer fake.createAccessMutex.RUnlock()
	return len(fake.createAccessArgsForCall)
}

func (fake *FakePartitionServiceHandler) CreateAccessCalls(stub func(context.Context, *connect.Request[partitionv1.CreateAccessRequest]) (*connect.Response[partitionv1.CreateAccessResponse], error)) {
	fake.createAccessMutex.Lock()
	defer fake.createAccessMutex.Unlock()
	fake.CreateAccessStub = stub
}

func (fake *FakePartitionServiceHandler) CreateAccessArgsForCall(i int) (context.Context, *connect.Request[partitionv1.CreateAccessRequest]) {
	fake.createAccessMutex.RLock()
	defer fake.createAccessMutex.RUnlock()
	argsForCall := fake.createAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) CreateAccessReturns(result1 *connect.Response[partitionv1.CreateAccessResponse], result2 error) {
	fake.createAccessMutex.Lock()
	defer fake.createAccessMutex.Unlock()
	fake.CreateAccessStub = nil
	fake.createAccessReturns = struct {
		result1 *connect.Response[partitionv1.CreateAccessResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreateAccessReturnsOnCall(i int, result1 *connect.Response[partitionv1.CreateAccessResponse], result2 error) {
	fake.createAccessMutex.Lock()
	defer fake.createAccessMutex.Unlock()
	fake.CreateAccessStub = nil
	if fake.createAccessReturnsOnCall == nil {
		fake.createAccessReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.CreateAccessResponse]
			result2 error
		})
	}
	fake.createAccessReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.CreateAccessResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreateAccessRole(arg1 context.Context, arg2 *connect.Request[partitionv1.CreateAccessRoleRequest]) (*connect.Response[partitionv1.CreateAccessRoleResponse], error) {
	fake.createAccessRoleMutex.Lock()
	ret, specificReturn := fake.createAccessRoleReturnsOnCall[len(fake.createAccessRoleArgsForCall)]
	fake.createAccessRoleArgsForCall = append(fake.createAccessRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreateAccessRoleRequest]
	}{arg1, arg2})
	stub := fake.CreateAccessRoleStub
	fakeReturns := fake.createAccessRoleReturns
	fake.recordInvocation("CreateAccessRole", []interface{}{arg1, arg2})
	fake.createAccessRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) CreateAccessRoleCallCount() int {
	fake.createAccessRoleMutex.RLock()
	defer fake.createAccessRoleMutex.RUnlock()
	return len(fake.createAccessRoleArgsForCall)
}

func (fake *FakePartitionServiceHandler) CreateAccessRoleCalls(stub func(context.Context, *connect.Request[partitionv1.CreateAccessRoleRequest]) (*connect.Response[partitionv1.CreateAccessRoleResponse], error)) {
	fake.createAccessRoleMutex.Lock()
	defer fake.createAccessRoleMutex.Unlock()
	fake.CreateAccessRoleStub = stub
}

func (fake *FakePartitionServiceHandler) CreateAccessRoleArgsForCall(i int) (context.Context, *connect.Request[partitionv1.CreateAccessRoleRequest]) {
	fake.createAccessRoleMutex.RLock()
	defer fake.createAccessRoleMutex.RUnlock()
	argsForCall := fake.createAccessRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) CreateAccessRoleReturns(result1 *connect.Response[partitionv1.CreateAccessRoleResponse], result2 error) {
	fake.createAccessRoleMutex.Lock()
	defer fake.createAccessRoleMutex.Unlock()
	fake.CreateAccessRoleStub = nil
	fake.createAccessRoleReturns = struct {
		result1 *connect.Response[partitionv1.CreateAccessRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreateAccessRoleReturnsOnCall(i int, result1 *connect.Response[partitionv1.CreateAccessRoleResponse], result2 error) {
	fake.createAccessRoleMutex.Lock()
	defer fake.createAccessRoleMutex.Unlock()
	fake.CreateAccessRoleStub = nil
	if fake.createAccessRoleReturnsOnCall == nil {
		fake.createAccessRoleReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.CreateAccessRoleResponse]
			result2 error
		})
	}
	fake.createAccessRoleReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.CreateAccessRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreatePage(arg1 context.Context, arg2 *connect.Request[partitionv1.CreatePageRequest]) (*connect.Response[partitionv1.CreatePageResponse], error) {
	fake.createPageMutex.Lock()
	ret, specificReturn := fake.createPageReturnsOnCall[len(fake.createPageArgsForCall)]
	fake.createPageArgsForCall = append(fake.createPageArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreatePageRequest]
	}{arg1, arg2})
	stub := fake.CreatePageStub
	fakeReturns := fake.createPageReturns
	fake.recordInvocation("CreatePage", []interface{}{arg1, arg2})
	fake.createPageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) CreatePageCallCount() int {
	fake.createPageMutex.RLock()
	defer fake.createPageMutex.RUnlock()
	return len(fake.createPageArgsForCall)
}

func (fake *FakePartitionServiceHandler) CreatePageCalls(stub func(context.Context, *connect.Request[partitionv1.CreatePageRequest]) (*connect.Response[partitionv1.CreatePageResponse], error)) {
	fake.createPageMutex.Lock()
	defer fake.createPageMutex.Unlock()
	fake.CreatePageStub = stub
}

func (fake *FakePartitionServiceHandler) CreatePageArgsForCall(i int) (context.Context, *connect.Request[partitionv1.CreatePageRequest]) {
	fake.createPageMutex.RLock()
	defer fake.createPageMutex.RUnlock()
	argsForCall := fake.createPageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) CreatePageReturns(result1 *connect.Response[partitionv1.CreatePageResponse], result2 error) {
	fake.createPageMutex.Lock()
	defer fake.createPageMutex.Unlock()
	fake.CreatePageStub = nil
	fake.createPageReturns = struct {
		result1 *connect.Response[partitionv1.CreatePageResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreatePageReturnsOnCall(i int, result1 *connect.Response[partitionv1.CreatePageResponse], result2 error) {
	fake.createPageMutex.Lock()
	defer fake.createPageMutex.Unlock()
	fake.CreatePageStub = nil
	if fake.createPageReturnsOnCall == nil {
		fake.createPageReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.CreatePageResponse]
			result2 error
		})
	}
	fake.createPageReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.CreatePageResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreatePartition(arg1 context.Context, arg2 *connect.Request[partitionv1.CreatePartitionRequest]) (*connect.Response[partitionv1.CreatePartitionResponse], error) {
	fake.createPartitionMutex.Lock()
	ret, specificReturn := fake.createPartitionReturnsOnCall[len(fake.createPartitionArgsForCall)]
	fake.createPartitionArgsForCall = append(fake.createPartitionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreatePartitionRequest]
	}{arg1, arg2})
	stub := fake.CreatePartitionStub
	fakeReturns := fake.createPartitionReturns
	fake.recordInvocation("CreatePartition", []interface{}{arg1, arg2})
	fake.createPartitionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) CreatePartitionCallCount() int {
	fake.createPartitionMutex.RLock()
	defer fake.createPartitionMutex.RUnlock()
	return len(fake.createPartitionArgsForCall)
}

func (fake *FakePartitionServiceHandler) CreatePartitionCalls(stub func(context.Context, *connect.Request[partitionv1.CreatePartitionRequest]) (*connect.Response[partitionv1.CreatePartitionResponse], error)) {
	fake.createPartitionMutex.Lock()
	defer fake.createPartitionMutex.Unlock()
	fake.CreatePartitionStub = stub
}

func (fake *FakePartitionServiceHandler) CreatePartitionArgsForCall(i int) (context.Context, *connect.Request[partitionv1.CreatePartitionRequest]) {
	fake.createPartitionMutex.RLock()
	defer fake.createPartitionMutex.RUnlock()
	argsForCall := fake.createPartitionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) CreatePartitionReturns(result1 *connect.Response[partitionv1.CreatePartitionResponse], result2 error) {
	fake.createPartitionMutex.Lock()
	defer fake.createPartitionMutex.Unlock()
	fake.CreatePartitionStub = nil
	fake.createPartitionReturns = struct {
		result1 *connect.Response[partitionv1.CreatePartitionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreatePartitionReturnsOnCall(i int, result1 *connect.Response[partitionv1.CreatePartitionResponse], result2 error) {
	fake.createPartitionMutex.Lock()
	defer fake.createPartitionMutex.Unlock()
	fake.CreatePartitionStub = nil
	if fake.createPartitionReturnsOnCall == nil {
		fake.createPartitionReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.CreatePartitionResponse]
			result2 error
		})
	}
	fake.createPartitionReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.CreatePartitionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreatePartitionRole(arg1 context.Context, arg2 *connect.Request[partitionv1.CreatePartitionRoleRequest]) (*connect.Response[partitionv1.CreatePartitionRoleResponse], error) {
	fake.createPartitionRoleMutex.Lock()
	ret, specificReturn := fake.createPartitionRoleReturnsOnCall[len(fake.createPartitionRoleArgsForCall)]
	fake.createPartitionRoleArgsForCall = append(fake.createPartitionRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreatePartitionRoleRequest]
	}{arg1, arg2})
	stub := fake.CreatePartitionRoleStub
	fakeReturns := fake.createPartitionRoleReturns
	fake.recordInvocation("CreatePartitionRole", []interface{}{arg1, arg2})
	fake.createPartitionRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) CreatePartitionRoleCallCount() int {
	fake.createPartitionRoleMutex.RLock()
	defer fake.createPartitionRoleMutex.RUnlock()
	return len(fake.createPartitionRoleArgsForCall)
}

func (fake *FakePartitionServiceHandler) CreatePartitionRoleCalls(stub func(context.Context, *connect.Request[partitionv1.CreatePartitionRoleRequest]) (*connect.Response[partitionv1.CreatePartitionRoleResponse], error)) {
	fake.createPartitionRoleMutex.Lock()
	defer fake.createPartitionRoleMutex.Unlock()
	fake.CreatePartitionRoleStub = stub
}

func (fake *FakePartitionServiceHandler) CreatePartitionRoleArgsForCall(i int) (context.Context, *connect.Request[partitionv1.CreatePartitionRoleRequest]) {
	fake.createPartitionRoleMutex.RLock()
	defer fake.createPartitionRoleMutex.RUnlock()
	argsForCall := fake.createPartitionRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) CreatePartitionRoleReturns(result1 *connect.Response[partitionv1.CreatePartitionRoleResponse], result2 error) {
	fake.createPartitionRoleMutex.Lock()
	defer fake.createPartitionRoleMutex.Unlock()
	fake.CreatePartitionRoleStub = nil
	fake.createPartitionRoleReturns = struct {
		result1 *connect.Response[partitionv1.CreatePartitionRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreatePartitionRoleReturnsOnCall(i int, result1 *connect.Response[partitionv1.CreatePartitionRoleResponse], result2 error) {
	fake.createPartitionRoleMutex.Lock()
	defer fake.createPartitionRoleMutex.Unlock()
	fake.CreatePartitionRoleStub = nil
	if fake.createPartitionRoleReturnsOnCall == nil {
		fake.createPartitionRoleReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.CreatePartitionRoleResponse]
			result2 error
		})
	}
	fake.createPartitionRoleReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.CreatePartitionRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreateTenant(arg1 context.Context, arg2 *connect.Request[partitionv1.CreateTenantRequest]) (*connect.Response[partitionv1.CreateTenantResponse], error) {
	fake.createTenantMutex.Lock()
	ret, specificReturn := fake.createTenantReturnsOnCall[len(fake.createTenantArgsForCall)]
	fake.createTenantArgsForCall = append(fake.createTenantArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.CreateTenantRequest]
	}{arg1, arg2})
	stub := fake.CreateTenantStub
	fakeReturns := fake.createTenantReturns
	fake.recordInvocation("CreateTenant", []interface{}{arg1, arg2})
	fake.createTenantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) CreateTenantCallCount() int {
	fake.createTenantMutex.RLock()
	defer fake.createTenantMutex.RUnlock()
	return len(fake.createTenantArgsForCall)
}

func (fake *FakePartitionServiceHandler) CreateTenantCalls(stub func(context.Context, *connect.Request[partitionv1.CreateTenantRequest]) (*connect.Response[partitionv1.CreateTenantResponse], error)) {
	fake.createTenantMutex.Lock()
	defer fake.createTenantMutex.Unlock()
	fake.CreateTenantStub = stub
}

func (fake *FakePartitionServiceHandler) CreateTenantArgsForCall(i int) (context.Context, *connect.Request[partitionv1.CreateTenantRequest]) {
	fake.createTenantMutex.RLock()
	defer fake.createTenantMutex.RUnlock()
	argsForCall := fake.createTenantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) CreateTenantReturns(result1 *connect.Response[partitionv1.CreateTenantResponse], result2 error) {
	fake.createTenantMutex.Lock()
	defer fake.createTenantMutex.Unlock()
	fake.CreateTenantStub = nil
	fake.createTenantReturns = struct {
		result1 *connect.Response[partitionv1.CreateTenantResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) CreateTenantReturnsOnCall(i int, result1 *connect.Response[partitionv1.CreateTenantResponse], result2 error) {
	fake.createTenantMutex.Lock()
	defer fake.createTenantMutex.Unlock()
	fake.CreateTenantStub = nil
	if fake.createTenantReturnsOnCall == nil {
		fake.createTenantReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.CreateTenantResponse]
			result2 error
		})
	}
	fake.createTenantReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.CreateTenantResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetAccess(arg1 context.Context, arg2 *connect.Request[partitionv1.GetAccessRequest]) (*connect.Response[partitionv1.GetAccessResponse], error) {
	fake.getAccessMutex.Lock()
	ret, specificReturn := fake.getAccessReturnsOnCall[len(fake.getAccessArgsForCall)]
	fake.getAccessArgsForCall = append(fake.getAccessArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetAccessRequest]
	}{arg1, arg2})
	stub := fake.GetAccessStub
	fakeReturns := fake.getAccessReturns
	fake.recordInvocation("GetAccess", []interface{}{arg1, arg2})
	fake.getAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) GetAccessCallCount() int {
	fake.getAccessMutex.RLock()
	defer fake.getAccessMutex.RUnlock()
	return len(fake.getAccessArgsForCall)
}

func (fake *FakePartitionServiceHandler) GetAccessCalls(stub func(context.Context, *connect.Request[partitionv1.GetAccessRequest]) (*connect.Response[partitionv1.GetAccessResponse], error)) {
	fake.getAccessMutex.Lock()
	defer fake.getAccessMutex.Unlock()
	fake.GetAccessStub = stub
}

func (fake *FakePartitionServiceHandler) GetAccessArgsForCall(i int) (context.Context, *connect.Request[partitionv1.GetAccessRequest]) {
	fake.getAccessMutex.RLock()
	defer fake.getAccessMutex.RUnlock()
	argsForCall := fake.getAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) GetAccessReturns(result1 *connect.Response[partitionv1.GetAccessResponse], result2 error) {
	fake.getAccessMutex.Lock()
	defer fake.getAccessMutex.Unlock()
	fake.GetAccessStub = nil
	fake.getAccessReturns = struct {
		result1 *connect.Response[partitionv1.GetAccessResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetAccessReturnsOnCall(i int, result1 *connect.Response[partitionv1.GetAccessResponse], result2 error) {
	fake.getAccessMutex.Lock()
	defer fake.getAccessMutex.Unlock()
	fake.GetAccessStub = nil
	if fake.getAccessReturnsOnCall == nil {
		fake.getAccessReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.GetAccessResponse]
			result2 error
		})
	}
	fake.getAccessReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.GetAccessResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetPage(arg1 context.Context, arg2 *connect.Request[partitionv1.GetPageRequest]) (*connect.Response[partitionv1.GetPageResponse], error) {
	fake.getPageMutex.Lock()
	ret, specificReturn := fake.getPageReturnsOnCall[len(fake.getPageArgsForCall)]
	fake.getPageArgsForCall = append(fake.getPageArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetPageRequest]
	}{arg1, arg2})
	stub := fake.GetPageStub
	fakeReturns := fake.getPageReturns
	fake.recordInvocation("GetPage", []interface{}{arg1, arg2})
	fake.getPageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) GetPageCallCount() int {
	fake.getPageMutex.RLock()
	defer fake.getPageMutex.RUnlock()
	return len(fake.getPageArgsForCall)
}

func (fake *FakePartitionServiceHandler) GetPageCalls(stub func(context.Context, *connect.Request[partitionv1.GetPageRequest]) (*connect.Response[partitionv1.GetPageResponse], error)) {
	fake.getPageMutex.Lock()
	defer fake.getPageMutex.Unlock()
	fake.GetPageStub = stub
}

func (fake *FakePartitionServiceHandler) GetPageArgsForCall(i int) (context.Context, *connect.Request[partitionv1.GetPageRequest]) {
	fake.getPageMutex.RLock()
	defer fake.getPageMutex.RUnlock()
	argsForCall := fake.getPageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) GetPageReturns(result1 *connect.Response[partitionv1.GetPageResponse], result2 error) {
	fake.getPageMutex.Lock()
	defer fake.getPageMutex.Unlock()
	fake.GetPageStub = nil
	fake.getPageReturns = struct {
		result1 *connect.Response[partitionv1.GetPageResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetPageReturnsOnCall(i int, result1 *connect.Response[partitionv1.GetPageResponse], result2 error) {
	fake.getPageMutex.Lock()
	defer fake.getPageMutex.Unlock()
	fake.GetPageStub = nil
	if fake.getPageReturnsOnCall == nil {
		fake.getPageReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.GetPageResponse]
			result2 error
		})
	}
	fake.getPageReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.GetPageResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetPartition(arg1 context.Context, arg2 *connect.Request[partitionv1.GetPartitionRequest]) (*connect.Response[partitionv1.GetPartitionResponse], error) {
	fake.getPartitionMutex.Lock()
	ret, specificReturn := fake.getPartitionReturnsOnCall[len(fake.getPartitionArgsForCall)]
	fake.getPartitionArgsForCall = append(fake.getPartitionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetPartitionRequest]
	}{arg1, arg2})
	stub := fake.GetPartitionStub
	fakeReturns := fake.getPartitionReturns
	fake.recordInvocation("GetPartition", []interface{}{arg1, arg2})
	fake.getPartitionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) GetPartitionCallCount() int {
	fake.getPartitionMutex.RLock()
	defer fake.getPartitionMutex.RUnlock()
	return len(fake.getPartitionArgsForCall)
}

func (fake *FakePartitionServiceHandler) GetPartitionCalls(stub func(context.Context, *connect.Request[partitionv1.GetPartitionRequest]) (*connect.Response[partitionv1.GetPartitionResponse], error)) {
	fake.getPartitionMutex.Lock()
	defer fake.getPartitionMutex.Unlock()
	fake.GetPartitionStub = stub
}

func (fake *FakePartitionServiceHandler) GetPartitionArgsForCall(i int) (context.Context, *connect.Request[partitionv1.GetPartitionRequest]) {
	fake.getPartitionMutex.RLock()
	defer fake.getPartitionMutex.RUnlock()
	argsForCall := fake.getPartitionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) GetPartitionReturns(result1 *connect.Response[partitionv1.GetPartitionResponse], result2 error) {
	fake.getPartitionMutex.Lock()
	defer fake.getPartitionMutex.Unlock()
	fake.GetPartitionStub = nil
	fake.getPartitionReturns = struct {
		result1 *connect.Response[partitionv1.GetPartitionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetPartitionReturnsOnCall(i int, result1 *connect.Response[partitionv1.GetPartitionResponse], result2 error) {
	fake.getPartitionMutex.Lock()
	defer fake.getPartitionMutex.Unlock()
	fake.GetPartitionStub = nil
	if fake.getPartitionReturnsOnCall == nil {
		fake.getPartitionReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.GetPartitionResponse]
			result2 error
		})
	}
	fake.getPartitionReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.GetPartitionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetPartitionParents(arg1 context.Context, arg2 *connect.Request[partitionv1.GetPartitionParentsRequest]) (*connect.Response[partitionv1.GetPartitionParentsResponse], error) {
	fake.getPartitionParentsMutex.Lock()
	ret, specificReturn := fake.getPartitionParentsReturnsOnCall[len(fake.getPartitionParentsArgsForCall)]
	fake.getPartitionParentsArgsForCall = append(fake.getPartitionParentsArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetPartitionParentsRequest]
	}{arg1, arg2})
	stub := fake.GetPartitionParentsStub
	fakeReturns := fake.getPartitionParentsReturns
	fake.recordInvocation("GetPartitionParents", []interface{}{arg1, arg2})
	fake.getPartitionParentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) GetPartitionParentsCallCount() int {
	fake.getPartitionParentsMutex.RLock()
	defer fake.getPartitionParentsMutex.RUnlock()
	return len(fake.getPartitionParentsArgsForCall)
}

func (fake *FakePartitionServiceHandler) GetPartitionParentsCalls(stub func(context.Context, *connect.Request[partitionv1.GetPartitionParentsRequest]) (*connect.Response[partitionv1.GetPartitionParentsResponse], error)) {
	fake.getPartitionParentsMutex.Lock()
	defer fake.getPartitionParentsMutex.Unlock()
	fake.GetPartitionParentsStub = stub
}

func (fake *FakePartitionServiceHandler) GetPartitionParentsArgsForCall(i int) (context.Context, *connect.Request[partitionv1.GetPartitionParentsRequest]) {
	fake.getPartitionParentsMutex.RLock()
	defer fake.getPartitionParentsMutex.RUnlock()
	argsForCall := fake.getPartitionParentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) GetPartitionParentsReturns(result1 *connect.Response[partitionv1.GetPartitionParentsResponse], result2 error) {
	fake.getPartitionParentsMutex.Lock()
	defer fake.getPartitionParentsMutex.Unlock()
	fake.GetPartitionParentsStub = nil
	fake.getPartitionParentsReturns = struct {
		result1 *connect.Response[partitionv1.GetPartitionParentsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetPartitionParentsReturnsOnCall(i int, result1 *connect.Response[partitionv1.GetPartitionParentsResponse], result2 error) {
	fake.getPartitionParentsMutex.Lock()
	defer fake.getPartitionParentsMutex.Unlock()
	fake.GetPartitionParentsStub = nil
	if fake.getPartitionParentsReturnsOnCall == nil {
		fake.getPartitionParentsReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.GetPartitionParentsResponse]
			result2 error
		})
	}
	fake.getPartitionParentsReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.GetPartitionParentsResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetTenant(arg1 context.Context, arg2 *connect.Request[partitionv1.GetTenantRequest]) (*connect.Response[partitionv1.GetTenantResponse], error) {
	fake.getTenantMutex.Lock()
	ret, specificReturn := fake.getTenantReturnsOnCall[len(fake.getTenantArgsForCall)]
	fake.getTenantArgsForCall = append(fake.getTenantArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.GetTenantRequest]
	}{arg1, arg2})
	stub := fake.GetTenantStub
	fakeReturns := fake.getTenantReturns
	fake.recordInvocation("GetTenant", []interface{}{arg1, arg2})
	fake.getTenantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) GetTenantCallCount() int {
	fake.getTenantMutex.RLock()
	defer fake.getTenantMutex.RUnlock()
	return len(fake.getTenantArgsForCall)
}

func (fake *FakePartitionServiceHandler) GetTenantCalls(stub func(context.Context, *connect.Request[partitionv1.GetTenantRequest]) (*connect.Response[partitionv1.GetTenantResponse], error)) {
	fake.getTenantMutex.Lock()
	defer fake.getTenantMutex.Unlock()
	fake.GetTenantStub = stub
}

func (fake *FakePartitionServiceHandler) GetTenantArgsForCall(i int) (context.Context, *connect.Request[partitionv1.GetTenantRequest]) {
	fake.getTenantMutex.RLock()
	defer fake.getTenantMutex.RUnlock()
	argsForCall := fake.getTenantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) GetTenantReturns(result1 *connect.Response[partitionv1.GetTenantResponse], result2 error) {
	fake.getTenantMutex.Lock()
	defer fake.getTenantMutex.Unlock()
	fake.GetTenantStub = nil
	fake.getTenantReturns = struct {
		result1 *connect.Response[partitionv1.GetTenantResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) GetTenantReturnsOnCall(i int, result1 *connect.Response[partitionv1.GetTenantResponse], result2 error) {
	fake.getTenantMutex.Lock()
	defer fake.getTenantMutex.Unlock()
	fake.GetTenantStub = nil
	if fake.getTenantReturnsOnCall == nil {
		fake.getTenantReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.GetTenantResponse]
			result2 error
		})
	}
	fake.getTenantReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.GetTenantResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) ListAccessRole(arg1 context.Context, arg2 *connect.Request[partitionv1.ListAccessRoleRequest], arg3 *connect.ServerStream[partitionv1.ListAccessRoleResponse]) error {
	fake.listAccessRoleMutex.Lock()
	ret, specificReturn := fake.listAccessRoleReturnsOnCall[len(fake.listAccessRoleArgsForCall)]
	fake.listAccessRoleArgsForCall = append(fake.listAccessRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListAccessRoleRequest]
		arg3 *connect.ServerStream[partitionv1.ListAccessRoleResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListAccessRoleStub
	fakeReturns := fake.listAccessRoleReturns
	fake.recordInvocation("ListAccessRole", []interface{}{arg1, arg2, arg3})
	fake.listAccessRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePartitionServiceHandler) ListAccessRoleCallCount() int {
	fake.listAccessRoleMutex.RLock()
	defer fake.listAccessRoleMutex.RUnlock()
	return len(fake.listAccessRoleArgsForCall)
}

func (fake *FakePartitionServiceHandler) ListAccessRoleCalls(stub func(context.Context, *connect.Request[partitionv1.ListAccessRoleRequest], *connect.ServerStream[partitionv1.ListAccessRoleResponse]) error) {
	fake.listAccessRoleMutex.Lock()
	defer fake.listAccessRoleMutex.Unlock()
	fake.ListAccessRoleStub = stub
}

func (fake *FakePartitionServiceHandler) ListAccessRoleArgsForCall(i int) (context.Context, *connect.Request[partitionv1.ListAccessRoleRequest], *connect.ServerStream[partitionv1.ListAccessRoleResponse]) {
	fake.listAccessRoleMutex.RLock()
	defer fake.listAccessRoleMutex.RUnlock()
	argsForCall := fake.listAccessRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePartitionServiceHandler) ListAccessRoleReturns(result1 error) {
	fake.listAccessRoleMutex.Lock()
	defer fake.listAccessRoleMutex.Unlock()
	fake.ListAccessRoleStub = nil
	fake.listAccessRoleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListAccessRoleReturnsOnCall(i int, result1 error) {
	fake.listAccessRoleMutex.Lock()
	defer fake.listAccessRoleMutex.Unlock()
	fake.ListAccessRoleStub = nil
	if fake.listAccessRoleReturnsOnCall == nil {
		fake.listAccessRoleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listAccessRoleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListPartition(arg1 context.Context, arg2 *connect.Request[partitionv1.ListPartitionRequest], arg3 *connect.ServerStream[partitionv1.ListPartitionResponse]) error {
	fake.listPartitionMutex.Lock()
	ret, specificReturn := fake.listPartitionReturnsOnCall[len(fake.listPartitionArgsForCall)]
	fake.listPartitionArgsForCall = append(fake.listPartitionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListPartitionRequest]
		arg3 *connect.ServerStream[partitionv1.ListPartitionResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListPartitionStub
	fakeReturns := fake.listPartitionReturns
	fake.recordInvocation("ListPartition", []interface{}{arg1, arg2, arg3})
	fake.listPartitionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePartitionServiceHandler) ListPartitionCallCount() int {
	fake.listPartitionMutex.RLock()
	defer fake.listPartitionMutex.RUnlock()
	return len(fake.listPartitionArgsForCall)
}

func (fake *FakePartitionServiceHandler) ListPartitionCalls(stub func(context.Context, *connect.Request[partitionv1.ListPartitionRequest], *connect.ServerStream[partitionv1.ListPartitionResponse]) error) {
	fake.listPartitionMutex.Lock()
	defer fake.listPartitionMutex.Unlock()
	fake.ListPartitionStub = stub
}

func (fake *FakePartitionServiceHandler) ListPartitionArgsForCall(i int) (context.Context, *connect.Request[partitionv1.ListPartitionRequest], *connect.ServerStream[partitionv1.ListPartitionResponse]) {
	fake.listPartitionMutex.RLock()
	defer fake.listPartitionMutex.RUnlock()
	argsForCall := fake.listPartitionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePartitionServiceHandler) ListPartitionReturns(result1 error) {
	fake.listPartitionMutex.Lock()
	defer fake.listPartitionMutex.Unlock()
	fake.ListPartitionStub = nil
	fake.listPartitionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListPartitionReturnsOnCall(i int, result1 error) {
	fake.listPartitionMutex.Lock()
	defer fake.listPartitionMutex.Unlock()
	fake.ListPartitionStub = nil
	if fake.listPartitionReturnsOnCall == nil {
		fake.listPartitionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listPartitionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListPartitionRole(arg1 context.Context, arg2 *connect.Request[partitionv1.ListPartitionRoleRequest], arg3 *connect.ServerStream[partitionv1.ListPartitionRoleResponse]) error {
	fake.listPartitionRoleMutex.Lock()
	ret, specificReturn := fake.listPartitionRoleReturnsOnCall[len(fake.listPartitionRoleArgsForCall)]
	fake.listPartitionRoleArgsForCall = append(fake.listPartitionRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListPartitionRoleRequest]
		arg3 *connect.ServerStream[partitionv1.ListPartitionRoleResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListPartitionRoleStub
	fakeReturns := fake.listPartitionRoleReturns
	fake.recordInvocation("ListPartitionRole", []interface{}{arg1, arg2, arg3})
	fake.listPartitionRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePartitionServiceHandler) ListPartitionRoleCallCount() int {
	fake.listPartitionRoleMutex.RLock()
	defer fake.listPartitionRoleMutex.RUnlock()
	return len(fake.listPartitionRoleArgsForCall)
}

func (fake *FakePartitionServiceHandler) ListPartitionRoleCalls(stub func(context.Context, *connect.Request[partitionv1.ListPartitionRoleRequest], *connect.ServerStream[partitionv1.ListPartitionRoleResponse]) error) {
	fake.listPartitionRoleMutex.Lock()
	defer fake.listPartitionRoleMutex.Unlock()
	fake.ListPartitionRoleStub = stub
}

func (fake *FakePartitionServiceHandler) ListPartitionRoleArgsForCall(i int) (context.Context, *connect.Request[partitionv1.ListPartitionRoleRequest], *connect.ServerStream[partitionv1.ListPartitionRoleResponse]) {
	fake.listPartitionRoleMutex.RLock()
	defer fake.listPartitionRoleMutex.RUnlock()
	argsForCall := fake.listPartitionRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePartitionServiceHandler) ListPartitionRoleReturns(result1 error) {
	fake.listPartitionRoleMutex.Lock()
	defer fake.listPartitionRoleMutex.Unlock()
	fake.ListPartitionRoleStub = nil
	fake.listPartitionRoleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListPartitionRoleReturnsOnCall(i int, result1 error) {
	fake.listPartitionRoleMutex.Lock()
	defer fake.listPartitionRoleMutex.Unlock()
	fake.ListPartitionRoleStub = nil
	if fake.listPartitionRoleReturnsOnCall == nil {
		fake.listPartitionRoleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listPartitionRoleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListTenant(arg1 context.Context, arg2 *connect.Request[partitionv1.ListTenantRequest], arg3 *connect.ServerStream[partitionv1.ListTenantResponse]) error {
	fake.listTenantMutex.Lock()
	ret, specificReturn := fake.listTenantReturnsOnCall[len(fake.listTenantArgsForCall)]
	fake.listTenantArgsForCall = append(fake.listTenantArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.ListTenantRequest]
		arg3 *connect.ServerStream[partitionv1.ListTenantResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListTenantStub
	fakeReturns := fake.listTenantReturns
	fake.recordInvocation("ListTenant", []interface{}{arg1, arg2, arg3})
	fake.listTenantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePartitionServiceHandler) ListTenantCallCount() int {
	fake.listTenantMutex.RLock()
	defer fake.listTenantMutex.RUnlock()
	return len(fake.listTenantArgsForCall)
}

func (fake *FakePartitionServiceHandler) ListTenantCalls(stub func(context.Context, *connect.Request[partitionv1.ListTenantRequest], *connect.ServerStream[partitionv1.ListTenantResponse]) error) {
	fake.listTenantMutex.Lock()
	defer fake.listTenantMutex.Unlock()
	fake.ListTenantStub = stub
}

func (fake *FakePartitionServiceHandler) ListTenantArgsForCall(i int) (context.Context, *connect.Request[partitionv1.ListTenantRequest], *connect.ServerStream[partitionv1.ListTenantResponse]) {
	fake.listTenantMutex.RLock()
	defer fake.listTenantMutex.RUnlock()
	argsForCall := fake.listTenantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePartitionServiceHandler) ListTenantReturns(result1 error) {
	fake.listTenantMutex.Lock()
	defer fake.listTenantMutex.Unlock()
	fake.ListTenantStub = nil
	fake.listTenantReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) ListTenantReturnsOnCall(i int, result1 error) {
	fake.listTenantMutex.Lock()
	defer fake.listTenantMutex.Unlock()
	fake.ListTenantStub = nil
	if fake.listTenantReturnsOnCall == nil {
		fake.listTenantReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listTenantReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePartitionServiceHandler) RemoveAccess(arg1 context.Context, arg2 *connect.Request[partitionv1.RemoveAccessRequest]) (*connect.Response[partitionv1.RemoveAccessResponse], error) {
	fake.removeAccessMutex.Lock()
	ret, specificReturn := fake.removeAccessReturnsOnCall[len(fake.removeAccessArgsForCall)]
	fake.removeAccessArgsForCall = append(fake.removeAccessArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemoveAccessRequest]
	}{arg1, arg2})
	stub := fake.RemoveAccessStub
	fakeReturns := fake.removeAccessReturns
	fake.recordInvocation("RemoveAccess", []interface{}{arg1, arg2})
	fake.removeAccessMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) RemoveAccessCallCount() int {
	fake.removeAccessMutex.RLock()
	defer fake.removeAccessMutex.RUnlock()
	return len(fake.removeAccessArgsForCall)
}

func (fake *FakePartitionServiceHandler) RemoveAccessCalls(stub func(context.Context, *connect.Request[partitionv1.RemoveAccessRequest]) (*connect.Response[partitionv1.RemoveAccessResponse], error)) {
	fake.removeAccessMutex.Lock()
	defer fake.removeAccessMutex.Unlock()
	fake.RemoveAccessStub = stub
}

func (fake *FakePartitionServiceHandler) RemoveAccessArgsForCall(i int) (context.Context, *connect.Request[partitionv1.RemoveAccessRequest]) {
	fake.removeAccessMutex.RLock()
	defer fake.removeAccessMutex.RUnlock()
	argsForCall := fake.removeAccessArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) RemoveAccessReturns(result1 *connect.Response[partitionv1.RemoveAccessResponse], result2 error) {
	fake.removeAccessMutex.Lock()
	defer fake.removeAccessMutex.Unlock()
	fake.RemoveAccessStub = nil
	fake.removeAccessReturns = struct {
		result1 *connect.Response[partitionv1.RemoveAccessResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemoveAccessReturnsOnCall(i int, result1 *connect.Response[partitionv1.RemoveAccessResponse], result2 error) {
	fake.removeAccessMutex.Lock()
	defer fake.removeAccessMutex.Unlock()
	fake.RemoveAccessStub = nil
	if fake.removeAccessReturnsOnCall == nil {
		fake.removeAccessReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.RemoveAccessResponse]
			result2 error
		})
	}
	fake.removeAccessReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.RemoveAccessResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemoveAccessRole(arg1 context.Context, arg2 *connect.Request[partitionv1.RemoveAccessRoleRequest]) (*connect.Response[partitionv1.RemoveAccessRoleResponse], error) {
	fake.removeAccessRoleMutex.Lock()
	ret, specificReturn := fake.removeAccessRoleReturnsOnCall[len(fake.removeAccessRoleArgsForCall)]
	fake.removeAccessRoleArgsForCall = append(fake.removeAccessRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemoveAccessRoleRequest]
	}{arg1, arg2})
	stub := fake.RemoveAccessRoleStub
	fakeReturns := fake.removeAccessRoleReturns
	fake.recordInvocation("RemoveAccessRole", []interface{}{arg1, arg2})
	fake.removeAccessRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) RemoveAccessRoleCallCount() int {
	fake.removeAccessRoleMutex.RLock()
	defer fake.removeAccessRoleMutex.RUnlock()
	return len(fake.removeAccessRoleArgsForCall)
}

func (fake *FakePartitionServiceHandler) RemoveAccessRoleCalls(stub func(context.Context, *connect.Request[partitionv1.RemoveAccessRoleRequest]) (*connect.Response[partitionv1.RemoveAccessRoleResponse], error)) {
	fake.removeAccessRoleMutex.Lock()
	defer fake.removeAccessRoleMutex.Unlock()
	fake.RemoveAccessRoleStub = stub
}

func (fake *FakePartitionServiceHandler) RemoveAccessRoleArgsForCall(i int) (context.Context, *connect.Request[partitionv1.RemoveAccessRoleRequest]) {
	fake.removeAccessRoleMutex.RLock()
	defer fake.removeAccessRoleMutex.RUnlock()
	argsForCall := fake.removeAccessRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) RemoveAccessRoleReturns(result1 *connect.Response[partitionv1.RemoveAccessRoleResponse], result2 error) {
	fake.removeAccessRoleMutex.Lock()
	defer fake.removeAccessRoleMutex.Unlock()
	fake.RemoveAccessRoleStub = nil
	fake.removeAccessRoleReturns = struct {
		result1 *connect.Response[partitionv1.RemoveAccessRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemoveAccessRoleReturnsOnCall(i int, result1 *connect.Response[partitionv1.RemoveAccessRoleResponse], result2 error) {
	fake.removeAccessRoleMutex.Lock()
	defer fake.removeAccessRoleMutex.Unlock()
	fake.RemoveAccessRoleStub = nil
	if fake.removeAccessRoleReturnsOnCall == nil {
		fake.removeAccessRoleReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.RemoveAccessRoleResponse]
			result2 error
		})
	}
	fake.removeAccessRoleReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.RemoveAccessRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemovePage(arg1 context.Context, arg2 *connect.Request[partitionv1.RemovePageRequest]) (*connect.Response[partitionv1.RemovePageResponse], error) {
	fake.removePageMutex.Lock()
	ret, specificReturn := fake.removePageReturnsOnCall[len(fake.removePageArgsForCall)]
	fake.removePageArgsForCall = append(fake.removePageArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemovePageRequest]
	}{arg1, arg2})
	stub := fake.RemovePageStub
	fakeReturns := fake.removePageReturns
	fake.recordInvocation("RemovePage", []interface{}{arg1, arg2})
	fake.removePageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) RemovePageCallCount() int {
	fake.removePageMutex.RLock()
	defer fake.removePageMutex.RUnlock()
	return len(fake.removePageArgsForCall)
}

func (fake *FakePartitionServiceHandler) RemovePageCalls(stub func(context.Context, *connect.Request[partitionv1.RemovePageRequest]) (*connect.Response[partitionv1.RemovePageResponse], error)) {
	fake.removePageMutex.Lock()
	defer fake.removePageMutex.Unlock()
	fake.RemovePageStub = stub
}

func (fake *FakePartitionServiceHandler) RemovePageArgsForCall(i int) (context.Context, *connect.Request[partitionv1.RemovePageRequest]) {
	fake.removePageMutex.RLock()
	defer fake.removePageMutex.RUnlock()
	argsForCall := fake.removePageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) RemovePageReturns(result1 *connect.Response[partitionv1.RemovePageResponse], result2 error) {
	fake.removePageMutex.Lock()
	defer fake.removePageMutex.Unlock()
	fake.RemovePageStub = nil
	fake.removePageReturns = struct {
		result1 *connect.Response[partitionv1.RemovePageResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemovePageReturnsOnCall(i int, result1 *connect.Response[partitionv1.RemovePageResponse], result2 error) {
	fake.removePageMutex.Lock()
	defer fake.removePageMutex.Unlock()
	fake.RemovePageStub = nil
	if fake.removePageReturnsOnCall == nil {
		fake.removePageReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.RemovePageResponse]
			result2 error
		})
	}
	fake.removePageReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.RemovePageResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemovePartitionRole(arg1 context.Context, arg2 *connect.Request[partitionv1.RemovePartitionRoleRequest]) (*connect.Response[partitionv1.RemovePartitionRoleResponse], error) {
	fake.removePartitionRoleMutex.Lock()
	ret, specificReturn := fake.removePartitionRoleReturnsOnCall[len(fake.removePartitionRoleArgsForCall)]
	fake.removePartitionRoleArgsForCall = append(fake.removePartitionRoleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.RemovePartitionRoleRequest]
	}{arg1, arg2})
	stub := fake.RemovePartitionRoleStub
	fakeReturns := fake.removePartitionRoleReturns
	fake.recordInvocation("RemovePartitionRole", []interface{}{arg1, arg2})
	fake.removePartitionRoleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) RemovePartitionRoleCallCount() int {
	fake.removePartitionRoleMutex.RLock()
	defer fake.removePartitionRoleMutex.RUnlock()
	return len(fake.removePartitionRoleArgsForCall)
}

func (fake *FakePartitionServiceHandler) RemovePartitionRoleCalls(stub func(context.Context, *connect.Request[partitionv1.RemovePartitionRoleRequest]) (*connect.Response[partitionv1.RemovePartitionRoleResponse], error)) {
	fake.removePartitionRoleMutex.Lock()
	defer fake.removePartitionRoleMutex.Unlock()
	fake.RemovePartitionRoleStub = stub
}

func (fake *FakePartitionServiceHandler) RemovePartitionRoleArgsForCall(i int) (context.Context, *connect.Request[partitionv1.RemovePartitionRoleRequest]) {
	fake.removePartitionRoleMutex.RLock()
	defer fake.removePartitionRoleMutex.RUnlock()
	argsForCall := fake.removePartitionRoleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) RemovePartitionRoleReturns(result1 *connect.Response[partitionv1.RemovePartitionRoleResponse], result2 error) {
	fake.removePartitionRoleMutex.Lock()
	defer fake.removePartitionRoleMutex.Unlock()
	fake.RemovePartitionRoleStub = nil
	fake.removePartitionRoleReturns = struct {
		result1 *connect.Response[partitionv1.RemovePartitionRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) RemovePartitionRoleReturnsOnCall(i int, result1 *connect.Response[partitionv1.RemovePartitionRoleResponse], result2 error) {
	fake.removePartitionRoleMutex.Lock()
	defer fake.removePartitionRoleMutex.Unlock()
	fake.RemovePartitionRoleStub = nil
	if fake.removePartitionRoleReturnsOnCall == nil {
		fake.removePartitionRoleReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.RemovePartitionRoleResponse]
			result2 error
		})
	}
	fake.removePartitionRoleReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.RemovePartitionRoleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) UpdatePartition(arg1 context.Context, arg2 *connect.Request[partitionv1.UpdatePartitionRequest]) (*connect.Response[partitionv1.UpdatePartitionResponse], error) {
	fake.updatePartitionMutex.Lock()
	ret, specificReturn := fake.updatePartitionReturnsOnCall[len(fake.updatePartitionArgsForCall)]
	fake.updatePartitionArgsForCall = append(fake.updatePartitionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.UpdatePartitionRequest]
	}{arg1, arg2})
	stub := fake.UpdatePartitionStub
	fakeReturns := fake.updatePartitionReturns
	fake.recordInvocation("UpdatePartition", []interface{}{arg1, arg2})
	fake.updatePartitionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) UpdatePartitionCallCount() int {
	fake.updatePartitionMutex.RLock()
	defer fake.updatePartitionMutex.RUnlock()
	return len(fake.updatePartitionArgsForCall)
}

func (fake *FakePartitionServiceHandler) UpdatePartitionCalls(stub func(context.Context, *connect.Request[partitionv1.UpdatePartitionRequest]) (*connect.Response[partitionv1.UpdatePartitionResponse], error)) {
	fake.updatePartitionMutex.Lock()
	defer fake.updatePartitionMutex.Unlock()
	fake.UpdatePartitionStub = stub
}

func (fake *FakePartitionServiceHandler) UpdatePartitionArgsForCall(i int) (context.Context, *connect.Request[partitionv1.UpdatePartitionRequest]) {
	fake.updatePartitionMutex.RLock()
	defer fake.updatePartitionMutex.RUnlock()
	argsForCall := fake.updatePartitionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) UpdatePartitionReturns(result1 *connect.Response[partitionv1.UpdatePartitionResponse], result2 error) {
	fake.updatePartitionMutex.Lock()
	defer fake.updatePartitionMutex.Unlock()
	fake.UpdatePartitionStub = nil
	fake.updatePartitionReturns = struct {
		result1 *connect.Response[partitionv1.UpdatePartitionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) UpdatePartitionReturnsOnCall(i int, result1 *connect.Response[partitionv1.UpdatePartitionResponse], result2 error) {
	fake.updatePartitionMutex.Lock()
	defer fake.updatePartitionMutex.Unlock()
	fake.UpdatePartitionStub = nil
	if fake.updatePartitionReturnsOnCall == nil {
		fake.updatePartitionReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.UpdatePartitionResponse]
			result2 error
		})
	}
	fake.updatePartitionReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.UpdatePartitionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) UpdateTenant(arg1 context.Context, arg2 *connect.Request[partitionv1.UpdateTenantRequest]) (*connect.Response[partitionv1.UpdateTenantResponse], error) {
	fake.updateTenantMutex.Lock()
	ret, specificReturn := fake.updateTenantReturnsOnCall[len(fake.updateTenantArgsForCall)]
	fake.updateTenantArgsForCall = append(fake.updateTenantArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[partitionv1.UpdateTenantRequest]
	}{arg1, arg2})
	stub := fake.UpdateTenantStub
	fakeReturns := fake.updateTenantReturns
	fake.recordInvocation("UpdateTenant", []interface{}{arg1, arg2})
	fake.updateTenantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePartitionServiceHandler) UpdateTenantCallCount() int {
	fake.updateTenantMutex.RLock()
	defer fake.updateTenantMutex.RUnlock()
	return len(fake.updateTenantArgsForCall)
}

func (fake *FakePartitionServiceHandler) UpdateTenantCalls(stub func(context.Context, *connect.Request[partitionv1.UpdateTenantRequest]) (*connect.Response[partitionv1.UpdateTenantResponse], error)) {
	fake.updateTenantMutex.Lock()
	defer fake.updateTenantMutex.Unlock()
	fake.UpdateTenantStub = stub
}

func (fake *FakePartitionServiceHandler) UpdateTenantArgsForCall(i int) (context.Context, *connect.Request[partitionv1.UpdateTenantRequest]) {
	fake.updateTenantMutex.RLock()
	defer fake.updateTenantMutex.RUnlock()
	argsForCall := fake.updateTenantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePartitionServiceHandler) UpdateTenantReturns(result1 *connect.Response[partitionv1.UpdateTenantResponse], result2 error) {
	fake.updateTenantMutex.Lock()
	defer fake.updateTenantMutex.Unlock()
	fake.UpdateTenantStub = nil
	fake.updateTenantReturns = struct {
		result1 *connect.Response[partitionv1.UpdateTenantResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) UpdateTenantReturnsOnCall(i int, result1 *connect.Response[partitionv1.UpdateTenantResponse], result2 error) {
	fake.updateTenantMutex.Lock()
	defer fake.updateTenantMutex.Unlock()
	fake.UpdateTenantStub = nil
	if fake.updateTenantReturnsOnCall == nil {
		fake.updateTenantReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[partitionv1.UpdateTenantResponse]
			result2 error
		})
	}
	fake.updateTenantReturnsOnCall[i] = struct {
		result1 *connect.Response[partitionv1.UpdateTenantResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePartitionServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePartitionServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ partitionv1connect.PartitionServiceHandler = new(FakePartitionServiceHandler)
