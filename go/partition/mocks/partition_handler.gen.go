// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/partition/connectrpc/go/partition/v1/partitionv1connect.PartitionServiceHandler -o partition_handler.gen.go -n PartitionServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/partition/protocolbuffers/go/partition/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// PartitionServiceHandlerMock implements mm_partitionv1connect.PartitionServiceHandler
type PartitionServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAccess          func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) (pp2 *connect.Response[v1.CreateAccessResponse], err error)
	funcCreateAccessOrigin    string
	inspectFuncCreateAccess   func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest])
	afterCreateAccessCounter  uint64
	beforeCreateAccessCounter uint64
	CreateAccessMock          mPartitionServiceHandlerMockCreateAccess

	funcCreateAccessRole          func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) (pp2 *connect.Response[v1.CreateAccessRoleResponse], err error)
	funcCreateAccessRoleOrigin    string
	inspectFuncCreateAccessRole   func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest])
	afterCreateAccessRoleCounter  uint64
	beforeCreateAccessRoleCounter uint64
	CreateAccessRoleMock          mPartitionServiceHandlerMockCreateAccessRole

	funcCreatePage          func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) (pp2 *connect.Response[v1.CreatePageResponse], err error)
	funcCreatePageOrigin    string
	inspectFuncCreatePage   func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest])
	afterCreatePageCounter  uint64
	beforeCreatePageCounter uint64
	CreatePageMock          mPartitionServiceHandlerMockCreatePage

	funcCreatePartition          func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) (pp2 *connect.Response[v1.CreatePartitionResponse], err error)
	funcCreatePartitionOrigin    string
	inspectFuncCreatePartition   func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest])
	afterCreatePartitionCounter  uint64
	beforeCreatePartitionCounter uint64
	CreatePartitionMock          mPartitionServiceHandlerMockCreatePartition

	funcCreatePartitionRole          func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) (pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error)
	funcCreatePartitionRoleOrigin    string
	inspectFuncCreatePartitionRole   func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest])
	afterCreatePartitionRoleCounter  uint64
	beforeCreatePartitionRoleCounter uint64
	CreatePartitionRoleMock          mPartitionServiceHandlerMockCreatePartitionRole

	funcCreateTenant          func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) (pp2 *connect.Response[v1.CreateTenantResponse], err error)
	funcCreateTenantOrigin    string
	inspectFuncCreateTenant   func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest])
	afterCreateTenantCounter  uint64
	beforeCreateTenantCounter uint64
	CreateTenantMock          mPartitionServiceHandlerMockCreateTenant

	funcGetAccess          func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) (pp2 *connect.Response[v1.GetAccessResponse], err error)
	funcGetAccessOrigin    string
	inspectFuncGetAccess   func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest])
	afterGetAccessCounter  uint64
	beforeGetAccessCounter uint64
	GetAccessMock          mPartitionServiceHandlerMockGetAccess

	funcGetPage          func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) (pp2 *connect.Response[v1.GetPageResponse], err error)
	funcGetPageOrigin    string
	inspectFuncGetPage   func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest])
	afterGetPageCounter  uint64
	beforeGetPageCounter uint64
	GetPageMock          mPartitionServiceHandlerMockGetPage

	funcGetPartition          func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) (pp2 *connect.Response[v1.GetPartitionResponse], err error)
	funcGetPartitionOrigin    string
	inspectFuncGetPartition   func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest])
	afterGetPartitionCounter  uint64
	beforeGetPartitionCounter uint64
	GetPartitionMock          mPartitionServiceHandlerMockGetPartition

	funcGetPartitionParents          func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) (pp2 *connect.Response[v1.GetPartitionParentsResponse], err error)
	funcGetPartitionParentsOrigin    string
	inspectFuncGetPartitionParents   func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest])
	afterGetPartitionParentsCounter  uint64
	beforeGetPartitionParentsCounter uint64
	GetPartitionParentsMock          mPartitionServiceHandlerMockGetPartitionParents

	funcGetTenant          func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) (pp2 *connect.Response[v1.GetTenantResponse], err error)
	funcGetTenantOrigin    string
	inspectFuncGetTenant   func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest])
	afterGetTenantCounter  uint64
	beforeGetTenantCounter uint64
	GetTenantMock          mPartitionServiceHandlerMockGetTenant

	funcListAccessRole          func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse]) (err error)
	funcListAccessRoleOrigin    string
	inspectFuncListAccessRole   func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse])
	afterListAccessRoleCounter  uint64
	beforeListAccessRoleCounter uint64
	ListAccessRoleMock          mPartitionServiceHandlerMockListAccessRole

	funcListPartition          func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse]) (err error)
	funcListPartitionOrigin    string
	inspectFuncListPartition   func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse])
	afterListPartitionCounter  uint64
	beforeListPartitionCounter uint64
	ListPartitionMock          mPartitionServiceHandlerMockListPartition

	funcListPartitionRole          func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]) (err error)
	funcListPartitionRoleOrigin    string
	inspectFuncListPartitionRole   func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse])
	afterListPartitionRoleCounter  uint64
	beforeListPartitionRoleCounter uint64
	ListPartitionRoleMock          mPartitionServiceHandlerMockListPartitionRole

	funcListTenant          func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse]) (err error)
	funcListTenantOrigin    string
	inspectFuncListTenant   func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse])
	afterListTenantCounter  uint64
	beforeListTenantCounter uint64
	ListTenantMock          mPartitionServiceHandlerMockListTenant

	funcRemoveAccess          func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) (pp2 *connect.Response[v1.RemoveAccessResponse], err error)
	funcRemoveAccessOrigin    string
	inspectFuncRemoveAccess   func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest])
	afterRemoveAccessCounter  uint64
	beforeRemoveAccessCounter uint64
	RemoveAccessMock          mPartitionServiceHandlerMockRemoveAccess

	funcRemoveAccessRole          func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) (pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error)
	funcRemoveAccessRoleOrigin    string
	inspectFuncRemoveAccessRole   func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest])
	afterRemoveAccessRoleCounter  uint64
	beforeRemoveAccessRoleCounter uint64
	RemoveAccessRoleMock          mPartitionServiceHandlerMockRemoveAccessRole

	funcRemovePage          func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) (pp2 *connect.Response[v1.RemovePageResponse], err error)
	funcRemovePageOrigin    string
	inspectFuncRemovePage   func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest])
	afterRemovePageCounter  uint64
	beforeRemovePageCounter uint64
	RemovePageMock          mPartitionServiceHandlerMockRemovePage

	funcRemovePartitionRole          func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) (pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error)
	funcRemovePartitionRoleOrigin    string
	inspectFuncRemovePartitionRole   func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest])
	afterRemovePartitionRoleCounter  uint64
	beforeRemovePartitionRoleCounter uint64
	RemovePartitionRoleMock          mPartitionServiceHandlerMockRemovePartitionRole

	funcUpdatePartition          func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) (pp2 *connect.Response[v1.UpdatePartitionResponse], err error)
	funcUpdatePartitionOrigin    string
	inspectFuncUpdatePartition   func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest])
	afterUpdatePartitionCounter  uint64
	beforeUpdatePartitionCounter uint64
	UpdatePartitionMock          mPartitionServiceHandlerMockUpdatePartition

	funcUpdateTenant          func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) (pp2 *connect.Response[v1.UpdateTenantResponse], err error)
	funcUpdateTenantOrigin    string
	inspectFuncUpdateTenant   func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest])
	afterUpdateTenantCounter  uint64
	beforeUpdateTenantCounter uint64
	UpdateTenantMock          mPartitionServiceHandlerMockUpdateTenant
}

// NewPartitionServiceHandlerMock returns a mock for mm_partitionv1connect.PartitionServiceHandler
func NewPartitionServiceHandlerMock(t minimock.Tester) *PartitionServiceHandlerMock {
	m := &PartitionServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAccessMock = mPartitionServiceHandlerMockCreateAccess{mock: m}
	m.CreateAccessMock.callArgs = []*PartitionServiceHandlerMockCreateAccessParams{}

	m.CreateAccessRoleMock = mPartitionServiceHandlerMockCreateAccessRole{mock: m}
	m.CreateAccessRoleMock.callArgs = []*PartitionServiceHandlerMockCreateAccessRoleParams{}

	m.CreatePageMock = mPartitionServiceHandlerMockCreatePage{mock: m}
	m.CreatePageMock.callArgs = []*PartitionServiceHandlerMockCreatePageParams{}

	m.CreatePartitionMock = mPartitionServiceHandlerMockCreatePartition{mock: m}
	m.CreatePartitionMock.callArgs = []*PartitionServiceHandlerMockCreatePartitionParams{}

	m.CreatePartitionRoleMock = mPartitionServiceHandlerMockCreatePartitionRole{mock: m}
	m.CreatePartitionRoleMock.callArgs = []*PartitionServiceHandlerMockCreatePartitionRoleParams{}

	m.CreateTenantMock = mPartitionServiceHandlerMockCreateTenant{mock: m}
	m.CreateTenantMock.callArgs = []*PartitionServiceHandlerMockCreateTenantParams{}

	m.GetAccessMock = mPartitionServiceHandlerMockGetAccess{mock: m}
	m.GetAccessMock.callArgs = []*PartitionServiceHandlerMockGetAccessParams{}

	m.GetPageMock = mPartitionServiceHandlerMockGetPage{mock: m}
	m.GetPageMock.callArgs = []*PartitionServiceHandlerMockGetPageParams{}

	m.GetPartitionMock = mPartitionServiceHandlerMockGetPartition{mock: m}
	m.GetPartitionMock.callArgs = []*PartitionServiceHandlerMockGetPartitionParams{}

	m.GetPartitionParentsMock = mPartitionServiceHandlerMockGetPartitionParents{mock: m}
	m.GetPartitionParentsMock.callArgs = []*PartitionServiceHandlerMockGetPartitionParentsParams{}

	m.GetTenantMock = mPartitionServiceHandlerMockGetTenant{mock: m}
	m.GetTenantMock.callArgs = []*PartitionServiceHandlerMockGetTenantParams{}

	m.ListAccessRoleMock = mPartitionServiceHandlerMockListAccessRole{mock: m}
	m.ListAccessRoleMock.callArgs = []*PartitionServiceHandlerMockListAccessRoleParams{}

	m.ListPartitionMock = mPartitionServiceHandlerMockListPartition{mock: m}
	m.ListPartitionMock.callArgs = []*PartitionServiceHandlerMockListPartitionParams{}

	m.ListPartitionRoleMock = mPartitionServiceHandlerMockListPartitionRole{mock: m}
	m.ListPartitionRoleMock.callArgs = []*PartitionServiceHandlerMockListPartitionRoleParams{}

	m.ListTenantMock = mPartitionServiceHandlerMockListTenant{mock: m}
	m.ListTenantMock.callArgs = []*PartitionServiceHandlerMockListTenantParams{}

	m.RemoveAccessMock = mPartitionServiceHandlerMockRemoveAccess{mock: m}
	m.RemoveAccessMock.callArgs = []*PartitionServiceHandlerMockRemoveAccessParams{}

	m.RemoveAccessRoleMock = mPartitionServiceHandlerMockRemoveAccessRole{mock: m}
	m.RemoveAccessRoleMock.callArgs = []*PartitionServiceHandlerMockRemoveAccessRoleParams{}

	m.RemovePageMock = mPartitionServiceHandlerMockRemovePage{mock: m}
	m.RemovePageMock.callArgs = []*PartitionServiceHandlerMockRemovePageParams{}

	m.RemovePartitionRoleMock = mPartitionServiceHandlerMockRemovePartitionRole{mock: m}
	m.RemovePartitionRoleMock.callArgs = []*PartitionServiceHandlerMockRemovePartitionRoleParams{}

	m.UpdatePartitionMock = mPartitionServiceHandlerMockUpdatePartition{mock: m}
	m.UpdatePartitionMock.callArgs = []*PartitionServiceHandlerMockUpdatePartitionParams{}

	m.UpdateTenantMock = mPartitionServiceHandlerMockUpdateTenant{mock: m}
	m.UpdateTenantMock.callArgs = []*PartitionServiceHandlerMockUpdateTenantParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPartitionServiceHandlerMockCreateAccess struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockCreateAccessExpectation
	expectations       []*PartitionServiceHandlerMockCreateAccessExpectation

	callArgs []*PartitionServiceHandlerMockCreateAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockCreateAccessExpectation specifies expectation struct of the PartitionServiceHandler.CreateAccess
type PartitionServiceHandlerMockCreateAccessExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockCreateAccessParams
	paramPtrs          *PartitionServiceHandlerMockCreateAccessParamPtrs
	expectationOrigins PartitionServiceHandlerMockCreateAccessExpectationOrigins
	results            *PartitionServiceHandlerMockCreateAccessResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockCreateAccessParams contains parameters of the PartitionServiceHandler.CreateAccess
type PartitionServiceHandlerMockCreateAccessParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateAccessRequest]
}

// PartitionServiceHandlerMockCreateAccessParamPtrs contains pointers to parameters of the PartitionServiceHandler.CreateAccess
type PartitionServiceHandlerMockCreateAccessParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateAccessRequest]
}

// PartitionServiceHandlerMockCreateAccessResults contains results of the PartitionServiceHandler.CreateAccess
type PartitionServiceHandlerMockCreateAccessResults struct {
	pp2 *connect.Response[v1.CreateAccessResponse]
	err error
}

// PartitionServiceHandlerMockCreateAccessOrigins contains origins of expectations of the PartitionServiceHandler.CreateAccess
type PartitionServiceHandlerMockCreateAccessExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Optional() *mPartitionServiceHandlerMockCreateAccess {
	mmCreateAccess.optional = true
	return mmCreateAccess
}

// Expect sets up expected params for PartitionServiceHandler.CreateAccess
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) *mPartitionServiceHandlerMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceHandlerMockCreateAccessExpectation{}
	}

	if mmCreateAccess.defaultExpectation.paramPtrs != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by ExpectParams functions")
	}

	mmCreateAccess.defaultExpectation.params = &PartitionServiceHandlerMockCreateAccessParams{ctx, pp1}
	mmCreateAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccess.expectations {
		if minimock.Equal(e.params, mmCreateAccess.defaultExpectation.params) {
			mmCreateAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccess.defaultExpectation.params)
		}
	}

	return mmCreateAccess
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.CreateAccess
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceHandlerMockCreateAccessExpectation{}
	}

	if mmCreateAccess.defaultExpectation.params != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Expect")
	}

	if mmCreateAccess.defaultExpectation.paramPtrs == nil {
		mmCreateAccess.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreateAccessParamPtrs{}
	}
	mmCreateAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccess
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.CreateAccess
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) ExpectPp1Param2(pp1 *connect.Request[v1.CreateAccessRequest]) *mPartitionServiceHandlerMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceHandlerMockCreateAccessExpectation{}
	}

	if mmCreateAccess.defaultExpectation.params != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Expect")
	}

	if mmCreateAccess.defaultExpectation.paramPtrs == nil {
		mmCreateAccess.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreateAccessParamPtrs{}
	}
	mmCreateAccess.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateAccess.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateAccess
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.CreateAccess
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest])) *mPartitionServiceHandlerMockCreateAccess {
	if mmCreateAccess.mock.inspectFuncCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.CreateAccess")
	}

	mmCreateAccess.mock.inspectFuncCreateAccess = f

	return mmCreateAccess
}

// Return sets up results that will be returned by PartitionServiceHandler.CreateAccess
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Return(pp2 *connect.Response[v1.CreateAccessResponse], err error) *PartitionServiceHandlerMock {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceHandlerMockCreateAccessExpectation{mock: mmCreateAccess.mock}
	}
	mmCreateAccess.defaultExpectation.results = &PartitionServiceHandlerMockCreateAccessResults{pp2, err}
	mmCreateAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccess.mock
}

// Set uses given function f to mock the PartitionServiceHandler.CreateAccess method
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) (pp2 *connect.Response[v1.CreateAccessResponse], err error)) *PartitionServiceHandlerMock {
	if mmCreateAccess.defaultExpectation != nil {
		mmCreateAccess.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.CreateAccess method")
	}

	if len(mmCreateAccess.expectations) > 0 {
		mmCreateAccess.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.CreateAccess method")
	}

	mmCreateAccess.mock.funcCreateAccess = f
	mmCreateAccess.mock.funcCreateAccessOrigin = minimock.CallerInfo(1)
	return mmCreateAccess.mock
}

// When sets expectation for the PartitionServiceHandler.CreateAccess which will trigger the result defined by the following
// Then helper
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) When(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) *PartitionServiceHandlerMockCreateAccessExpectation {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccess mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockCreateAccessExpectation{
		mock:               mmCreateAccess.mock,
		params:             &PartitionServiceHandlerMockCreateAccessParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockCreateAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccess.expectations = append(mmCreateAccess.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.CreateAccess return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockCreateAccessExpectation) Then(pp2 *connect.Response[v1.CreateAccessResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockCreateAccessResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.CreateAccess should be invoked
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Times(n uint64) *mPartitionServiceHandlerMockCreateAccess {
	if n == 0 {
		mmCreateAccess.mock.t.Fatalf("Times of PartitionServiceHandlerMock.CreateAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccess.expectedInvocations, n)
	mmCreateAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccess
}

func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) invocationsDone() bool {
	if len(mmCreateAccess.expectations) == 0 && mmCreateAccess.defaultExpectation == nil && mmCreateAccess.mock.funcCreateAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccess.mock.afterCreateAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccess implements mm_partitionv1connect.PartitionServiceHandler
func (mmCreateAccess *PartitionServiceHandlerMock) CreateAccess(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) (pp2 *connect.Response[v1.CreateAccessResponse], err error) {
	mm_atomic.AddUint64(&mmCreateAccess.beforeCreateAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccess.afterCreateAccessCounter, 1)

	mmCreateAccess.t.Helper()

	if mmCreateAccess.inspectFuncCreateAccess != nil {
		mmCreateAccess.inspectFuncCreateAccess(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockCreateAccessParams{ctx, pp1}

	// Record call args
	mmCreateAccess.CreateAccessMock.mutex.Lock()
	mmCreateAccess.CreateAccessMock.callArgs = append(mmCreateAccess.CreateAccessMock.callArgs, &mm_params)
	mmCreateAccess.CreateAccessMock.mutex.Unlock()

	for _, e := range mmCreateAccess.CreateAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateAccess.CreateAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccess.CreateAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccess.CreateAccessMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccess.CreateAccessMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockCreateAccessParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccess.t.Errorf("PartitionServiceHandlerMock.CreateAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccess.CreateAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateAccess.t.Errorf("PartitionServiceHandlerMock.CreateAccess got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccess.CreateAccessMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccess.t.Errorf("PartitionServiceHandlerMock.CreateAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccess.CreateAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccess.CreateAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccess.t.Fatal("No results are set for the PartitionServiceHandlerMock.CreateAccess")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateAccess.funcCreateAccess != nil {
		return mmCreateAccess.funcCreateAccess(ctx, pp1)
	}
	mmCreateAccess.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.CreateAccess. %v %v", ctx, pp1)
	return
}

// CreateAccessAfterCounter returns a count of finished PartitionServiceHandlerMock.CreateAccess invocations
func (mmCreateAccess *PartitionServiceHandlerMock) CreateAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.afterCreateAccessCounter)
}

// CreateAccessBeforeCounter returns a count of PartitionServiceHandlerMock.CreateAccess invocations
func (mmCreateAccess *PartitionServiceHandlerMock) CreateAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.beforeCreateAccessCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.CreateAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccess *mPartitionServiceHandlerMockCreateAccess) Calls() []*PartitionServiceHandlerMockCreateAccessParams {
	mmCreateAccess.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockCreateAccessParams, len(mmCreateAccess.callArgs))
	copy(argCopy, mmCreateAccess.callArgs)

	mmCreateAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessDone returns true if the count of the CreateAccess invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockCreateAccessDone() bool {
	if m.CreateAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccessMock.invocationsDone()
}

// MinimockCreateAccessInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockCreateAccessInspect() {
	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccessCounter := mm_atomic.LoadUint64(&m.afterCreateAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessMock.defaultExpectation != nil && afterCreateAccessCounter < 1 {
		if m.CreateAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccess at\n%s", m.CreateAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccess at\n%s with params: %#v", m.CreateAccessMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccess != nil && afterCreateAccessCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccess at\n%s", m.funcCreateAccessOrigin)
	}

	if !m.CreateAccessMock.invocationsDone() && afterCreateAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.CreateAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccessMock.expectedInvocations), m.CreateAccessMock.expectedInvocationsOrigin, afterCreateAccessCounter)
	}
}

type mPartitionServiceHandlerMockCreateAccessRole struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockCreateAccessRoleExpectation
	expectations       []*PartitionServiceHandlerMockCreateAccessRoleExpectation

	callArgs []*PartitionServiceHandlerMockCreateAccessRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockCreateAccessRoleExpectation specifies expectation struct of the PartitionServiceHandler.CreateAccessRole
type PartitionServiceHandlerMockCreateAccessRoleExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockCreateAccessRoleParams
	paramPtrs          *PartitionServiceHandlerMockCreateAccessRoleParamPtrs
	expectationOrigins PartitionServiceHandlerMockCreateAccessRoleExpectationOrigins
	results            *PartitionServiceHandlerMockCreateAccessRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockCreateAccessRoleParams contains parameters of the PartitionServiceHandler.CreateAccessRole
type PartitionServiceHandlerMockCreateAccessRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateAccessRoleRequest]
}

// PartitionServiceHandlerMockCreateAccessRoleParamPtrs contains pointers to parameters of the PartitionServiceHandler.CreateAccessRole
type PartitionServiceHandlerMockCreateAccessRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateAccessRoleRequest]
}

// PartitionServiceHandlerMockCreateAccessRoleResults contains results of the PartitionServiceHandler.CreateAccessRole
type PartitionServiceHandlerMockCreateAccessRoleResults struct {
	pp2 *connect.Response[v1.CreateAccessRoleResponse]
	err error
}

// PartitionServiceHandlerMockCreateAccessRoleOrigins contains origins of expectations of the PartitionServiceHandler.CreateAccessRole
type PartitionServiceHandlerMockCreateAccessRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Optional() *mPartitionServiceHandlerMockCreateAccessRole {
	mmCreateAccessRole.optional = true
	return mmCreateAccessRole
}

// Expect sets up expected params for PartitionServiceHandler.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) *mPartitionServiceHandlerMockCreateAccessRole {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceHandlerMockCreateAccessRoleExpectation{}
	}

	if mmCreateAccessRole.defaultExpectation.paramPtrs != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by ExpectParams functions")
	}

	mmCreateAccessRole.defaultExpectation.params = &PartitionServiceHandlerMockCreateAccessRoleParams{ctx, pp1}
	mmCreateAccessRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccessRole.expectations {
		if minimock.Equal(e.params, mmCreateAccessRole.defaultExpectation.params) {
			mmCreateAccessRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccessRole.defaultExpectation.params)
		}
	}

	return mmCreateAccessRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockCreateAccessRole {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceHandlerMockCreateAccessRoleExpectation{}
	}

	if mmCreateAccessRole.defaultExpectation.params != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Expect")
	}

	if mmCreateAccessRole.defaultExpectation.paramPtrs == nil {
		mmCreateAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreateAccessRoleParamPtrs{}
	}
	mmCreateAccessRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccessRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccessRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) ExpectPp1Param2(pp1 *connect.Request[v1.CreateAccessRoleRequest]) *mPartitionServiceHandlerMockCreateAccessRole {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceHandlerMockCreateAccessRoleExpectation{}
	}

	if mmCreateAccessRole.defaultExpectation.params != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Expect")
	}

	if mmCreateAccessRole.defaultExpectation.paramPtrs == nil {
		mmCreateAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreateAccessRoleParamPtrs{}
	}
	mmCreateAccessRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateAccessRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateAccessRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest])) *mPartitionServiceHandlerMockCreateAccessRole {
	if mmCreateAccessRole.mock.inspectFuncCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.CreateAccessRole")
	}

	mmCreateAccessRole.mock.inspectFuncCreateAccessRole = f

	return mmCreateAccessRole
}

// Return sets up results that will be returned by PartitionServiceHandler.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Return(pp2 *connect.Response[v1.CreateAccessRoleResponse], err error) *PartitionServiceHandlerMock {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceHandlerMockCreateAccessRoleExpectation{mock: mmCreateAccessRole.mock}
	}
	mmCreateAccessRole.defaultExpectation.results = &PartitionServiceHandlerMockCreateAccessRoleResults{pp2, err}
	mmCreateAccessRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccessRole.mock
}

// Set uses given function f to mock the PartitionServiceHandler.CreateAccessRole method
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) (pp2 *connect.Response[v1.CreateAccessRoleResponse], err error)) *PartitionServiceHandlerMock {
	if mmCreateAccessRole.defaultExpectation != nil {
		mmCreateAccessRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.CreateAccessRole method")
	}

	if len(mmCreateAccessRole.expectations) > 0 {
		mmCreateAccessRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.CreateAccessRole method")
	}

	mmCreateAccessRole.mock.funcCreateAccessRole = f
	mmCreateAccessRole.mock.funcCreateAccessRoleOrigin = minimock.CallerInfo(1)
	return mmCreateAccessRole.mock
}

// When sets expectation for the PartitionServiceHandler.CreateAccessRole which will trigger the result defined by the following
// Then helper
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) When(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) *PartitionServiceHandlerMockCreateAccessRoleExpectation {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreateAccessRole mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockCreateAccessRoleExpectation{
		mock:               mmCreateAccessRole.mock,
		params:             &PartitionServiceHandlerMockCreateAccessRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockCreateAccessRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccessRole.expectations = append(mmCreateAccessRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.CreateAccessRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockCreateAccessRoleExpectation) Then(pp2 *connect.Response[v1.CreateAccessRoleResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockCreateAccessRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.CreateAccessRole should be invoked
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Times(n uint64) *mPartitionServiceHandlerMockCreateAccessRole {
	if n == 0 {
		mmCreateAccessRole.mock.t.Fatalf("Times of PartitionServiceHandlerMock.CreateAccessRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccessRole.expectedInvocations, n)
	mmCreateAccessRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccessRole
}

func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) invocationsDone() bool {
	if len(mmCreateAccessRole.expectations) == 0 && mmCreateAccessRole.defaultExpectation == nil && mmCreateAccessRole.mock.funcCreateAccessRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccessRole.mock.afterCreateAccessRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccessRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccessRole implements mm_partitionv1connect.PartitionServiceHandler
func (mmCreateAccessRole *PartitionServiceHandlerMock) CreateAccessRole(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) (pp2 *connect.Response[v1.CreateAccessRoleResponse], err error) {
	mm_atomic.AddUint64(&mmCreateAccessRole.beforeCreateAccessRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccessRole.afterCreateAccessRoleCounter, 1)

	mmCreateAccessRole.t.Helper()

	if mmCreateAccessRole.inspectFuncCreateAccessRole != nil {
		mmCreateAccessRole.inspectFuncCreateAccessRole(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockCreateAccessRoleParams{ctx, pp1}

	// Record call args
	mmCreateAccessRole.CreateAccessRoleMock.mutex.Lock()
	mmCreateAccessRole.CreateAccessRoleMock.callArgs = append(mmCreateAccessRole.CreateAccessRoleMock.callArgs, &mm_params)
	mmCreateAccessRole.CreateAccessRoleMock.mutex.Unlock()

	for _, e := range mmCreateAccessRole.CreateAccessRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockCreateAccessRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccessRole.t.Errorf("PartitionServiceHandlerMock.CreateAccessRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateAccessRole.t.Errorf("PartitionServiceHandlerMock.CreateAccessRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccessRole.t.Errorf("PartitionServiceHandlerMock.CreateAccessRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccessRole.t.Fatal("No results are set for the PartitionServiceHandlerMock.CreateAccessRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateAccessRole.funcCreateAccessRole != nil {
		return mmCreateAccessRole.funcCreateAccessRole(ctx, pp1)
	}
	mmCreateAccessRole.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.CreateAccessRole. %v %v", ctx, pp1)
	return
}

// CreateAccessRoleAfterCounter returns a count of finished PartitionServiceHandlerMock.CreateAccessRole invocations
func (mmCreateAccessRole *PartitionServiceHandlerMock) CreateAccessRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccessRole.afterCreateAccessRoleCounter)
}

// CreateAccessRoleBeforeCounter returns a count of PartitionServiceHandlerMock.CreateAccessRole invocations
func (mmCreateAccessRole *PartitionServiceHandlerMock) CreateAccessRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccessRole.beforeCreateAccessRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.CreateAccessRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccessRole *mPartitionServiceHandlerMockCreateAccessRole) Calls() []*PartitionServiceHandlerMockCreateAccessRoleParams {
	mmCreateAccessRole.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockCreateAccessRoleParams, len(mmCreateAccessRole.callArgs))
	copy(argCopy, mmCreateAccessRole.callArgs)

	mmCreateAccessRole.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessRoleDone returns true if the count of the CreateAccessRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockCreateAccessRoleDone() bool {
	if m.CreateAccessRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccessRoleMock.invocationsDone()
}

// MinimockCreateAccessRoleInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockCreateAccessRoleInspect() {
	for _, e := range m.CreateAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccessRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccessRoleCounter := mm_atomic.LoadUint64(&m.afterCreateAccessRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessRoleMock.defaultExpectation != nil && afterCreateAccessRoleCounter < 1 {
		if m.CreateAccessRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccessRole at\n%s", m.CreateAccessRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccessRole at\n%s with params: %#v", m.CreateAccessRoleMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccessRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccessRole != nil && afterCreateAccessRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateAccessRole at\n%s", m.funcCreateAccessRoleOrigin)
	}

	if !m.CreateAccessRoleMock.invocationsDone() && afterCreateAccessRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.CreateAccessRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccessRoleMock.expectedInvocations), m.CreateAccessRoleMock.expectedInvocationsOrigin, afterCreateAccessRoleCounter)
	}
}

type mPartitionServiceHandlerMockCreatePage struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockCreatePageExpectation
	expectations       []*PartitionServiceHandlerMockCreatePageExpectation

	callArgs []*PartitionServiceHandlerMockCreatePageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockCreatePageExpectation specifies expectation struct of the PartitionServiceHandler.CreatePage
type PartitionServiceHandlerMockCreatePageExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockCreatePageParams
	paramPtrs          *PartitionServiceHandlerMockCreatePageParamPtrs
	expectationOrigins PartitionServiceHandlerMockCreatePageExpectationOrigins
	results            *PartitionServiceHandlerMockCreatePageResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockCreatePageParams contains parameters of the PartitionServiceHandler.CreatePage
type PartitionServiceHandlerMockCreatePageParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePageRequest]
}

// PartitionServiceHandlerMockCreatePageParamPtrs contains pointers to parameters of the PartitionServiceHandler.CreatePage
type PartitionServiceHandlerMockCreatePageParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePageRequest]
}

// PartitionServiceHandlerMockCreatePageResults contains results of the PartitionServiceHandler.CreatePage
type PartitionServiceHandlerMockCreatePageResults struct {
	pp2 *connect.Response[v1.CreatePageResponse]
	err error
}

// PartitionServiceHandlerMockCreatePageOrigins contains origins of expectations of the PartitionServiceHandler.CreatePage
type PartitionServiceHandlerMockCreatePageExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Optional() *mPartitionServiceHandlerMockCreatePage {
	mmCreatePage.optional = true
	return mmCreatePage
}

// Expect sets up expected params for PartitionServiceHandler.CreatePage
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) *mPartitionServiceHandlerMockCreatePage {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceHandlerMockCreatePageExpectation{}
	}

	if mmCreatePage.defaultExpectation.paramPtrs != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by ExpectParams functions")
	}

	mmCreatePage.defaultExpectation.params = &PartitionServiceHandlerMockCreatePageParams{ctx, pp1}
	mmCreatePage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePage.expectations {
		if minimock.Equal(e.params, mmCreatePage.defaultExpectation.params) {
			mmCreatePage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePage.defaultExpectation.params)
		}
	}

	return mmCreatePage
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.CreatePage
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockCreatePage {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceHandlerMockCreatePageExpectation{}
	}

	if mmCreatePage.defaultExpectation.params != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Expect")
	}

	if mmCreatePage.defaultExpectation.paramPtrs == nil {
		mmCreatePage.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreatePageParamPtrs{}
	}
	mmCreatePage.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePage
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.CreatePage
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePageRequest]) *mPartitionServiceHandlerMockCreatePage {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceHandlerMockCreatePageExpectation{}
	}

	if mmCreatePage.defaultExpectation.params != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Expect")
	}

	if mmCreatePage.defaultExpectation.paramPtrs == nil {
		mmCreatePage.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreatePageParamPtrs{}
	}
	mmCreatePage.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePage.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePage
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.CreatePage
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest])) *mPartitionServiceHandlerMockCreatePage {
	if mmCreatePage.mock.inspectFuncCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.CreatePage")
	}

	mmCreatePage.mock.inspectFuncCreatePage = f

	return mmCreatePage
}

// Return sets up results that will be returned by PartitionServiceHandler.CreatePage
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Return(pp2 *connect.Response[v1.CreatePageResponse], err error) *PartitionServiceHandlerMock {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceHandlerMockCreatePageExpectation{mock: mmCreatePage.mock}
	}
	mmCreatePage.defaultExpectation.results = &PartitionServiceHandlerMockCreatePageResults{pp2, err}
	mmCreatePage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePage.mock
}

// Set uses given function f to mock the PartitionServiceHandler.CreatePage method
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) (pp2 *connect.Response[v1.CreatePageResponse], err error)) *PartitionServiceHandlerMock {
	if mmCreatePage.defaultExpectation != nil {
		mmCreatePage.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.CreatePage method")
	}

	if len(mmCreatePage.expectations) > 0 {
		mmCreatePage.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.CreatePage method")
	}

	mmCreatePage.mock.funcCreatePage = f
	mmCreatePage.mock.funcCreatePageOrigin = minimock.CallerInfo(1)
	return mmCreatePage.mock
}

// When sets expectation for the PartitionServiceHandler.CreatePage which will trigger the result defined by the following
// Then helper
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) When(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) *PartitionServiceHandlerMockCreatePageExpectation {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePage mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockCreatePageExpectation{
		mock:               mmCreatePage.mock,
		params:             &PartitionServiceHandlerMockCreatePageParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockCreatePageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePage.expectations = append(mmCreatePage.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.CreatePage return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockCreatePageExpectation) Then(pp2 *connect.Response[v1.CreatePageResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockCreatePageResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.CreatePage should be invoked
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Times(n uint64) *mPartitionServiceHandlerMockCreatePage {
	if n == 0 {
		mmCreatePage.mock.t.Fatalf("Times of PartitionServiceHandlerMock.CreatePage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePage.expectedInvocations, n)
	mmCreatePage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePage
}

func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) invocationsDone() bool {
	if len(mmCreatePage.expectations) == 0 && mmCreatePage.defaultExpectation == nil && mmCreatePage.mock.funcCreatePage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePage.mock.afterCreatePageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePage implements mm_partitionv1connect.PartitionServiceHandler
func (mmCreatePage *PartitionServiceHandlerMock) CreatePage(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) (pp2 *connect.Response[v1.CreatePageResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePage.beforeCreatePageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePage.afterCreatePageCounter, 1)

	mmCreatePage.t.Helper()

	if mmCreatePage.inspectFuncCreatePage != nil {
		mmCreatePage.inspectFuncCreatePage(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockCreatePageParams{ctx, pp1}

	// Record call args
	mmCreatePage.CreatePageMock.mutex.Lock()
	mmCreatePage.CreatePageMock.callArgs = append(mmCreatePage.CreatePageMock.callArgs, &mm_params)
	mmCreatePage.CreatePageMock.mutex.Unlock()

	for _, e := range mmCreatePage.CreatePageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePage.CreatePageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePage.CreatePageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePage.CreatePageMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePage.CreatePageMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockCreatePageParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePage.t.Errorf("PartitionServiceHandlerMock.CreatePage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePage.CreatePageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePage.t.Errorf("PartitionServiceHandlerMock.CreatePage got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePage.CreatePageMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePage.t.Errorf("PartitionServiceHandlerMock.CreatePage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePage.CreatePageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePage.CreatePageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePage.t.Fatal("No results are set for the PartitionServiceHandlerMock.CreatePage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePage.funcCreatePage != nil {
		return mmCreatePage.funcCreatePage(ctx, pp1)
	}
	mmCreatePage.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.CreatePage. %v %v", ctx, pp1)
	return
}

// CreatePageAfterCounter returns a count of finished PartitionServiceHandlerMock.CreatePage invocations
func (mmCreatePage *PartitionServiceHandlerMock) CreatePageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePage.afterCreatePageCounter)
}

// CreatePageBeforeCounter returns a count of PartitionServiceHandlerMock.CreatePage invocations
func (mmCreatePage *PartitionServiceHandlerMock) CreatePageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePage.beforeCreatePageCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.CreatePage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePage *mPartitionServiceHandlerMockCreatePage) Calls() []*PartitionServiceHandlerMockCreatePageParams {
	mmCreatePage.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockCreatePageParams, len(mmCreatePage.callArgs))
	copy(argCopy, mmCreatePage.callArgs)

	mmCreatePage.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePageDone returns true if the count of the CreatePage invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockCreatePageDone() bool {
	if m.CreatePageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePageMock.invocationsDone()
}

// MinimockCreatePageInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockCreatePageInspect() {
	for _, e := range m.CreatePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePageCounter := mm_atomic.LoadUint64(&m.afterCreatePageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePageMock.defaultExpectation != nil && afterCreatePageCounter < 1 {
		if m.CreatePageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePage at\n%s", m.CreatePageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePage at\n%s with params: %#v", m.CreatePageMock.defaultExpectation.expectationOrigins.origin, *m.CreatePageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePage != nil && afterCreatePageCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePage at\n%s", m.funcCreatePageOrigin)
	}

	if !m.CreatePageMock.invocationsDone() && afterCreatePageCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.CreatePage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePageMock.expectedInvocations), m.CreatePageMock.expectedInvocationsOrigin, afterCreatePageCounter)
	}
}

type mPartitionServiceHandlerMockCreatePartition struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockCreatePartitionExpectation
	expectations       []*PartitionServiceHandlerMockCreatePartitionExpectation

	callArgs []*PartitionServiceHandlerMockCreatePartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockCreatePartitionExpectation specifies expectation struct of the PartitionServiceHandler.CreatePartition
type PartitionServiceHandlerMockCreatePartitionExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockCreatePartitionParams
	paramPtrs          *PartitionServiceHandlerMockCreatePartitionParamPtrs
	expectationOrigins PartitionServiceHandlerMockCreatePartitionExpectationOrigins
	results            *PartitionServiceHandlerMockCreatePartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockCreatePartitionParams contains parameters of the PartitionServiceHandler.CreatePartition
type PartitionServiceHandlerMockCreatePartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePartitionRequest]
}

// PartitionServiceHandlerMockCreatePartitionParamPtrs contains pointers to parameters of the PartitionServiceHandler.CreatePartition
type PartitionServiceHandlerMockCreatePartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePartitionRequest]
}

// PartitionServiceHandlerMockCreatePartitionResults contains results of the PartitionServiceHandler.CreatePartition
type PartitionServiceHandlerMockCreatePartitionResults struct {
	pp2 *connect.Response[v1.CreatePartitionResponse]
	err error
}

// PartitionServiceHandlerMockCreatePartitionOrigins contains origins of expectations of the PartitionServiceHandler.CreatePartition
type PartitionServiceHandlerMockCreatePartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Optional() *mPartitionServiceHandlerMockCreatePartition {
	mmCreatePartition.optional = true
	return mmCreatePartition
}

// Expect sets up expected params for PartitionServiceHandler.CreatePartition
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) *mPartitionServiceHandlerMockCreatePartition {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionExpectation{}
	}

	if mmCreatePartition.defaultExpectation.paramPtrs != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by ExpectParams functions")
	}

	mmCreatePartition.defaultExpectation.params = &PartitionServiceHandlerMockCreatePartitionParams{ctx, pp1}
	mmCreatePartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePartition.expectations {
		if minimock.Equal(e.params, mmCreatePartition.defaultExpectation.params) {
			mmCreatePartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePartition.defaultExpectation.params)
		}
	}

	return mmCreatePartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.CreatePartition
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockCreatePartition {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionExpectation{}
	}

	if mmCreatePartition.defaultExpectation.params != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Expect")
	}

	if mmCreatePartition.defaultExpectation.paramPtrs == nil {
		mmCreatePartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreatePartitionParamPtrs{}
	}
	mmCreatePartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.CreatePartition
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePartitionRequest]) *mPartitionServiceHandlerMockCreatePartition {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionExpectation{}
	}

	if mmCreatePartition.defaultExpectation.params != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Expect")
	}

	if mmCreatePartition.defaultExpectation.paramPtrs == nil {
		mmCreatePartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreatePartitionParamPtrs{}
	}
	mmCreatePartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.CreatePartition
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest])) *mPartitionServiceHandlerMockCreatePartition {
	if mmCreatePartition.mock.inspectFuncCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.CreatePartition")
	}

	mmCreatePartition.mock.inspectFuncCreatePartition = f

	return mmCreatePartition
}

// Return sets up results that will be returned by PartitionServiceHandler.CreatePartition
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Return(pp2 *connect.Response[v1.CreatePartitionResponse], err error) *PartitionServiceHandlerMock {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionExpectation{mock: mmCreatePartition.mock}
	}
	mmCreatePartition.defaultExpectation.results = &PartitionServiceHandlerMockCreatePartitionResults{pp2, err}
	mmCreatePartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePartition.mock
}

// Set uses given function f to mock the PartitionServiceHandler.CreatePartition method
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) (pp2 *connect.Response[v1.CreatePartitionResponse], err error)) *PartitionServiceHandlerMock {
	if mmCreatePartition.defaultExpectation != nil {
		mmCreatePartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.CreatePartition method")
	}

	if len(mmCreatePartition.expectations) > 0 {
		mmCreatePartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.CreatePartition method")
	}

	mmCreatePartition.mock.funcCreatePartition = f
	mmCreatePartition.mock.funcCreatePartitionOrigin = minimock.CallerInfo(1)
	return mmCreatePartition.mock
}

// When sets expectation for the PartitionServiceHandler.CreatePartition which will trigger the result defined by the following
// Then helper
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) When(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) *PartitionServiceHandlerMockCreatePartitionExpectation {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartition mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockCreatePartitionExpectation{
		mock:               mmCreatePartition.mock,
		params:             &PartitionServiceHandlerMockCreatePartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockCreatePartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePartition.expectations = append(mmCreatePartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.CreatePartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockCreatePartitionExpectation) Then(pp2 *connect.Response[v1.CreatePartitionResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockCreatePartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.CreatePartition should be invoked
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Times(n uint64) *mPartitionServiceHandlerMockCreatePartition {
	if n == 0 {
		mmCreatePartition.mock.t.Fatalf("Times of PartitionServiceHandlerMock.CreatePartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePartition.expectedInvocations, n)
	mmCreatePartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePartition
}

func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) invocationsDone() bool {
	if len(mmCreatePartition.expectations) == 0 && mmCreatePartition.defaultExpectation == nil && mmCreatePartition.mock.funcCreatePartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePartition.mock.afterCreatePartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePartition implements mm_partitionv1connect.PartitionServiceHandler
func (mmCreatePartition *PartitionServiceHandlerMock) CreatePartition(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) (pp2 *connect.Response[v1.CreatePartitionResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePartition.beforeCreatePartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePartition.afterCreatePartitionCounter, 1)

	mmCreatePartition.t.Helper()

	if mmCreatePartition.inspectFuncCreatePartition != nil {
		mmCreatePartition.inspectFuncCreatePartition(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockCreatePartitionParams{ctx, pp1}

	// Record call args
	mmCreatePartition.CreatePartitionMock.mutex.Lock()
	mmCreatePartition.CreatePartitionMock.callArgs = append(mmCreatePartition.CreatePartitionMock.callArgs, &mm_params)
	mmCreatePartition.CreatePartitionMock.mutex.Unlock()

	for _, e := range mmCreatePartition.CreatePartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePartition.CreatePartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePartition.CreatePartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePartition.CreatePartitionMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePartition.CreatePartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockCreatePartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePartition.t.Errorf("PartitionServiceHandlerMock.CreatePartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartition.CreatePartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePartition.t.Errorf("PartitionServiceHandlerMock.CreatePartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartition.CreatePartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePartition.t.Errorf("PartitionServiceHandlerMock.CreatePartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePartition.CreatePartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePartition.CreatePartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePartition.t.Fatal("No results are set for the PartitionServiceHandlerMock.CreatePartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePartition.funcCreatePartition != nil {
		return mmCreatePartition.funcCreatePartition(ctx, pp1)
	}
	mmCreatePartition.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.CreatePartition. %v %v", ctx, pp1)
	return
}

// CreatePartitionAfterCounter returns a count of finished PartitionServiceHandlerMock.CreatePartition invocations
func (mmCreatePartition *PartitionServiceHandlerMock) CreatePartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartition.afterCreatePartitionCounter)
}

// CreatePartitionBeforeCounter returns a count of PartitionServiceHandlerMock.CreatePartition invocations
func (mmCreatePartition *PartitionServiceHandlerMock) CreatePartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartition.beforeCreatePartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.CreatePartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePartition *mPartitionServiceHandlerMockCreatePartition) Calls() []*PartitionServiceHandlerMockCreatePartitionParams {
	mmCreatePartition.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockCreatePartitionParams, len(mmCreatePartition.callArgs))
	copy(argCopy, mmCreatePartition.callArgs)

	mmCreatePartition.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePartitionDone returns true if the count of the CreatePartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockCreatePartitionDone() bool {
	if m.CreatePartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePartitionMock.invocationsDone()
}

// MinimockCreatePartitionInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockCreatePartitionInspect() {
	for _, e := range m.CreatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePartitionCounter := mm_atomic.LoadUint64(&m.afterCreatePartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePartitionMock.defaultExpectation != nil && afterCreatePartitionCounter < 1 {
		if m.CreatePartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartition at\n%s", m.CreatePartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartition at\n%s with params: %#v", m.CreatePartitionMock.defaultExpectation.expectationOrigins.origin, *m.CreatePartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePartition != nil && afterCreatePartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartition at\n%s", m.funcCreatePartitionOrigin)
	}

	if !m.CreatePartitionMock.invocationsDone() && afterCreatePartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.CreatePartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePartitionMock.expectedInvocations), m.CreatePartitionMock.expectedInvocationsOrigin, afterCreatePartitionCounter)
	}
}

type mPartitionServiceHandlerMockCreatePartitionRole struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockCreatePartitionRoleExpectation
	expectations       []*PartitionServiceHandlerMockCreatePartitionRoleExpectation

	callArgs []*PartitionServiceHandlerMockCreatePartitionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockCreatePartitionRoleExpectation specifies expectation struct of the PartitionServiceHandler.CreatePartitionRole
type PartitionServiceHandlerMockCreatePartitionRoleExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockCreatePartitionRoleParams
	paramPtrs          *PartitionServiceHandlerMockCreatePartitionRoleParamPtrs
	expectationOrigins PartitionServiceHandlerMockCreatePartitionRoleExpectationOrigins
	results            *PartitionServiceHandlerMockCreatePartitionRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockCreatePartitionRoleParams contains parameters of the PartitionServiceHandler.CreatePartitionRole
type PartitionServiceHandlerMockCreatePartitionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePartitionRoleRequest]
}

// PartitionServiceHandlerMockCreatePartitionRoleParamPtrs contains pointers to parameters of the PartitionServiceHandler.CreatePartitionRole
type PartitionServiceHandlerMockCreatePartitionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePartitionRoleRequest]
}

// PartitionServiceHandlerMockCreatePartitionRoleResults contains results of the PartitionServiceHandler.CreatePartitionRole
type PartitionServiceHandlerMockCreatePartitionRoleResults struct {
	pp2 *connect.Response[v1.CreatePartitionRoleResponse]
	err error
}

// PartitionServiceHandlerMockCreatePartitionRoleOrigins contains origins of expectations of the PartitionServiceHandler.CreatePartitionRole
type PartitionServiceHandlerMockCreatePartitionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Optional() *mPartitionServiceHandlerMockCreatePartitionRole {
	mmCreatePartitionRole.optional = true
	return mmCreatePartitionRole
}

// Expect sets up expected params for PartitionServiceHandler.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) *mPartitionServiceHandlerMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionRoleExpectation{}
	}

	if mmCreatePartitionRole.defaultExpectation.paramPtrs != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by ExpectParams functions")
	}

	mmCreatePartitionRole.defaultExpectation.params = &PartitionServiceHandlerMockCreatePartitionRoleParams{ctx, pp1}
	mmCreatePartitionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePartitionRole.expectations {
		if minimock.Equal(e.params, mmCreatePartitionRole.defaultExpectation.params) {
			mmCreatePartitionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePartitionRole.defaultExpectation.params)
		}
	}

	return mmCreatePartitionRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionRoleExpectation{}
	}

	if mmCreatePartitionRole.defaultExpectation.params != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Expect")
	}

	if mmCreatePartitionRole.defaultExpectation.paramPtrs == nil {
		mmCreatePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreatePartitionRoleParamPtrs{}
	}
	mmCreatePartitionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePartitionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePartitionRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePartitionRoleRequest]) *mPartitionServiceHandlerMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionRoleExpectation{}
	}

	if mmCreatePartitionRole.defaultExpectation.params != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Expect")
	}

	if mmCreatePartitionRole.defaultExpectation.paramPtrs == nil {
		mmCreatePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreatePartitionRoleParamPtrs{}
	}
	mmCreatePartitionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePartitionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePartitionRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest])) *mPartitionServiceHandlerMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.inspectFuncCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.CreatePartitionRole")
	}

	mmCreatePartitionRole.mock.inspectFuncCreatePartitionRole = f

	return mmCreatePartitionRole
}

// Return sets up results that will be returned by PartitionServiceHandler.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Return(pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error) *PartitionServiceHandlerMock {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceHandlerMockCreatePartitionRoleExpectation{mock: mmCreatePartitionRole.mock}
	}
	mmCreatePartitionRole.defaultExpectation.results = &PartitionServiceHandlerMockCreatePartitionRoleResults{pp2, err}
	mmCreatePartitionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePartitionRole.mock
}

// Set uses given function f to mock the PartitionServiceHandler.CreatePartitionRole method
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) (pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error)) *PartitionServiceHandlerMock {
	if mmCreatePartitionRole.defaultExpectation != nil {
		mmCreatePartitionRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.CreatePartitionRole method")
	}

	if len(mmCreatePartitionRole.expectations) > 0 {
		mmCreatePartitionRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.CreatePartitionRole method")
	}

	mmCreatePartitionRole.mock.funcCreatePartitionRole = f
	mmCreatePartitionRole.mock.funcCreatePartitionRoleOrigin = minimock.CallerInfo(1)
	return mmCreatePartitionRole.mock
}

// When sets expectation for the PartitionServiceHandler.CreatePartitionRole which will trigger the result defined by the following
// Then helper
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) When(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) *PartitionServiceHandlerMockCreatePartitionRoleExpectation {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.CreatePartitionRole mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockCreatePartitionRoleExpectation{
		mock:               mmCreatePartitionRole.mock,
		params:             &PartitionServiceHandlerMockCreatePartitionRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockCreatePartitionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePartitionRole.expectations = append(mmCreatePartitionRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.CreatePartitionRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockCreatePartitionRoleExpectation) Then(pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockCreatePartitionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.CreatePartitionRole should be invoked
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Times(n uint64) *mPartitionServiceHandlerMockCreatePartitionRole {
	if n == 0 {
		mmCreatePartitionRole.mock.t.Fatalf("Times of PartitionServiceHandlerMock.CreatePartitionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePartitionRole.expectedInvocations, n)
	mmCreatePartitionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePartitionRole
}

func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) invocationsDone() bool {
	if len(mmCreatePartitionRole.expectations) == 0 && mmCreatePartitionRole.defaultExpectation == nil && mmCreatePartitionRole.mock.funcCreatePartitionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePartitionRole.mock.afterCreatePartitionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePartitionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePartitionRole implements mm_partitionv1connect.PartitionServiceHandler
func (mmCreatePartitionRole *PartitionServiceHandlerMock) CreatePartitionRole(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) (pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePartitionRole.beforeCreatePartitionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePartitionRole.afterCreatePartitionRoleCounter, 1)

	mmCreatePartitionRole.t.Helper()

	if mmCreatePartitionRole.inspectFuncCreatePartitionRole != nil {
		mmCreatePartitionRole.inspectFuncCreatePartitionRole(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockCreatePartitionRoleParams{ctx, pp1}

	// Record call args
	mmCreatePartitionRole.CreatePartitionRoleMock.mutex.Lock()
	mmCreatePartitionRole.CreatePartitionRoleMock.callArgs = append(mmCreatePartitionRole.CreatePartitionRoleMock.callArgs, &mm_params)
	mmCreatePartitionRole.CreatePartitionRoleMock.mutex.Unlock()

	for _, e := range mmCreatePartitionRole.CreatePartitionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockCreatePartitionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePartitionRole.t.Errorf("PartitionServiceHandlerMock.CreatePartitionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePartitionRole.t.Errorf("PartitionServiceHandlerMock.CreatePartitionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePartitionRole.t.Errorf("PartitionServiceHandlerMock.CreatePartitionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePartitionRole.t.Fatal("No results are set for the PartitionServiceHandlerMock.CreatePartitionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePartitionRole.funcCreatePartitionRole != nil {
		return mmCreatePartitionRole.funcCreatePartitionRole(ctx, pp1)
	}
	mmCreatePartitionRole.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.CreatePartitionRole. %v %v", ctx, pp1)
	return
}

// CreatePartitionRoleAfterCounter returns a count of finished PartitionServiceHandlerMock.CreatePartitionRole invocations
func (mmCreatePartitionRole *PartitionServiceHandlerMock) CreatePartitionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartitionRole.afterCreatePartitionRoleCounter)
}

// CreatePartitionRoleBeforeCounter returns a count of PartitionServiceHandlerMock.CreatePartitionRole invocations
func (mmCreatePartitionRole *PartitionServiceHandlerMock) CreatePartitionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartitionRole.beforeCreatePartitionRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.CreatePartitionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePartitionRole *mPartitionServiceHandlerMockCreatePartitionRole) Calls() []*PartitionServiceHandlerMockCreatePartitionRoleParams {
	mmCreatePartitionRole.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockCreatePartitionRoleParams, len(mmCreatePartitionRole.callArgs))
	copy(argCopy, mmCreatePartitionRole.callArgs)

	mmCreatePartitionRole.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePartitionRoleDone returns true if the count of the CreatePartitionRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockCreatePartitionRoleDone() bool {
	if m.CreatePartitionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePartitionRoleMock.invocationsDone()
}

// MinimockCreatePartitionRoleInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockCreatePartitionRoleInspect() {
	for _, e := range m.CreatePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartitionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePartitionRoleCounter := mm_atomic.LoadUint64(&m.afterCreatePartitionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePartitionRoleMock.defaultExpectation != nil && afterCreatePartitionRoleCounter < 1 {
		if m.CreatePartitionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartitionRole at\n%s", m.CreatePartitionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartitionRole at\n%s with params: %#v", m.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *m.CreatePartitionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePartitionRole != nil && afterCreatePartitionRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreatePartitionRole at\n%s", m.funcCreatePartitionRoleOrigin)
	}

	if !m.CreatePartitionRoleMock.invocationsDone() && afterCreatePartitionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.CreatePartitionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePartitionRoleMock.expectedInvocations), m.CreatePartitionRoleMock.expectedInvocationsOrigin, afterCreatePartitionRoleCounter)
	}
}

type mPartitionServiceHandlerMockCreateTenant struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockCreateTenantExpectation
	expectations       []*PartitionServiceHandlerMockCreateTenantExpectation

	callArgs []*PartitionServiceHandlerMockCreateTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockCreateTenantExpectation specifies expectation struct of the PartitionServiceHandler.CreateTenant
type PartitionServiceHandlerMockCreateTenantExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockCreateTenantParams
	paramPtrs          *PartitionServiceHandlerMockCreateTenantParamPtrs
	expectationOrigins PartitionServiceHandlerMockCreateTenantExpectationOrigins
	results            *PartitionServiceHandlerMockCreateTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockCreateTenantParams contains parameters of the PartitionServiceHandler.CreateTenant
type PartitionServiceHandlerMockCreateTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateTenantRequest]
}

// PartitionServiceHandlerMockCreateTenantParamPtrs contains pointers to parameters of the PartitionServiceHandler.CreateTenant
type PartitionServiceHandlerMockCreateTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateTenantRequest]
}

// PartitionServiceHandlerMockCreateTenantResults contains results of the PartitionServiceHandler.CreateTenant
type PartitionServiceHandlerMockCreateTenantResults struct {
	pp2 *connect.Response[v1.CreateTenantResponse]
	err error
}

// PartitionServiceHandlerMockCreateTenantOrigins contains origins of expectations of the PartitionServiceHandler.CreateTenant
type PartitionServiceHandlerMockCreateTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Optional() *mPartitionServiceHandlerMockCreateTenant {
	mmCreateTenant.optional = true
	return mmCreateTenant
}

// Expect sets up expected params for PartitionServiceHandler.CreateTenant
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) *mPartitionServiceHandlerMockCreateTenant {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceHandlerMockCreateTenantExpectation{}
	}

	if mmCreateTenant.defaultExpectation.paramPtrs != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by ExpectParams functions")
	}

	mmCreateTenant.defaultExpectation.params = &PartitionServiceHandlerMockCreateTenantParams{ctx, pp1}
	mmCreateTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTenant.expectations {
		if minimock.Equal(e.params, mmCreateTenant.defaultExpectation.params) {
			mmCreateTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTenant.defaultExpectation.params)
		}
	}

	return mmCreateTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.CreateTenant
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockCreateTenant {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceHandlerMockCreateTenantExpectation{}
	}

	if mmCreateTenant.defaultExpectation.params != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Expect")
	}

	if mmCreateTenant.defaultExpectation.paramPtrs == nil {
		mmCreateTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreateTenantParamPtrs{}
	}
	mmCreateTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.CreateTenant
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) ExpectPp1Param2(pp1 *connect.Request[v1.CreateTenantRequest]) *mPartitionServiceHandlerMockCreateTenant {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceHandlerMockCreateTenantExpectation{}
	}

	if mmCreateTenant.defaultExpectation.params != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Expect")
	}

	if mmCreateTenant.defaultExpectation.paramPtrs == nil {
		mmCreateTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockCreateTenantParamPtrs{}
	}
	mmCreateTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.CreateTenant
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest])) *mPartitionServiceHandlerMockCreateTenant {
	if mmCreateTenant.mock.inspectFuncCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.CreateTenant")
	}

	mmCreateTenant.mock.inspectFuncCreateTenant = f

	return mmCreateTenant
}

// Return sets up results that will be returned by PartitionServiceHandler.CreateTenant
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Return(pp2 *connect.Response[v1.CreateTenantResponse], err error) *PartitionServiceHandlerMock {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceHandlerMockCreateTenantExpectation{mock: mmCreateTenant.mock}
	}
	mmCreateTenant.defaultExpectation.results = &PartitionServiceHandlerMockCreateTenantResults{pp2, err}
	mmCreateTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTenant.mock
}

// Set uses given function f to mock the PartitionServiceHandler.CreateTenant method
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) (pp2 *connect.Response[v1.CreateTenantResponse], err error)) *PartitionServiceHandlerMock {
	if mmCreateTenant.defaultExpectation != nil {
		mmCreateTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.CreateTenant method")
	}

	if len(mmCreateTenant.expectations) > 0 {
		mmCreateTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.CreateTenant method")
	}

	mmCreateTenant.mock.funcCreateTenant = f
	mmCreateTenant.mock.funcCreateTenantOrigin = minimock.CallerInfo(1)
	return mmCreateTenant.mock
}

// When sets expectation for the PartitionServiceHandler.CreateTenant which will trigger the result defined by the following
// Then helper
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) When(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) *PartitionServiceHandlerMockCreateTenantExpectation {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.CreateTenant mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockCreateTenantExpectation{
		mock:               mmCreateTenant.mock,
		params:             &PartitionServiceHandlerMockCreateTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockCreateTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTenant.expectations = append(mmCreateTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.CreateTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockCreateTenantExpectation) Then(pp2 *connect.Response[v1.CreateTenantResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockCreateTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.CreateTenant should be invoked
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Times(n uint64) *mPartitionServiceHandlerMockCreateTenant {
	if n == 0 {
		mmCreateTenant.mock.t.Fatalf("Times of PartitionServiceHandlerMock.CreateTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTenant.expectedInvocations, n)
	mmCreateTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTenant
}

func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) invocationsDone() bool {
	if len(mmCreateTenant.expectations) == 0 && mmCreateTenant.defaultExpectation == nil && mmCreateTenant.mock.funcCreateTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTenant.mock.afterCreateTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTenant implements mm_partitionv1connect.PartitionServiceHandler
func (mmCreateTenant *PartitionServiceHandlerMock) CreateTenant(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) (pp2 *connect.Response[v1.CreateTenantResponse], err error) {
	mm_atomic.AddUint64(&mmCreateTenant.beforeCreateTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTenant.afterCreateTenantCounter, 1)

	mmCreateTenant.t.Helper()

	if mmCreateTenant.inspectFuncCreateTenant != nil {
		mmCreateTenant.inspectFuncCreateTenant(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockCreateTenantParams{ctx, pp1}

	// Record call args
	mmCreateTenant.CreateTenantMock.mutex.Lock()
	mmCreateTenant.CreateTenantMock.callArgs = append(mmCreateTenant.CreateTenantMock.callArgs, &mm_params)
	mmCreateTenant.CreateTenantMock.mutex.Unlock()

	for _, e := range mmCreateTenant.CreateTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateTenant.CreateTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTenant.CreateTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTenant.CreateTenantMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTenant.CreateTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockCreateTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTenant.t.Errorf("PartitionServiceHandlerMock.CreateTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTenant.CreateTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateTenant.t.Errorf("PartitionServiceHandlerMock.CreateTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTenant.CreateTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTenant.t.Errorf("PartitionServiceHandlerMock.CreateTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTenant.CreateTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTenant.CreateTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTenant.t.Fatal("No results are set for the PartitionServiceHandlerMock.CreateTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateTenant.funcCreateTenant != nil {
		return mmCreateTenant.funcCreateTenant(ctx, pp1)
	}
	mmCreateTenant.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.CreateTenant. %v %v", ctx, pp1)
	return
}

// CreateTenantAfterCounter returns a count of finished PartitionServiceHandlerMock.CreateTenant invocations
func (mmCreateTenant *PartitionServiceHandlerMock) CreateTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTenant.afterCreateTenantCounter)
}

// CreateTenantBeforeCounter returns a count of PartitionServiceHandlerMock.CreateTenant invocations
func (mmCreateTenant *PartitionServiceHandlerMock) CreateTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTenant.beforeCreateTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.CreateTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTenant *mPartitionServiceHandlerMockCreateTenant) Calls() []*PartitionServiceHandlerMockCreateTenantParams {
	mmCreateTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockCreateTenantParams, len(mmCreateTenant.callArgs))
	copy(argCopy, mmCreateTenant.callArgs)

	mmCreateTenant.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTenantDone returns true if the count of the CreateTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockCreateTenantDone() bool {
	if m.CreateTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTenantMock.invocationsDone()
}

// MinimockCreateTenantInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockCreateTenantInspect() {
	for _, e := range m.CreateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTenantCounter := mm_atomic.LoadUint64(&m.afterCreateTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTenantMock.defaultExpectation != nil && afterCreateTenantCounter < 1 {
		if m.CreateTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateTenant at\n%s", m.CreateTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateTenant at\n%s with params: %#v", m.CreateTenantMock.defaultExpectation.expectationOrigins.origin, *m.CreateTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTenant != nil && afterCreateTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.CreateTenant at\n%s", m.funcCreateTenantOrigin)
	}

	if !m.CreateTenantMock.invocationsDone() && afterCreateTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.CreateTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTenantMock.expectedInvocations), m.CreateTenantMock.expectedInvocationsOrigin, afterCreateTenantCounter)
	}
}

type mPartitionServiceHandlerMockGetAccess struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockGetAccessExpectation
	expectations       []*PartitionServiceHandlerMockGetAccessExpectation

	callArgs []*PartitionServiceHandlerMockGetAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockGetAccessExpectation specifies expectation struct of the PartitionServiceHandler.GetAccess
type PartitionServiceHandlerMockGetAccessExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockGetAccessParams
	paramPtrs          *PartitionServiceHandlerMockGetAccessParamPtrs
	expectationOrigins PartitionServiceHandlerMockGetAccessExpectationOrigins
	results            *PartitionServiceHandlerMockGetAccessResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockGetAccessParams contains parameters of the PartitionServiceHandler.GetAccess
type PartitionServiceHandlerMockGetAccessParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetAccessRequest]
}

// PartitionServiceHandlerMockGetAccessParamPtrs contains pointers to parameters of the PartitionServiceHandler.GetAccess
type PartitionServiceHandlerMockGetAccessParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetAccessRequest]
}

// PartitionServiceHandlerMockGetAccessResults contains results of the PartitionServiceHandler.GetAccess
type PartitionServiceHandlerMockGetAccessResults struct {
	pp2 *connect.Response[v1.GetAccessResponse]
	err error
}

// PartitionServiceHandlerMockGetAccessOrigins contains origins of expectations of the PartitionServiceHandler.GetAccess
type PartitionServiceHandlerMockGetAccessExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Optional() *mPartitionServiceHandlerMockGetAccess {
	mmGetAccess.optional = true
	return mmGetAccess
}

// Expect sets up expected params for PartitionServiceHandler.GetAccess
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Expect(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) *mPartitionServiceHandlerMockGetAccess {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceHandlerMockGetAccessExpectation{}
	}

	if mmGetAccess.defaultExpectation.paramPtrs != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by ExpectParams functions")
	}

	mmGetAccess.defaultExpectation.params = &PartitionServiceHandlerMockGetAccessParams{ctx, pp1}
	mmGetAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccess.expectations {
		if minimock.Equal(e.params, mmGetAccess.defaultExpectation.params) {
			mmGetAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccess.defaultExpectation.params)
		}
	}

	return mmGetAccess
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.GetAccess
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockGetAccess {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceHandlerMockGetAccessExpectation{}
	}

	if mmGetAccess.defaultExpectation.params != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Expect")
	}

	if mmGetAccess.defaultExpectation.paramPtrs == nil {
		mmGetAccess.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetAccessParamPtrs{}
	}
	mmGetAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccess
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.GetAccess
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) ExpectPp1Param2(pp1 *connect.Request[v1.GetAccessRequest]) *mPartitionServiceHandlerMockGetAccess {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceHandlerMockGetAccessExpectation{}
	}

	if mmGetAccess.defaultExpectation.params != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Expect")
	}

	if mmGetAccess.defaultExpectation.paramPtrs == nil {
		mmGetAccess.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetAccessParamPtrs{}
	}
	mmGetAccess.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetAccess.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetAccess
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.GetAccess
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest])) *mPartitionServiceHandlerMockGetAccess {
	if mmGetAccess.mock.inspectFuncGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.GetAccess")
	}

	mmGetAccess.mock.inspectFuncGetAccess = f

	return mmGetAccess
}

// Return sets up results that will be returned by PartitionServiceHandler.GetAccess
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Return(pp2 *connect.Response[v1.GetAccessResponse], err error) *PartitionServiceHandlerMock {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceHandlerMockGetAccessExpectation{mock: mmGetAccess.mock}
	}
	mmGetAccess.defaultExpectation.results = &PartitionServiceHandlerMockGetAccessResults{pp2, err}
	mmGetAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccess.mock
}

// Set uses given function f to mock the PartitionServiceHandler.GetAccess method
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) (pp2 *connect.Response[v1.GetAccessResponse], err error)) *PartitionServiceHandlerMock {
	if mmGetAccess.defaultExpectation != nil {
		mmGetAccess.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.GetAccess method")
	}

	if len(mmGetAccess.expectations) > 0 {
		mmGetAccess.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.GetAccess method")
	}

	mmGetAccess.mock.funcGetAccess = f
	mmGetAccess.mock.funcGetAccessOrigin = minimock.CallerInfo(1)
	return mmGetAccess.mock
}

// When sets expectation for the PartitionServiceHandler.GetAccess which will trigger the result defined by the following
// Then helper
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) When(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) *PartitionServiceHandlerMockGetAccessExpectation {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceHandlerMock.GetAccess mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockGetAccessExpectation{
		mock:               mmGetAccess.mock,
		params:             &PartitionServiceHandlerMockGetAccessParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockGetAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccess.expectations = append(mmGetAccess.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.GetAccess return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockGetAccessExpectation) Then(pp2 *connect.Response[v1.GetAccessResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockGetAccessResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.GetAccess should be invoked
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Times(n uint64) *mPartitionServiceHandlerMockGetAccess {
	if n == 0 {
		mmGetAccess.mock.t.Fatalf("Times of PartitionServiceHandlerMock.GetAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccess.expectedInvocations, n)
	mmGetAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccess
}

func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) invocationsDone() bool {
	if len(mmGetAccess.expectations) == 0 && mmGetAccess.defaultExpectation == nil && mmGetAccess.mock.funcGetAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccess.mock.afterGetAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccess implements mm_partitionv1connect.PartitionServiceHandler
func (mmGetAccess *PartitionServiceHandlerMock) GetAccess(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) (pp2 *connect.Response[v1.GetAccessResponse], err error) {
	mm_atomic.AddUint64(&mmGetAccess.beforeGetAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccess.afterGetAccessCounter, 1)

	mmGetAccess.t.Helper()

	if mmGetAccess.inspectFuncGetAccess != nil {
		mmGetAccess.inspectFuncGetAccess(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockGetAccessParams{ctx, pp1}

	// Record call args
	mmGetAccess.GetAccessMock.mutex.Lock()
	mmGetAccess.GetAccessMock.callArgs = append(mmGetAccess.GetAccessMock.callArgs, &mm_params)
	mmGetAccess.GetAccessMock.mutex.Unlock()

	for _, e := range mmGetAccess.GetAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetAccess.GetAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccess.GetAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccess.GetAccessMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccess.GetAccessMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockGetAccessParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccess.t.Errorf("PartitionServiceHandlerMock.GetAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccess.GetAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetAccess.t.Errorf("PartitionServiceHandlerMock.GetAccess got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccess.GetAccessMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccess.t.Errorf("PartitionServiceHandlerMock.GetAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccess.GetAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccess.GetAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccess.t.Fatal("No results are set for the PartitionServiceHandlerMock.GetAccess")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetAccess.funcGetAccess != nil {
		return mmGetAccess.funcGetAccess(ctx, pp1)
	}
	mmGetAccess.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.GetAccess. %v %v", ctx, pp1)
	return
}

// GetAccessAfterCounter returns a count of finished PartitionServiceHandlerMock.GetAccess invocations
func (mmGetAccess *PartitionServiceHandlerMock) GetAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccess.afterGetAccessCounter)
}

// GetAccessBeforeCounter returns a count of PartitionServiceHandlerMock.GetAccess invocations
func (mmGetAccess *PartitionServiceHandlerMock) GetAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccess.beforeGetAccessCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.GetAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccess *mPartitionServiceHandlerMockGetAccess) Calls() []*PartitionServiceHandlerMockGetAccessParams {
	mmGetAccess.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockGetAccessParams, len(mmGetAccess.callArgs))
	copy(argCopy, mmGetAccess.callArgs)

	mmGetAccess.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessDone returns true if the count of the GetAccess invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockGetAccessDone() bool {
	if m.GetAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessMock.invocationsDone()
}

// MinimockGetAccessInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockGetAccessInspect() {
	for _, e := range m.GetAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccessCounter := mm_atomic.LoadUint64(&m.afterGetAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessMock.defaultExpectation != nil && afterGetAccessCounter < 1 {
		if m.GetAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetAccess at\n%s", m.GetAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetAccess at\n%s with params: %#v", m.GetAccessMock.defaultExpectation.expectationOrigins.origin, *m.GetAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccess != nil && afterGetAccessCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetAccess at\n%s", m.funcGetAccessOrigin)
	}

	if !m.GetAccessMock.invocationsDone() && afterGetAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.GetAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessMock.expectedInvocations), m.GetAccessMock.expectedInvocationsOrigin, afterGetAccessCounter)
	}
}

type mPartitionServiceHandlerMockGetPage struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockGetPageExpectation
	expectations       []*PartitionServiceHandlerMockGetPageExpectation

	callArgs []*PartitionServiceHandlerMockGetPageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockGetPageExpectation specifies expectation struct of the PartitionServiceHandler.GetPage
type PartitionServiceHandlerMockGetPageExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockGetPageParams
	paramPtrs          *PartitionServiceHandlerMockGetPageParamPtrs
	expectationOrigins PartitionServiceHandlerMockGetPageExpectationOrigins
	results            *PartitionServiceHandlerMockGetPageResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockGetPageParams contains parameters of the PartitionServiceHandler.GetPage
type PartitionServiceHandlerMockGetPageParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetPageRequest]
}

// PartitionServiceHandlerMockGetPageParamPtrs contains pointers to parameters of the PartitionServiceHandler.GetPage
type PartitionServiceHandlerMockGetPageParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetPageRequest]
}

// PartitionServiceHandlerMockGetPageResults contains results of the PartitionServiceHandler.GetPage
type PartitionServiceHandlerMockGetPageResults struct {
	pp2 *connect.Response[v1.GetPageResponse]
	err error
}

// PartitionServiceHandlerMockGetPageOrigins contains origins of expectations of the PartitionServiceHandler.GetPage
type PartitionServiceHandlerMockGetPageExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Optional() *mPartitionServiceHandlerMockGetPage {
	mmGetPage.optional = true
	return mmGetPage
}

// Expect sets up expected params for PartitionServiceHandler.GetPage
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Expect(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) *mPartitionServiceHandlerMockGetPage {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceHandlerMockGetPageExpectation{}
	}

	if mmGetPage.defaultExpectation.paramPtrs != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by ExpectParams functions")
	}

	mmGetPage.defaultExpectation.params = &PartitionServiceHandlerMockGetPageParams{ctx, pp1}
	mmGetPage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPage.expectations {
		if minimock.Equal(e.params, mmGetPage.defaultExpectation.params) {
			mmGetPage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPage.defaultExpectation.params)
		}
	}

	return mmGetPage
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.GetPage
func (mmGetPage *mPartitionServiceHandlerMockGetPage) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockGetPage {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceHandlerMockGetPageExpectation{}
	}

	if mmGetPage.defaultExpectation.params != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Expect")
	}

	if mmGetPage.defaultExpectation.paramPtrs == nil {
		mmGetPage.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetPageParamPtrs{}
	}
	mmGetPage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPage
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.GetPage
func (mmGetPage *mPartitionServiceHandlerMockGetPage) ExpectPp1Param2(pp1 *connect.Request[v1.GetPageRequest]) *mPartitionServiceHandlerMockGetPage {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceHandlerMockGetPageExpectation{}
	}

	if mmGetPage.defaultExpectation.params != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Expect")
	}

	if mmGetPage.defaultExpectation.paramPtrs == nil {
		mmGetPage.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetPageParamPtrs{}
	}
	mmGetPage.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetPage.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetPage
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.GetPage
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest])) *mPartitionServiceHandlerMockGetPage {
	if mmGetPage.mock.inspectFuncGetPage != nil {
		mmGetPage.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.GetPage")
	}

	mmGetPage.mock.inspectFuncGetPage = f

	return mmGetPage
}

// Return sets up results that will be returned by PartitionServiceHandler.GetPage
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Return(pp2 *connect.Response[v1.GetPageResponse], err error) *PartitionServiceHandlerMock {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceHandlerMockGetPageExpectation{mock: mmGetPage.mock}
	}
	mmGetPage.defaultExpectation.results = &PartitionServiceHandlerMockGetPageResults{pp2, err}
	mmGetPage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPage.mock
}

// Set uses given function f to mock the PartitionServiceHandler.GetPage method
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) (pp2 *connect.Response[v1.GetPageResponse], err error)) *PartitionServiceHandlerMock {
	if mmGetPage.defaultExpectation != nil {
		mmGetPage.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.GetPage method")
	}

	if len(mmGetPage.expectations) > 0 {
		mmGetPage.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.GetPage method")
	}

	mmGetPage.mock.funcGetPage = f
	mmGetPage.mock.funcGetPageOrigin = minimock.CallerInfo(1)
	return mmGetPage.mock
}

// When sets expectation for the PartitionServiceHandler.GetPage which will trigger the result defined by the following
// Then helper
func (mmGetPage *mPartitionServiceHandlerMockGetPage) When(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) *PartitionServiceHandlerMockGetPageExpectation {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceHandlerMock.GetPage mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockGetPageExpectation{
		mock:               mmGetPage.mock,
		params:             &PartitionServiceHandlerMockGetPageParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockGetPageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPage.expectations = append(mmGetPage.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.GetPage return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockGetPageExpectation) Then(pp2 *connect.Response[v1.GetPageResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockGetPageResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.GetPage should be invoked
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Times(n uint64) *mPartitionServiceHandlerMockGetPage {
	if n == 0 {
		mmGetPage.mock.t.Fatalf("Times of PartitionServiceHandlerMock.GetPage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPage.expectedInvocations, n)
	mmGetPage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPage
}

func (mmGetPage *mPartitionServiceHandlerMockGetPage) invocationsDone() bool {
	if len(mmGetPage.expectations) == 0 && mmGetPage.defaultExpectation == nil && mmGetPage.mock.funcGetPage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPage.mock.afterGetPageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPage implements mm_partitionv1connect.PartitionServiceHandler
func (mmGetPage *PartitionServiceHandlerMock) GetPage(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) (pp2 *connect.Response[v1.GetPageResponse], err error) {
	mm_atomic.AddUint64(&mmGetPage.beforeGetPageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPage.afterGetPageCounter, 1)

	mmGetPage.t.Helper()

	if mmGetPage.inspectFuncGetPage != nil {
		mmGetPage.inspectFuncGetPage(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockGetPageParams{ctx, pp1}

	// Record call args
	mmGetPage.GetPageMock.mutex.Lock()
	mmGetPage.GetPageMock.callArgs = append(mmGetPage.GetPageMock.callArgs, &mm_params)
	mmGetPage.GetPageMock.mutex.Unlock()

	for _, e := range mmGetPage.GetPageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetPage.GetPageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPage.GetPageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPage.GetPageMock.defaultExpectation.params
		mm_want_ptrs := mmGetPage.GetPageMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockGetPageParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPage.t.Errorf("PartitionServiceHandlerMock.GetPage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPage.GetPageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetPage.t.Errorf("PartitionServiceHandlerMock.GetPage got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPage.GetPageMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPage.t.Errorf("PartitionServiceHandlerMock.GetPage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPage.GetPageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPage.GetPageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPage.t.Fatal("No results are set for the PartitionServiceHandlerMock.GetPage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetPage.funcGetPage != nil {
		return mmGetPage.funcGetPage(ctx, pp1)
	}
	mmGetPage.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.GetPage. %v %v", ctx, pp1)
	return
}

// GetPageAfterCounter returns a count of finished PartitionServiceHandlerMock.GetPage invocations
func (mmGetPage *PartitionServiceHandlerMock) GetPageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPage.afterGetPageCounter)
}

// GetPageBeforeCounter returns a count of PartitionServiceHandlerMock.GetPage invocations
func (mmGetPage *PartitionServiceHandlerMock) GetPageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPage.beforeGetPageCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.GetPage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPage *mPartitionServiceHandlerMockGetPage) Calls() []*PartitionServiceHandlerMockGetPageParams {
	mmGetPage.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockGetPageParams, len(mmGetPage.callArgs))
	copy(argCopy, mmGetPage.callArgs)

	mmGetPage.mutex.RUnlock()

	return argCopy
}

// MinimockGetPageDone returns true if the count of the GetPage invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockGetPageDone() bool {
	if m.GetPageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPageMock.invocationsDone()
}

// MinimockGetPageInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockGetPageInspect() {
	for _, e := range m.GetPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPageCounter := mm_atomic.LoadUint64(&m.afterGetPageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPageMock.defaultExpectation != nil && afterGetPageCounter < 1 {
		if m.GetPageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPage at\n%s", m.GetPageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPage at\n%s with params: %#v", m.GetPageMock.defaultExpectation.expectationOrigins.origin, *m.GetPageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPage != nil && afterGetPageCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPage at\n%s", m.funcGetPageOrigin)
	}

	if !m.GetPageMock.invocationsDone() && afterGetPageCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.GetPage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPageMock.expectedInvocations), m.GetPageMock.expectedInvocationsOrigin, afterGetPageCounter)
	}
}

type mPartitionServiceHandlerMockGetPartition struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockGetPartitionExpectation
	expectations       []*PartitionServiceHandlerMockGetPartitionExpectation

	callArgs []*PartitionServiceHandlerMockGetPartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockGetPartitionExpectation specifies expectation struct of the PartitionServiceHandler.GetPartition
type PartitionServiceHandlerMockGetPartitionExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockGetPartitionParams
	paramPtrs          *PartitionServiceHandlerMockGetPartitionParamPtrs
	expectationOrigins PartitionServiceHandlerMockGetPartitionExpectationOrigins
	results            *PartitionServiceHandlerMockGetPartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockGetPartitionParams contains parameters of the PartitionServiceHandler.GetPartition
type PartitionServiceHandlerMockGetPartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetPartitionRequest]
}

// PartitionServiceHandlerMockGetPartitionParamPtrs contains pointers to parameters of the PartitionServiceHandler.GetPartition
type PartitionServiceHandlerMockGetPartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetPartitionRequest]
}

// PartitionServiceHandlerMockGetPartitionResults contains results of the PartitionServiceHandler.GetPartition
type PartitionServiceHandlerMockGetPartitionResults struct {
	pp2 *connect.Response[v1.GetPartitionResponse]
	err error
}

// PartitionServiceHandlerMockGetPartitionOrigins contains origins of expectations of the PartitionServiceHandler.GetPartition
type PartitionServiceHandlerMockGetPartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Optional() *mPartitionServiceHandlerMockGetPartition {
	mmGetPartition.optional = true
	return mmGetPartition
}

// Expect sets up expected params for PartitionServiceHandler.GetPartition
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Expect(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) *mPartitionServiceHandlerMockGetPartition {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceHandlerMockGetPartitionExpectation{}
	}

	if mmGetPartition.defaultExpectation.paramPtrs != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by ExpectParams functions")
	}

	mmGetPartition.defaultExpectation.params = &PartitionServiceHandlerMockGetPartitionParams{ctx, pp1}
	mmGetPartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPartition.expectations {
		if minimock.Equal(e.params, mmGetPartition.defaultExpectation.params) {
			mmGetPartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPartition.defaultExpectation.params)
		}
	}

	return mmGetPartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.GetPartition
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockGetPartition {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceHandlerMockGetPartitionExpectation{}
	}

	if mmGetPartition.defaultExpectation.params != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Expect")
	}

	if mmGetPartition.defaultExpectation.paramPtrs == nil {
		mmGetPartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetPartitionParamPtrs{}
	}
	mmGetPartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.GetPartition
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) ExpectPp1Param2(pp1 *connect.Request[v1.GetPartitionRequest]) *mPartitionServiceHandlerMockGetPartition {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceHandlerMockGetPartitionExpectation{}
	}

	if mmGetPartition.defaultExpectation.params != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Expect")
	}

	if mmGetPartition.defaultExpectation.paramPtrs == nil {
		mmGetPartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetPartitionParamPtrs{}
	}
	mmGetPartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetPartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetPartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.GetPartition
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest])) *mPartitionServiceHandlerMockGetPartition {
	if mmGetPartition.mock.inspectFuncGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.GetPartition")
	}

	mmGetPartition.mock.inspectFuncGetPartition = f

	return mmGetPartition
}

// Return sets up results that will be returned by PartitionServiceHandler.GetPartition
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Return(pp2 *connect.Response[v1.GetPartitionResponse], err error) *PartitionServiceHandlerMock {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceHandlerMockGetPartitionExpectation{mock: mmGetPartition.mock}
	}
	mmGetPartition.defaultExpectation.results = &PartitionServiceHandlerMockGetPartitionResults{pp2, err}
	mmGetPartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPartition.mock
}

// Set uses given function f to mock the PartitionServiceHandler.GetPartition method
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) (pp2 *connect.Response[v1.GetPartitionResponse], err error)) *PartitionServiceHandlerMock {
	if mmGetPartition.defaultExpectation != nil {
		mmGetPartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.GetPartition method")
	}

	if len(mmGetPartition.expectations) > 0 {
		mmGetPartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.GetPartition method")
	}

	mmGetPartition.mock.funcGetPartition = f
	mmGetPartition.mock.funcGetPartitionOrigin = minimock.CallerInfo(1)
	return mmGetPartition.mock
}

// When sets expectation for the PartitionServiceHandler.GetPartition which will trigger the result defined by the following
// Then helper
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) When(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) *PartitionServiceHandlerMockGetPartitionExpectation {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartition mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockGetPartitionExpectation{
		mock:               mmGetPartition.mock,
		params:             &PartitionServiceHandlerMockGetPartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockGetPartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPartition.expectations = append(mmGetPartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.GetPartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockGetPartitionExpectation) Then(pp2 *connect.Response[v1.GetPartitionResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockGetPartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.GetPartition should be invoked
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Times(n uint64) *mPartitionServiceHandlerMockGetPartition {
	if n == 0 {
		mmGetPartition.mock.t.Fatalf("Times of PartitionServiceHandlerMock.GetPartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPartition.expectedInvocations, n)
	mmGetPartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPartition
}

func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) invocationsDone() bool {
	if len(mmGetPartition.expectations) == 0 && mmGetPartition.defaultExpectation == nil && mmGetPartition.mock.funcGetPartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPartition.mock.afterGetPartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPartition implements mm_partitionv1connect.PartitionServiceHandler
func (mmGetPartition *PartitionServiceHandlerMock) GetPartition(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) (pp2 *connect.Response[v1.GetPartitionResponse], err error) {
	mm_atomic.AddUint64(&mmGetPartition.beforeGetPartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPartition.afterGetPartitionCounter, 1)

	mmGetPartition.t.Helper()

	if mmGetPartition.inspectFuncGetPartition != nil {
		mmGetPartition.inspectFuncGetPartition(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockGetPartitionParams{ctx, pp1}

	// Record call args
	mmGetPartition.GetPartitionMock.mutex.Lock()
	mmGetPartition.GetPartitionMock.callArgs = append(mmGetPartition.GetPartitionMock.callArgs, &mm_params)
	mmGetPartition.GetPartitionMock.mutex.Unlock()

	for _, e := range mmGetPartition.GetPartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetPartition.GetPartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPartition.GetPartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPartition.GetPartitionMock.defaultExpectation.params
		mm_want_ptrs := mmGetPartition.GetPartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockGetPartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPartition.t.Errorf("PartitionServiceHandlerMock.GetPartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartition.GetPartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetPartition.t.Errorf("PartitionServiceHandlerMock.GetPartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartition.GetPartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPartition.t.Errorf("PartitionServiceHandlerMock.GetPartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPartition.GetPartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPartition.GetPartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPartition.t.Fatal("No results are set for the PartitionServiceHandlerMock.GetPartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetPartition.funcGetPartition != nil {
		return mmGetPartition.funcGetPartition(ctx, pp1)
	}
	mmGetPartition.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.GetPartition. %v %v", ctx, pp1)
	return
}

// GetPartitionAfterCounter returns a count of finished PartitionServiceHandlerMock.GetPartition invocations
func (mmGetPartition *PartitionServiceHandlerMock) GetPartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartition.afterGetPartitionCounter)
}

// GetPartitionBeforeCounter returns a count of PartitionServiceHandlerMock.GetPartition invocations
func (mmGetPartition *PartitionServiceHandlerMock) GetPartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartition.beforeGetPartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.GetPartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPartition *mPartitionServiceHandlerMockGetPartition) Calls() []*PartitionServiceHandlerMockGetPartitionParams {
	mmGetPartition.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockGetPartitionParams, len(mmGetPartition.callArgs))
	copy(argCopy, mmGetPartition.callArgs)

	mmGetPartition.mutex.RUnlock()

	return argCopy
}

// MinimockGetPartitionDone returns true if the count of the GetPartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockGetPartitionDone() bool {
	if m.GetPartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPartitionMock.invocationsDone()
}

// MinimockGetPartitionInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockGetPartitionInspect() {
	for _, e := range m.GetPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPartitionCounter := mm_atomic.LoadUint64(&m.afterGetPartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPartitionMock.defaultExpectation != nil && afterGetPartitionCounter < 1 {
		if m.GetPartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartition at\n%s", m.GetPartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartition at\n%s with params: %#v", m.GetPartitionMock.defaultExpectation.expectationOrigins.origin, *m.GetPartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPartition != nil && afterGetPartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartition at\n%s", m.funcGetPartitionOrigin)
	}

	if !m.GetPartitionMock.invocationsDone() && afterGetPartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.GetPartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPartitionMock.expectedInvocations), m.GetPartitionMock.expectedInvocationsOrigin, afterGetPartitionCounter)
	}
}

type mPartitionServiceHandlerMockGetPartitionParents struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockGetPartitionParentsExpectation
	expectations       []*PartitionServiceHandlerMockGetPartitionParentsExpectation

	callArgs []*PartitionServiceHandlerMockGetPartitionParentsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockGetPartitionParentsExpectation specifies expectation struct of the PartitionServiceHandler.GetPartitionParents
type PartitionServiceHandlerMockGetPartitionParentsExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockGetPartitionParentsParams
	paramPtrs          *PartitionServiceHandlerMockGetPartitionParentsParamPtrs
	expectationOrigins PartitionServiceHandlerMockGetPartitionParentsExpectationOrigins
	results            *PartitionServiceHandlerMockGetPartitionParentsResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockGetPartitionParentsParams contains parameters of the PartitionServiceHandler.GetPartitionParents
type PartitionServiceHandlerMockGetPartitionParentsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetPartitionParentsRequest]
}

// PartitionServiceHandlerMockGetPartitionParentsParamPtrs contains pointers to parameters of the PartitionServiceHandler.GetPartitionParents
type PartitionServiceHandlerMockGetPartitionParentsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetPartitionParentsRequest]
}

// PartitionServiceHandlerMockGetPartitionParentsResults contains results of the PartitionServiceHandler.GetPartitionParents
type PartitionServiceHandlerMockGetPartitionParentsResults struct {
	pp2 *connect.Response[v1.GetPartitionParentsResponse]
	err error
}

// PartitionServiceHandlerMockGetPartitionParentsOrigins contains origins of expectations of the PartitionServiceHandler.GetPartitionParents
type PartitionServiceHandlerMockGetPartitionParentsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Optional() *mPartitionServiceHandlerMockGetPartitionParents {
	mmGetPartitionParents.optional = true
	return mmGetPartitionParents
}

// Expect sets up expected params for PartitionServiceHandler.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Expect(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) *mPartitionServiceHandlerMockGetPartitionParents {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceHandlerMockGetPartitionParentsExpectation{}
	}

	if mmGetPartitionParents.defaultExpectation.paramPtrs != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by ExpectParams functions")
	}

	mmGetPartitionParents.defaultExpectation.params = &PartitionServiceHandlerMockGetPartitionParentsParams{ctx, pp1}
	mmGetPartitionParents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPartitionParents.expectations {
		if minimock.Equal(e.params, mmGetPartitionParents.defaultExpectation.params) {
			mmGetPartitionParents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPartitionParents.defaultExpectation.params)
		}
	}

	return mmGetPartitionParents
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockGetPartitionParents {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceHandlerMockGetPartitionParentsExpectation{}
	}

	if mmGetPartitionParents.defaultExpectation.params != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Expect")
	}

	if mmGetPartitionParents.defaultExpectation.paramPtrs == nil {
		mmGetPartitionParents.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetPartitionParentsParamPtrs{}
	}
	mmGetPartitionParents.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPartitionParents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPartitionParents
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) ExpectPp1Param2(pp1 *connect.Request[v1.GetPartitionParentsRequest]) *mPartitionServiceHandlerMockGetPartitionParents {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceHandlerMockGetPartitionParentsExpectation{}
	}

	if mmGetPartitionParents.defaultExpectation.params != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Expect")
	}

	if mmGetPartitionParents.defaultExpectation.paramPtrs == nil {
		mmGetPartitionParents.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetPartitionParentsParamPtrs{}
	}
	mmGetPartitionParents.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetPartitionParents.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetPartitionParents
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest])) *mPartitionServiceHandlerMockGetPartitionParents {
	if mmGetPartitionParents.mock.inspectFuncGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.GetPartitionParents")
	}

	mmGetPartitionParents.mock.inspectFuncGetPartitionParents = f

	return mmGetPartitionParents
}

// Return sets up results that will be returned by PartitionServiceHandler.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Return(pp2 *connect.Response[v1.GetPartitionParentsResponse], err error) *PartitionServiceHandlerMock {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceHandlerMockGetPartitionParentsExpectation{mock: mmGetPartitionParents.mock}
	}
	mmGetPartitionParents.defaultExpectation.results = &PartitionServiceHandlerMockGetPartitionParentsResults{pp2, err}
	mmGetPartitionParents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPartitionParents.mock
}

// Set uses given function f to mock the PartitionServiceHandler.GetPartitionParents method
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) (pp2 *connect.Response[v1.GetPartitionParentsResponse], err error)) *PartitionServiceHandlerMock {
	if mmGetPartitionParents.defaultExpectation != nil {
		mmGetPartitionParents.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.GetPartitionParents method")
	}

	if len(mmGetPartitionParents.expectations) > 0 {
		mmGetPartitionParents.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.GetPartitionParents method")
	}

	mmGetPartitionParents.mock.funcGetPartitionParents = f
	mmGetPartitionParents.mock.funcGetPartitionParentsOrigin = minimock.CallerInfo(1)
	return mmGetPartitionParents.mock
}

// When sets expectation for the PartitionServiceHandler.GetPartitionParents which will trigger the result defined by the following
// Then helper
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) When(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) *PartitionServiceHandlerMockGetPartitionParentsExpectation {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceHandlerMock.GetPartitionParents mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockGetPartitionParentsExpectation{
		mock:               mmGetPartitionParents.mock,
		params:             &PartitionServiceHandlerMockGetPartitionParentsParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockGetPartitionParentsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPartitionParents.expectations = append(mmGetPartitionParents.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.GetPartitionParents return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockGetPartitionParentsExpectation) Then(pp2 *connect.Response[v1.GetPartitionParentsResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockGetPartitionParentsResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.GetPartitionParents should be invoked
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Times(n uint64) *mPartitionServiceHandlerMockGetPartitionParents {
	if n == 0 {
		mmGetPartitionParents.mock.t.Fatalf("Times of PartitionServiceHandlerMock.GetPartitionParents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPartitionParents.expectedInvocations, n)
	mmGetPartitionParents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPartitionParents
}

func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) invocationsDone() bool {
	if len(mmGetPartitionParents.expectations) == 0 && mmGetPartitionParents.defaultExpectation == nil && mmGetPartitionParents.mock.funcGetPartitionParents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPartitionParents.mock.afterGetPartitionParentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPartitionParents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPartitionParents implements mm_partitionv1connect.PartitionServiceHandler
func (mmGetPartitionParents *PartitionServiceHandlerMock) GetPartitionParents(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) (pp2 *connect.Response[v1.GetPartitionParentsResponse], err error) {
	mm_atomic.AddUint64(&mmGetPartitionParents.beforeGetPartitionParentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPartitionParents.afterGetPartitionParentsCounter, 1)

	mmGetPartitionParents.t.Helper()

	if mmGetPartitionParents.inspectFuncGetPartitionParents != nil {
		mmGetPartitionParents.inspectFuncGetPartitionParents(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockGetPartitionParentsParams{ctx, pp1}

	// Record call args
	mmGetPartitionParents.GetPartitionParentsMock.mutex.Lock()
	mmGetPartitionParents.GetPartitionParentsMock.callArgs = append(mmGetPartitionParents.GetPartitionParentsMock.callArgs, &mm_params)
	mmGetPartitionParents.GetPartitionParentsMock.mutex.Unlock()

	for _, e := range mmGetPartitionParents.GetPartitionParentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockGetPartitionParentsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPartitionParents.t.Errorf("PartitionServiceHandlerMock.GetPartitionParents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetPartitionParents.t.Errorf("PartitionServiceHandlerMock.GetPartitionParents got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPartitionParents.t.Errorf("PartitionServiceHandlerMock.GetPartitionParents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPartitionParents.t.Fatal("No results are set for the PartitionServiceHandlerMock.GetPartitionParents")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetPartitionParents.funcGetPartitionParents != nil {
		return mmGetPartitionParents.funcGetPartitionParents(ctx, pp1)
	}
	mmGetPartitionParents.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.GetPartitionParents. %v %v", ctx, pp1)
	return
}

// GetPartitionParentsAfterCounter returns a count of finished PartitionServiceHandlerMock.GetPartitionParents invocations
func (mmGetPartitionParents *PartitionServiceHandlerMock) GetPartitionParentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartitionParents.afterGetPartitionParentsCounter)
}

// GetPartitionParentsBeforeCounter returns a count of PartitionServiceHandlerMock.GetPartitionParents invocations
func (mmGetPartitionParents *PartitionServiceHandlerMock) GetPartitionParentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartitionParents.beforeGetPartitionParentsCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.GetPartitionParents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPartitionParents *mPartitionServiceHandlerMockGetPartitionParents) Calls() []*PartitionServiceHandlerMockGetPartitionParentsParams {
	mmGetPartitionParents.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockGetPartitionParentsParams, len(mmGetPartitionParents.callArgs))
	copy(argCopy, mmGetPartitionParents.callArgs)

	mmGetPartitionParents.mutex.RUnlock()

	return argCopy
}

// MinimockGetPartitionParentsDone returns true if the count of the GetPartitionParents invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockGetPartitionParentsDone() bool {
	if m.GetPartitionParentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPartitionParentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPartitionParentsMock.invocationsDone()
}

// MinimockGetPartitionParentsInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockGetPartitionParentsInspect() {
	for _, e := range m.GetPartitionParentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartitionParents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPartitionParentsCounter := mm_atomic.LoadUint64(&m.afterGetPartitionParentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPartitionParentsMock.defaultExpectation != nil && afterGetPartitionParentsCounter < 1 {
		if m.GetPartitionParentsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartitionParents at\n%s", m.GetPartitionParentsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartitionParents at\n%s with params: %#v", m.GetPartitionParentsMock.defaultExpectation.expectationOrigins.origin, *m.GetPartitionParentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPartitionParents != nil && afterGetPartitionParentsCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetPartitionParents at\n%s", m.funcGetPartitionParentsOrigin)
	}

	if !m.GetPartitionParentsMock.invocationsDone() && afterGetPartitionParentsCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.GetPartitionParents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPartitionParentsMock.expectedInvocations), m.GetPartitionParentsMock.expectedInvocationsOrigin, afterGetPartitionParentsCounter)
	}
}

type mPartitionServiceHandlerMockGetTenant struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockGetTenantExpectation
	expectations       []*PartitionServiceHandlerMockGetTenantExpectation

	callArgs []*PartitionServiceHandlerMockGetTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockGetTenantExpectation specifies expectation struct of the PartitionServiceHandler.GetTenant
type PartitionServiceHandlerMockGetTenantExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockGetTenantParams
	paramPtrs          *PartitionServiceHandlerMockGetTenantParamPtrs
	expectationOrigins PartitionServiceHandlerMockGetTenantExpectationOrigins
	results            *PartitionServiceHandlerMockGetTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockGetTenantParams contains parameters of the PartitionServiceHandler.GetTenant
type PartitionServiceHandlerMockGetTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetTenantRequest]
}

// PartitionServiceHandlerMockGetTenantParamPtrs contains pointers to parameters of the PartitionServiceHandler.GetTenant
type PartitionServiceHandlerMockGetTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetTenantRequest]
}

// PartitionServiceHandlerMockGetTenantResults contains results of the PartitionServiceHandler.GetTenant
type PartitionServiceHandlerMockGetTenantResults struct {
	pp2 *connect.Response[v1.GetTenantResponse]
	err error
}

// PartitionServiceHandlerMockGetTenantOrigins contains origins of expectations of the PartitionServiceHandler.GetTenant
type PartitionServiceHandlerMockGetTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Optional() *mPartitionServiceHandlerMockGetTenant {
	mmGetTenant.optional = true
	return mmGetTenant
}

// Expect sets up expected params for PartitionServiceHandler.GetTenant
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) *mPartitionServiceHandlerMockGetTenant {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceHandlerMockGetTenantExpectation{}
	}

	if mmGetTenant.defaultExpectation.paramPtrs != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by ExpectParams functions")
	}

	mmGetTenant.defaultExpectation.params = &PartitionServiceHandlerMockGetTenantParams{ctx, pp1}
	mmGetTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTenant.expectations {
		if minimock.Equal(e.params, mmGetTenant.defaultExpectation.params) {
			mmGetTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTenant.defaultExpectation.params)
		}
	}

	return mmGetTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.GetTenant
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockGetTenant {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceHandlerMockGetTenantExpectation{}
	}

	if mmGetTenant.defaultExpectation.params != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Expect")
	}

	if mmGetTenant.defaultExpectation.paramPtrs == nil {
		mmGetTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetTenantParamPtrs{}
	}
	mmGetTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.GetTenant
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) ExpectPp1Param2(pp1 *connect.Request[v1.GetTenantRequest]) *mPartitionServiceHandlerMockGetTenant {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceHandlerMockGetTenantExpectation{}
	}

	if mmGetTenant.defaultExpectation.params != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Expect")
	}

	if mmGetTenant.defaultExpectation.paramPtrs == nil {
		mmGetTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockGetTenantParamPtrs{}
	}
	mmGetTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.GetTenant
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest])) *mPartitionServiceHandlerMockGetTenant {
	if mmGetTenant.mock.inspectFuncGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.GetTenant")
	}

	mmGetTenant.mock.inspectFuncGetTenant = f

	return mmGetTenant
}

// Return sets up results that will be returned by PartitionServiceHandler.GetTenant
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Return(pp2 *connect.Response[v1.GetTenantResponse], err error) *PartitionServiceHandlerMock {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceHandlerMockGetTenantExpectation{mock: mmGetTenant.mock}
	}
	mmGetTenant.defaultExpectation.results = &PartitionServiceHandlerMockGetTenantResults{pp2, err}
	mmGetTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTenant.mock
}

// Set uses given function f to mock the PartitionServiceHandler.GetTenant method
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) (pp2 *connect.Response[v1.GetTenantResponse], err error)) *PartitionServiceHandlerMock {
	if mmGetTenant.defaultExpectation != nil {
		mmGetTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.GetTenant method")
	}

	if len(mmGetTenant.expectations) > 0 {
		mmGetTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.GetTenant method")
	}

	mmGetTenant.mock.funcGetTenant = f
	mmGetTenant.mock.funcGetTenantOrigin = minimock.CallerInfo(1)
	return mmGetTenant.mock
}

// When sets expectation for the PartitionServiceHandler.GetTenant which will trigger the result defined by the following
// Then helper
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) When(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) *PartitionServiceHandlerMockGetTenantExpectation {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceHandlerMock.GetTenant mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockGetTenantExpectation{
		mock:               mmGetTenant.mock,
		params:             &PartitionServiceHandlerMockGetTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockGetTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTenant.expectations = append(mmGetTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.GetTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockGetTenantExpectation) Then(pp2 *connect.Response[v1.GetTenantResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockGetTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.GetTenant should be invoked
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Times(n uint64) *mPartitionServiceHandlerMockGetTenant {
	if n == 0 {
		mmGetTenant.mock.t.Fatalf("Times of PartitionServiceHandlerMock.GetTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTenant.expectedInvocations, n)
	mmGetTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTenant
}

func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) invocationsDone() bool {
	if len(mmGetTenant.expectations) == 0 && mmGetTenant.defaultExpectation == nil && mmGetTenant.mock.funcGetTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTenant.mock.afterGetTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTenant implements mm_partitionv1connect.PartitionServiceHandler
func (mmGetTenant *PartitionServiceHandlerMock) GetTenant(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) (pp2 *connect.Response[v1.GetTenantResponse], err error) {
	mm_atomic.AddUint64(&mmGetTenant.beforeGetTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTenant.afterGetTenantCounter, 1)

	mmGetTenant.t.Helper()

	if mmGetTenant.inspectFuncGetTenant != nil {
		mmGetTenant.inspectFuncGetTenant(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockGetTenantParams{ctx, pp1}

	// Record call args
	mmGetTenant.GetTenantMock.mutex.Lock()
	mmGetTenant.GetTenantMock.callArgs = append(mmGetTenant.GetTenantMock.callArgs, &mm_params)
	mmGetTenant.GetTenantMock.mutex.Unlock()

	for _, e := range mmGetTenant.GetTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetTenant.GetTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTenant.GetTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTenant.GetTenantMock.defaultExpectation.params
		mm_want_ptrs := mmGetTenant.GetTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockGetTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTenant.t.Errorf("PartitionServiceHandlerMock.GetTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTenant.GetTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetTenant.t.Errorf("PartitionServiceHandlerMock.GetTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTenant.GetTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTenant.t.Errorf("PartitionServiceHandlerMock.GetTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTenant.GetTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTenant.GetTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTenant.t.Fatal("No results are set for the PartitionServiceHandlerMock.GetTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetTenant.funcGetTenant != nil {
		return mmGetTenant.funcGetTenant(ctx, pp1)
	}
	mmGetTenant.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.GetTenant. %v %v", ctx, pp1)
	return
}

// GetTenantAfterCounter returns a count of finished PartitionServiceHandlerMock.GetTenant invocations
func (mmGetTenant *PartitionServiceHandlerMock) GetTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTenant.afterGetTenantCounter)
}

// GetTenantBeforeCounter returns a count of PartitionServiceHandlerMock.GetTenant invocations
func (mmGetTenant *PartitionServiceHandlerMock) GetTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTenant.beforeGetTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.GetTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTenant *mPartitionServiceHandlerMockGetTenant) Calls() []*PartitionServiceHandlerMockGetTenantParams {
	mmGetTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockGetTenantParams, len(mmGetTenant.callArgs))
	copy(argCopy, mmGetTenant.callArgs)

	mmGetTenant.mutex.RUnlock()

	return argCopy
}

// MinimockGetTenantDone returns true if the count of the GetTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockGetTenantDone() bool {
	if m.GetTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTenantMock.invocationsDone()
}

// MinimockGetTenantInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockGetTenantInspect() {
	for _, e := range m.GetTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTenantCounter := mm_atomic.LoadUint64(&m.afterGetTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTenantMock.defaultExpectation != nil && afterGetTenantCounter < 1 {
		if m.GetTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetTenant at\n%s", m.GetTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetTenant at\n%s with params: %#v", m.GetTenantMock.defaultExpectation.expectationOrigins.origin, *m.GetTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTenant != nil && afterGetTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.GetTenant at\n%s", m.funcGetTenantOrigin)
	}

	if !m.GetTenantMock.invocationsDone() && afterGetTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.GetTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTenantMock.expectedInvocations), m.GetTenantMock.expectedInvocationsOrigin, afterGetTenantCounter)
	}
}

type mPartitionServiceHandlerMockListAccessRole struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockListAccessRoleExpectation
	expectations       []*PartitionServiceHandlerMockListAccessRoleExpectation

	callArgs []*PartitionServiceHandlerMockListAccessRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockListAccessRoleExpectation specifies expectation struct of the PartitionServiceHandler.ListAccessRole
type PartitionServiceHandlerMockListAccessRoleExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockListAccessRoleParams
	paramPtrs          *PartitionServiceHandlerMockListAccessRoleParamPtrs
	expectationOrigins PartitionServiceHandlerMockListAccessRoleExpectationOrigins
	results            *PartitionServiceHandlerMockListAccessRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockListAccessRoleParams contains parameters of the PartitionServiceHandler.ListAccessRole
type PartitionServiceHandlerMockListAccessRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListAccessRoleRequest]
	pp2 *connect.ServerStream[v1.ListAccessRoleResponse]
}

// PartitionServiceHandlerMockListAccessRoleParamPtrs contains pointers to parameters of the PartitionServiceHandler.ListAccessRole
type PartitionServiceHandlerMockListAccessRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListAccessRoleRequest]
	pp2 **connect.ServerStream[v1.ListAccessRoleResponse]
}

// PartitionServiceHandlerMockListAccessRoleResults contains results of the PartitionServiceHandler.ListAccessRole
type PartitionServiceHandlerMockListAccessRoleResults struct {
	err error
}

// PartitionServiceHandlerMockListAccessRoleOrigins contains origins of expectations of the PartitionServiceHandler.ListAccessRole
type PartitionServiceHandlerMockListAccessRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Optional() *mPartitionServiceHandlerMockListAccessRole {
	mmListAccessRole.optional = true
	return mmListAccessRole
}

// Expect sets up expected params for PartitionServiceHandler.ListAccessRole
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Expect(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse]) *mPartitionServiceHandlerMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceHandlerMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.paramPtrs != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by ExpectParams functions")
	}

	mmListAccessRole.defaultExpectation.params = &PartitionServiceHandlerMockListAccessRoleParams{ctx, pp1, pp2}
	mmListAccessRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAccessRole.expectations {
		if minimock.Equal(e.params, mmListAccessRole.defaultExpectation.params) {
			mmListAccessRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAccessRole.defaultExpectation.params)
		}
	}

	return mmListAccessRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.ListAccessRole
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceHandlerMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.params != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Expect")
	}

	if mmListAccessRole.defaultExpectation.paramPtrs == nil {
		mmListAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListAccessRoleParamPtrs{}
	}
	mmListAccessRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAccessRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAccessRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.ListAccessRole
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) ExpectPp1Param2(pp1 *connect.Request[v1.ListAccessRoleRequest]) *mPartitionServiceHandlerMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceHandlerMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.params != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Expect")
	}

	if mmListAccessRole.defaultExpectation.paramPtrs == nil {
		mmListAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListAccessRoleParamPtrs{}
	}
	mmListAccessRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListAccessRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListAccessRole
}

// ExpectPp2Param3 sets up expected param pp2 for PartitionServiceHandler.ListAccessRole
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListAccessRoleResponse]) *mPartitionServiceHandlerMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceHandlerMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.params != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Expect")
	}

	if mmListAccessRole.defaultExpectation.paramPtrs == nil {
		mmListAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListAccessRoleParamPtrs{}
	}
	mmListAccessRole.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListAccessRole.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListAccessRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.ListAccessRole
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse])) *mPartitionServiceHandlerMockListAccessRole {
	if mmListAccessRole.mock.inspectFuncListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.ListAccessRole")
	}

	mmListAccessRole.mock.inspectFuncListAccessRole = f

	return mmListAccessRole
}

// Return sets up results that will be returned by PartitionServiceHandler.ListAccessRole
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Return(err error) *PartitionServiceHandlerMock {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceHandlerMockListAccessRoleExpectation{mock: mmListAccessRole.mock}
	}
	mmListAccessRole.defaultExpectation.results = &PartitionServiceHandlerMockListAccessRoleResults{err}
	mmListAccessRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAccessRole.mock
}

// Set uses given function f to mock the PartitionServiceHandler.ListAccessRole method
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse]) (err error)) *PartitionServiceHandlerMock {
	if mmListAccessRole.defaultExpectation != nil {
		mmListAccessRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.ListAccessRole method")
	}

	if len(mmListAccessRole.expectations) > 0 {
		mmListAccessRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.ListAccessRole method")
	}

	mmListAccessRole.mock.funcListAccessRole = f
	mmListAccessRole.mock.funcListAccessRoleOrigin = minimock.CallerInfo(1)
	return mmListAccessRole.mock
}

// When sets expectation for the PartitionServiceHandler.ListAccessRole which will trigger the result defined by the following
// Then helper
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) When(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse]) *PartitionServiceHandlerMockListAccessRoleExpectation {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListAccessRole mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockListAccessRoleExpectation{
		mock:               mmListAccessRole.mock,
		params:             &PartitionServiceHandlerMockListAccessRoleParams{ctx, pp1, pp2},
		expectationOrigins: PartitionServiceHandlerMockListAccessRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAccessRole.expectations = append(mmListAccessRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.ListAccessRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockListAccessRoleExpectation) Then(err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockListAccessRoleResults{err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.ListAccessRole should be invoked
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Times(n uint64) *mPartitionServiceHandlerMockListAccessRole {
	if n == 0 {
		mmListAccessRole.mock.t.Fatalf("Times of PartitionServiceHandlerMock.ListAccessRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAccessRole.expectedInvocations, n)
	mmListAccessRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAccessRole
}

func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) invocationsDone() bool {
	if len(mmListAccessRole.expectations) == 0 && mmListAccessRole.defaultExpectation == nil && mmListAccessRole.mock.funcListAccessRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAccessRole.mock.afterListAccessRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAccessRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAccessRole implements mm_partitionv1connect.PartitionServiceHandler
func (mmListAccessRole *PartitionServiceHandlerMock) ListAccessRole(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest], pp2 *connect.ServerStream[v1.ListAccessRoleResponse]) (err error) {
	mm_atomic.AddUint64(&mmListAccessRole.beforeListAccessRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmListAccessRole.afterListAccessRoleCounter, 1)

	mmListAccessRole.t.Helper()

	if mmListAccessRole.inspectFuncListAccessRole != nil {
		mmListAccessRole.inspectFuncListAccessRole(ctx, pp1, pp2)
	}

	mm_params := PartitionServiceHandlerMockListAccessRoleParams{ctx, pp1, pp2}

	// Record call args
	mmListAccessRole.ListAccessRoleMock.mutex.Lock()
	mmListAccessRole.ListAccessRoleMock.callArgs = append(mmListAccessRole.ListAccessRoleMock.callArgs, &mm_params)
	mmListAccessRole.ListAccessRoleMock.mutex.Unlock()

	for _, e := range mmListAccessRole.ListAccessRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListAccessRole.ListAccessRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAccessRole.ListAccessRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmListAccessRole.ListAccessRoleMock.defaultExpectation.params
		mm_want_ptrs := mmListAccessRole.ListAccessRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockListAccessRoleParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAccessRole.t.Errorf("PartitionServiceHandlerMock.ListAccessRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListAccessRole.t.Errorf("PartitionServiceHandlerMock.ListAccessRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListAccessRole.t.Errorf("PartitionServiceHandlerMock.ListAccessRole got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAccessRole.t.Errorf("PartitionServiceHandlerMock.ListAccessRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAccessRole.ListAccessRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmListAccessRole.t.Fatal("No results are set for the PartitionServiceHandlerMock.ListAccessRole")
		}
		return (*mm_results).err
	}
	if mmListAccessRole.funcListAccessRole != nil {
		return mmListAccessRole.funcListAccessRole(ctx, pp1, pp2)
	}
	mmListAccessRole.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.ListAccessRole. %v %v %v", ctx, pp1, pp2)
	return
}

// ListAccessRoleAfterCounter returns a count of finished PartitionServiceHandlerMock.ListAccessRole invocations
func (mmListAccessRole *PartitionServiceHandlerMock) ListAccessRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAccessRole.afterListAccessRoleCounter)
}

// ListAccessRoleBeforeCounter returns a count of PartitionServiceHandlerMock.ListAccessRole invocations
func (mmListAccessRole *PartitionServiceHandlerMock) ListAccessRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAccessRole.beforeListAccessRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.ListAccessRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAccessRole *mPartitionServiceHandlerMockListAccessRole) Calls() []*PartitionServiceHandlerMockListAccessRoleParams {
	mmListAccessRole.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockListAccessRoleParams, len(mmListAccessRole.callArgs))
	copy(argCopy, mmListAccessRole.callArgs)

	mmListAccessRole.mutex.RUnlock()

	return argCopy
}

// MinimockListAccessRoleDone returns true if the count of the ListAccessRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockListAccessRoleDone() bool {
	if m.ListAccessRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAccessRoleMock.invocationsDone()
}

// MinimockListAccessRoleInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockListAccessRoleInspect() {
	for _, e := range m.ListAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListAccessRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAccessRoleCounter := mm_atomic.LoadUint64(&m.afterListAccessRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAccessRoleMock.defaultExpectation != nil && afterListAccessRoleCounter < 1 {
		if m.ListAccessRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListAccessRole at\n%s", m.ListAccessRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListAccessRole at\n%s with params: %#v", m.ListAccessRoleMock.defaultExpectation.expectationOrigins.origin, *m.ListAccessRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAccessRole != nil && afterListAccessRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListAccessRole at\n%s", m.funcListAccessRoleOrigin)
	}

	if !m.ListAccessRoleMock.invocationsDone() && afterListAccessRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.ListAccessRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAccessRoleMock.expectedInvocations), m.ListAccessRoleMock.expectedInvocationsOrigin, afterListAccessRoleCounter)
	}
}

type mPartitionServiceHandlerMockListPartition struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockListPartitionExpectation
	expectations       []*PartitionServiceHandlerMockListPartitionExpectation

	callArgs []*PartitionServiceHandlerMockListPartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockListPartitionExpectation specifies expectation struct of the PartitionServiceHandler.ListPartition
type PartitionServiceHandlerMockListPartitionExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockListPartitionParams
	paramPtrs          *PartitionServiceHandlerMockListPartitionParamPtrs
	expectationOrigins PartitionServiceHandlerMockListPartitionExpectationOrigins
	results            *PartitionServiceHandlerMockListPartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockListPartitionParams contains parameters of the PartitionServiceHandler.ListPartition
type PartitionServiceHandlerMockListPartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListPartitionRequest]
	pp2 *connect.ServerStream[v1.ListPartitionResponse]
}

// PartitionServiceHandlerMockListPartitionParamPtrs contains pointers to parameters of the PartitionServiceHandler.ListPartition
type PartitionServiceHandlerMockListPartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListPartitionRequest]
	pp2 **connect.ServerStream[v1.ListPartitionResponse]
}

// PartitionServiceHandlerMockListPartitionResults contains results of the PartitionServiceHandler.ListPartition
type PartitionServiceHandlerMockListPartitionResults struct {
	err error
}

// PartitionServiceHandlerMockListPartitionOrigins contains origins of expectations of the PartitionServiceHandler.ListPartition
type PartitionServiceHandlerMockListPartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Optional() *mPartitionServiceHandlerMockListPartition {
	mmListPartition.optional = true
	return mmListPartition
}

// Expect sets up expected params for PartitionServiceHandler.ListPartition
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Expect(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse]) *mPartitionServiceHandlerMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceHandlerMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.paramPtrs != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by ExpectParams functions")
	}

	mmListPartition.defaultExpectation.params = &PartitionServiceHandlerMockListPartitionParams{ctx, pp1, pp2}
	mmListPartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPartition.expectations {
		if minimock.Equal(e.params, mmListPartition.defaultExpectation.params) {
			mmListPartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPartition.defaultExpectation.params)
		}
	}

	return mmListPartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.ListPartition
func (mmListPartition *mPartitionServiceHandlerMockListPartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceHandlerMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.params != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Expect")
	}

	if mmListPartition.defaultExpectation.paramPtrs == nil {
		mmListPartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListPartitionParamPtrs{}
	}
	mmListPartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.ListPartition
func (mmListPartition *mPartitionServiceHandlerMockListPartition) ExpectPp1Param2(pp1 *connect.Request[v1.ListPartitionRequest]) *mPartitionServiceHandlerMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceHandlerMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.params != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Expect")
	}

	if mmListPartition.defaultExpectation.paramPtrs == nil {
		mmListPartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListPartitionParamPtrs{}
	}
	mmListPartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListPartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListPartition
}

// ExpectPp2Param3 sets up expected param pp2 for PartitionServiceHandler.ListPartition
func (mmListPartition *mPartitionServiceHandlerMockListPartition) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListPartitionResponse]) *mPartitionServiceHandlerMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceHandlerMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.params != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Expect")
	}

	if mmListPartition.defaultExpectation.paramPtrs == nil {
		mmListPartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListPartitionParamPtrs{}
	}
	mmListPartition.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListPartition.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListPartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.ListPartition
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse])) *mPartitionServiceHandlerMockListPartition {
	if mmListPartition.mock.inspectFuncListPartition != nil {
		mmListPartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.ListPartition")
	}

	mmListPartition.mock.inspectFuncListPartition = f

	return mmListPartition
}

// Return sets up results that will be returned by PartitionServiceHandler.ListPartition
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Return(err error) *PartitionServiceHandlerMock {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceHandlerMockListPartitionExpectation{mock: mmListPartition.mock}
	}
	mmListPartition.defaultExpectation.results = &PartitionServiceHandlerMockListPartitionResults{err}
	mmListPartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPartition.mock
}

// Set uses given function f to mock the PartitionServiceHandler.ListPartition method
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse]) (err error)) *PartitionServiceHandlerMock {
	if mmListPartition.defaultExpectation != nil {
		mmListPartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.ListPartition method")
	}

	if len(mmListPartition.expectations) > 0 {
		mmListPartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.ListPartition method")
	}

	mmListPartition.mock.funcListPartition = f
	mmListPartition.mock.funcListPartitionOrigin = minimock.CallerInfo(1)
	return mmListPartition.mock
}

// When sets expectation for the PartitionServiceHandler.ListPartition which will trigger the result defined by the following
// Then helper
func (mmListPartition *mPartitionServiceHandlerMockListPartition) When(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse]) *PartitionServiceHandlerMockListPartitionExpectation {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartition mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockListPartitionExpectation{
		mock:               mmListPartition.mock,
		params:             &PartitionServiceHandlerMockListPartitionParams{ctx, pp1, pp2},
		expectationOrigins: PartitionServiceHandlerMockListPartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPartition.expectations = append(mmListPartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.ListPartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockListPartitionExpectation) Then(err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockListPartitionResults{err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.ListPartition should be invoked
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Times(n uint64) *mPartitionServiceHandlerMockListPartition {
	if n == 0 {
		mmListPartition.mock.t.Fatalf("Times of PartitionServiceHandlerMock.ListPartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPartition.expectedInvocations, n)
	mmListPartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPartition
}

func (mmListPartition *mPartitionServiceHandlerMockListPartition) invocationsDone() bool {
	if len(mmListPartition.expectations) == 0 && mmListPartition.defaultExpectation == nil && mmListPartition.mock.funcListPartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPartition.mock.afterListPartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPartition implements mm_partitionv1connect.PartitionServiceHandler
func (mmListPartition *PartitionServiceHandlerMock) ListPartition(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest], pp2 *connect.ServerStream[v1.ListPartitionResponse]) (err error) {
	mm_atomic.AddUint64(&mmListPartition.beforeListPartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmListPartition.afterListPartitionCounter, 1)

	mmListPartition.t.Helper()

	if mmListPartition.inspectFuncListPartition != nil {
		mmListPartition.inspectFuncListPartition(ctx, pp1, pp2)
	}

	mm_params := PartitionServiceHandlerMockListPartitionParams{ctx, pp1, pp2}

	// Record call args
	mmListPartition.ListPartitionMock.mutex.Lock()
	mmListPartition.ListPartitionMock.callArgs = append(mmListPartition.ListPartitionMock.callArgs, &mm_params)
	mmListPartition.ListPartitionMock.mutex.Unlock()

	for _, e := range mmListPartition.ListPartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListPartition.ListPartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPartition.ListPartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmListPartition.ListPartitionMock.defaultExpectation.params
		mm_want_ptrs := mmListPartition.ListPartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockListPartitionParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPartition.t.Errorf("PartitionServiceHandlerMock.ListPartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListPartition.t.Errorf("PartitionServiceHandlerMock.ListPartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListPartition.t.Errorf("PartitionServiceHandlerMock.ListPartition got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPartition.t.Errorf("PartitionServiceHandlerMock.ListPartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPartition.ListPartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmListPartition.t.Fatal("No results are set for the PartitionServiceHandlerMock.ListPartition")
		}
		return (*mm_results).err
	}
	if mmListPartition.funcListPartition != nil {
		return mmListPartition.funcListPartition(ctx, pp1, pp2)
	}
	mmListPartition.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.ListPartition. %v %v %v", ctx, pp1, pp2)
	return
}

// ListPartitionAfterCounter returns a count of finished PartitionServiceHandlerMock.ListPartition invocations
func (mmListPartition *PartitionServiceHandlerMock) ListPartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartition.afterListPartitionCounter)
}

// ListPartitionBeforeCounter returns a count of PartitionServiceHandlerMock.ListPartition invocations
func (mmListPartition *PartitionServiceHandlerMock) ListPartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartition.beforeListPartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.ListPartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPartition *mPartitionServiceHandlerMockListPartition) Calls() []*PartitionServiceHandlerMockListPartitionParams {
	mmListPartition.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockListPartitionParams, len(mmListPartition.callArgs))
	copy(argCopy, mmListPartition.callArgs)

	mmListPartition.mutex.RUnlock()

	return argCopy
}

// MinimockListPartitionDone returns true if the count of the ListPartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockListPartitionDone() bool {
	if m.ListPartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPartitionMock.invocationsDone()
}

// MinimockListPartitionInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockListPartitionInspect() {
	for _, e := range m.ListPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPartitionCounter := mm_atomic.LoadUint64(&m.afterListPartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPartitionMock.defaultExpectation != nil && afterListPartitionCounter < 1 {
		if m.ListPartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartition at\n%s", m.ListPartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartition at\n%s with params: %#v", m.ListPartitionMock.defaultExpectation.expectationOrigins.origin, *m.ListPartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPartition != nil && afterListPartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartition at\n%s", m.funcListPartitionOrigin)
	}

	if !m.ListPartitionMock.invocationsDone() && afterListPartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.ListPartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPartitionMock.expectedInvocations), m.ListPartitionMock.expectedInvocationsOrigin, afterListPartitionCounter)
	}
}

type mPartitionServiceHandlerMockListPartitionRole struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockListPartitionRoleExpectation
	expectations       []*PartitionServiceHandlerMockListPartitionRoleExpectation

	callArgs []*PartitionServiceHandlerMockListPartitionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockListPartitionRoleExpectation specifies expectation struct of the PartitionServiceHandler.ListPartitionRole
type PartitionServiceHandlerMockListPartitionRoleExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockListPartitionRoleParams
	paramPtrs          *PartitionServiceHandlerMockListPartitionRoleParamPtrs
	expectationOrigins PartitionServiceHandlerMockListPartitionRoleExpectationOrigins
	results            *PartitionServiceHandlerMockListPartitionRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockListPartitionRoleParams contains parameters of the PartitionServiceHandler.ListPartitionRole
type PartitionServiceHandlerMockListPartitionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListPartitionRoleRequest]
	pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]
}

// PartitionServiceHandlerMockListPartitionRoleParamPtrs contains pointers to parameters of the PartitionServiceHandler.ListPartitionRole
type PartitionServiceHandlerMockListPartitionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListPartitionRoleRequest]
	pp2 **connect.ServerStream[v1.ListPartitionRoleResponse]
}

// PartitionServiceHandlerMockListPartitionRoleResults contains results of the PartitionServiceHandler.ListPartitionRole
type PartitionServiceHandlerMockListPartitionRoleResults struct {
	err error
}

// PartitionServiceHandlerMockListPartitionRoleOrigins contains origins of expectations of the PartitionServiceHandler.ListPartitionRole
type PartitionServiceHandlerMockListPartitionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Optional() *mPartitionServiceHandlerMockListPartitionRole {
	mmListPartitionRole.optional = true
	return mmListPartitionRole
}

// Expect sets up expected params for PartitionServiceHandler.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]) *mPartitionServiceHandlerMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceHandlerMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by ExpectParams functions")
	}

	mmListPartitionRole.defaultExpectation.params = &PartitionServiceHandlerMockListPartitionRoleParams{ctx, pp1, pp2}
	mmListPartitionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPartitionRole.expectations {
		if minimock.Equal(e.params, mmListPartitionRole.defaultExpectation.params) {
			mmListPartitionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPartitionRole.defaultExpectation.params)
		}
	}

	return mmListPartitionRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceHandlerMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.params != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Expect")
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs == nil {
		mmListPartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListPartitionRoleParamPtrs{}
	}
	mmListPartitionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPartitionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPartitionRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) ExpectPp1Param2(pp1 *connect.Request[v1.ListPartitionRoleRequest]) *mPartitionServiceHandlerMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceHandlerMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.params != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Expect")
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs == nil {
		mmListPartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListPartitionRoleParamPtrs{}
	}
	mmListPartitionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListPartitionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListPartitionRole
}

// ExpectPp2Param3 sets up expected param pp2 for PartitionServiceHandler.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]) *mPartitionServiceHandlerMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceHandlerMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.params != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Expect")
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs == nil {
		mmListPartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListPartitionRoleParamPtrs{}
	}
	mmListPartitionRole.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListPartitionRole.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListPartitionRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse])) *mPartitionServiceHandlerMockListPartitionRole {
	if mmListPartitionRole.mock.inspectFuncListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.ListPartitionRole")
	}

	mmListPartitionRole.mock.inspectFuncListPartitionRole = f

	return mmListPartitionRole
}

// Return sets up results that will be returned by PartitionServiceHandler.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Return(err error) *PartitionServiceHandlerMock {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceHandlerMockListPartitionRoleExpectation{mock: mmListPartitionRole.mock}
	}
	mmListPartitionRole.defaultExpectation.results = &PartitionServiceHandlerMockListPartitionRoleResults{err}
	mmListPartitionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPartitionRole.mock
}

// Set uses given function f to mock the PartitionServiceHandler.ListPartitionRole method
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]) (err error)) *PartitionServiceHandlerMock {
	if mmListPartitionRole.defaultExpectation != nil {
		mmListPartitionRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.ListPartitionRole method")
	}

	if len(mmListPartitionRole.expectations) > 0 {
		mmListPartitionRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.ListPartitionRole method")
	}

	mmListPartitionRole.mock.funcListPartitionRole = f
	mmListPartitionRole.mock.funcListPartitionRoleOrigin = minimock.CallerInfo(1)
	return mmListPartitionRole.mock
}

// When sets expectation for the PartitionServiceHandler.ListPartitionRole which will trigger the result defined by the following
// Then helper
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) When(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]) *PartitionServiceHandlerMockListPartitionRoleExpectation {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.ListPartitionRole mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockListPartitionRoleExpectation{
		mock:               mmListPartitionRole.mock,
		params:             &PartitionServiceHandlerMockListPartitionRoleParams{ctx, pp1, pp2},
		expectationOrigins: PartitionServiceHandlerMockListPartitionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPartitionRole.expectations = append(mmListPartitionRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.ListPartitionRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockListPartitionRoleExpectation) Then(err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockListPartitionRoleResults{err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.ListPartitionRole should be invoked
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Times(n uint64) *mPartitionServiceHandlerMockListPartitionRole {
	if n == 0 {
		mmListPartitionRole.mock.t.Fatalf("Times of PartitionServiceHandlerMock.ListPartitionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPartitionRole.expectedInvocations, n)
	mmListPartitionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPartitionRole
}

func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) invocationsDone() bool {
	if len(mmListPartitionRole.expectations) == 0 && mmListPartitionRole.defaultExpectation == nil && mmListPartitionRole.mock.funcListPartitionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPartitionRole.mock.afterListPartitionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPartitionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPartitionRole implements mm_partitionv1connect.PartitionServiceHandler
func (mmListPartitionRole *PartitionServiceHandlerMock) ListPartitionRole(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest], pp2 *connect.ServerStream[v1.ListPartitionRoleResponse]) (err error) {
	mm_atomic.AddUint64(&mmListPartitionRole.beforeListPartitionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmListPartitionRole.afterListPartitionRoleCounter, 1)

	mmListPartitionRole.t.Helper()

	if mmListPartitionRole.inspectFuncListPartitionRole != nil {
		mmListPartitionRole.inspectFuncListPartitionRole(ctx, pp1, pp2)
	}

	mm_params := PartitionServiceHandlerMockListPartitionRoleParams{ctx, pp1, pp2}

	// Record call args
	mmListPartitionRole.ListPartitionRoleMock.mutex.Lock()
	mmListPartitionRole.ListPartitionRoleMock.callArgs = append(mmListPartitionRole.ListPartitionRoleMock.callArgs, &mm_params)
	mmListPartitionRole.ListPartitionRoleMock.mutex.Unlock()

	for _, e := range mmListPartitionRole.ListPartitionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListPartitionRole.ListPartitionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockListPartitionRoleParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPartitionRole.t.Errorf("PartitionServiceHandlerMock.ListPartitionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListPartitionRole.t.Errorf("PartitionServiceHandlerMock.ListPartitionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListPartitionRole.t.Errorf("PartitionServiceHandlerMock.ListPartitionRole got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPartitionRole.t.Errorf("PartitionServiceHandlerMock.ListPartitionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmListPartitionRole.t.Fatal("No results are set for the PartitionServiceHandlerMock.ListPartitionRole")
		}
		return (*mm_results).err
	}
	if mmListPartitionRole.funcListPartitionRole != nil {
		return mmListPartitionRole.funcListPartitionRole(ctx, pp1, pp2)
	}
	mmListPartitionRole.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.ListPartitionRole. %v %v %v", ctx, pp1, pp2)
	return
}

// ListPartitionRoleAfterCounter returns a count of finished PartitionServiceHandlerMock.ListPartitionRole invocations
func (mmListPartitionRole *PartitionServiceHandlerMock) ListPartitionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartitionRole.afterListPartitionRoleCounter)
}

// ListPartitionRoleBeforeCounter returns a count of PartitionServiceHandlerMock.ListPartitionRole invocations
func (mmListPartitionRole *PartitionServiceHandlerMock) ListPartitionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartitionRole.beforeListPartitionRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.ListPartitionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPartitionRole *mPartitionServiceHandlerMockListPartitionRole) Calls() []*PartitionServiceHandlerMockListPartitionRoleParams {
	mmListPartitionRole.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockListPartitionRoleParams, len(mmListPartitionRole.callArgs))
	copy(argCopy, mmListPartitionRole.callArgs)

	mmListPartitionRole.mutex.RUnlock()

	return argCopy
}

// MinimockListPartitionRoleDone returns true if the count of the ListPartitionRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockListPartitionRoleDone() bool {
	if m.ListPartitionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPartitionRoleMock.invocationsDone()
}

// MinimockListPartitionRoleInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockListPartitionRoleInspect() {
	for _, e := range m.ListPartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartitionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPartitionRoleCounter := mm_atomic.LoadUint64(&m.afterListPartitionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPartitionRoleMock.defaultExpectation != nil && afterListPartitionRoleCounter < 1 {
		if m.ListPartitionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartitionRole at\n%s", m.ListPartitionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartitionRole at\n%s with params: %#v", m.ListPartitionRoleMock.defaultExpectation.expectationOrigins.origin, *m.ListPartitionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPartitionRole != nil && afterListPartitionRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListPartitionRole at\n%s", m.funcListPartitionRoleOrigin)
	}

	if !m.ListPartitionRoleMock.invocationsDone() && afterListPartitionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.ListPartitionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPartitionRoleMock.expectedInvocations), m.ListPartitionRoleMock.expectedInvocationsOrigin, afterListPartitionRoleCounter)
	}
}

type mPartitionServiceHandlerMockListTenant struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockListTenantExpectation
	expectations       []*PartitionServiceHandlerMockListTenantExpectation

	callArgs []*PartitionServiceHandlerMockListTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockListTenantExpectation specifies expectation struct of the PartitionServiceHandler.ListTenant
type PartitionServiceHandlerMockListTenantExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockListTenantParams
	paramPtrs          *PartitionServiceHandlerMockListTenantParamPtrs
	expectationOrigins PartitionServiceHandlerMockListTenantExpectationOrigins
	results            *PartitionServiceHandlerMockListTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockListTenantParams contains parameters of the PartitionServiceHandler.ListTenant
type PartitionServiceHandlerMockListTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListTenantRequest]
	pp2 *connect.ServerStream[v1.ListTenantResponse]
}

// PartitionServiceHandlerMockListTenantParamPtrs contains pointers to parameters of the PartitionServiceHandler.ListTenant
type PartitionServiceHandlerMockListTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListTenantRequest]
	pp2 **connect.ServerStream[v1.ListTenantResponse]
}

// PartitionServiceHandlerMockListTenantResults contains results of the PartitionServiceHandler.ListTenant
type PartitionServiceHandlerMockListTenantResults struct {
	err error
}

// PartitionServiceHandlerMockListTenantOrigins contains origins of expectations of the PartitionServiceHandler.ListTenant
type PartitionServiceHandlerMockListTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Optional() *mPartitionServiceHandlerMockListTenant {
	mmListTenant.optional = true
	return mmListTenant
}

// Expect sets up expected params for PartitionServiceHandler.ListTenant
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse]) *mPartitionServiceHandlerMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceHandlerMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.paramPtrs != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by ExpectParams functions")
	}

	mmListTenant.defaultExpectation.params = &PartitionServiceHandlerMockListTenantParams{ctx, pp1, pp2}
	mmListTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTenant.expectations {
		if minimock.Equal(e.params, mmListTenant.defaultExpectation.params) {
			mmListTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTenant.defaultExpectation.params)
		}
	}

	return mmListTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.ListTenant
func (mmListTenant *mPartitionServiceHandlerMockListTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceHandlerMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.params != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Expect")
	}

	if mmListTenant.defaultExpectation.paramPtrs == nil {
		mmListTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListTenantParamPtrs{}
	}
	mmListTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.ListTenant
func (mmListTenant *mPartitionServiceHandlerMockListTenant) ExpectPp1Param2(pp1 *connect.Request[v1.ListTenantRequest]) *mPartitionServiceHandlerMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceHandlerMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.params != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Expect")
	}

	if mmListTenant.defaultExpectation.paramPtrs == nil {
		mmListTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListTenantParamPtrs{}
	}
	mmListTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListTenant
}

// ExpectPp2Param3 sets up expected param pp2 for PartitionServiceHandler.ListTenant
func (mmListTenant *mPartitionServiceHandlerMockListTenant) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListTenantResponse]) *mPartitionServiceHandlerMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceHandlerMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.params != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Expect")
	}

	if mmListTenant.defaultExpectation.paramPtrs == nil {
		mmListTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockListTenantParamPtrs{}
	}
	mmListTenant.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListTenant.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.ListTenant
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse])) *mPartitionServiceHandlerMockListTenant {
	if mmListTenant.mock.inspectFuncListTenant != nil {
		mmListTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.ListTenant")
	}

	mmListTenant.mock.inspectFuncListTenant = f

	return mmListTenant
}

// Return sets up results that will be returned by PartitionServiceHandler.ListTenant
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Return(err error) *PartitionServiceHandlerMock {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceHandlerMockListTenantExpectation{mock: mmListTenant.mock}
	}
	mmListTenant.defaultExpectation.results = &PartitionServiceHandlerMockListTenantResults{err}
	mmListTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTenant.mock
}

// Set uses given function f to mock the PartitionServiceHandler.ListTenant method
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse]) (err error)) *PartitionServiceHandlerMock {
	if mmListTenant.defaultExpectation != nil {
		mmListTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.ListTenant method")
	}

	if len(mmListTenant.expectations) > 0 {
		mmListTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.ListTenant method")
	}

	mmListTenant.mock.funcListTenant = f
	mmListTenant.mock.funcListTenantOrigin = minimock.CallerInfo(1)
	return mmListTenant.mock
}

// When sets expectation for the PartitionServiceHandler.ListTenant which will trigger the result defined by the following
// Then helper
func (mmListTenant *mPartitionServiceHandlerMockListTenant) When(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse]) *PartitionServiceHandlerMockListTenantExpectation {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceHandlerMock.ListTenant mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockListTenantExpectation{
		mock:               mmListTenant.mock,
		params:             &PartitionServiceHandlerMockListTenantParams{ctx, pp1, pp2},
		expectationOrigins: PartitionServiceHandlerMockListTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTenant.expectations = append(mmListTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.ListTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockListTenantExpectation) Then(err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockListTenantResults{err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.ListTenant should be invoked
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Times(n uint64) *mPartitionServiceHandlerMockListTenant {
	if n == 0 {
		mmListTenant.mock.t.Fatalf("Times of PartitionServiceHandlerMock.ListTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTenant.expectedInvocations, n)
	mmListTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTenant
}

func (mmListTenant *mPartitionServiceHandlerMockListTenant) invocationsDone() bool {
	if len(mmListTenant.expectations) == 0 && mmListTenant.defaultExpectation == nil && mmListTenant.mock.funcListTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTenant.mock.afterListTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTenant implements mm_partitionv1connect.PartitionServiceHandler
func (mmListTenant *PartitionServiceHandlerMock) ListTenant(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest], pp2 *connect.ServerStream[v1.ListTenantResponse]) (err error) {
	mm_atomic.AddUint64(&mmListTenant.beforeListTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmListTenant.afterListTenantCounter, 1)

	mmListTenant.t.Helper()

	if mmListTenant.inspectFuncListTenant != nil {
		mmListTenant.inspectFuncListTenant(ctx, pp1, pp2)
	}

	mm_params := PartitionServiceHandlerMockListTenantParams{ctx, pp1, pp2}

	// Record call args
	mmListTenant.ListTenantMock.mutex.Lock()
	mmListTenant.ListTenantMock.callArgs = append(mmListTenant.ListTenantMock.callArgs, &mm_params)
	mmListTenant.ListTenantMock.mutex.Unlock()

	for _, e := range mmListTenant.ListTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListTenant.ListTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTenant.ListTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmListTenant.ListTenantMock.defaultExpectation.params
		mm_want_ptrs := mmListTenant.ListTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockListTenantParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTenant.t.Errorf("PartitionServiceHandlerMock.ListTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListTenant.t.Errorf("PartitionServiceHandlerMock.ListTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListTenant.t.Errorf("PartitionServiceHandlerMock.ListTenant got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTenant.t.Errorf("PartitionServiceHandlerMock.ListTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTenant.ListTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmListTenant.t.Fatal("No results are set for the PartitionServiceHandlerMock.ListTenant")
		}
		return (*mm_results).err
	}
	if mmListTenant.funcListTenant != nil {
		return mmListTenant.funcListTenant(ctx, pp1, pp2)
	}
	mmListTenant.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.ListTenant. %v %v %v", ctx, pp1, pp2)
	return
}

// ListTenantAfterCounter returns a count of finished PartitionServiceHandlerMock.ListTenant invocations
func (mmListTenant *PartitionServiceHandlerMock) ListTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTenant.afterListTenantCounter)
}

// ListTenantBeforeCounter returns a count of PartitionServiceHandlerMock.ListTenant invocations
func (mmListTenant *PartitionServiceHandlerMock) ListTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTenant.beforeListTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.ListTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTenant *mPartitionServiceHandlerMockListTenant) Calls() []*PartitionServiceHandlerMockListTenantParams {
	mmListTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockListTenantParams, len(mmListTenant.callArgs))
	copy(argCopy, mmListTenant.callArgs)

	mmListTenant.mutex.RUnlock()

	return argCopy
}

// MinimockListTenantDone returns true if the count of the ListTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockListTenantDone() bool {
	if m.ListTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTenantMock.invocationsDone()
}

// MinimockListTenantInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockListTenantInspect() {
	for _, e := range m.ListTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTenantCounter := mm_atomic.LoadUint64(&m.afterListTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTenantMock.defaultExpectation != nil && afterListTenantCounter < 1 {
		if m.ListTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListTenant at\n%s", m.ListTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListTenant at\n%s with params: %#v", m.ListTenantMock.defaultExpectation.expectationOrigins.origin, *m.ListTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTenant != nil && afterListTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.ListTenant at\n%s", m.funcListTenantOrigin)
	}

	if !m.ListTenantMock.invocationsDone() && afterListTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.ListTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTenantMock.expectedInvocations), m.ListTenantMock.expectedInvocationsOrigin, afterListTenantCounter)
	}
}

type mPartitionServiceHandlerMockRemoveAccess struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockRemoveAccessExpectation
	expectations       []*PartitionServiceHandlerMockRemoveAccessExpectation

	callArgs []*PartitionServiceHandlerMockRemoveAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockRemoveAccessExpectation specifies expectation struct of the PartitionServiceHandler.RemoveAccess
type PartitionServiceHandlerMockRemoveAccessExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockRemoveAccessParams
	paramPtrs          *PartitionServiceHandlerMockRemoveAccessParamPtrs
	expectationOrigins PartitionServiceHandlerMockRemoveAccessExpectationOrigins
	results            *PartitionServiceHandlerMockRemoveAccessResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockRemoveAccessParams contains parameters of the PartitionServiceHandler.RemoveAccess
type PartitionServiceHandlerMockRemoveAccessParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveAccessRequest]
}

// PartitionServiceHandlerMockRemoveAccessParamPtrs contains pointers to parameters of the PartitionServiceHandler.RemoveAccess
type PartitionServiceHandlerMockRemoveAccessParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveAccessRequest]
}

// PartitionServiceHandlerMockRemoveAccessResults contains results of the PartitionServiceHandler.RemoveAccess
type PartitionServiceHandlerMockRemoveAccessResults struct {
	pp2 *connect.Response[v1.RemoveAccessResponse]
	err error
}

// PartitionServiceHandlerMockRemoveAccessOrigins contains origins of expectations of the PartitionServiceHandler.RemoveAccess
type PartitionServiceHandlerMockRemoveAccessExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Optional() *mPartitionServiceHandlerMockRemoveAccess {
	mmRemoveAccess.optional = true
	return mmRemoveAccess
}

// Expect sets up expected params for PartitionServiceHandler.RemoveAccess
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) *mPartitionServiceHandlerMockRemoveAccess {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessExpectation{}
	}

	if mmRemoveAccess.defaultExpectation.paramPtrs != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by ExpectParams functions")
	}

	mmRemoveAccess.defaultExpectation.params = &PartitionServiceHandlerMockRemoveAccessParams{ctx, pp1}
	mmRemoveAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveAccess.expectations {
		if minimock.Equal(e.params, mmRemoveAccess.defaultExpectation.params) {
			mmRemoveAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAccess.defaultExpectation.params)
		}
	}

	return mmRemoveAccess
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.RemoveAccess
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockRemoveAccess {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessExpectation{}
	}

	if mmRemoveAccess.defaultExpectation.params != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Expect")
	}

	if mmRemoveAccess.defaultExpectation.paramPtrs == nil {
		mmRemoveAccess.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemoveAccessParamPtrs{}
	}
	mmRemoveAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveAccess
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.RemoveAccess
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveAccessRequest]) *mPartitionServiceHandlerMockRemoveAccess {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessExpectation{}
	}

	if mmRemoveAccess.defaultExpectation.params != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Expect")
	}

	if mmRemoveAccess.defaultExpectation.paramPtrs == nil {
		mmRemoveAccess.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemoveAccessParamPtrs{}
	}
	mmRemoveAccess.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveAccess.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveAccess
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.RemoveAccess
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest])) *mPartitionServiceHandlerMockRemoveAccess {
	if mmRemoveAccess.mock.inspectFuncRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.RemoveAccess")
	}

	mmRemoveAccess.mock.inspectFuncRemoveAccess = f

	return mmRemoveAccess
}

// Return sets up results that will be returned by PartitionServiceHandler.RemoveAccess
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Return(pp2 *connect.Response[v1.RemoveAccessResponse], err error) *PartitionServiceHandlerMock {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessExpectation{mock: mmRemoveAccess.mock}
	}
	mmRemoveAccess.defaultExpectation.results = &PartitionServiceHandlerMockRemoveAccessResults{pp2, err}
	mmRemoveAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveAccess.mock
}

// Set uses given function f to mock the PartitionServiceHandler.RemoveAccess method
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) (pp2 *connect.Response[v1.RemoveAccessResponse], err error)) *PartitionServiceHandlerMock {
	if mmRemoveAccess.defaultExpectation != nil {
		mmRemoveAccess.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.RemoveAccess method")
	}

	if len(mmRemoveAccess.expectations) > 0 {
		mmRemoveAccess.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.RemoveAccess method")
	}

	mmRemoveAccess.mock.funcRemoveAccess = f
	mmRemoveAccess.mock.funcRemoveAccessOrigin = minimock.CallerInfo(1)
	return mmRemoveAccess.mock
}

// When sets expectation for the PartitionServiceHandler.RemoveAccess which will trigger the result defined by the following
// Then helper
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) When(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) *PartitionServiceHandlerMockRemoveAccessExpectation {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccess mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockRemoveAccessExpectation{
		mock:               mmRemoveAccess.mock,
		params:             &PartitionServiceHandlerMockRemoveAccessParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockRemoveAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveAccess.expectations = append(mmRemoveAccess.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.RemoveAccess return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockRemoveAccessExpectation) Then(pp2 *connect.Response[v1.RemoveAccessResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockRemoveAccessResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.RemoveAccess should be invoked
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Times(n uint64) *mPartitionServiceHandlerMockRemoveAccess {
	if n == 0 {
		mmRemoveAccess.mock.t.Fatalf("Times of PartitionServiceHandlerMock.RemoveAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveAccess.expectedInvocations, n)
	mmRemoveAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveAccess
}

func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) invocationsDone() bool {
	if len(mmRemoveAccess.expectations) == 0 && mmRemoveAccess.defaultExpectation == nil && mmRemoveAccess.mock.funcRemoveAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveAccess.mock.afterRemoveAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveAccess implements mm_partitionv1connect.PartitionServiceHandler
func (mmRemoveAccess *PartitionServiceHandlerMock) RemoveAccess(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) (pp2 *connect.Response[v1.RemoveAccessResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAccess.beforeRemoveAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAccess.afterRemoveAccessCounter, 1)

	mmRemoveAccess.t.Helper()

	if mmRemoveAccess.inspectFuncRemoveAccess != nil {
		mmRemoveAccess.inspectFuncRemoveAccess(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockRemoveAccessParams{ctx, pp1}

	// Record call args
	mmRemoveAccess.RemoveAccessMock.mutex.Lock()
	mmRemoveAccess.RemoveAccessMock.callArgs = append(mmRemoveAccess.RemoveAccessMock.callArgs, &mm_params)
	mmRemoveAccess.RemoveAccessMock.mutex.Unlock()

	for _, e := range mmRemoveAccess.RemoveAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAccess.RemoveAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAccess.RemoveAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAccess.RemoveAccessMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveAccess.RemoveAccessMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockRemoveAccessParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveAccess.t.Errorf("PartitionServiceHandlerMock.RemoveAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccess.RemoveAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveAccess.t.Errorf("PartitionServiceHandlerMock.RemoveAccess got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccess.RemoveAccessMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAccess.t.Errorf("PartitionServiceHandlerMock.RemoveAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveAccess.RemoveAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAccess.RemoveAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAccess.t.Fatal("No results are set for the PartitionServiceHandlerMock.RemoveAccess")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAccess.funcRemoveAccess != nil {
		return mmRemoveAccess.funcRemoveAccess(ctx, pp1)
	}
	mmRemoveAccess.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.RemoveAccess. %v %v", ctx, pp1)
	return
}

// RemoveAccessAfterCounter returns a count of finished PartitionServiceHandlerMock.RemoveAccess invocations
func (mmRemoveAccess *PartitionServiceHandlerMock) RemoveAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccess.afterRemoveAccessCounter)
}

// RemoveAccessBeforeCounter returns a count of PartitionServiceHandlerMock.RemoveAccess invocations
func (mmRemoveAccess *PartitionServiceHandlerMock) RemoveAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccess.beforeRemoveAccessCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.RemoveAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAccess *mPartitionServiceHandlerMockRemoveAccess) Calls() []*PartitionServiceHandlerMockRemoveAccessParams {
	mmRemoveAccess.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockRemoveAccessParams, len(mmRemoveAccess.callArgs))
	copy(argCopy, mmRemoveAccess.callArgs)

	mmRemoveAccess.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAccessDone returns true if the count of the RemoveAccess invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockRemoveAccessDone() bool {
	if m.RemoveAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveAccessMock.invocationsDone()
}

// MinimockRemoveAccessInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockRemoveAccessInspect() {
	for _, e := range m.RemoveAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveAccessCounter := mm_atomic.LoadUint64(&m.afterRemoveAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAccessMock.defaultExpectation != nil && afterRemoveAccessCounter < 1 {
		if m.RemoveAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccess at\n%s", m.RemoveAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccess at\n%s with params: %#v", m.RemoveAccessMock.defaultExpectation.expectationOrigins.origin, *m.RemoveAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAccess != nil && afterRemoveAccessCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccess at\n%s", m.funcRemoveAccessOrigin)
	}

	if !m.RemoveAccessMock.invocationsDone() && afterRemoveAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.RemoveAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveAccessMock.expectedInvocations), m.RemoveAccessMock.expectedInvocationsOrigin, afterRemoveAccessCounter)
	}
}

type mPartitionServiceHandlerMockRemoveAccessRole struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockRemoveAccessRoleExpectation
	expectations       []*PartitionServiceHandlerMockRemoveAccessRoleExpectation

	callArgs []*PartitionServiceHandlerMockRemoveAccessRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockRemoveAccessRoleExpectation specifies expectation struct of the PartitionServiceHandler.RemoveAccessRole
type PartitionServiceHandlerMockRemoveAccessRoleExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockRemoveAccessRoleParams
	paramPtrs          *PartitionServiceHandlerMockRemoveAccessRoleParamPtrs
	expectationOrigins PartitionServiceHandlerMockRemoveAccessRoleExpectationOrigins
	results            *PartitionServiceHandlerMockRemoveAccessRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockRemoveAccessRoleParams contains parameters of the PartitionServiceHandler.RemoveAccessRole
type PartitionServiceHandlerMockRemoveAccessRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveAccessRoleRequest]
}

// PartitionServiceHandlerMockRemoveAccessRoleParamPtrs contains pointers to parameters of the PartitionServiceHandler.RemoveAccessRole
type PartitionServiceHandlerMockRemoveAccessRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveAccessRoleRequest]
}

// PartitionServiceHandlerMockRemoveAccessRoleResults contains results of the PartitionServiceHandler.RemoveAccessRole
type PartitionServiceHandlerMockRemoveAccessRoleResults struct {
	pp2 *connect.Response[v1.RemoveAccessRoleResponse]
	err error
}

// PartitionServiceHandlerMockRemoveAccessRoleOrigins contains origins of expectations of the PartitionServiceHandler.RemoveAccessRole
type PartitionServiceHandlerMockRemoveAccessRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Optional() *mPartitionServiceHandlerMockRemoveAccessRole {
	mmRemoveAccessRole.optional = true
	return mmRemoveAccessRole
}

// Expect sets up expected params for PartitionServiceHandler.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) *mPartitionServiceHandlerMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessRoleExpectation{}
	}

	if mmRemoveAccessRole.defaultExpectation.paramPtrs != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by ExpectParams functions")
	}

	mmRemoveAccessRole.defaultExpectation.params = &PartitionServiceHandlerMockRemoveAccessRoleParams{ctx, pp1}
	mmRemoveAccessRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveAccessRole.expectations {
		if minimock.Equal(e.params, mmRemoveAccessRole.defaultExpectation.params) {
			mmRemoveAccessRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAccessRole.defaultExpectation.params)
		}
	}

	return mmRemoveAccessRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessRoleExpectation{}
	}

	if mmRemoveAccessRole.defaultExpectation.params != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Expect")
	}

	if mmRemoveAccessRole.defaultExpectation.paramPtrs == nil {
		mmRemoveAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemoveAccessRoleParamPtrs{}
	}
	mmRemoveAccessRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveAccessRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveAccessRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveAccessRoleRequest]) *mPartitionServiceHandlerMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessRoleExpectation{}
	}

	if mmRemoveAccessRole.defaultExpectation.params != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Expect")
	}

	if mmRemoveAccessRole.defaultExpectation.paramPtrs == nil {
		mmRemoveAccessRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemoveAccessRoleParamPtrs{}
	}
	mmRemoveAccessRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveAccessRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveAccessRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest])) *mPartitionServiceHandlerMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.inspectFuncRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.RemoveAccessRole")
	}

	mmRemoveAccessRole.mock.inspectFuncRemoveAccessRole = f

	return mmRemoveAccessRole
}

// Return sets up results that will be returned by PartitionServiceHandler.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Return(pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error) *PartitionServiceHandlerMock {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceHandlerMockRemoveAccessRoleExpectation{mock: mmRemoveAccessRole.mock}
	}
	mmRemoveAccessRole.defaultExpectation.results = &PartitionServiceHandlerMockRemoveAccessRoleResults{pp2, err}
	mmRemoveAccessRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveAccessRole.mock
}

// Set uses given function f to mock the PartitionServiceHandler.RemoveAccessRole method
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) (pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error)) *PartitionServiceHandlerMock {
	if mmRemoveAccessRole.defaultExpectation != nil {
		mmRemoveAccessRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.RemoveAccessRole method")
	}

	if len(mmRemoveAccessRole.expectations) > 0 {
		mmRemoveAccessRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.RemoveAccessRole method")
	}

	mmRemoveAccessRole.mock.funcRemoveAccessRole = f
	mmRemoveAccessRole.mock.funcRemoveAccessRoleOrigin = minimock.CallerInfo(1)
	return mmRemoveAccessRole.mock
}

// When sets expectation for the PartitionServiceHandler.RemoveAccessRole which will trigger the result defined by the following
// Then helper
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) When(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) *PartitionServiceHandlerMockRemoveAccessRoleExpectation {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemoveAccessRole mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockRemoveAccessRoleExpectation{
		mock:               mmRemoveAccessRole.mock,
		params:             &PartitionServiceHandlerMockRemoveAccessRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockRemoveAccessRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveAccessRole.expectations = append(mmRemoveAccessRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.RemoveAccessRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockRemoveAccessRoleExpectation) Then(pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockRemoveAccessRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.RemoveAccessRole should be invoked
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Times(n uint64) *mPartitionServiceHandlerMockRemoveAccessRole {
	if n == 0 {
		mmRemoveAccessRole.mock.t.Fatalf("Times of PartitionServiceHandlerMock.RemoveAccessRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveAccessRole.expectedInvocations, n)
	mmRemoveAccessRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveAccessRole
}

func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) invocationsDone() bool {
	if len(mmRemoveAccessRole.expectations) == 0 && mmRemoveAccessRole.defaultExpectation == nil && mmRemoveAccessRole.mock.funcRemoveAccessRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveAccessRole.mock.afterRemoveAccessRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveAccessRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveAccessRole implements mm_partitionv1connect.PartitionServiceHandler
func (mmRemoveAccessRole *PartitionServiceHandlerMock) RemoveAccessRole(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) (pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAccessRole.beforeRemoveAccessRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAccessRole.afterRemoveAccessRoleCounter, 1)

	mmRemoveAccessRole.t.Helper()

	if mmRemoveAccessRole.inspectFuncRemoveAccessRole != nil {
		mmRemoveAccessRole.inspectFuncRemoveAccessRole(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockRemoveAccessRoleParams{ctx, pp1}

	// Record call args
	mmRemoveAccessRole.RemoveAccessRoleMock.mutex.Lock()
	mmRemoveAccessRole.RemoveAccessRoleMock.callArgs = append(mmRemoveAccessRole.RemoveAccessRoleMock.callArgs, &mm_params)
	mmRemoveAccessRole.RemoveAccessRoleMock.mutex.Unlock()

	for _, e := range mmRemoveAccessRole.RemoveAccessRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockRemoveAccessRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveAccessRole.t.Errorf("PartitionServiceHandlerMock.RemoveAccessRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveAccessRole.t.Errorf("PartitionServiceHandlerMock.RemoveAccessRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAccessRole.t.Errorf("PartitionServiceHandlerMock.RemoveAccessRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAccessRole.t.Fatal("No results are set for the PartitionServiceHandlerMock.RemoveAccessRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAccessRole.funcRemoveAccessRole != nil {
		return mmRemoveAccessRole.funcRemoveAccessRole(ctx, pp1)
	}
	mmRemoveAccessRole.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.RemoveAccessRole. %v %v", ctx, pp1)
	return
}

// RemoveAccessRoleAfterCounter returns a count of finished PartitionServiceHandlerMock.RemoveAccessRole invocations
func (mmRemoveAccessRole *PartitionServiceHandlerMock) RemoveAccessRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccessRole.afterRemoveAccessRoleCounter)
}

// RemoveAccessRoleBeforeCounter returns a count of PartitionServiceHandlerMock.RemoveAccessRole invocations
func (mmRemoveAccessRole *PartitionServiceHandlerMock) RemoveAccessRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccessRole.beforeRemoveAccessRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.RemoveAccessRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAccessRole *mPartitionServiceHandlerMockRemoveAccessRole) Calls() []*PartitionServiceHandlerMockRemoveAccessRoleParams {
	mmRemoveAccessRole.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockRemoveAccessRoleParams, len(mmRemoveAccessRole.callArgs))
	copy(argCopy, mmRemoveAccessRole.callArgs)

	mmRemoveAccessRole.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAccessRoleDone returns true if the count of the RemoveAccessRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockRemoveAccessRoleDone() bool {
	if m.RemoveAccessRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveAccessRoleMock.invocationsDone()
}

// MinimockRemoveAccessRoleInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockRemoveAccessRoleInspect() {
	for _, e := range m.RemoveAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccessRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveAccessRoleCounter := mm_atomic.LoadUint64(&m.afterRemoveAccessRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAccessRoleMock.defaultExpectation != nil && afterRemoveAccessRoleCounter < 1 {
		if m.RemoveAccessRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccessRole at\n%s", m.RemoveAccessRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccessRole at\n%s with params: %#v", m.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.origin, *m.RemoveAccessRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAccessRole != nil && afterRemoveAccessRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemoveAccessRole at\n%s", m.funcRemoveAccessRoleOrigin)
	}

	if !m.RemoveAccessRoleMock.invocationsDone() && afterRemoveAccessRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.RemoveAccessRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveAccessRoleMock.expectedInvocations), m.RemoveAccessRoleMock.expectedInvocationsOrigin, afterRemoveAccessRoleCounter)
	}
}

type mPartitionServiceHandlerMockRemovePage struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockRemovePageExpectation
	expectations       []*PartitionServiceHandlerMockRemovePageExpectation

	callArgs []*PartitionServiceHandlerMockRemovePageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockRemovePageExpectation specifies expectation struct of the PartitionServiceHandler.RemovePage
type PartitionServiceHandlerMockRemovePageExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockRemovePageParams
	paramPtrs          *PartitionServiceHandlerMockRemovePageParamPtrs
	expectationOrigins PartitionServiceHandlerMockRemovePageExpectationOrigins
	results            *PartitionServiceHandlerMockRemovePageResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockRemovePageParams contains parameters of the PartitionServiceHandler.RemovePage
type PartitionServiceHandlerMockRemovePageParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemovePageRequest]
}

// PartitionServiceHandlerMockRemovePageParamPtrs contains pointers to parameters of the PartitionServiceHandler.RemovePage
type PartitionServiceHandlerMockRemovePageParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemovePageRequest]
}

// PartitionServiceHandlerMockRemovePageResults contains results of the PartitionServiceHandler.RemovePage
type PartitionServiceHandlerMockRemovePageResults struct {
	pp2 *connect.Response[v1.RemovePageResponse]
	err error
}

// PartitionServiceHandlerMockRemovePageOrigins contains origins of expectations of the PartitionServiceHandler.RemovePage
type PartitionServiceHandlerMockRemovePageExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Optional() *mPartitionServiceHandlerMockRemovePage {
	mmRemovePage.optional = true
	return mmRemovePage
}

// Expect sets up expected params for PartitionServiceHandler.RemovePage
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Expect(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) *mPartitionServiceHandlerMockRemovePage {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceHandlerMockRemovePageExpectation{}
	}

	if mmRemovePage.defaultExpectation.paramPtrs != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by ExpectParams functions")
	}

	mmRemovePage.defaultExpectation.params = &PartitionServiceHandlerMockRemovePageParams{ctx, pp1}
	mmRemovePage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemovePage.expectations {
		if minimock.Equal(e.params, mmRemovePage.defaultExpectation.params) {
			mmRemovePage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemovePage.defaultExpectation.params)
		}
	}

	return mmRemovePage
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.RemovePage
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockRemovePage {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceHandlerMockRemovePageExpectation{}
	}

	if mmRemovePage.defaultExpectation.params != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Expect")
	}

	if mmRemovePage.defaultExpectation.paramPtrs == nil {
		mmRemovePage.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemovePageParamPtrs{}
	}
	mmRemovePage.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemovePage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemovePage
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.RemovePage
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) ExpectPp1Param2(pp1 *connect.Request[v1.RemovePageRequest]) *mPartitionServiceHandlerMockRemovePage {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceHandlerMockRemovePageExpectation{}
	}

	if mmRemovePage.defaultExpectation.params != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Expect")
	}

	if mmRemovePage.defaultExpectation.paramPtrs == nil {
		mmRemovePage.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemovePageParamPtrs{}
	}
	mmRemovePage.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemovePage.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemovePage
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.RemovePage
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest])) *mPartitionServiceHandlerMockRemovePage {
	if mmRemovePage.mock.inspectFuncRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.RemovePage")
	}

	mmRemovePage.mock.inspectFuncRemovePage = f

	return mmRemovePage
}

// Return sets up results that will be returned by PartitionServiceHandler.RemovePage
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Return(pp2 *connect.Response[v1.RemovePageResponse], err error) *PartitionServiceHandlerMock {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceHandlerMockRemovePageExpectation{mock: mmRemovePage.mock}
	}
	mmRemovePage.defaultExpectation.results = &PartitionServiceHandlerMockRemovePageResults{pp2, err}
	mmRemovePage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemovePage.mock
}

// Set uses given function f to mock the PartitionServiceHandler.RemovePage method
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) (pp2 *connect.Response[v1.RemovePageResponse], err error)) *PartitionServiceHandlerMock {
	if mmRemovePage.defaultExpectation != nil {
		mmRemovePage.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.RemovePage method")
	}

	if len(mmRemovePage.expectations) > 0 {
		mmRemovePage.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.RemovePage method")
	}

	mmRemovePage.mock.funcRemovePage = f
	mmRemovePage.mock.funcRemovePageOrigin = minimock.CallerInfo(1)
	return mmRemovePage.mock
}

// When sets expectation for the PartitionServiceHandler.RemovePage which will trigger the result defined by the following
// Then helper
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) When(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) *PartitionServiceHandlerMockRemovePageExpectation {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePage mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockRemovePageExpectation{
		mock:               mmRemovePage.mock,
		params:             &PartitionServiceHandlerMockRemovePageParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockRemovePageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemovePage.expectations = append(mmRemovePage.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.RemovePage return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockRemovePageExpectation) Then(pp2 *connect.Response[v1.RemovePageResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockRemovePageResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.RemovePage should be invoked
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Times(n uint64) *mPartitionServiceHandlerMockRemovePage {
	if n == 0 {
		mmRemovePage.mock.t.Fatalf("Times of PartitionServiceHandlerMock.RemovePage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemovePage.expectedInvocations, n)
	mmRemovePage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemovePage
}

func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) invocationsDone() bool {
	if len(mmRemovePage.expectations) == 0 && mmRemovePage.defaultExpectation == nil && mmRemovePage.mock.funcRemovePage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemovePage.mock.afterRemovePageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemovePage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemovePage implements mm_partitionv1connect.PartitionServiceHandler
func (mmRemovePage *PartitionServiceHandlerMock) RemovePage(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) (pp2 *connect.Response[v1.RemovePageResponse], err error) {
	mm_atomic.AddUint64(&mmRemovePage.beforeRemovePageCounter, 1)
	defer mm_atomic.AddUint64(&mmRemovePage.afterRemovePageCounter, 1)

	mmRemovePage.t.Helper()

	if mmRemovePage.inspectFuncRemovePage != nil {
		mmRemovePage.inspectFuncRemovePage(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockRemovePageParams{ctx, pp1}

	// Record call args
	mmRemovePage.RemovePageMock.mutex.Lock()
	mmRemovePage.RemovePageMock.callArgs = append(mmRemovePage.RemovePageMock.callArgs, &mm_params)
	mmRemovePage.RemovePageMock.mutex.Unlock()

	for _, e := range mmRemovePage.RemovePageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemovePage.RemovePageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemovePage.RemovePageMock.defaultExpectation.Counter, 1)
		mm_want := mmRemovePage.RemovePageMock.defaultExpectation.params
		mm_want_ptrs := mmRemovePage.RemovePageMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockRemovePageParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemovePage.t.Errorf("PartitionServiceHandlerMock.RemovePage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePage.RemovePageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemovePage.t.Errorf("PartitionServiceHandlerMock.RemovePage got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePage.RemovePageMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemovePage.t.Errorf("PartitionServiceHandlerMock.RemovePage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemovePage.RemovePageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemovePage.RemovePageMock.defaultExpectation.results
		if mm_results == nil {
			mmRemovePage.t.Fatal("No results are set for the PartitionServiceHandlerMock.RemovePage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemovePage.funcRemovePage != nil {
		return mmRemovePage.funcRemovePage(ctx, pp1)
	}
	mmRemovePage.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.RemovePage. %v %v", ctx, pp1)
	return
}

// RemovePageAfterCounter returns a count of finished PartitionServiceHandlerMock.RemovePage invocations
func (mmRemovePage *PartitionServiceHandlerMock) RemovePageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePage.afterRemovePageCounter)
}

// RemovePageBeforeCounter returns a count of PartitionServiceHandlerMock.RemovePage invocations
func (mmRemovePage *PartitionServiceHandlerMock) RemovePageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePage.beforeRemovePageCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.RemovePage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemovePage *mPartitionServiceHandlerMockRemovePage) Calls() []*PartitionServiceHandlerMockRemovePageParams {
	mmRemovePage.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockRemovePageParams, len(mmRemovePage.callArgs))
	copy(argCopy, mmRemovePage.callArgs)

	mmRemovePage.mutex.RUnlock()

	return argCopy
}

// MinimockRemovePageDone returns true if the count of the RemovePage invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockRemovePageDone() bool {
	if m.RemovePageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemovePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemovePageMock.invocationsDone()
}

// MinimockRemovePageInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockRemovePageInspect() {
	for _, e := range m.RemovePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemovePageCounter := mm_atomic.LoadUint64(&m.afterRemovePageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemovePageMock.defaultExpectation != nil && afterRemovePageCounter < 1 {
		if m.RemovePageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePage at\n%s", m.RemovePageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePage at\n%s with params: %#v", m.RemovePageMock.defaultExpectation.expectationOrigins.origin, *m.RemovePageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemovePage != nil && afterRemovePageCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePage at\n%s", m.funcRemovePageOrigin)
	}

	if !m.RemovePageMock.invocationsDone() && afterRemovePageCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.RemovePage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemovePageMock.expectedInvocations), m.RemovePageMock.expectedInvocationsOrigin, afterRemovePageCounter)
	}
}

type mPartitionServiceHandlerMockRemovePartitionRole struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockRemovePartitionRoleExpectation
	expectations       []*PartitionServiceHandlerMockRemovePartitionRoleExpectation

	callArgs []*PartitionServiceHandlerMockRemovePartitionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockRemovePartitionRoleExpectation specifies expectation struct of the PartitionServiceHandler.RemovePartitionRole
type PartitionServiceHandlerMockRemovePartitionRoleExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockRemovePartitionRoleParams
	paramPtrs          *PartitionServiceHandlerMockRemovePartitionRoleParamPtrs
	expectationOrigins PartitionServiceHandlerMockRemovePartitionRoleExpectationOrigins
	results            *PartitionServiceHandlerMockRemovePartitionRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockRemovePartitionRoleParams contains parameters of the PartitionServiceHandler.RemovePartitionRole
type PartitionServiceHandlerMockRemovePartitionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemovePartitionRoleRequest]
}

// PartitionServiceHandlerMockRemovePartitionRoleParamPtrs contains pointers to parameters of the PartitionServiceHandler.RemovePartitionRole
type PartitionServiceHandlerMockRemovePartitionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemovePartitionRoleRequest]
}

// PartitionServiceHandlerMockRemovePartitionRoleResults contains results of the PartitionServiceHandler.RemovePartitionRole
type PartitionServiceHandlerMockRemovePartitionRoleResults struct {
	pp2 *connect.Response[v1.RemovePartitionRoleResponse]
	err error
}

// PartitionServiceHandlerMockRemovePartitionRoleOrigins contains origins of expectations of the PartitionServiceHandler.RemovePartitionRole
type PartitionServiceHandlerMockRemovePartitionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Optional() *mPartitionServiceHandlerMockRemovePartitionRole {
	mmRemovePartitionRole.optional = true
	return mmRemovePartitionRole
}

// Expect sets up expected params for PartitionServiceHandler.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) *mPartitionServiceHandlerMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceHandlerMockRemovePartitionRoleExpectation{}
	}

	if mmRemovePartitionRole.defaultExpectation.paramPtrs != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by ExpectParams functions")
	}

	mmRemovePartitionRole.defaultExpectation.params = &PartitionServiceHandlerMockRemovePartitionRoleParams{ctx, pp1}
	mmRemovePartitionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemovePartitionRole.expectations {
		if minimock.Equal(e.params, mmRemovePartitionRole.defaultExpectation.params) {
			mmRemovePartitionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemovePartitionRole.defaultExpectation.params)
		}
	}

	return mmRemovePartitionRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceHandlerMockRemovePartitionRoleExpectation{}
	}

	if mmRemovePartitionRole.defaultExpectation.params != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Expect")
	}

	if mmRemovePartitionRole.defaultExpectation.paramPtrs == nil {
		mmRemovePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemovePartitionRoleParamPtrs{}
	}
	mmRemovePartitionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemovePartitionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemovePartitionRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) ExpectPp1Param2(pp1 *connect.Request[v1.RemovePartitionRoleRequest]) *mPartitionServiceHandlerMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceHandlerMockRemovePartitionRoleExpectation{}
	}

	if mmRemovePartitionRole.defaultExpectation.params != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Expect")
	}

	if mmRemovePartitionRole.defaultExpectation.paramPtrs == nil {
		mmRemovePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockRemovePartitionRoleParamPtrs{}
	}
	mmRemovePartitionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemovePartitionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemovePartitionRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest])) *mPartitionServiceHandlerMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.inspectFuncRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.RemovePartitionRole")
	}

	mmRemovePartitionRole.mock.inspectFuncRemovePartitionRole = f

	return mmRemovePartitionRole
}

// Return sets up results that will be returned by PartitionServiceHandler.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Return(pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error) *PartitionServiceHandlerMock {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceHandlerMockRemovePartitionRoleExpectation{mock: mmRemovePartitionRole.mock}
	}
	mmRemovePartitionRole.defaultExpectation.results = &PartitionServiceHandlerMockRemovePartitionRoleResults{pp2, err}
	mmRemovePartitionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemovePartitionRole.mock
}

// Set uses given function f to mock the PartitionServiceHandler.RemovePartitionRole method
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) (pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error)) *PartitionServiceHandlerMock {
	if mmRemovePartitionRole.defaultExpectation != nil {
		mmRemovePartitionRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.RemovePartitionRole method")
	}

	if len(mmRemovePartitionRole.expectations) > 0 {
		mmRemovePartitionRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.RemovePartitionRole method")
	}

	mmRemovePartitionRole.mock.funcRemovePartitionRole = f
	mmRemovePartitionRole.mock.funcRemovePartitionRoleOrigin = minimock.CallerInfo(1)
	return mmRemovePartitionRole.mock
}

// When sets expectation for the PartitionServiceHandler.RemovePartitionRole which will trigger the result defined by the following
// Then helper
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) When(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) *PartitionServiceHandlerMockRemovePartitionRoleExpectation {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceHandlerMock.RemovePartitionRole mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockRemovePartitionRoleExpectation{
		mock:               mmRemovePartitionRole.mock,
		params:             &PartitionServiceHandlerMockRemovePartitionRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockRemovePartitionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemovePartitionRole.expectations = append(mmRemovePartitionRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.RemovePartitionRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockRemovePartitionRoleExpectation) Then(pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockRemovePartitionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.RemovePartitionRole should be invoked
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Times(n uint64) *mPartitionServiceHandlerMockRemovePartitionRole {
	if n == 0 {
		mmRemovePartitionRole.mock.t.Fatalf("Times of PartitionServiceHandlerMock.RemovePartitionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemovePartitionRole.expectedInvocations, n)
	mmRemovePartitionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemovePartitionRole
}

func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) invocationsDone() bool {
	if len(mmRemovePartitionRole.expectations) == 0 && mmRemovePartitionRole.defaultExpectation == nil && mmRemovePartitionRole.mock.funcRemovePartitionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemovePartitionRole.mock.afterRemovePartitionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemovePartitionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemovePartitionRole implements mm_partitionv1connect.PartitionServiceHandler
func (mmRemovePartitionRole *PartitionServiceHandlerMock) RemovePartitionRole(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) (pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmRemovePartitionRole.beforeRemovePartitionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmRemovePartitionRole.afterRemovePartitionRoleCounter, 1)

	mmRemovePartitionRole.t.Helper()

	if mmRemovePartitionRole.inspectFuncRemovePartitionRole != nil {
		mmRemovePartitionRole.inspectFuncRemovePartitionRole(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockRemovePartitionRoleParams{ctx, pp1}

	// Record call args
	mmRemovePartitionRole.RemovePartitionRoleMock.mutex.Lock()
	mmRemovePartitionRole.RemovePartitionRoleMock.callArgs = append(mmRemovePartitionRole.RemovePartitionRoleMock.callArgs, &mm_params)
	mmRemovePartitionRole.RemovePartitionRoleMock.mutex.Unlock()

	for _, e := range mmRemovePartitionRole.RemovePartitionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockRemovePartitionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemovePartitionRole.t.Errorf("PartitionServiceHandlerMock.RemovePartitionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemovePartitionRole.t.Errorf("PartitionServiceHandlerMock.RemovePartitionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemovePartitionRole.t.Errorf("PartitionServiceHandlerMock.RemovePartitionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmRemovePartitionRole.t.Fatal("No results are set for the PartitionServiceHandlerMock.RemovePartitionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemovePartitionRole.funcRemovePartitionRole != nil {
		return mmRemovePartitionRole.funcRemovePartitionRole(ctx, pp1)
	}
	mmRemovePartitionRole.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.RemovePartitionRole. %v %v", ctx, pp1)
	return
}

// RemovePartitionRoleAfterCounter returns a count of finished PartitionServiceHandlerMock.RemovePartitionRole invocations
func (mmRemovePartitionRole *PartitionServiceHandlerMock) RemovePartitionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePartitionRole.afterRemovePartitionRoleCounter)
}

// RemovePartitionRoleBeforeCounter returns a count of PartitionServiceHandlerMock.RemovePartitionRole invocations
func (mmRemovePartitionRole *PartitionServiceHandlerMock) RemovePartitionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePartitionRole.beforeRemovePartitionRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.RemovePartitionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemovePartitionRole *mPartitionServiceHandlerMockRemovePartitionRole) Calls() []*PartitionServiceHandlerMockRemovePartitionRoleParams {
	mmRemovePartitionRole.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockRemovePartitionRoleParams, len(mmRemovePartitionRole.callArgs))
	copy(argCopy, mmRemovePartitionRole.callArgs)

	mmRemovePartitionRole.mutex.RUnlock()

	return argCopy
}

// MinimockRemovePartitionRoleDone returns true if the count of the RemovePartitionRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockRemovePartitionRoleDone() bool {
	if m.RemovePartitionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemovePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemovePartitionRoleMock.invocationsDone()
}

// MinimockRemovePartitionRoleInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockRemovePartitionRoleInspect() {
	for _, e := range m.RemovePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePartitionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemovePartitionRoleCounter := mm_atomic.LoadUint64(&m.afterRemovePartitionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemovePartitionRoleMock.defaultExpectation != nil && afterRemovePartitionRoleCounter < 1 {
		if m.RemovePartitionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePartitionRole at\n%s", m.RemovePartitionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePartitionRole at\n%s with params: %#v", m.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *m.RemovePartitionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemovePartitionRole != nil && afterRemovePartitionRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.RemovePartitionRole at\n%s", m.funcRemovePartitionRoleOrigin)
	}

	if !m.RemovePartitionRoleMock.invocationsDone() && afterRemovePartitionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.RemovePartitionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemovePartitionRoleMock.expectedInvocations), m.RemovePartitionRoleMock.expectedInvocationsOrigin, afterRemovePartitionRoleCounter)
	}
}

type mPartitionServiceHandlerMockUpdatePartition struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockUpdatePartitionExpectation
	expectations       []*PartitionServiceHandlerMockUpdatePartitionExpectation

	callArgs []*PartitionServiceHandlerMockUpdatePartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockUpdatePartitionExpectation specifies expectation struct of the PartitionServiceHandler.UpdatePartition
type PartitionServiceHandlerMockUpdatePartitionExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockUpdatePartitionParams
	paramPtrs          *PartitionServiceHandlerMockUpdatePartitionParamPtrs
	expectationOrigins PartitionServiceHandlerMockUpdatePartitionExpectationOrigins
	results            *PartitionServiceHandlerMockUpdatePartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockUpdatePartitionParams contains parameters of the PartitionServiceHandler.UpdatePartition
type PartitionServiceHandlerMockUpdatePartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdatePartitionRequest]
}

// PartitionServiceHandlerMockUpdatePartitionParamPtrs contains pointers to parameters of the PartitionServiceHandler.UpdatePartition
type PartitionServiceHandlerMockUpdatePartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdatePartitionRequest]
}

// PartitionServiceHandlerMockUpdatePartitionResults contains results of the PartitionServiceHandler.UpdatePartition
type PartitionServiceHandlerMockUpdatePartitionResults struct {
	pp2 *connect.Response[v1.UpdatePartitionResponse]
	err error
}

// PartitionServiceHandlerMockUpdatePartitionOrigins contains origins of expectations of the PartitionServiceHandler.UpdatePartition
type PartitionServiceHandlerMockUpdatePartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Optional() *mPartitionServiceHandlerMockUpdatePartition {
	mmUpdatePartition.optional = true
	return mmUpdatePartition
}

// Expect sets up expected params for PartitionServiceHandler.UpdatePartition
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) *mPartitionServiceHandlerMockUpdatePartition {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceHandlerMockUpdatePartitionExpectation{}
	}

	if mmUpdatePartition.defaultExpectation.paramPtrs != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by ExpectParams functions")
	}

	mmUpdatePartition.defaultExpectation.params = &PartitionServiceHandlerMockUpdatePartitionParams{ctx, pp1}
	mmUpdatePartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePartition.expectations {
		if minimock.Equal(e.params, mmUpdatePartition.defaultExpectation.params) {
			mmUpdatePartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePartition.defaultExpectation.params)
		}
	}

	return mmUpdatePartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.UpdatePartition
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockUpdatePartition {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceHandlerMockUpdatePartitionExpectation{}
	}

	if mmUpdatePartition.defaultExpectation.params != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Expect")
	}

	if mmUpdatePartition.defaultExpectation.paramPtrs == nil {
		mmUpdatePartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockUpdatePartitionParamPtrs{}
	}
	mmUpdatePartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.UpdatePartition
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) ExpectPp1Param2(pp1 *connect.Request[v1.UpdatePartitionRequest]) *mPartitionServiceHandlerMockUpdatePartition {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceHandlerMockUpdatePartitionExpectation{}
	}

	if mmUpdatePartition.defaultExpectation.params != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Expect")
	}

	if mmUpdatePartition.defaultExpectation.paramPtrs == nil {
		mmUpdatePartition.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockUpdatePartitionParamPtrs{}
	}
	mmUpdatePartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdatePartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdatePartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.UpdatePartition
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest])) *mPartitionServiceHandlerMockUpdatePartition {
	if mmUpdatePartition.mock.inspectFuncUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.UpdatePartition")
	}

	mmUpdatePartition.mock.inspectFuncUpdatePartition = f

	return mmUpdatePartition
}

// Return sets up results that will be returned by PartitionServiceHandler.UpdatePartition
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Return(pp2 *connect.Response[v1.UpdatePartitionResponse], err error) *PartitionServiceHandlerMock {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceHandlerMockUpdatePartitionExpectation{mock: mmUpdatePartition.mock}
	}
	mmUpdatePartition.defaultExpectation.results = &PartitionServiceHandlerMockUpdatePartitionResults{pp2, err}
	mmUpdatePartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePartition.mock
}

// Set uses given function f to mock the PartitionServiceHandler.UpdatePartition method
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) (pp2 *connect.Response[v1.UpdatePartitionResponse], err error)) *PartitionServiceHandlerMock {
	if mmUpdatePartition.defaultExpectation != nil {
		mmUpdatePartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.UpdatePartition method")
	}

	if len(mmUpdatePartition.expectations) > 0 {
		mmUpdatePartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.UpdatePartition method")
	}

	mmUpdatePartition.mock.funcUpdatePartition = f
	mmUpdatePartition.mock.funcUpdatePartitionOrigin = minimock.CallerInfo(1)
	return mmUpdatePartition.mock
}

// When sets expectation for the PartitionServiceHandler.UpdatePartition which will trigger the result defined by the following
// Then helper
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) When(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) *PartitionServiceHandlerMockUpdatePartitionExpectation {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceHandlerMock.UpdatePartition mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockUpdatePartitionExpectation{
		mock:               mmUpdatePartition.mock,
		params:             &PartitionServiceHandlerMockUpdatePartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockUpdatePartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePartition.expectations = append(mmUpdatePartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.UpdatePartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockUpdatePartitionExpectation) Then(pp2 *connect.Response[v1.UpdatePartitionResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockUpdatePartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.UpdatePartition should be invoked
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Times(n uint64) *mPartitionServiceHandlerMockUpdatePartition {
	if n == 0 {
		mmUpdatePartition.mock.t.Fatalf("Times of PartitionServiceHandlerMock.UpdatePartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePartition.expectedInvocations, n)
	mmUpdatePartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePartition
}

func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) invocationsDone() bool {
	if len(mmUpdatePartition.expectations) == 0 && mmUpdatePartition.defaultExpectation == nil && mmUpdatePartition.mock.funcUpdatePartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePartition.mock.afterUpdatePartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePartition implements mm_partitionv1connect.PartitionServiceHandler
func (mmUpdatePartition *PartitionServiceHandlerMock) UpdatePartition(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) (pp2 *connect.Response[v1.UpdatePartitionResponse], err error) {
	mm_atomic.AddUint64(&mmUpdatePartition.beforeUpdatePartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePartition.afterUpdatePartitionCounter, 1)

	mmUpdatePartition.t.Helper()

	if mmUpdatePartition.inspectFuncUpdatePartition != nil {
		mmUpdatePartition.inspectFuncUpdatePartition(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockUpdatePartitionParams{ctx, pp1}

	// Record call args
	mmUpdatePartition.UpdatePartitionMock.mutex.Lock()
	mmUpdatePartition.UpdatePartitionMock.callArgs = append(mmUpdatePartition.UpdatePartitionMock.callArgs, &mm_params)
	mmUpdatePartition.UpdatePartitionMock.mutex.Unlock()

	for _, e := range mmUpdatePartition.UpdatePartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdatePartition.UpdatePartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePartition.UpdatePartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePartition.UpdatePartitionMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePartition.UpdatePartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockUpdatePartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePartition.t.Errorf("PartitionServiceHandlerMock.UpdatePartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePartition.UpdatePartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdatePartition.t.Errorf("PartitionServiceHandlerMock.UpdatePartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePartition.UpdatePartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePartition.t.Errorf("PartitionServiceHandlerMock.UpdatePartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePartition.UpdatePartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePartition.UpdatePartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePartition.t.Fatal("No results are set for the PartitionServiceHandlerMock.UpdatePartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdatePartition.funcUpdatePartition != nil {
		return mmUpdatePartition.funcUpdatePartition(ctx, pp1)
	}
	mmUpdatePartition.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.UpdatePartition. %v %v", ctx, pp1)
	return
}

// UpdatePartitionAfterCounter returns a count of finished PartitionServiceHandlerMock.UpdatePartition invocations
func (mmUpdatePartition *PartitionServiceHandlerMock) UpdatePartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePartition.afterUpdatePartitionCounter)
}

// UpdatePartitionBeforeCounter returns a count of PartitionServiceHandlerMock.UpdatePartition invocations
func (mmUpdatePartition *PartitionServiceHandlerMock) UpdatePartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePartition.beforeUpdatePartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.UpdatePartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePartition *mPartitionServiceHandlerMockUpdatePartition) Calls() []*PartitionServiceHandlerMockUpdatePartitionParams {
	mmUpdatePartition.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockUpdatePartitionParams, len(mmUpdatePartition.callArgs))
	copy(argCopy, mmUpdatePartition.callArgs)

	mmUpdatePartition.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePartitionDone returns true if the count of the UpdatePartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockUpdatePartitionDone() bool {
	if m.UpdatePartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePartitionMock.invocationsDone()
}

// MinimockUpdatePartitionInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockUpdatePartitionInspect() {
	for _, e := range m.UpdatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdatePartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePartitionCounter := mm_atomic.LoadUint64(&m.afterUpdatePartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePartitionMock.defaultExpectation != nil && afterUpdatePartitionCounter < 1 {
		if m.UpdatePartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdatePartition at\n%s", m.UpdatePartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdatePartition at\n%s with params: %#v", m.UpdatePartitionMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePartition != nil && afterUpdatePartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdatePartition at\n%s", m.funcUpdatePartitionOrigin)
	}

	if !m.UpdatePartitionMock.invocationsDone() && afterUpdatePartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.UpdatePartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePartitionMock.expectedInvocations), m.UpdatePartitionMock.expectedInvocationsOrigin, afterUpdatePartitionCounter)
	}
}

type mPartitionServiceHandlerMockUpdateTenant struct {
	optional           bool
	mock               *PartitionServiceHandlerMock
	defaultExpectation *PartitionServiceHandlerMockUpdateTenantExpectation
	expectations       []*PartitionServiceHandlerMockUpdateTenantExpectation

	callArgs []*PartitionServiceHandlerMockUpdateTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceHandlerMockUpdateTenantExpectation specifies expectation struct of the PartitionServiceHandler.UpdateTenant
type PartitionServiceHandlerMockUpdateTenantExpectation struct {
	mock               *PartitionServiceHandlerMock
	params             *PartitionServiceHandlerMockUpdateTenantParams
	paramPtrs          *PartitionServiceHandlerMockUpdateTenantParamPtrs
	expectationOrigins PartitionServiceHandlerMockUpdateTenantExpectationOrigins
	results            *PartitionServiceHandlerMockUpdateTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceHandlerMockUpdateTenantParams contains parameters of the PartitionServiceHandler.UpdateTenant
type PartitionServiceHandlerMockUpdateTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateTenantRequest]
}

// PartitionServiceHandlerMockUpdateTenantParamPtrs contains pointers to parameters of the PartitionServiceHandler.UpdateTenant
type PartitionServiceHandlerMockUpdateTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateTenantRequest]
}

// PartitionServiceHandlerMockUpdateTenantResults contains results of the PartitionServiceHandler.UpdateTenant
type PartitionServiceHandlerMockUpdateTenantResults struct {
	pp2 *connect.Response[v1.UpdateTenantResponse]
	err error
}

// PartitionServiceHandlerMockUpdateTenantOrigins contains origins of expectations of the PartitionServiceHandler.UpdateTenant
type PartitionServiceHandlerMockUpdateTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Optional() *mPartitionServiceHandlerMockUpdateTenant {
	mmUpdateTenant.optional = true
	return mmUpdateTenant
}

// Expect sets up expected params for PartitionServiceHandler.UpdateTenant
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) *mPartitionServiceHandlerMockUpdateTenant {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceHandlerMockUpdateTenantExpectation{}
	}

	if mmUpdateTenant.defaultExpectation.paramPtrs != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by ExpectParams functions")
	}

	mmUpdateTenant.defaultExpectation.params = &PartitionServiceHandlerMockUpdateTenantParams{ctx, pp1}
	mmUpdateTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTenant.expectations {
		if minimock.Equal(e.params, mmUpdateTenant.defaultExpectation.params) {
			mmUpdateTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTenant.defaultExpectation.params)
		}
	}

	return mmUpdateTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceHandler.UpdateTenant
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceHandlerMockUpdateTenant {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceHandlerMockUpdateTenantExpectation{}
	}

	if mmUpdateTenant.defaultExpectation.params != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Expect")
	}

	if mmUpdateTenant.defaultExpectation.paramPtrs == nil {
		mmUpdateTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockUpdateTenantParamPtrs{}
	}
	mmUpdateTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceHandler.UpdateTenant
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateTenantRequest]) *mPartitionServiceHandlerMockUpdateTenant {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceHandlerMockUpdateTenantExpectation{}
	}

	if mmUpdateTenant.defaultExpectation.params != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Expect")
	}

	if mmUpdateTenant.defaultExpectation.paramPtrs == nil {
		mmUpdateTenant.defaultExpectation.paramPtrs = &PartitionServiceHandlerMockUpdateTenantParamPtrs{}
	}
	mmUpdateTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceHandler.UpdateTenant
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest])) *mPartitionServiceHandlerMockUpdateTenant {
	if mmUpdateTenant.mock.inspectFuncUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceHandlerMock.UpdateTenant")
	}

	mmUpdateTenant.mock.inspectFuncUpdateTenant = f

	return mmUpdateTenant
}

// Return sets up results that will be returned by PartitionServiceHandler.UpdateTenant
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Return(pp2 *connect.Response[v1.UpdateTenantResponse], err error) *PartitionServiceHandlerMock {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceHandlerMockUpdateTenantExpectation{mock: mmUpdateTenant.mock}
	}
	mmUpdateTenant.defaultExpectation.results = &PartitionServiceHandlerMockUpdateTenantResults{pp2, err}
	mmUpdateTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTenant.mock
}

// Set uses given function f to mock the PartitionServiceHandler.UpdateTenant method
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) (pp2 *connect.Response[v1.UpdateTenantResponse], err error)) *PartitionServiceHandlerMock {
	if mmUpdateTenant.defaultExpectation != nil {
		mmUpdateTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceHandler.UpdateTenant method")
	}

	if len(mmUpdateTenant.expectations) > 0 {
		mmUpdateTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceHandler.UpdateTenant method")
	}

	mmUpdateTenant.mock.funcUpdateTenant = f
	mmUpdateTenant.mock.funcUpdateTenantOrigin = minimock.CallerInfo(1)
	return mmUpdateTenant.mock
}

// When sets expectation for the PartitionServiceHandler.UpdateTenant which will trigger the result defined by the following
// Then helper
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) When(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) *PartitionServiceHandlerMockUpdateTenantExpectation {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceHandlerMock.UpdateTenant mock is already set by Set")
	}

	expectation := &PartitionServiceHandlerMockUpdateTenantExpectation{
		mock:               mmUpdateTenant.mock,
		params:             &PartitionServiceHandlerMockUpdateTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceHandlerMockUpdateTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTenant.expectations = append(mmUpdateTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceHandler.UpdateTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceHandlerMockUpdateTenantExpectation) Then(pp2 *connect.Response[v1.UpdateTenantResponse], err error) *PartitionServiceHandlerMock {
	e.results = &PartitionServiceHandlerMockUpdateTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceHandler.UpdateTenant should be invoked
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Times(n uint64) *mPartitionServiceHandlerMockUpdateTenant {
	if n == 0 {
		mmUpdateTenant.mock.t.Fatalf("Times of PartitionServiceHandlerMock.UpdateTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTenant.expectedInvocations, n)
	mmUpdateTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTenant
}

func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) invocationsDone() bool {
	if len(mmUpdateTenant.expectations) == 0 && mmUpdateTenant.defaultExpectation == nil && mmUpdateTenant.mock.funcUpdateTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTenant.mock.afterUpdateTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTenant implements mm_partitionv1connect.PartitionServiceHandler
func (mmUpdateTenant *PartitionServiceHandlerMock) UpdateTenant(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) (pp2 *connect.Response[v1.UpdateTenantResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateTenant.beforeUpdateTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTenant.afterUpdateTenantCounter, 1)

	mmUpdateTenant.t.Helper()

	if mmUpdateTenant.inspectFuncUpdateTenant != nil {
		mmUpdateTenant.inspectFuncUpdateTenant(ctx, pp1)
	}

	mm_params := PartitionServiceHandlerMockUpdateTenantParams{ctx, pp1}

	// Record call args
	mmUpdateTenant.UpdateTenantMock.mutex.Lock()
	mmUpdateTenant.UpdateTenantMock.callArgs = append(mmUpdateTenant.UpdateTenantMock.callArgs, &mm_params)
	mmUpdateTenant.UpdateTenantMock.mutex.Unlock()

	for _, e := range mmUpdateTenant.UpdateTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateTenant.UpdateTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTenant.UpdateTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTenant.UpdateTenantMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTenant.UpdateTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceHandlerMockUpdateTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTenant.t.Errorf("PartitionServiceHandlerMock.UpdateTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTenant.UpdateTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateTenant.t.Errorf("PartitionServiceHandlerMock.UpdateTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTenant.UpdateTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTenant.t.Errorf("PartitionServiceHandlerMock.UpdateTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTenant.UpdateTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTenant.UpdateTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTenant.t.Fatal("No results are set for the PartitionServiceHandlerMock.UpdateTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateTenant.funcUpdateTenant != nil {
		return mmUpdateTenant.funcUpdateTenant(ctx, pp1)
	}
	mmUpdateTenant.t.Fatalf("Unexpected call to PartitionServiceHandlerMock.UpdateTenant. %v %v", ctx, pp1)
	return
}

// UpdateTenantAfterCounter returns a count of finished PartitionServiceHandlerMock.UpdateTenant invocations
func (mmUpdateTenant *PartitionServiceHandlerMock) UpdateTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTenant.afterUpdateTenantCounter)
}

// UpdateTenantBeforeCounter returns a count of PartitionServiceHandlerMock.UpdateTenant invocations
func (mmUpdateTenant *PartitionServiceHandlerMock) UpdateTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTenant.beforeUpdateTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceHandlerMock.UpdateTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTenant *mPartitionServiceHandlerMockUpdateTenant) Calls() []*PartitionServiceHandlerMockUpdateTenantParams {
	mmUpdateTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceHandlerMockUpdateTenantParams, len(mmUpdateTenant.callArgs))
	copy(argCopy, mmUpdateTenant.callArgs)

	mmUpdateTenant.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTenantDone returns true if the count of the UpdateTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceHandlerMock) MinimockUpdateTenantDone() bool {
	if m.UpdateTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTenantMock.invocationsDone()
}

// MinimockUpdateTenantInspect logs each unmet expectation
func (m *PartitionServiceHandlerMock) MinimockUpdateTenantInspect() {
	for _, e := range m.UpdateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdateTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTenantCounter := mm_atomic.LoadUint64(&m.afterUpdateTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTenantMock.defaultExpectation != nil && afterUpdateTenantCounter < 1 {
		if m.UpdateTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdateTenant at\n%s", m.UpdateTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdateTenant at\n%s with params: %#v", m.UpdateTenantMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTenant != nil && afterUpdateTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceHandlerMock.UpdateTenant at\n%s", m.funcUpdateTenantOrigin)
	}

	if !m.UpdateTenantMock.invocationsDone() && afterUpdateTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceHandlerMock.UpdateTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTenantMock.expectedInvocations), m.UpdateTenantMock.expectedInvocationsOrigin, afterUpdateTenantCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PartitionServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAccessInspect()

			m.MinimockCreateAccessRoleInspect()

			m.MinimockCreatePageInspect()

			m.MinimockCreatePartitionInspect()

			m.MinimockCreatePartitionRoleInspect()

			m.MinimockCreateTenantInspect()

			m.MinimockGetAccessInspect()

			m.MinimockGetPageInspect()

			m.MinimockGetPartitionInspect()

			m.MinimockGetPartitionParentsInspect()

			m.MinimockGetTenantInspect()

			m.MinimockListAccessRoleInspect()

			m.MinimockListPartitionInspect()

			m.MinimockListPartitionRoleInspect()

			m.MinimockListTenantInspect()

			m.MinimockRemoveAccessInspect()

			m.MinimockRemoveAccessRoleInspect()

			m.MinimockRemovePageInspect()

			m.MinimockRemovePartitionRoleInspect()

			m.MinimockUpdatePartitionInspect()

			m.MinimockUpdateTenantInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PartitionServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PartitionServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAccessDone() &&
		m.MinimockCreateAccessRoleDone() &&
		m.MinimockCreatePageDone() &&
		m.MinimockCreatePartitionDone() &&
		m.MinimockCreatePartitionRoleDone() &&
		m.MinimockCreateTenantDone() &&
		m.MinimockGetAccessDone() &&
		m.MinimockGetPageDone() &&
		m.MinimockGetPartitionDone() &&
		m.MinimockGetPartitionParentsDone() &&
		m.MinimockGetTenantDone() &&
		m.MinimockListAccessRoleDone() &&
		m.MinimockListPartitionDone() &&
		m.MinimockListPartitionRoleDone() &&
		m.MinimockListTenantDone() &&
		m.MinimockRemoveAccessDone() &&
		m.MinimockRemoveAccessRoleDone() &&
		m.MinimockRemovePageDone() &&
		m.MinimockRemovePartitionRoleDone() &&
		m.MinimockUpdatePartitionDone() &&
		m.MinimockUpdateTenantDone()
}
