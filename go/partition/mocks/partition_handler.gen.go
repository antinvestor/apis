// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/partition/connectrpc/go/partition/v1/partitionv1connect.PartitionServiceClient -o partition_handler.gen.go -n PartitionServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/partition/protocolbuffers/go/partition/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// PartitionServiceClientMock implements mm_partitionv1connect.PartitionServiceClient
type PartitionServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAccess          func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) (pp2 *connect.Response[v1.CreateAccessResponse], err error)
	funcCreateAccessOrigin    string
	inspectFuncCreateAccess   func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest])
	afterCreateAccessCounter  uint64
	beforeCreateAccessCounter uint64
	CreateAccessMock          mPartitionServiceClientMockCreateAccess

	funcCreateAccessRole          func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) (pp2 *connect.Response[v1.CreateAccessRoleResponse], err error)
	funcCreateAccessRoleOrigin    string
	inspectFuncCreateAccessRole   func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest])
	afterCreateAccessRoleCounter  uint64
	beforeCreateAccessRoleCounter uint64
	CreateAccessRoleMock          mPartitionServiceClientMockCreateAccessRole

	funcCreatePage          func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) (pp2 *connect.Response[v1.CreatePageResponse], err error)
	funcCreatePageOrigin    string
	inspectFuncCreatePage   func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest])
	afterCreatePageCounter  uint64
	beforeCreatePageCounter uint64
	CreatePageMock          mPartitionServiceClientMockCreatePage

	funcCreatePartition          func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) (pp2 *connect.Response[v1.CreatePartitionResponse], err error)
	funcCreatePartitionOrigin    string
	inspectFuncCreatePartition   func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest])
	afterCreatePartitionCounter  uint64
	beforeCreatePartitionCounter uint64
	CreatePartitionMock          mPartitionServiceClientMockCreatePartition

	funcCreatePartitionRole          func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) (pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error)
	funcCreatePartitionRoleOrigin    string
	inspectFuncCreatePartitionRole   func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest])
	afterCreatePartitionRoleCounter  uint64
	beforeCreatePartitionRoleCounter uint64
	CreatePartitionRoleMock          mPartitionServiceClientMockCreatePartitionRole

	funcCreateTenant          func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) (pp2 *connect.Response[v1.CreateTenantResponse], err error)
	funcCreateTenantOrigin    string
	inspectFuncCreateTenant   func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest])
	afterCreateTenantCounter  uint64
	beforeCreateTenantCounter uint64
	CreateTenantMock          mPartitionServiceClientMockCreateTenant

	funcGetAccess          func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) (pp2 *connect.Response[v1.GetAccessResponse], err error)
	funcGetAccessOrigin    string
	inspectFuncGetAccess   func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest])
	afterGetAccessCounter  uint64
	beforeGetAccessCounter uint64
	GetAccessMock          mPartitionServiceClientMockGetAccess

	funcGetPage          func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) (pp2 *connect.Response[v1.GetPageResponse], err error)
	funcGetPageOrigin    string
	inspectFuncGetPage   func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest])
	afterGetPageCounter  uint64
	beforeGetPageCounter uint64
	GetPageMock          mPartitionServiceClientMockGetPage

	funcGetPartition          func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) (pp2 *connect.Response[v1.GetPartitionResponse], err error)
	funcGetPartitionOrigin    string
	inspectFuncGetPartition   func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest])
	afterGetPartitionCounter  uint64
	beforeGetPartitionCounter uint64
	GetPartitionMock          mPartitionServiceClientMockGetPartition

	funcGetPartitionParents          func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) (pp2 *connect.Response[v1.GetPartitionParentsResponse], err error)
	funcGetPartitionParentsOrigin    string
	inspectFuncGetPartitionParents   func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest])
	afterGetPartitionParentsCounter  uint64
	beforeGetPartitionParentsCounter uint64
	GetPartitionParentsMock          mPartitionServiceClientMockGetPartitionParents

	funcGetTenant          func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) (pp2 *connect.Response[v1.GetTenantResponse], err error)
	funcGetTenantOrigin    string
	inspectFuncGetTenant   func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest])
	afterGetTenantCounter  uint64
	beforeGetTenantCounter uint64
	GetTenantMock          mPartitionServiceClientMockGetTenant

	funcListAccessRole          func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListAccessRoleResponse], err error)
	funcListAccessRoleOrigin    string
	inspectFuncListAccessRole   func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest])
	afterListAccessRoleCounter  uint64
	beforeListAccessRoleCounter uint64
	ListAccessRoleMock          mPartitionServiceClientMockListAccessRole

	funcListPartition          func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPartitionResponse], err error)
	funcListPartitionOrigin    string
	inspectFuncListPartition   func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest])
	afterListPartitionCounter  uint64
	beforeListPartitionCounter uint64
	ListPartitionMock          mPartitionServiceClientMockListPartition

	funcListPartitionRole          func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPartitionRoleResponse], err error)
	funcListPartitionRoleOrigin    string
	inspectFuncListPartitionRole   func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest])
	afterListPartitionRoleCounter  uint64
	beforeListPartitionRoleCounter uint64
	ListPartitionRoleMock          mPartitionServiceClientMockListPartitionRole

	funcListTenant          func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest]) (pp2 *connect.ServerStreamForClient[v1.ListTenantResponse], err error)
	funcListTenantOrigin    string
	inspectFuncListTenant   func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest])
	afterListTenantCounter  uint64
	beforeListTenantCounter uint64
	ListTenantMock          mPartitionServiceClientMockListTenant

	funcRemoveAccess          func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) (pp2 *connect.Response[v1.RemoveAccessResponse], err error)
	funcRemoveAccessOrigin    string
	inspectFuncRemoveAccess   func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest])
	afterRemoveAccessCounter  uint64
	beforeRemoveAccessCounter uint64
	RemoveAccessMock          mPartitionServiceClientMockRemoveAccess

	funcRemoveAccessRole          func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) (pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error)
	funcRemoveAccessRoleOrigin    string
	inspectFuncRemoveAccessRole   func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest])
	afterRemoveAccessRoleCounter  uint64
	beforeRemoveAccessRoleCounter uint64
	RemoveAccessRoleMock          mPartitionServiceClientMockRemoveAccessRole

	funcRemovePage          func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) (pp2 *connect.Response[v1.RemovePageResponse], err error)
	funcRemovePageOrigin    string
	inspectFuncRemovePage   func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest])
	afterRemovePageCounter  uint64
	beforeRemovePageCounter uint64
	RemovePageMock          mPartitionServiceClientMockRemovePage

	funcRemovePartitionRole          func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) (pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error)
	funcRemovePartitionRoleOrigin    string
	inspectFuncRemovePartitionRole   func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest])
	afterRemovePartitionRoleCounter  uint64
	beforeRemovePartitionRoleCounter uint64
	RemovePartitionRoleMock          mPartitionServiceClientMockRemovePartitionRole

	funcUpdatePartition          func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) (pp2 *connect.Response[v1.UpdatePartitionResponse], err error)
	funcUpdatePartitionOrigin    string
	inspectFuncUpdatePartition   func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest])
	afterUpdatePartitionCounter  uint64
	beforeUpdatePartitionCounter uint64
	UpdatePartitionMock          mPartitionServiceClientMockUpdatePartition

	funcUpdateTenant          func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) (pp2 *connect.Response[v1.UpdateTenantResponse], err error)
	funcUpdateTenantOrigin    string
	inspectFuncUpdateTenant   func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest])
	afterUpdateTenantCounter  uint64
	beforeUpdateTenantCounter uint64
	UpdateTenantMock          mPartitionServiceClientMockUpdateTenant
}

// NewPartitionServiceClientMock returns a mock for mm_partitionv1connect.PartitionServiceClient
func NewPartitionServiceClientMock(t minimock.Tester) *PartitionServiceClientMock {
	m := &PartitionServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAccessMock = mPartitionServiceClientMockCreateAccess{mock: m}
	m.CreateAccessMock.callArgs = []*PartitionServiceClientMockCreateAccessParams{}

	m.CreateAccessRoleMock = mPartitionServiceClientMockCreateAccessRole{mock: m}
	m.CreateAccessRoleMock.callArgs = []*PartitionServiceClientMockCreateAccessRoleParams{}

	m.CreatePageMock = mPartitionServiceClientMockCreatePage{mock: m}
	m.CreatePageMock.callArgs = []*PartitionServiceClientMockCreatePageParams{}

	m.CreatePartitionMock = mPartitionServiceClientMockCreatePartition{mock: m}
	m.CreatePartitionMock.callArgs = []*PartitionServiceClientMockCreatePartitionParams{}

	m.CreatePartitionRoleMock = mPartitionServiceClientMockCreatePartitionRole{mock: m}
	m.CreatePartitionRoleMock.callArgs = []*PartitionServiceClientMockCreatePartitionRoleParams{}

	m.CreateTenantMock = mPartitionServiceClientMockCreateTenant{mock: m}
	m.CreateTenantMock.callArgs = []*PartitionServiceClientMockCreateTenantParams{}

	m.GetAccessMock = mPartitionServiceClientMockGetAccess{mock: m}
	m.GetAccessMock.callArgs = []*PartitionServiceClientMockGetAccessParams{}

	m.GetPageMock = mPartitionServiceClientMockGetPage{mock: m}
	m.GetPageMock.callArgs = []*PartitionServiceClientMockGetPageParams{}

	m.GetPartitionMock = mPartitionServiceClientMockGetPartition{mock: m}
	m.GetPartitionMock.callArgs = []*PartitionServiceClientMockGetPartitionParams{}

	m.GetPartitionParentsMock = mPartitionServiceClientMockGetPartitionParents{mock: m}
	m.GetPartitionParentsMock.callArgs = []*PartitionServiceClientMockGetPartitionParentsParams{}

	m.GetTenantMock = mPartitionServiceClientMockGetTenant{mock: m}
	m.GetTenantMock.callArgs = []*PartitionServiceClientMockGetTenantParams{}

	m.ListAccessRoleMock = mPartitionServiceClientMockListAccessRole{mock: m}
	m.ListAccessRoleMock.callArgs = []*PartitionServiceClientMockListAccessRoleParams{}

	m.ListPartitionMock = mPartitionServiceClientMockListPartition{mock: m}
	m.ListPartitionMock.callArgs = []*PartitionServiceClientMockListPartitionParams{}

	m.ListPartitionRoleMock = mPartitionServiceClientMockListPartitionRole{mock: m}
	m.ListPartitionRoleMock.callArgs = []*PartitionServiceClientMockListPartitionRoleParams{}

	m.ListTenantMock = mPartitionServiceClientMockListTenant{mock: m}
	m.ListTenantMock.callArgs = []*PartitionServiceClientMockListTenantParams{}

	m.RemoveAccessMock = mPartitionServiceClientMockRemoveAccess{mock: m}
	m.RemoveAccessMock.callArgs = []*PartitionServiceClientMockRemoveAccessParams{}

	m.RemoveAccessRoleMock = mPartitionServiceClientMockRemoveAccessRole{mock: m}
	m.RemoveAccessRoleMock.callArgs = []*PartitionServiceClientMockRemoveAccessRoleParams{}

	m.RemovePageMock = mPartitionServiceClientMockRemovePage{mock: m}
	m.RemovePageMock.callArgs = []*PartitionServiceClientMockRemovePageParams{}

	m.RemovePartitionRoleMock = mPartitionServiceClientMockRemovePartitionRole{mock: m}
	m.RemovePartitionRoleMock.callArgs = []*PartitionServiceClientMockRemovePartitionRoleParams{}

	m.UpdatePartitionMock = mPartitionServiceClientMockUpdatePartition{mock: m}
	m.UpdatePartitionMock.callArgs = []*PartitionServiceClientMockUpdatePartitionParams{}

	m.UpdateTenantMock = mPartitionServiceClientMockUpdateTenant{mock: m}
	m.UpdateTenantMock.callArgs = []*PartitionServiceClientMockUpdateTenantParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPartitionServiceClientMockCreateAccess struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockCreateAccessExpectation
	expectations       []*PartitionServiceClientMockCreateAccessExpectation

	callArgs []*PartitionServiceClientMockCreateAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockCreateAccessExpectation specifies expectation struct of the PartitionServiceClient.CreateAccess
type PartitionServiceClientMockCreateAccessExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockCreateAccessParams
	paramPtrs          *PartitionServiceClientMockCreateAccessParamPtrs
	expectationOrigins PartitionServiceClientMockCreateAccessExpectationOrigins
	results            *PartitionServiceClientMockCreateAccessResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockCreateAccessParams contains parameters of the PartitionServiceClient.CreateAccess
type PartitionServiceClientMockCreateAccessParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateAccessRequest]
}

// PartitionServiceClientMockCreateAccessParamPtrs contains pointers to parameters of the PartitionServiceClient.CreateAccess
type PartitionServiceClientMockCreateAccessParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateAccessRequest]
}

// PartitionServiceClientMockCreateAccessResults contains results of the PartitionServiceClient.CreateAccess
type PartitionServiceClientMockCreateAccessResults struct {
	pp2 *connect.Response[v1.CreateAccessResponse]
	err error
}

// PartitionServiceClientMockCreateAccessOrigins contains origins of expectations of the PartitionServiceClient.CreateAccess
type PartitionServiceClientMockCreateAccessExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Optional() *mPartitionServiceClientMockCreateAccess {
	mmCreateAccess.optional = true
	return mmCreateAccess
}

// Expect sets up expected params for PartitionServiceClient.CreateAccess
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) *mPartitionServiceClientMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceClientMockCreateAccessExpectation{}
	}

	if mmCreateAccess.defaultExpectation.paramPtrs != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by ExpectParams functions")
	}

	mmCreateAccess.defaultExpectation.params = &PartitionServiceClientMockCreateAccessParams{ctx, pp1}
	mmCreateAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccess.expectations {
		if minimock.Equal(e.params, mmCreateAccess.defaultExpectation.params) {
			mmCreateAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccess.defaultExpectation.params)
		}
	}

	return mmCreateAccess
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.CreateAccess
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceClientMockCreateAccessExpectation{}
	}

	if mmCreateAccess.defaultExpectation.params != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Expect")
	}

	if mmCreateAccess.defaultExpectation.paramPtrs == nil {
		mmCreateAccess.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreateAccessParamPtrs{}
	}
	mmCreateAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccess
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.CreateAccess
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) ExpectPp1Param2(pp1 *connect.Request[v1.CreateAccessRequest]) *mPartitionServiceClientMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceClientMockCreateAccessExpectation{}
	}

	if mmCreateAccess.defaultExpectation.params != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Expect")
	}

	if mmCreateAccess.defaultExpectation.paramPtrs == nil {
		mmCreateAccess.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreateAccessParamPtrs{}
	}
	mmCreateAccess.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateAccess.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateAccess
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.CreateAccess
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest])) *mPartitionServiceClientMockCreateAccess {
	if mmCreateAccess.mock.inspectFuncCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.CreateAccess")
	}

	mmCreateAccess.mock.inspectFuncCreateAccess = f

	return mmCreateAccess
}

// Return sets up results that will be returned by PartitionServiceClient.CreateAccess
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Return(pp2 *connect.Response[v1.CreateAccessResponse], err error) *PartitionServiceClientMock {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &PartitionServiceClientMockCreateAccessExpectation{mock: mmCreateAccess.mock}
	}
	mmCreateAccess.defaultExpectation.results = &PartitionServiceClientMockCreateAccessResults{pp2, err}
	mmCreateAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccess.mock
}

// Set uses given function f to mock the PartitionServiceClient.CreateAccess method
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) (pp2 *connect.Response[v1.CreateAccessResponse], err error)) *PartitionServiceClientMock {
	if mmCreateAccess.defaultExpectation != nil {
		mmCreateAccess.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.CreateAccess method")
	}

	if len(mmCreateAccess.expectations) > 0 {
		mmCreateAccess.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.CreateAccess method")
	}

	mmCreateAccess.mock.funcCreateAccess = f
	mmCreateAccess.mock.funcCreateAccessOrigin = minimock.CallerInfo(1)
	return mmCreateAccess.mock
}

// When sets expectation for the PartitionServiceClient.CreateAccess which will trigger the result defined by the following
// Then helper
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) When(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) *PartitionServiceClientMockCreateAccessExpectation {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("PartitionServiceClientMock.CreateAccess mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockCreateAccessExpectation{
		mock:               mmCreateAccess.mock,
		params:             &PartitionServiceClientMockCreateAccessParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockCreateAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccess.expectations = append(mmCreateAccess.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.CreateAccess return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockCreateAccessExpectation) Then(pp2 *connect.Response[v1.CreateAccessResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockCreateAccessResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.CreateAccess should be invoked
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Times(n uint64) *mPartitionServiceClientMockCreateAccess {
	if n == 0 {
		mmCreateAccess.mock.t.Fatalf("Times of PartitionServiceClientMock.CreateAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccess.expectedInvocations, n)
	mmCreateAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccess
}

func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) invocationsDone() bool {
	if len(mmCreateAccess.expectations) == 0 && mmCreateAccess.defaultExpectation == nil && mmCreateAccess.mock.funcCreateAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccess.mock.afterCreateAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccess implements mm_partitionv1connect.PartitionServiceClient
func (mmCreateAccess *PartitionServiceClientMock) CreateAccess(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRequest]) (pp2 *connect.Response[v1.CreateAccessResponse], err error) {
	mm_atomic.AddUint64(&mmCreateAccess.beforeCreateAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccess.afterCreateAccessCounter, 1)

	mmCreateAccess.t.Helper()

	if mmCreateAccess.inspectFuncCreateAccess != nil {
		mmCreateAccess.inspectFuncCreateAccess(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockCreateAccessParams{ctx, pp1}

	// Record call args
	mmCreateAccess.CreateAccessMock.mutex.Lock()
	mmCreateAccess.CreateAccessMock.callArgs = append(mmCreateAccess.CreateAccessMock.callArgs, &mm_params)
	mmCreateAccess.CreateAccessMock.mutex.Unlock()

	for _, e := range mmCreateAccess.CreateAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateAccess.CreateAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccess.CreateAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccess.CreateAccessMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccess.CreateAccessMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockCreateAccessParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccess.t.Errorf("PartitionServiceClientMock.CreateAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccess.CreateAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateAccess.t.Errorf("PartitionServiceClientMock.CreateAccess got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccess.CreateAccessMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccess.t.Errorf("PartitionServiceClientMock.CreateAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccess.CreateAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccess.CreateAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccess.t.Fatal("No results are set for the PartitionServiceClientMock.CreateAccess")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateAccess.funcCreateAccess != nil {
		return mmCreateAccess.funcCreateAccess(ctx, pp1)
	}
	mmCreateAccess.t.Fatalf("Unexpected call to PartitionServiceClientMock.CreateAccess. %v %v", ctx, pp1)
	return
}

// CreateAccessAfterCounter returns a count of finished PartitionServiceClientMock.CreateAccess invocations
func (mmCreateAccess *PartitionServiceClientMock) CreateAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.afterCreateAccessCounter)
}

// CreateAccessBeforeCounter returns a count of PartitionServiceClientMock.CreateAccess invocations
func (mmCreateAccess *PartitionServiceClientMock) CreateAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.beforeCreateAccessCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.CreateAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccess *mPartitionServiceClientMockCreateAccess) Calls() []*PartitionServiceClientMockCreateAccessParams {
	mmCreateAccess.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockCreateAccessParams, len(mmCreateAccess.callArgs))
	copy(argCopy, mmCreateAccess.callArgs)

	mmCreateAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessDone returns true if the count of the CreateAccess invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockCreateAccessDone() bool {
	if m.CreateAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccessMock.invocationsDone()
}

// MinimockCreateAccessInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockCreateAccessInspect() {
	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccessCounter := mm_atomic.LoadUint64(&m.afterCreateAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessMock.defaultExpectation != nil && afterCreateAccessCounter < 1 {
		if m.CreateAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccess at\n%s", m.CreateAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccess at\n%s with params: %#v", m.CreateAccessMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccess != nil && afterCreateAccessCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccess at\n%s", m.funcCreateAccessOrigin)
	}

	if !m.CreateAccessMock.invocationsDone() && afterCreateAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.CreateAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccessMock.expectedInvocations), m.CreateAccessMock.expectedInvocationsOrigin, afterCreateAccessCounter)
	}
}

type mPartitionServiceClientMockCreateAccessRole struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockCreateAccessRoleExpectation
	expectations       []*PartitionServiceClientMockCreateAccessRoleExpectation

	callArgs []*PartitionServiceClientMockCreateAccessRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockCreateAccessRoleExpectation specifies expectation struct of the PartitionServiceClient.CreateAccessRole
type PartitionServiceClientMockCreateAccessRoleExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockCreateAccessRoleParams
	paramPtrs          *PartitionServiceClientMockCreateAccessRoleParamPtrs
	expectationOrigins PartitionServiceClientMockCreateAccessRoleExpectationOrigins
	results            *PartitionServiceClientMockCreateAccessRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockCreateAccessRoleParams contains parameters of the PartitionServiceClient.CreateAccessRole
type PartitionServiceClientMockCreateAccessRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateAccessRoleRequest]
}

// PartitionServiceClientMockCreateAccessRoleParamPtrs contains pointers to parameters of the PartitionServiceClient.CreateAccessRole
type PartitionServiceClientMockCreateAccessRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateAccessRoleRequest]
}

// PartitionServiceClientMockCreateAccessRoleResults contains results of the PartitionServiceClient.CreateAccessRole
type PartitionServiceClientMockCreateAccessRoleResults struct {
	pp2 *connect.Response[v1.CreateAccessRoleResponse]
	err error
}

// PartitionServiceClientMockCreateAccessRoleOrigins contains origins of expectations of the PartitionServiceClient.CreateAccessRole
type PartitionServiceClientMockCreateAccessRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Optional() *mPartitionServiceClientMockCreateAccessRole {
	mmCreateAccessRole.optional = true
	return mmCreateAccessRole
}

// Expect sets up expected params for PartitionServiceClient.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) *mPartitionServiceClientMockCreateAccessRole {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceClientMockCreateAccessRoleExpectation{}
	}

	if mmCreateAccessRole.defaultExpectation.paramPtrs != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by ExpectParams functions")
	}

	mmCreateAccessRole.defaultExpectation.params = &PartitionServiceClientMockCreateAccessRoleParams{ctx, pp1}
	mmCreateAccessRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccessRole.expectations {
		if minimock.Equal(e.params, mmCreateAccessRole.defaultExpectation.params) {
			mmCreateAccessRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccessRole.defaultExpectation.params)
		}
	}

	return mmCreateAccessRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockCreateAccessRole {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceClientMockCreateAccessRoleExpectation{}
	}

	if mmCreateAccessRole.defaultExpectation.params != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Expect")
	}

	if mmCreateAccessRole.defaultExpectation.paramPtrs == nil {
		mmCreateAccessRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreateAccessRoleParamPtrs{}
	}
	mmCreateAccessRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccessRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccessRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) ExpectPp1Param2(pp1 *connect.Request[v1.CreateAccessRoleRequest]) *mPartitionServiceClientMockCreateAccessRole {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceClientMockCreateAccessRoleExpectation{}
	}

	if mmCreateAccessRole.defaultExpectation.params != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Expect")
	}

	if mmCreateAccessRole.defaultExpectation.paramPtrs == nil {
		mmCreateAccessRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreateAccessRoleParamPtrs{}
	}
	mmCreateAccessRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateAccessRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateAccessRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest])) *mPartitionServiceClientMockCreateAccessRole {
	if mmCreateAccessRole.mock.inspectFuncCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.CreateAccessRole")
	}

	mmCreateAccessRole.mock.inspectFuncCreateAccessRole = f

	return mmCreateAccessRole
}

// Return sets up results that will be returned by PartitionServiceClient.CreateAccessRole
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Return(pp2 *connect.Response[v1.CreateAccessRoleResponse], err error) *PartitionServiceClientMock {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Set")
	}

	if mmCreateAccessRole.defaultExpectation == nil {
		mmCreateAccessRole.defaultExpectation = &PartitionServiceClientMockCreateAccessRoleExpectation{mock: mmCreateAccessRole.mock}
	}
	mmCreateAccessRole.defaultExpectation.results = &PartitionServiceClientMockCreateAccessRoleResults{pp2, err}
	mmCreateAccessRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccessRole.mock
}

// Set uses given function f to mock the PartitionServiceClient.CreateAccessRole method
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) (pp2 *connect.Response[v1.CreateAccessRoleResponse], err error)) *PartitionServiceClientMock {
	if mmCreateAccessRole.defaultExpectation != nil {
		mmCreateAccessRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.CreateAccessRole method")
	}

	if len(mmCreateAccessRole.expectations) > 0 {
		mmCreateAccessRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.CreateAccessRole method")
	}

	mmCreateAccessRole.mock.funcCreateAccessRole = f
	mmCreateAccessRole.mock.funcCreateAccessRoleOrigin = minimock.CallerInfo(1)
	return mmCreateAccessRole.mock
}

// When sets expectation for the PartitionServiceClient.CreateAccessRole which will trigger the result defined by the following
// Then helper
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) When(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) *PartitionServiceClientMockCreateAccessRoleExpectation {
	if mmCreateAccessRole.mock.funcCreateAccessRole != nil {
		mmCreateAccessRole.mock.t.Fatalf("PartitionServiceClientMock.CreateAccessRole mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockCreateAccessRoleExpectation{
		mock:               mmCreateAccessRole.mock,
		params:             &PartitionServiceClientMockCreateAccessRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockCreateAccessRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccessRole.expectations = append(mmCreateAccessRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.CreateAccessRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockCreateAccessRoleExpectation) Then(pp2 *connect.Response[v1.CreateAccessRoleResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockCreateAccessRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.CreateAccessRole should be invoked
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Times(n uint64) *mPartitionServiceClientMockCreateAccessRole {
	if n == 0 {
		mmCreateAccessRole.mock.t.Fatalf("Times of PartitionServiceClientMock.CreateAccessRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccessRole.expectedInvocations, n)
	mmCreateAccessRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccessRole
}

func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) invocationsDone() bool {
	if len(mmCreateAccessRole.expectations) == 0 && mmCreateAccessRole.defaultExpectation == nil && mmCreateAccessRole.mock.funcCreateAccessRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccessRole.mock.afterCreateAccessRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccessRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccessRole implements mm_partitionv1connect.PartitionServiceClient
func (mmCreateAccessRole *PartitionServiceClientMock) CreateAccessRole(ctx context.Context, pp1 *connect.Request[v1.CreateAccessRoleRequest]) (pp2 *connect.Response[v1.CreateAccessRoleResponse], err error) {
	mm_atomic.AddUint64(&mmCreateAccessRole.beforeCreateAccessRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccessRole.afterCreateAccessRoleCounter, 1)

	mmCreateAccessRole.t.Helper()

	if mmCreateAccessRole.inspectFuncCreateAccessRole != nil {
		mmCreateAccessRole.inspectFuncCreateAccessRole(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockCreateAccessRoleParams{ctx, pp1}

	// Record call args
	mmCreateAccessRole.CreateAccessRoleMock.mutex.Lock()
	mmCreateAccessRole.CreateAccessRoleMock.callArgs = append(mmCreateAccessRole.CreateAccessRoleMock.callArgs, &mm_params)
	mmCreateAccessRole.CreateAccessRoleMock.mutex.Unlock()

	for _, e := range mmCreateAccessRole.CreateAccessRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockCreateAccessRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccessRole.t.Errorf("PartitionServiceClientMock.CreateAccessRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateAccessRole.t.Errorf("PartitionServiceClientMock.CreateAccessRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccessRole.t.Errorf("PartitionServiceClientMock.CreateAccessRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccessRole.CreateAccessRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccessRole.t.Fatal("No results are set for the PartitionServiceClientMock.CreateAccessRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateAccessRole.funcCreateAccessRole != nil {
		return mmCreateAccessRole.funcCreateAccessRole(ctx, pp1)
	}
	mmCreateAccessRole.t.Fatalf("Unexpected call to PartitionServiceClientMock.CreateAccessRole. %v %v", ctx, pp1)
	return
}

// CreateAccessRoleAfterCounter returns a count of finished PartitionServiceClientMock.CreateAccessRole invocations
func (mmCreateAccessRole *PartitionServiceClientMock) CreateAccessRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccessRole.afterCreateAccessRoleCounter)
}

// CreateAccessRoleBeforeCounter returns a count of PartitionServiceClientMock.CreateAccessRole invocations
func (mmCreateAccessRole *PartitionServiceClientMock) CreateAccessRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccessRole.beforeCreateAccessRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.CreateAccessRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccessRole *mPartitionServiceClientMockCreateAccessRole) Calls() []*PartitionServiceClientMockCreateAccessRoleParams {
	mmCreateAccessRole.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockCreateAccessRoleParams, len(mmCreateAccessRole.callArgs))
	copy(argCopy, mmCreateAccessRole.callArgs)

	mmCreateAccessRole.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessRoleDone returns true if the count of the CreateAccessRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockCreateAccessRoleDone() bool {
	if m.CreateAccessRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccessRoleMock.invocationsDone()
}

// MinimockCreateAccessRoleInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockCreateAccessRoleInspect() {
	for _, e := range m.CreateAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccessRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccessRoleCounter := mm_atomic.LoadUint64(&m.afterCreateAccessRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessRoleMock.defaultExpectation != nil && afterCreateAccessRoleCounter < 1 {
		if m.CreateAccessRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccessRole at\n%s", m.CreateAccessRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccessRole at\n%s with params: %#v", m.CreateAccessRoleMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccessRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccessRole != nil && afterCreateAccessRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.CreateAccessRole at\n%s", m.funcCreateAccessRoleOrigin)
	}

	if !m.CreateAccessRoleMock.invocationsDone() && afterCreateAccessRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.CreateAccessRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccessRoleMock.expectedInvocations), m.CreateAccessRoleMock.expectedInvocationsOrigin, afterCreateAccessRoleCounter)
	}
}

type mPartitionServiceClientMockCreatePage struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockCreatePageExpectation
	expectations       []*PartitionServiceClientMockCreatePageExpectation

	callArgs []*PartitionServiceClientMockCreatePageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockCreatePageExpectation specifies expectation struct of the PartitionServiceClient.CreatePage
type PartitionServiceClientMockCreatePageExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockCreatePageParams
	paramPtrs          *PartitionServiceClientMockCreatePageParamPtrs
	expectationOrigins PartitionServiceClientMockCreatePageExpectationOrigins
	results            *PartitionServiceClientMockCreatePageResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockCreatePageParams contains parameters of the PartitionServiceClient.CreatePage
type PartitionServiceClientMockCreatePageParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePageRequest]
}

// PartitionServiceClientMockCreatePageParamPtrs contains pointers to parameters of the PartitionServiceClient.CreatePage
type PartitionServiceClientMockCreatePageParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePageRequest]
}

// PartitionServiceClientMockCreatePageResults contains results of the PartitionServiceClient.CreatePage
type PartitionServiceClientMockCreatePageResults struct {
	pp2 *connect.Response[v1.CreatePageResponse]
	err error
}

// PartitionServiceClientMockCreatePageOrigins contains origins of expectations of the PartitionServiceClient.CreatePage
type PartitionServiceClientMockCreatePageExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Optional() *mPartitionServiceClientMockCreatePage {
	mmCreatePage.optional = true
	return mmCreatePage
}

// Expect sets up expected params for PartitionServiceClient.CreatePage
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) *mPartitionServiceClientMockCreatePage {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceClientMockCreatePageExpectation{}
	}

	if mmCreatePage.defaultExpectation.paramPtrs != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by ExpectParams functions")
	}

	mmCreatePage.defaultExpectation.params = &PartitionServiceClientMockCreatePageParams{ctx, pp1}
	mmCreatePage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePage.expectations {
		if minimock.Equal(e.params, mmCreatePage.defaultExpectation.params) {
			mmCreatePage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePage.defaultExpectation.params)
		}
	}

	return mmCreatePage
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.CreatePage
func (mmCreatePage *mPartitionServiceClientMockCreatePage) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockCreatePage {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceClientMockCreatePageExpectation{}
	}

	if mmCreatePage.defaultExpectation.params != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Expect")
	}

	if mmCreatePage.defaultExpectation.paramPtrs == nil {
		mmCreatePage.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreatePageParamPtrs{}
	}
	mmCreatePage.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePage
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.CreatePage
func (mmCreatePage *mPartitionServiceClientMockCreatePage) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePageRequest]) *mPartitionServiceClientMockCreatePage {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceClientMockCreatePageExpectation{}
	}

	if mmCreatePage.defaultExpectation.params != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Expect")
	}

	if mmCreatePage.defaultExpectation.paramPtrs == nil {
		mmCreatePage.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreatePageParamPtrs{}
	}
	mmCreatePage.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePage.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePage
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.CreatePage
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest])) *mPartitionServiceClientMockCreatePage {
	if mmCreatePage.mock.inspectFuncCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.CreatePage")
	}

	mmCreatePage.mock.inspectFuncCreatePage = f

	return mmCreatePage
}

// Return sets up results that will be returned by PartitionServiceClient.CreatePage
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Return(pp2 *connect.Response[v1.CreatePageResponse], err error) *PartitionServiceClientMock {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Set")
	}

	if mmCreatePage.defaultExpectation == nil {
		mmCreatePage.defaultExpectation = &PartitionServiceClientMockCreatePageExpectation{mock: mmCreatePage.mock}
	}
	mmCreatePage.defaultExpectation.results = &PartitionServiceClientMockCreatePageResults{pp2, err}
	mmCreatePage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePage.mock
}

// Set uses given function f to mock the PartitionServiceClient.CreatePage method
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) (pp2 *connect.Response[v1.CreatePageResponse], err error)) *PartitionServiceClientMock {
	if mmCreatePage.defaultExpectation != nil {
		mmCreatePage.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.CreatePage method")
	}

	if len(mmCreatePage.expectations) > 0 {
		mmCreatePage.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.CreatePage method")
	}

	mmCreatePage.mock.funcCreatePage = f
	mmCreatePage.mock.funcCreatePageOrigin = minimock.CallerInfo(1)
	return mmCreatePage.mock
}

// When sets expectation for the PartitionServiceClient.CreatePage which will trigger the result defined by the following
// Then helper
func (mmCreatePage *mPartitionServiceClientMockCreatePage) When(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) *PartitionServiceClientMockCreatePageExpectation {
	if mmCreatePage.mock.funcCreatePage != nil {
		mmCreatePage.mock.t.Fatalf("PartitionServiceClientMock.CreatePage mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockCreatePageExpectation{
		mock:               mmCreatePage.mock,
		params:             &PartitionServiceClientMockCreatePageParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockCreatePageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePage.expectations = append(mmCreatePage.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.CreatePage return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockCreatePageExpectation) Then(pp2 *connect.Response[v1.CreatePageResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockCreatePageResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.CreatePage should be invoked
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Times(n uint64) *mPartitionServiceClientMockCreatePage {
	if n == 0 {
		mmCreatePage.mock.t.Fatalf("Times of PartitionServiceClientMock.CreatePage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePage.expectedInvocations, n)
	mmCreatePage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePage
}

func (mmCreatePage *mPartitionServiceClientMockCreatePage) invocationsDone() bool {
	if len(mmCreatePage.expectations) == 0 && mmCreatePage.defaultExpectation == nil && mmCreatePage.mock.funcCreatePage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePage.mock.afterCreatePageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePage implements mm_partitionv1connect.PartitionServiceClient
func (mmCreatePage *PartitionServiceClientMock) CreatePage(ctx context.Context, pp1 *connect.Request[v1.CreatePageRequest]) (pp2 *connect.Response[v1.CreatePageResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePage.beforeCreatePageCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePage.afterCreatePageCounter, 1)

	mmCreatePage.t.Helper()

	if mmCreatePage.inspectFuncCreatePage != nil {
		mmCreatePage.inspectFuncCreatePage(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockCreatePageParams{ctx, pp1}

	// Record call args
	mmCreatePage.CreatePageMock.mutex.Lock()
	mmCreatePage.CreatePageMock.callArgs = append(mmCreatePage.CreatePageMock.callArgs, &mm_params)
	mmCreatePage.CreatePageMock.mutex.Unlock()

	for _, e := range mmCreatePage.CreatePageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePage.CreatePageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePage.CreatePageMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePage.CreatePageMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePage.CreatePageMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockCreatePageParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePage.t.Errorf("PartitionServiceClientMock.CreatePage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePage.CreatePageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePage.t.Errorf("PartitionServiceClientMock.CreatePage got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePage.CreatePageMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePage.t.Errorf("PartitionServiceClientMock.CreatePage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePage.CreatePageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePage.CreatePageMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePage.t.Fatal("No results are set for the PartitionServiceClientMock.CreatePage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePage.funcCreatePage != nil {
		return mmCreatePage.funcCreatePage(ctx, pp1)
	}
	mmCreatePage.t.Fatalf("Unexpected call to PartitionServiceClientMock.CreatePage. %v %v", ctx, pp1)
	return
}

// CreatePageAfterCounter returns a count of finished PartitionServiceClientMock.CreatePage invocations
func (mmCreatePage *PartitionServiceClientMock) CreatePageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePage.afterCreatePageCounter)
}

// CreatePageBeforeCounter returns a count of PartitionServiceClientMock.CreatePage invocations
func (mmCreatePage *PartitionServiceClientMock) CreatePageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePage.beforeCreatePageCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.CreatePage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePage *mPartitionServiceClientMockCreatePage) Calls() []*PartitionServiceClientMockCreatePageParams {
	mmCreatePage.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockCreatePageParams, len(mmCreatePage.callArgs))
	copy(argCopy, mmCreatePage.callArgs)

	mmCreatePage.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePageDone returns true if the count of the CreatePage invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockCreatePageDone() bool {
	if m.CreatePageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePageMock.invocationsDone()
}

// MinimockCreatePageInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockCreatePageInspect() {
	for _, e := range m.CreatePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePageCounter := mm_atomic.LoadUint64(&m.afterCreatePageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePageMock.defaultExpectation != nil && afterCreatePageCounter < 1 {
		if m.CreatePageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePage at\n%s", m.CreatePageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePage at\n%s with params: %#v", m.CreatePageMock.defaultExpectation.expectationOrigins.origin, *m.CreatePageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePage != nil && afterCreatePageCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePage at\n%s", m.funcCreatePageOrigin)
	}

	if !m.CreatePageMock.invocationsDone() && afterCreatePageCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.CreatePage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePageMock.expectedInvocations), m.CreatePageMock.expectedInvocationsOrigin, afterCreatePageCounter)
	}
}

type mPartitionServiceClientMockCreatePartition struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockCreatePartitionExpectation
	expectations       []*PartitionServiceClientMockCreatePartitionExpectation

	callArgs []*PartitionServiceClientMockCreatePartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockCreatePartitionExpectation specifies expectation struct of the PartitionServiceClient.CreatePartition
type PartitionServiceClientMockCreatePartitionExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockCreatePartitionParams
	paramPtrs          *PartitionServiceClientMockCreatePartitionParamPtrs
	expectationOrigins PartitionServiceClientMockCreatePartitionExpectationOrigins
	results            *PartitionServiceClientMockCreatePartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockCreatePartitionParams contains parameters of the PartitionServiceClient.CreatePartition
type PartitionServiceClientMockCreatePartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePartitionRequest]
}

// PartitionServiceClientMockCreatePartitionParamPtrs contains pointers to parameters of the PartitionServiceClient.CreatePartition
type PartitionServiceClientMockCreatePartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePartitionRequest]
}

// PartitionServiceClientMockCreatePartitionResults contains results of the PartitionServiceClient.CreatePartition
type PartitionServiceClientMockCreatePartitionResults struct {
	pp2 *connect.Response[v1.CreatePartitionResponse]
	err error
}

// PartitionServiceClientMockCreatePartitionOrigins contains origins of expectations of the PartitionServiceClient.CreatePartition
type PartitionServiceClientMockCreatePartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Optional() *mPartitionServiceClientMockCreatePartition {
	mmCreatePartition.optional = true
	return mmCreatePartition
}

// Expect sets up expected params for PartitionServiceClient.CreatePartition
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) *mPartitionServiceClientMockCreatePartition {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceClientMockCreatePartitionExpectation{}
	}

	if mmCreatePartition.defaultExpectation.paramPtrs != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by ExpectParams functions")
	}

	mmCreatePartition.defaultExpectation.params = &PartitionServiceClientMockCreatePartitionParams{ctx, pp1}
	mmCreatePartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePartition.expectations {
		if minimock.Equal(e.params, mmCreatePartition.defaultExpectation.params) {
			mmCreatePartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePartition.defaultExpectation.params)
		}
	}

	return mmCreatePartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.CreatePartition
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockCreatePartition {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceClientMockCreatePartitionExpectation{}
	}

	if mmCreatePartition.defaultExpectation.params != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Expect")
	}

	if mmCreatePartition.defaultExpectation.paramPtrs == nil {
		mmCreatePartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreatePartitionParamPtrs{}
	}
	mmCreatePartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.CreatePartition
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePartitionRequest]) *mPartitionServiceClientMockCreatePartition {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceClientMockCreatePartitionExpectation{}
	}

	if mmCreatePartition.defaultExpectation.params != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Expect")
	}

	if mmCreatePartition.defaultExpectation.paramPtrs == nil {
		mmCreatePartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreatePartitionParamPtrs{}
	}
	mmCreatePartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.CreatePartition
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest])) *mPartitionServiceClientMockCreatePartition {
	if mmCreatePartition.mock.inspectFuncCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.CreatePartition")
	}

	mmCreatePartition.mock.inspectFuncCreatePartition = f

	return mmCreatePartition
}

// Return sets up results that will be returned by PartitionServiceClient.CreatePartition
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Return(pp2 *connect.Response[v1.CreatePartitionResponse], err error) *PartitionServiceClientMock {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Set")
	}

	if mmCreatePartition.defaultExpectation == nil {
		mmCreatePartition.defaultExpectation = &PartitionServiceClientMockCreatePartitionExpectation{mock: mmCreatePartition.mock}
	}
	mmCreatePartition.defaultExpectation.results = &PartitionServiceClientMockCreatePartitionResults{pp2, err}
	mmCreatePartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePartition.mock
}

// Set uses given function f to mock the PartitionServiceClient.CreatePartition method
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) (pp2 *connect.Response[v1.CreatePartitionResponse], err error)) *PartitionServiceClientMock {
	if mmCreatePartition.defaultExpectation != nil {
		mmCreatePartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.CreatePartition method")
	}

	if len(mmCreatePartition.expectations) > 0 {
		mmCreatePartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.CreatePartition method")
	}

	mmCreatePartition.mock.funcCreatePartition = f
	mmCreatePartition.mock.funcCreatePartitionOrigin = minimock.CallerInfo(1)
	return mmCreatePartition.mock
}

// When sets expectation for the PartitionServiceClient.CreatePartition which will trigger the result defined by the following
// Then helper
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) When(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) *PartitionServiceClientMockCreatePartitionExpectation {
	if mmCreatePartition.mock.funcCreatePartition != nil {
		mmCreatePartition.mock.t.Fatalf("PartitionServiceClientMock.CreatePartition mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockCreatePartitionExpectation{
		mock:               mmCreatePartition.mock,
		params:             &PartitionServiceClientMockCreatePartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockCreatePartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePartition.expectations = append(mmCreatePartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.CreatePartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockCreatePartitionExpectation) Then(pp2 *connect.Response[v1.CreatePartitionResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockCreatePartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.CreatePartition should be invoked
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Times(n uint64) *mPartitionServiceClientMockCreatePartition {
	if n == 0 {
		mmCreatePartition.mock.t.Fatalf("Times of PartitionServiceClientMock.CreatePartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePartition.expectedInvocations, n)
	mmCreatePartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePartition
}

func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) invocationsDone() bool {
	if len(mmCreatePartition.expectations) == 0 && mmCreatePartition.defaultExpectation == nil && mmCreatePartition.mock.funcCreatePartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePartition.mock.afterCreatePartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePartition implements mm_partitionv1connect.PartitionServiceClient
func (mmCreatePartition *PartitionServiceClientMock) CreatePartition(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRequest]) (pp2 *connect.Response[v1.CreatePartitionResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePartition.beforeCreatePartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePartition.afterCreatePartitionCounter, 1)

	mmCreatePartition.t.Helper()

	if mmCreatePartition.inspectFuncCreatePartition != nil {
		mmCreatePartition.inspectFuncCreatePartition(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockCreatePartitionParams{ctx, pp1}

	// Record call args
	mmCreatePartition.CreatePartitionMock.mutex.Lock()
	mmCreatePartition.CreatePartitionMock.callArgs = append(mmCreatePartition.CreatePartitionMock.callArgs, &mm_params)
	mmCreatePartition.CreatePartitionMock.mutex.Unlock()

	for _, e := range mmCreatePartition.CreatePartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePartition.CreatePartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePartition.CreatePartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePartition.CreatePartitionMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePartition.CreatePartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockCreatePartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePartition.t.Errorf("PartitionServiceClientMock.CreatePartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartition.CreatePartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePartition.t.Errorf("PartitionServiceClientMock.CreatePartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartition.CreatePartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePartition.t.Errorf("PartitionServiceClientMock.CreatePartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePartition.CreatePartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePartition.CreatePartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePartition.t.Fatal("No results are set for the PartitionServiceClientMock.CreatePartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePartition.funcCreatePartition != nil {
		return mmCreatePartition.funcCreatePartition(ctx, pp1)
	}
	mmCreatePartition.t.Fatalf("Unexpected call to PartitionServiceClientMock.CreatePartition. %v %v", ctx, pp1)
	return
}

// CreatePartitionAfterCounter returns a count of finished PartitionServiceClientMock.CreatePartition invocations
func (mmCreatePartition *PartitionServiceClientMock) CreatePartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartition.afterCreatePartitionCounter)
}

// CreatePartitionBeforeCounter returns a count of PartitionServiceClientMock.CreatePartition invocations
func (mmCreatePartition *PartitionServiceClientMock) CreatePartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartition.beforeCreatePartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.CreatePartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePartition *mPartitionServiceClientMockCreatePartition) Calls() []*PartitionServiceClientMockCreatePartitionParams {
	mmCreatePartition.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockCreatePartitionParams, len(mmCreatePartition.callArgs))
	copy(argCopy, mmCreatePartition.callArgs)

	mmCreatePartition.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePartitionDone returns true if the count of the CreatePartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockCreatePartitionDone() bool {
	if m.CreatePartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePartitionMock.invocationsDone()
}

// MinimockCreatePartitionInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockCreatePartitionInspect() {
	for _, e := range m.CreatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePartitionCounter := mm_atomic.LoadUint64(&m.afterCreatePartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePartitionMock.defaultExpectation != nil && afterCreatePartitionCounter < 1 {
		if m.CreatePartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartition at\n%s", m.CreatePartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartition at\n%s with params: %#v", m.CreatePartitionMock.defaultExpectation.expectationOrigins.origin, *m.CreatePartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePartition != nil && afterCreatePartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartition at\n%s", m.funcCreatePartitionOrigin)
	}

	if !m.CreatePartitionMock.invocationsDone() && afterCreatePartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.CreatePartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePartitionMock.expectedInvocations), m.CreatePartitionMock.expectedInvocationsOrigin, afterCreatePartitionCounter)
	}
}

type mPartitionServiceClientMockCreatePartitionRole struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockCreatePartitionRoleExpectation
	expectations       []*PartitionServiceClientMockCreatePartitionRoleExpectation

	callArgs []*PartitionServiceClientMockCreatePartitionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockCreatePartitionRoleExpectation specifies expectation struct of the PartitionServiceClient.CreatePartitionRole
type PartitionServiceClientMockCreatePartitionRoleExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockCreatePartitionRoleParams
	paramPtrs          *PartitionServiceClientMockCreatePartitionRoleParamPtrs
	expectationOrigins PartitionServiceClientMockCreatePartitionRoleExpectationOrigins
	results            *PartitionServiceClientMockCreatePartitionRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockCreatePartitionRoleParams contains parameters of the PartitionServiceClient.CreatePartitionRole
type PartitionServiceClientMockCreatePartitionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePartitionRoleRequest]
}

// PartitionServiceClientMockCreatePartitionRoleParamPtrs contains pointers to parameters of the PartitionServiceClient.CreatePartitionRole
type PartitionServiceClientMockCreatePartitionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePartitionRoleRequest]
}

// PartitionServiceClientMockCreatePartitionRoleResults contains results of the PartitionServiceClient.CreatePartitionRole
type PartitionServiceClientMockCreatePartitionRoleResults struct {
	pp2 *connect.Response[v1.CreatePartitionRoleResponse]
	err error
}

// PartitionServiceClientMockCreatePartitionRoleOrigins contains origins of expectations of the PartitionServiceClient.CreatePartitionRole
type PartitionServiceClientMockCreatePartitionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Optional() *mPartitionServiceClientMockCreatePartitionRole {
	mmCreatePartitionRole.optional = true
	return mmCreatePartitionRole
}

// Expect sets up expected params for PartitionServiceClient.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) *mPartitionServiceClientMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceClientMockCreatePartitionRoleExpectation{}
	}

	if mmCreatePartitionRole.defaultExpectation.paramPtrs != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by ExpectParams functions")
	}

	mmCreatePartitionRole.defaultExpectation.params = &PartitionServiceClientMockCreatePartitionRoleParams{ctx, pp1}
	mmCreatePartitionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePartitionRole.expectations {
		if minimock.Equal(e.params, mmCreatePartitionRole.defaultExpectation.params) {
			mmCreatePartitionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePartitionRole.defaultExpectation.params)
		}
	}

	return mmCreatePartitionRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceClientMockCreatePartitionRoleExpectation{}
	}

	if mmCreatePartitionRole.defaultExpectation.params != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Expect")
	}

	if mmCreatePartitionRole.defaultExpectation.paramPtrs == nil {
		mmCreatePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreatePartitionRoleParamPtrs{}
	}
	mmCreatePartitionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePartitionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePartitionRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePartitionRoleRequest]) *mPartitionServiceClientMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceClientMockCreatePartitionRoleExpectation{}
	}

	if mmCreatePartitionRole.defaultExpectation.params != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Expect")
	}

	if mmCreatePartitionRole.defaultExpectation.paramPtrs == nil {
		mmCreatePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreatePartitionRoleParamPtrs{}
	}
	mmCreatePartitionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreatePartitionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreatePartitionRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest])) *mPartitionServiceClientMockCreatePartitionRole {
	if mmCreatePartitionRole.mock.inspectFuncCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.CreatePartitionRole")
	}

	mmCreatePartitionRole.mock.inspectFuncCreatePartitionRole = f

	return mmCreatePartitionRole
}

// Return sets up results that will be returned by PartitionServiceClient.CreatePartitionRole
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Return(pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error) *PartitionServiceClientMock {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Set")
	}

	if mmCreatePartitionRole.defaultExpectation == nil {
		mmCreatePartitionRole.defaultExpectation = &PartitionServiceClientMockCreatePartitionRoleExpectation{mock: mmCreatePartitionRole.mock}
	}
	mmCreatePartitionRole.defaultExpectation.results = &PartitionServiceClientMockCreatePartitionRoleResults{pp2, err}
	mmCreatePartitionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePartitionRole.mock
}

// Set uses given function f to mock the PartitionServiceClient.CreatePartitionRole method
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) (pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error)) *PartitionServiceClientMock {
	if mmCreatePartitionRole.defaultExpectation != nil {
		mmCreatePartitionRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.CreatePartitionRole method")
	}

	if len(mmCreatePartitionRole.expectations) > 0 {
		mmCreatePartitionRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.CreatePartitionRole method")
	}

	mmCreatePartitionRole.mock.funcCreatePartitionRole = f
	mmCreatePartitionRole.mock.funcCreatePartitionRoleOrigin = minimock.CallerInfo(1)
	return mmCreatePartitionRole.mock
}

// When sets expectation for the PartitionServiceClient.CreatePartitionRole which will trigger the result defined by the following
// Then helper
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) When(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) *PartitionServiceClientMockCreatePartitionRoleExpectation {
	if mmCreatePartitionRole.mock.funcCreatePartitionRole != nil {
		mmCreatePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.CreatePartitionRole mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockCreatePartitionRoleExpectation{
		mock:               mmCreatePartitionRole.mock,
		params:             &PartitionServiceClientMockCreatePartitionRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockCreatePartitionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePartitionRole.expectations = append(mmCreatePartitionRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.CreatePartitionRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockCreatePartitionRoleExpectation) Then(pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockCreatePartitionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.CreatePartitionRole should be invoked
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Times(n uint64) *mPartitionServiceClientMockCreatePartitionRole {
	if n == 0 {
		mmCreatePartitionRole.mock.t.Fatalf("Times of PartitionServiceClientMock.CreatePartitionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePartitionRole.expectedInvocations, n)
	mmCreatePartitionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePartitionRole
}

func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) invocationsDone() bool {
	if len(mmCreatePartitionRole.expectations) == 0 && mmCreatePartitionRole.defaultExpectation == nil && mmCreatePartitionRole.mock.funcCreatePartitionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePartitionRole.mock.afterCreatePartitionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePartitionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePartitionRole implements mm_partitionv1connect.PartitionServiceClient
func (mmCreatePartitionRole *PartitionServiceClientMock) CreatePartitionRole(ctx context.Context, pp1 *connect.Request[v1.CreatePartitionRoleRequest]) (pp2 *connect.Response[v1.CreatePartitionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmCreatePartitionRole.beforeCreatePartitionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePartitionRole.afterCreatePartitionRoleCounter, 1)

	mmCreatePartitionRole.t.Helper()

	if mmCreatePartitionRole.inspectFuncCreatePartitionRole != nil {
		mmCreatePartitionRole.inspectFuncCreatePartitionRole(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockCreatePartitionRoleParams{ctx, pp1}

	// Record call args
	mmCreatePartitionRole.CreatePartitionRoleMock.mutex.Lock()
	mmCreatePartitionRole.CreatePartitionRoleMock.callArgs = append(mmCreatePartitionRole.CreatePartitionRoleMock.callArgs, &mm_params)
	mmCreatePartitionRole.CreatePartitionRoleMock.mutex.Unlock()

	for _, e := range mmCreatePartitionRole.CreatePartitionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockCreatePartitionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePartitionRole.t.Errorf("PartitionServiceClientMock.CreatePartitionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreatePartitionRole.t.Errorf("PartitionServiceClientMock.CreatePartitionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePartitionRole.t.Errorf("PartitionServiceClientMock.CreatePartitionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePartitionRole.CreatePartitionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePartitionRole.t.Fatal("No results are set for the PartitionServiceClientMock.CreatePartitionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreatePartitionRole.funcCreatePartitionRole != nil {
		return mmCreatePartitionRole.funcCreatePartitionRole(ctx, pp1)
	}
	mmCreatePartitionRole.t.Fatalf("Unexpected call to PartitionServiceClientMock.CreatePartitionRole. %v %v", ctx, pp1)
	return
}

// CreatePartitionRoleAfterCounter returns a count of finished PartitionServiceClientMock.CreatePartitionRole invocations
func (mmCreatePartitionRole *PartitionServiceClientMock) CreatePartitionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartitionRole.afterCreatePartitionRoleCounter)
}

// CreatePartitionRoleBeforeCounter returns a count of PartitionServiceClientMock.CreatePartitionRole invocations
func (mmCreatePartitionRole *PartitionServiceClientMock) CreatePartitionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePartitionRole.beforeCreatePartitionRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.CreatePartitionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePartitionRole *mPartitionServiceClientMockCreatePartitionRole) Calls() []*PartitionServiceClientMockCreatePartitionRoleParams {
	mmCreatePartitionRole.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockCreatePartitionRoleParams, len(mmCreatePartitionRole.callArgs))
	copy(argCopy, mmCreatePartitionRole.callArgs)

	mmCreatePartitionRole.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePartitionRoleDone returns true if the count of the CreatePartitionRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockCreatePartitionRoleDone() bool {
	if m.CreatePartitionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePartitionRoleMock.invocationsDone()
}

// MinimockCreatePartitionRoleInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockCreatePartitionRoleInspect() {
	for _, e := range m.CreatePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartitionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePartitionRoleCounter := mm_atomic.LoadUint64(&m.afterCreatePartitionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePartitionRoleMock.defaultExpectation != nil && afterCreatePartitionRoleCounter < 1 {
		if m.CreatePartitionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartitionRole at\n%s", m.CreatePartitionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartitionRole at\n%s with params: %#v", m.CreatePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *m.CreatePartitionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePartitionRole != nil && afterCreatePartitionRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.CreatePartitionRole at\n%s", m.funcCreatePartitionRoleOrigin)
	}

	if !m.CreatePartitionRoleMock.invocationsDone() && afterCreatePartitionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.CreatePartitionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePartitionRoleMock.expectedInvocations), m.CreatePartitionRoleMock.expectedInvocationsOrigin, afterCreatePartitionRoleCounter)
	}
}

type mPartitionServiceClientMockCreateTenant struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockCreateTenantExpectation
	expectations       []*PartitionServiceClientMockCreateTenantExpectation

	callArgs []*PartitionServiceClientMockCreateTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockCreateTenantExpectation specifies expectation struct of the PartitionServiceClient.CreateTenant
type PartitionServiceClientMockCreateTenantExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockCreateTenantParams
	paramPtrs          *PartitionServiceClientMockCreateTenantParamPtrs
	expectationOrigins PartitionServiceClientMockCreateTenantExpectationOrigins
	results            *PartitionServiceClientMockCreateTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockCreateTenantParams contains parameters of the PartitionServiceClient.CreateTenant
type PartitionServiceClientMockCreateTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreateTenantRequest]
}

// PartitionServiceClientMockCreateTenantParamPtrs contains pointers to parameters of the PartitionServiceClient.CreateTenant
type PartitionServiceClientMockCreateTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreateTenantRequest]
}

// PartitionServiceClientMockCreateTenantResults contains results of the PartitionServiceClient.CreateTenant
type PartitionServiceClientMockCreateTenantResults struct {
	pp2 *connect.Response[v1.CreateTenantResponse]
	err error
}

// PartitionServiceClientMockCreateTenantOrigins contains origins of expectations of the PartitionServiceClient.CreateTenant
type PartitionServiceClientMockCreateTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Optional() *mPartitionServiceClientMockCreateTenant {
	mmCreateTenant.optional = true
	return mmCreateTenant
}

// Expect sets up expected params for PartitionServiceClient.CreateTenant
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) *mPartitionServiceClientMockCreateTenant {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceClientMockCreateTenantExpectation{}
	}

	if mmCreateTenant.defaultExpectation.paramPtrs != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by ExpectParams functions")
	}

	mmCreateTenant.defaultExpectation.params = &PartitionServiceClientMockCreateTenantParams{ctx, pp1}
	mmCreateTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTenant.expectations {
		if minimock.Equal(e.params, mmCreateTenant.defaultExpectation.params) {
			mmCreateTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTenant.defaultExpectation.params)
		}
	}

	return mmCreateTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.CreateTenant
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockCreateTenant {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceClientMockCreateTenantExpectation{}
	}

	if mmCreateTenant.defaultExpectation.params != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Expect")
	}

	if mmCreateTenant.defaultExpectation.paramPtrs == nil {
		mmCreateTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreateTenantParamPtrs{}
	}
	mmCreateTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.CreateTenant
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) ExpectPp1Param2(pp1 *connect.Request[v1.CreateTenantRequest]) *mPartitionServiceClientMockCreateTenant {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceClientMockCreateTenantExpectation{}
	}

	if mmCreateTenant.defaultExpectation.params != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Expect")
	}

	if mmCreateTenant.defaultExpectation.paramPtrs == nil {
		mmCreateTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockCreateTenantParamPtrs{}
	}
	mmCreateTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.CreateTenant
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest])) *mPartitionServiceClientMockCreateTenant {
	if mmCreateTenant.mock.inspectFuncCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.CreateTenant")
	}

	mmCreateTenant.mock.inspectFuncCreateTenant = f

	return mmCreateTenant
}

// Return sets up results that will be returned by PartitionServiceClient.CreateTenant
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Return(pp2 *connect.Response[v1.CreateTenantResponse], err error) *PartitionServiceClientMock {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Set")
	}

	if mmCreateTenant.defaultExpectation == nil {
		mmCreateTenant.defaultExpectation = &PartitionServiceClientMockCreateTenantExpectation{mock: mmCreateTenant.mock}
	}
	mmCreateTenant.defaultExpectation.results = &PartitionServiceClientMockCreateTenantResults{pp2, err}
	mmCreateTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTenant.mock
}

// Set uses given function f to mock the PartitionServiceClient.CreateTenant method
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) (pp2 *connect.Response[v1.CreateTenantResponse], err error)) *PartitionServiceClientMock {
	if mmCreateTenant.defaultExpectation != nil {
		mmCreateTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.CreateTenant method")
	}

	if len(mmCreateTenant.expectations) > 0 {
		mmCreateTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.CreateTenant method")
	}

	mmCreateTenant.mock.funcCreateTenant = f
	mmCreateTenant.mock.funcCreateTenantOrigin = minimock.CallerInfo(1)
	return mmCreateTenant.mock
}

// When sets expectation for the PartitionServiceClient.CreateTenant which will trigger the result defined by the following
// Then helper
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) When(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) *PartitionServiceClientMockCreateTenantExpectation {
	if mmCreateTenant.mock.funcCreateTenant != nil {
		mmCreateTenant.mock.t.Fatalf("PartitionServiceClientMock.CreateTenant mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockCreateTenantExpectation{
		mock:               mmCreateTenant.mock,
		params:             &PartitionServiceClientMockCreateTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockCreateTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTenant.expectations = append(mmCreateTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.CreateTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockCreateTenantExpectation) Then(pp2 *connect.Response[v1.CreateTenantResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockCreateTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.CreateTenant should be invoked
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Times(n uint64) *mPartitionServiceClientMockCreateTenant {
	if n == 0 {
		mmCreateTenant.mock.t.Fatalf("Times of PartitionServiceClientMock.CreateTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTenant.expectedInvocations, n)
	mmCreateTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTenant
}

func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) invocationsDone() bool {
	if len(mmCreateTenant.expectations) == 0 && mmCreateTenant.defaultExpectation == nil && mmCreateTenant.mock.funcCreateTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTenant.mock.afterCreateTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTenant implements mm_partitionv1connect.PartitionServiceClient
func (mmCreateTenant *PartitionServiceClientMock) CreateTenant(ctx context.Context, pp1 *connect.Request[v1.CreateTenantRequest]) (pp2 *connect.Response[v1.CreateTenantResponse], err error) {
	mm_atomic.AddUint64(&mmCreateTenant.beforeCreateTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTenant.afterCreateTenantCounter, 1)

	mmCreateTenant.t.Helper()

	if mmCreateTenant.inspectFuncCreateTenant != nil {
		mmCreateTenant.inspectFuncCreateTenant(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockCreateTenantParams{ctx, pp1}

	// Record call args
	mmCreateTenant.CreateTenantMock.mutex.Lock()
	mmCreateTenant.CreateTenantMock.callArgs = append(mmCreateTenant.CreateTenantMock.callArgs, &mm_params)
	mmCreateTenant.CreateTenantMock.mutex.Unlock()

	for _, e := range mmCreateTenant.CreateTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateTenant.CreateTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTenant.CreateTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTenant.CreateTenantMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTenant.CreateTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockCreateTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTenant.t.Errorf("PartitionServiceClientMock.CreateTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTenant.CreateTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateTenant.t.Errorf("PartitionServiceClientMock.CreateTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTenant.CreateTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTenant.t.Errorf("PartitionServiceClientMock.CreateTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTenant.CreateTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTenant.CreateTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTenant.t.Fatal("No results are set for the PartitionServiceClientMock.CreateTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateTenant.funcCreateTenant != nil {
		return mmCreateTenant.funcCreateTenant(ctx, pp1)
	}
	mmCreateTenant.t.Fatalf("Unexpected call to PartitionServiceClientMock.CreateTenant. %v %v", ctx, pp1)
	return
}

// CreateTenantAfterCounter returns a count of finished PartitionServiceClientMock.CreateTenant invocations
func (mmCreateTenant *PartitionServiceClientMock) CreateTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTenant.afterCreateTenantCounter)
}

// CreateTenantBeforeCounter returns a count of PartitionServiceClientMock.CreateTenant invocations
func (mmCreateTenant *PartitionServiceClientMock) CreateTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTenant.beforeCreateTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.CreateTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTenant *mPartitionServiceClientMockCreateTenant) Calls() []*PartitionServiceClientMockCreateTenantParams {
	mmCreateTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockCreateTenantParams, len(mmCreateTenant.callArgs))
	copy(argCopy, mmCreateTenant.callArgs)

	mmCreateTenant.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTenantDone returns true if the count of the CreateTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockCreateTenantDone() bool {
	if m.CreateTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTenantMock.invocationsDone()
}

// MinimockCreateTenantInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockCreateTenantInspect() {
	for _, e := range m.CreateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTenantCounter := mm_atomic.LoadUint64(&m.afterCreateTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTenantMock.defaultExpectation != nil && afterCreateTenantCounter < 1 {
		if m.CreateTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateTenant at\n%s", m.CreateTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.CreateTenant at\n%s with params: %#v", m.CreateTenantMock.defaultExpectation.expectationOrigins.origin, *m.CreateTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTenant != nil && afterCreateTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.CreateTenant at\n%s", m.funcCreateTenantOrigin)
	}

	if !m.CreateTenantMock.invocationsDone() && afterCreateTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.CreateTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTenantMock.expectedInvocations), m.CreateTenantMock.expectedInvocationsOrigin, afterCreateTenantCounter)
	}
}

type mPartitionServiceClientMockGetAccess struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockGetAccessExpectation
	expectations       []*PartitionServiceClientMockGetAccessExpectation

	callArgs []*PartitionServiceClientMockGetAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockGetAccessExpectation specifies expectation struct of the PartitionServiceClient.GetAccess
type PartitionServiceClientMockGetAccessExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockGetAccessParams
	paramPtrs          *PartitionServiceClientMockGetAccessParamPtrs
	expectationOrigins PartitionServiceClientMockGetAccessExpectationOrigins
	results            *PartitionServiceClientMockGetAccessResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockGetAccessParams contains parameters of the PartitionServiceClient.GetAccess
type PartitionServiceClientMockGetAccessParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetAccessRequest]
}

// PartitionServiceClientMockGetAccessParamPtrs contains pointers to parameters of the PartitionServiceClient.GetAccess
type PartitionServiceClientMockGetAccessParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetAccessRequest]
}

// PartitionServiceClientMockGetAccessResults contains results of the PartitionServiceClient.GetAccess
type PartitionServiceClientMockGetAccessResults struct {
	pp2 *connect.Response[v1.GetAccessResponse]
	err error
}

// PartitionServiceClientMockGetAccessOrigins contains origins of expectations of the PartitionServiceClient.GetAccess
type PartitionServiceClientMockGetAccessExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Optional() *mPartitionServiceClientMockGetAccess {
	mmGetAccess.optional = true
	return mmGetAccess
}

// Expect sets up expected params for PartitionServiceClient.GetAccess
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Expect(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) *mPartitionServiceClientMockGetAccess {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceClientMockGetAccessExpectation{}
	}

	if mmGetAccess.defaultExpectation.paramPtrs != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by ExpectParams functions")
	}

	mmGetAccess.defaultExpectation.params = &PartitionServiceClientMockGetAccessParams{ctx, pp1}
	mmGetAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAccess.expectations {
		if minimock.Equal(e.params, mmGetAccess.defaultExpectation.params) {
			mmGetAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccess.defaultExpectation.params)
		}
	}

	return mmGetAccess
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.GetAccess
func (mmGetAccess *mPartitionServiceClientMockGetAccess) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockGetAccess {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceClientMockGetAccessExpectation{}
	}

	if mmGetAccess.defaultExpectation.params != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Expect")
	}

	if mmGetAccess.defaultExpectation.paramPtrs == nil {
		mmGetAccess.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetAccessParamPtrs{}
	}
	mmGetAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAccess
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.GetAccess
func (mmGetAccess *mPartitionServiceClientMockGetAccess) ExpectPp1Param2(pp1 *connect.Request[v1.GetAccessRequest]) *mPartitionServiceClientMockGetAccess {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceClientMockGetAccessExpectation{}
	}

	if mmGetAccess.defaultExpectation.params != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Expect")
	}

	if mmGetAccess.defaultExpectation.paramPtrs == nil {
		mmGetAccess.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetAccessParamPtrs{}
	}
	mmGetAccess.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetAccess.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetAccess
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.GetAccess
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest])) *mPartitionServiceClientMockGetAccess {
	if mmGetAccess.mock.inspectFuncGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.GetAccess")
	}

	mmGetAccess.mock.inspectFuncGetAccess = f

	return mmGetAccess
}

// Return sets up results that will be returned by PartitionServiceClient.GetAccess
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Return(pp2 *connect.Response[v1.GetAccessResponse], err error) *PartitionServiceClientMock {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Set")
	}

	if mmGetAccess.defaultExpectation == nil {
		mmGetAccess.defaultExpectation = &PartitionServiceClientMockGetAccessExpectation{mock: mmGetAccess.mock}
	}
	mmGetAccess.defaultExpectation.results = &PartitionServiceClientMockGetAccessResults{pp2, err}
	mmGetAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAccess.mock
}

// Set uses given function f to mock the PartitionServiceClient.GetAccess method
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) (pp2 *connect.Response[v1.GetAccessResponse], err error)) *PartitionServiceClientMock {
	if mmGetAccess.defaultExpectation != nil {
		mmGetAccess.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.GetAccess method")
	}

	if len(mmGetAccess.expectations) > 0 {
		mmGetAccess.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.GetAccess method")
	}

	mmGetAccess.mock.funcGetAccess = f
	mmGetAccess.mock.funcGetAccessOrigin = minimock.CallerInfo(1)
	return mmGetAccess.mock
}

// When sets expectation for the PartitionServiceClient.GetAccess which will trigger the result defined by the following
// Then helper
func (mmGetAccess *mPartitionServiceClientMockGetAccess) When(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) *PartitionServiceClientMockGetAccessExpectation {
	if mmGetAccess.mock.funcGetAccess != nil {
		mmGetAccess.mock.t.Fatalf("PartitionServiceClientMock.GetAccess mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockGetAccessExpectation{
		mock:               mmGetAccess.mock,
		params:             &PartitionServiceClientMockGetAccessParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockGetAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAccess.expectations = append(mmGetAccess.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.GetAccess return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockGetAccessExpectation) Then(pp2 *connect.Response[v1.GetAccessResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockGetAccessResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.GetAccess should be invoked
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Times(n uint64) *mPartitionServiceClientMockGetAccess {
	if n == 0 {
		mmGetAccess.mock.t.Fatalf("Times of PartitionServiceClientMock.GetAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAccess.expectedInvocations, n)
	mmGetAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAccess
}

func (mmGetAccess *mPartitionServiceClientMockGetAccess) invocationsDone() bool {
	if len(mmGetAccess.expectations) == 0 && mmGetAccess.defaultExpectation == nil && mmGetAccess.mock.funcGetAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAccess.mock.afterGetAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAccess implements mm_partitionv1connect.PartitionServiceClient
func (mmGetAccess *PartitionServiceClientMock) GetAccess(ctx context.Context, pp1 *connect.Request[v1.GetAccessRequest]) (pp2 *connect.Response[v1.GetAccessResponse], err error) {
	mm_atomic.AddUint64(&mmGetAccess.beforeGetAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccess.afterGetAccessCounter, 1)

	mmGetAccess.t.Helper()

	if mmGetAccess.inspectFuncGetAccess != nil {
		mmGetAccess.inspectFuncGetAccess(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockGetAccessParams{ctx, pp1}

	// Record call args
	mmGetAccess.GetAccessMock.mutex.Lock()
	mmGetAccess.GetAccessMock.callArgs = append(mmGetAccess.GetAccessMock.callArgs, &mm_params)
	mmGetAccess.GetAccessMock.mutex.Unlock()

	for _, e := range mmGetAccess.GetAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetAccess.GetAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccess.GetAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccess.GetAccessMock.defaultExpectation.params
		mm_want_ptrs := mmGetAccess.GetAccessMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockGetAccessParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAccess.t.Errorf("PartitionServiceClientMock.GetAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccess.GetAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetAccess.t.Errorf("PartitionServiceClientMock.GetAccess got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAccess.GetAccessMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccess.t.Errorf("PartitionServiceClientMock.GetAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAccess.GetAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccess.GetAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccess.t.Fatal("No results are set for the PartitionServiceClientMock.GetAccess")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetAccess.funcGetAccess != nil {
		return mmGetAccess.funcGetAccess(ctx, pp1)
	}
	mmGetAccess.t.Fatalf("Unexpected call to PartitionServiceClientMock.GetAccess. %v %v", ctx, pp1)
	return
}

// GetAccessAfterCounter returns a count of finished PartitionServiceClientMock.GetAccess invocations
func (mmGetAccess *PartitionServiceClientMock) GetAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccess.afterGetAccessCounter)
}

// GetAccessBeforeCounter returns a count of PartitionServiceClientMock.GetAccess invocations
func (mmGetAccess *PartitionServiceClientMock) GetAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccess.beforeGetAccessCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.GetAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccess *mPartitionServiceClientMockGetAccess) Calls() []*PartitionServiceClientMockGetAccessParams {
	mmGetAccess.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockGetAccessParams, len(mmGetAccess.callArgs))
	copy(argCopy, mmGetAccess.callArgs)

	mmGetAccess.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessDone returns true if the count of the GetAccess invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockGetAccessDone() bool {
	if m.GetAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAccessMock.invocationsDone()
}

// MinimockGetAccessInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockGetAccessInspect() {
	for _, e := range m.GetAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAccessCounter := mm_atomic.LoadUint64(&m.afterGetAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessMock.defaultExpectation != nil && afterGetAccessCounter < 1 {
		if m.GetAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetAccess at\n%s", m.GetAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetAccess at\n%s with params: %#v", m.GetAccessMock.defaultExpectation.expectationOrigins.origin, *m.GetAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccess != nil && afterGetAccessCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.GetAccess at\n%s", m.funcGetAccessOrigin)
	}

	if !m.GetAccessMock.invocationsDone() && afterGetAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.GetAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAccessMock.expectedInvocations), m.GetAccessMock.expectedInvocationsOrigin, afterGetAccessCounter)
	}
}

type mPartitionServiceClientMockGetPage struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockGetPageExpectation
	expectations       []*PartitionServiceClientMockGetPageExpectation

	callArgs []*PartitionServiceClientMockGetPageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockGetPageExpectation specifies expectation struct of the PartitionServiceClient.GetPage
type PartitionServiceClientMockGetPageExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockGetPageParams
	paramPtrs          *PartitionServiceClientMockGetPageParamPtrs
	expectationOrigins PartitionServiceClientMockGetPageExpectationOrigins
	results            *PartitionServiceClientMockGetPageResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockGetPageParams contains parameters of the PartitionServiceClient.GetPage
type PartitionServiceClientMockGetPageParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetPageRequest]
}

// PartitionServiceClientMockGetPageParamPtrs contains pointers to parameters of the PartitionServiceClient.GetPage
type PartitionServiceClientMockGetPageParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetPageRequest]
}

// PartitionServiceClientMockGetPageResults contains results of the PartitionServiceClient.GetPage
type PartitionServiceClientMockGetPageResults struct {
	pp2 *connect.Response[v1.GetPageResponse]
	err error
}

// PartitionServiceClientMockGetPageOrigins contains origins of expectations of the PartitionServiceClient.GetPage
type PartitionServiceClientMockGetPageExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPage *mPartitionServiceClientMockGetPage) Optional() *mPartitionServiceClientMockGetPage {
	mmGetPage.optional = true
	return mmGetPage
}

// Expect sets up expected params for PartitionServiceClient.GetPage
func (mmGetPage *mPartitionServiceClientMockGetPage) Expect(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) *mPartitionServiceClientMockGetPage {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceClientMockGetPageExpectation{}
	}

	if mmGetPage.defaultExpectation.paramPtrs != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by ExpectParams functions")
	}

	mmGetPage.defaultExpectation.params = &PartitionServiceClientMockGetPageParams{ctx, pp1}
	mmGetPage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPage.expectations {
		if minimock.Equal(e.params, mmGetPage.defaultExpectation.params) {
			mmGetPage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPage.defaultExpectation.params)
		}
	}

	return mmGetPage
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.GetPage
func (mmGetPage *mPartitionServiceClientMockGetPage) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockGetPage {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceClientMockGetPageExpectation{}
	}

	if mmGetPage.defaultExpectation.params != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Expect")
	}

	if mmGetPage.defaultExpectation.paramPtrs == nil {
		mmGetPage.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetPageParamPtrs{}
	}
	mmGetPage.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPage
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.GetPage
func (mmGetPage *mPartitionServiceClientMockGetPage) ExpectPp1Param2(pp1 *connect.Request[v1.GetPageRequest]) *mPartitionServiceClientMockGetPage {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceClientMockGetPageExpectation{}
	}

	if mmGetPage.defaultExpectation.params != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Expect")
	}

	if mmGetPage.defaultExpectation.paramPtrs == nil {
		mmGetPage.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetPageParamPtrs{}
	}
	mmGetPage.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetPage.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetPage
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.GetPage
func (mmGetPage *mPartitionServiceClientMockGetPage) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest])) *mPartitionServiceClientMockGetPage {
	if mmGetPage.mock.inspectFuncGetPage != nil {
		mmGetPage.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.GetPage")
	}

	mmGetPage.mock.inspectFuncGetPage = f

	return mmGetPage
}

// Return sets up results that will be returned by PartitionServiceClient.GetPage
func (mmGetPage *mPartitionServiceClientMockGetPage) Return(pp2 *connect.Response[v1.GetPageResponse], err error) *PartitionServiceClientMock {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Set")
	}

	if mmGetPage.defaultExpectation == nil {
		mmGetPage.defaultExpectation = &PartitionServiceClientMockGetPageExpectation{mock: mmGetPage.mock}
	}
	mmGetPage.defaultExpectation.results = &PartitionServiceClientMockGetPageResults{pp2, err}
	mmGetPage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPage.mock
}

// Set uses given function f to mock the PartitionServiceClient.GetPage method
func (mmGetPage *mPartitionServiceClientMockGetPage) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) (pp2 *connect.Response[v1.GetPageResponse], err error)) *PartitionServiceClientMock {
	if mmGetPage.defaultExpectation != nil {
		mmGetPage.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.GetPage method")
	}

	if len(mmGetPage.expectations) > 0 {
		mmGetPage.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.GetPage method")
	}

	mmGetPage.mock.funcGetPage = f
	mmGetPage.mock.funcGetPageOrigin = minimock.CallerInfo(1)
	return mmGetPage.mock
}

// When sets expectation for the PartitionServiceClient.GetPage which will trigger the result defined by the following
// Then helper
func (mmGetPage *mPartitionServiceClientMockGetPage) When(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) *PartitionServiceClientMockGetPageExpectation {
	if mmGetPage.mock.funcGetPage != nil {
		mmGetPage.mock.t.Fatalf("PartitionServiceClientMock.GetPage mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockGetPageExpectation{
		mock:               mmGetPage.mock,
		params:             &PartitionServiceClientMockGetPageParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockGetPageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPage.expectations = append(mmGetPage.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.GetPage return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockGetPageExpectation) Then(pp2 *connect.Response[v1.GetPageResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockGetPageResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.GetPage should be invoked
func (mmGetPage *mPartitionServiceClientMockGetPage) Times(n uint64) *mPartitionServiceClientMockGetPage {
	if n == 0 {
		mmGetPage.mock.t.Fatalf("Times of PartitionServiceClientMock.GetPage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPage.expectedInvocations, n)
	mmGetPage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPage
}

func (mmGetPage *mPartitionServiceClientMockGetPage) invocationsDone() bool {
	if len(mmGetPage.expectations) == 0 && mmGetPage.defaultExpectation == nil && mmGetPage.mock.funcGetPage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPage.mock.afterGetPageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPage implements mm_partitionv1connect.PartitionServiceClient
func (mmGetPage *PartitionServiceClientMock) GetPage(ctx context.Context, pp1 *connect.Request[v1.GetPageRequest]) (pp2 *connect.Response[v1.GetPageResponse], err error) {
	mm_atomic.AddUint64(&mmGetPage.beforeGetPageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPage.afterGetPageCounter, 1)

	mmGetPage.t.Helper()

	if mmGetPage.inspectFuncGetPage != nil {
		mmGetPage.inspectFuncGetPage(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockGetPageParams{ctx, pp1}

	// Record call args
	mmGetPage.GetPageMock.mutex.Lock()
	mmGetPage.GetPageMock.callArgs = append(mmGetPage.GetPageMock.callArgs, &mm_params)
	mmGetPage.GetPageMock.mutex.Unlock()

	for _, e := range mmGetPage.GetPageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetPage.GetPageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPage.GetPageMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPage.GetPageMock.defaultExpectation.params
		mm_want_ptrs := mmGetPage.GetPageMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockGetPageParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPage.t.Errorf("PartitionServiceClientMock.GetPage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPage.GetPageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetPage.t.Errorf("PartitionServiceClientMock.GetPage got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPage.GetPageMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPage.t.Errorf("PartitionServiceClientMock.GetPage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPage.GetPageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPage.GetPageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPage.t.Fatal("No results are set for the PartitionServiceClientMock.GetPage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetPage.funcGetPage != nil {
		return mmGetPage.funcGetPage(ctx, pp1)
	}
	mmGetPage.t.Fatalf("Unexpected call to PartitionServiceClientMock.GetPage. %v %v", ctx, pp1)
	return
}

// GetPageAfterCounter returns a count of finished PartitionServiceClientMock.GetPage invocations
func (mmGetPage *PartitionServiceClientMock) GetPageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPage.afterGetPageCounter)
}

// GetPageBeforeCounter returns a count of PartitionServiceClientMock.GetPage invocations
func (mmGetPage *PartitionServiceClientMock) GetPageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPage.beforeGetPageCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.GetPage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPage *mPartitionServiceClientMockGetPage) Calls() []*PartitionServiceClientMockGetPageParams {
	mmGetPage.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockGetPageParams, len(mmGetPage.callArgs))
	copy(argCopy, mmGetPage.callArgs)

	mmGetPage.mutex.RUnlock()

	return argCopy
}

// MinimockGetPageDone returns true if the count of the GetPage invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockGetPageDone() bool {
	if m.GetPageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPageMock.invocationsDone()
}

// MinimockGetPageInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockGetPageInspect() {
	for _, e := range m.GetPageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPageCounter := mm_atomic.LoadUint64(&m.afterGetPageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPageMock.defaultExpectation != nil && afterGetPageCounter < 1 {
		if m.GetPageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPage at\n%s", m.GetPageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPage at\n%s with params: %#v", m.GetPageMock.defaultExpectation.expectationOrigins.origin, *m.GetPageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPage != nil && afterGetPageCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.GetPage at\n%s", m.funcGetPageOrigin)
	}

	if !m.GetPageMock.invocationsDone() && afterGetPageCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.GetPage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPageMock.expectedInvocations), m.GetPageMock.expectedInvocationsOrigin, afterGetPageCounter)
	}
}

type mPartitionServiceClientMockGetPartition struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockGetPartitionExpectation
	expectations       []*PartitionServiceClientMockGetPartitionExpectation

	callArgs []*PartitionServiceClientMockGetPartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockGetPartitionExpectation specifies expectation struct of the PartitionServiceClient.GetPartition
type PartitionServiceClientMockGetPartitionExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockGetPartitionParams
	paramPtrs          *PartitionServiceClientMockGetPartitionParamPtrs
	expectationOrigins PartitionServiceClientMockGetPartitionExpectationOrigins
	results            *PartitionServiceClientMockGetPartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockGetPartitionParams contains parameters of the PartitionServiceClient.GetPartition
type PartitionServiceClientMockGetPartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetPartitionRequest]
}

// PartitionServiceClientMockGetPartitionParamPtrs contains pointers to parameters of the PartitionServiceClient.GetPartition
type PartitionServiceClientMockGetPartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetPartitionRequest]
}

// PartitionServiceClientMockGetPartitionResults contains results of the PartitionServiceClient.GetPartition
type PartitionServiceClientMockGetPartitionResults struct {
	pp2 *connect.Response[v1.GetPartitionResponse]
	err error
}

// PartitionServiceClientMockGetPartitionOrigins contains origins of expectations of the PartitionServiceClient.GetPartition
type PartitionServiceClientMockGetPartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Optional() *mPartitionServiceClientMockGetPartition {
	mmGetPartition.optional = true
	return mmGetPartition
}

// Expect sets up expected params for PartitionServiceClient.GetPartition
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Expect(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) *mPartitionServiceClientMockGetPartition {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceClientMockGetPartitionExpectation{}
	}

	if mmGetPartition.defaultExpectation.paramPtrs != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by ExpectParams functions")
	}

	mmGetPartition.defaultExpectation.params = &PartitionServiceClientMockGetPartitionParams{ctx, pp1}
	mmGetPartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPartition.expectations {
		if minimock.Equal(e.params, mmGetPartition.defaultExpectation.params) {
			mmGetPartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPartition.defaultExpectation.params)
		}
	}

	return mmGetPartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.GetPartition
func (mmGetPartition *mPartitionServiceClientMockGetPartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockGetPartition {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceClientMockGetPartitionExpectation{}
	}

	if mmGetPartition.defaultExpectation.params != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Expect")
	}

	if mmGetPartition.defaultExpectation.paramPtrs == nil {
		mmGetPartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetPartitionParamPtrs{}
	}
	mmGetPartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.GetPartition
func (mmGetPartition *mPartitionServiceClientMockGetPartition) ExpectPp1Param2(pp1 *connect.Request[v1.GetPartitionRequest]) *mPartitionServiceClientMockGetPartition {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceClientMockGetPartitionExpectation{}
	}

	if mmGetPartition.defaultExpectation.params != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Expect")
	}

	if mmGetPartition.defaultExpectation.paramPtrs == nil {
		mmGetPartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetPartitionParamPtrs{}
	}
	mmGetPartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetPartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetPartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.GetPartition
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest])) *mPartitionServiceClientMockGetPartition {
	if mmGetPartition.mock.inspectFuncGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.GetPartition")
	}

	mmGetPartition.mock.inspectFuncGetPartition = f

	return mmGetPartition
}

// Return sets up results that will be returned by PartitionServiceClient.GetPartition
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Return(pp2 *connect.Response[v1.GetPartitionResponse], err error) *PartitionServiceClientMock {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Set")
	}

	if mmGetPartition.defaultExpectation == nil {
		mmGetPartition.defaultExpectation = &PartitionServiceClientMockGetPartitionExpectation{mock: mmGetPartition.mock}
	}
	mmGetPartition.defaultExpectation.results = &PartitionServiceClientMockGetPartitionResults{pp2, err}
	mmGetPartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPartition.mock
}

// Set uses given function f to mock the PartitionServiceClient.GetPartition method
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) (pp2 *connect.Response[v1.GetPartitionResponse], err error)) *PartitionServiceClientMock {
	if mmGetPartition.defaultExpectation != nil {
		mmGetPartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.GetPartition method")
	}

	if len(mmGetPartition.expectations) > 0 {
		mmGetPartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.GetPartition method")
	}

	mmGetPartition.mock.funcGetPartition = f
	mmGetPartition.mock.funcGetPartitionOrigin = minimock.CallerInfo(1)
	return mmGetPartition.mock
}

// When sets expectation for the PartitionServiceClient.GetPartition which will trigger the result defined by the following
// Then helper
func (mmGetPartition *mPartitionServiceClientMockGetPartition) When(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) *PartitionServiceClientMockGetPartitionExpectation {
	if mmGetPartition.mock.funcGetPartition != nil {
		mmGetPartition.mock.t.Fatalf("PartitionServiceClientMock.GetPartition mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockGetPartitionExpectation{
		mock:               mmGetPartition.mock,
		params:             &PartitionServiceClientMockGetPartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockGetPartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPartition.expectations = append(mmGetPartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.GetPartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockGetPartitionExpectation) Then(pp2 *connect.Response[v1.GetPartitionResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockGetPartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.GetPartition should be invoked
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Times(n uint64) *mPartitionServiceClientMockGetPartition {
	if n == 0 {
		mmGetPartition.mock.t.Fatalf("Times of PartitionServiceClientMock.GetPartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPartition.expectedInvocations, n)
	mmGetPartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPartition
}

func (mmGetPartition *mPartitionServiceClientMockGetPartition) invocationsDone() bool {
	if len(mmGetPartition.expectations) == 0 && mmGetPartition.defaultExpectation == nil && mmGetPartition.mock.funcGetPartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPartition.mock.afterGetPartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPartition implements mm_partitionv1connect.PartitionServiceClient
func (mmGetPartition *PartitionServiceClientMock) GetPartition(ctx context.Context, pp1 *connect.Request[v1.GetPartitionRequest]) (pp2 *connect.Response[v1.GetPartitionResponse], err error) {
	mm_atomic.AddUint64(&mmGetPartition.beforeGetPartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPartition.afterGetPartitionCounter, 1)

	mmGetPartition.t.Helper()

	if mmGetPartition.inspectFuncGetPartition != nil {
		mmGetPartition.inspectFuncGetPartition(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockGetPartitionParams{ctx, pp1}

	// Record call args
	mmGetPartition.GetPartitionMock.mutex.Lock()
	mmGetPartition.GetPartitionMock.callArgs = append(mmGetPartition.GetPartitionMock.callArgs, &mm_params)
	mmGetPartition.GetPartitionMock.mutex.Unlock()

	for _, e := range mmGetPartition.GetPartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetPartition.GetPartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPartition.GetPartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPartition.GetPartitionMock.defaultExpectation.params
		mm_want_ptrs := mmGetPartition.GetPartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockGetPartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPartition.t.Errorf("PartitionServiceClientMock.GetPartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartition.GetPartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetPartition.t.Errorf("PartitionServiceClientMock.GetPartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartition.GetPartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPartition.t.Errorf("PartitionServiceClientMock.GetPartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPartition.GetPartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPartition.GetPartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPartition.t.Fatal("No results are set for the PartitionServiceClientMock.GetPartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetPartition.funcGetPartition != nil {
		return mmGetPartition.funcGetPartition(ctx, pp1)
	}
	mmGetPartition.t.Fatalf("Unexpected call to PartitionServiceClientMock.GetPartition. %v %v", ctx, pp1)
	return
}

// GetPartitionAfterCounter returns a count of finished PartitionServiceClientMock.GetPartition invocations
func (mmGetPartition *PartitionServiceClientMock) GetPartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartition.afterGetPartitionCounter)
}

// GetPartitionBeforeCounter returns a count of PartitionServiceClientMock.GetPartition invocations
func (mmGetPartition *PartitionServiceClientMock) GetPartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartition.beforeGetPartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.GetPartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPartition *mPartitionServiceClientMockGetPartition) Calls() []*PartitionServiceClientMockGetPartitionParams {
	mmGetPartition.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockGetPartitionParams, len(mmGetPartition.callArgs))
	copy(argCopy, mmGetPartition.callArgs)

	mmGetPartition.mutex.RUnlock()

	return argCopy
}

// MinimockGetPartitionDone returns true if the count of the GetPartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockGetPartitionDone() bool {
	if m.GetPartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPartitionMock.invocationsDone()
}

// MinimockGetPartitionInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockGetPartitionInspect() {
	for _, e := range m.GetPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPartitionCounter := mm_atomic.LoadUint64(&m.afterGetPartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPartitionMock.defaultExpectation != nil && afterGetPartitionCounter < 1 {
		if m.GetPartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartition at\n%s", m.GetPartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartition at\n%s with params: %#v", m.GetPartitionMock.defaultExpectation.expectationOrigins.origin, *m.GetPartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPartition != nil && afterGetPartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartition at\n%s", m.funcGetPartitionOrigin)
	}

	if !m.GetPartitionMock.invocationsDone() && afterGetPartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.GetPartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPartitionMock.expectedInvocations), m.GetPartitionMock.expectedInvocationsOrigin, afterGetPartitionCounter)
	}
}

type mPartitionServiceClientMockGetPartitionParents struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockGetPartitionParentsExpectation
	expectations       []*PartitionServiceClientMockGetPartitionParentsExpectation

	callArgs []*PartitionServiceClientMockGetPartitionParentsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockGetPartitionParentsExpectation specifies expectation struct of the PartitionServiceClient.GetPartitionParents
type PartitionServiceClientMockGetPartitionParentsExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockGetPartitionParentsParams
	paramPtrs          *PartitionServiceClientMockGetPartitionParentsParamPtrs
	expectationOrigins PartitionServiceClientMockGetPartitionParentsExpectationOrigins
	results            *PartitionServiceClientMockGetPartitionParentsResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockGetPartitionParentsParams contains parameters of the PartitionServiceClient.GetPartitionParents
type PartitionServiceClientMockGetPartitionParentsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetPartitionParentsRequest]
}

// PartitionServiceClientMockGetPartitionParentsParamPtrs contains pointers to parameters of the PartitionServiceClient.GetPartitionParents
type PartitionServiceClientMockGetPartitionParentsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetPartitionParentsRequest]
}

// PartitionServiceClientMockGetPartitionParentsResults contains results of the PartitionServiceClient.GetPartitionParents
type PartitionServiceClientMockGetPartitionParentsResults struct {
	pp2 *connect.Response[v1.GetPartitionParentsResponse]
	err error
}

// PartitionServiceClientMockGetPartitionParentsOrigins contains origins of expectations of the PartitionServiceClient.GetPartitionParents
type PartitionServiceClientMockGetPartitionParentsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Optional() *mPartitionServiceClientMockGetPartitionParents {
	mmGetPartitionParents.optional = true
	return mmGetPartitionParents
}

// Expect sets up expected params for PartitionServiceClient.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Expect(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) *mPartitionServiceClientMockGetPartitionParents {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceClientMockGetPartitionParentsExpectation{}
	}

	if mmGetPartitionParents.defaultExpectation.paramPtrs != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by ExpectParams functions")
	}

	mmGetPartitionParents.defaultExpectation.params = &PartitionServiceClientMockGetPartitionParentsParams{ctx, pp1}
	mmGetPartitionParents.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPartitionParents.expectations {
		if minimock.Equal(e.params, mmGetPartitionParents.defaultExpectation.params) {
			mmGetPartitionParents.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPartitionParents.defaultExpectation.params)
		}
	}

	return mmGetPartitionParents
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockGetPartitionParents {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceClientMockGetPartitionParentsExpectation{}
	}

	if mmGetPartitionParents.defaultExpectation.params != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Expect")
	}

	if mmGetPartitionParents.defaultExpectation.paramPtrs == nil {
		mmGetPartitionParents.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetPartitionParentsParamPtrs{}
	}
	mmGetPartitionParents.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPartitionParents.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPartitionParents
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) ExpectPp1Param2(pp1 *connect.Request[v1.GetPartitionParentsRequest]) *mPartitionServiceClientMockGetPartitionParents {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceClientMockGetPartitionParentsExpectation{}
	}

	if mmGetPartitionParents.defaultExpectation.params != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Expect")
	}

	if mmGetPartitionParents.defaultExpectation.paramPtrs == nil {
		mmGetPartitionParents.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetPartitionParentsParamPtrs{}
	}
	mmGetPartitionParents.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetPartitionParents.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetPartitionParents
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest])) *mPartitionServiceClientMockGetPartitionParents {
	if mmGetPartitionParents.mock.inspectFuncGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.GetPartitionParents")
	}

	mmGetPartitionParents.mock.inspectFuncGetPartitionParents = f

	return mmGetPartitionParents
}

// Return sets up results that will be returned by PartitionServiceClient.GetPartitionParents
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Return(pp2 *connect.Response[v1.GetPartitionParentsResponse], err error) *PartitionServiceClientMock {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Set")
	}

	if mmGetPartitionParents.defaultExpectation == nil {
		mmGetPartitionParents.defaultExpectation = &PartitionServiceClientMockGetPartitionParentsExpectation{mock: mmGetPartitionParents.mock}
	}
	mmGetPartitionParents.defaultExpectation.results = &PartitionServiceClientMockGetPartitionParentsResults{pp2, err}
	mmGetPartitionParents.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPartitionParents.mock
}

// Set uses given function f to mock the PartitionServiceClient.GetPartitionParents method
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) (pp2 *connect.Response[v1.GetPartitionParentsResponse], err error)) *PartitionServiceClientMock {
	if mmGetPartitionParents.defaultExpectation != nil {
		mmGetPartitionParents.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.GetPartitionParents method")
	}

	if len(mmGetPartitionParents.expectations) > 0 {
		mmGetPartitionParents.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.GetPartitionParents method")
	}

	mmGetPartitionParents.mock.funcGetPartitionParents = f
	mmGetPartitionParents.mock.funcGetPartitionParentsOrigin = minimock.CallerInfo(1)
	return mmGetPartitionParents.mock
}

// When sets expectation for the PartitionServiceClient.GetPartitionParents which will trigger the result defined by the following
// Then helper
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) When(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) *PartitionServiceClientMockGetPartitionParentsExpectation {
	if mmGetPartitionParents.mock.funcGetPartitionParents != nil {
		mmGetPartitionParents.mock.t.Fatalf("PartitionServiceClientMock.GetPartitionParents mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockGetPartitionParentsExpectation{
		mock:               mmGetPartitionParents.mock,
		params:             &PartitionServiceClientMockGetPartitionParentsParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockGetPartitionParentsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPartitionParents.expectations = append(mmGetPartitionParents.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.GetPartitionParents return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockGetPartitionParentsExpectation) Then(pp2 *connect.Response[v1.GetPartitionParentsResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockGetPartitionParentsResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.GetPartitionParents should be invoked
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Times(n uint64) *mPartitionServiceClientMockGetPartitionParents {
	if n == 0 {
		mmGetPartitionParents.mock.t.Fatalf("Times of PartitionServiceClientMock.GetPartitionParents mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPartitionParents.expectedInvocations, n)
	mmGetPartitionParents.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPartitionParents
}

func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) invocationsDone() bool {
	if len(mmGetPartitionParents.expectations) == 0 && mmGetPartitionParents.defaultExpectation == nil && mmGetPartitionParents.mock.funcGetPartitionParents == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPartitionParents.mock.afterGetPartitionParentsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPartitionParents.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPartitionParents implements mm_partitionv1connect.PartitionServiceClient
func (mmGetPartitionParents *PartitionServiceClientMock) GetPartitionParents(ctx context.Context, pp1 *connect.Request[v1.GetPartitionParentsRequest]) (pp2 *connect.Response[v1.GetPartitionParentsResponse], err error) {
	mm_atomic.AddUint64(&mmGetPartitionParents.beforeGetPartitionParentsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPartitionParents.afterGetPartitionParentsCounter, 1)

	mmGetPartitionParents.t.Helper()

	if mmGetPartitionParents.inspectFuncGetPartitionParents != nil {
		mmGetPartitionParents.inspectFuncGetPartitionParents(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockGetPartitionParentsParams{ctx, pp1}

	// Record call args
	mmGetPartitionParents.GetPartitionParentsMock.mutex.Lock()
	mmGetPartitionParents.GetPartitionParentsMock.callArgs = append(mmGetPartitionParents.GetPartitionParentsMock.callArgs, &mm_params)
	mmGetPartitionParents.GetPartitionParentsMock.mutex.Unlock()

	for _, e := range mmGetPartitionParents.GetPartitionParentsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.params
		mm_want_ptrs := mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockGetPartitionParentsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPartitionParents.t.Errorf("PartitionServiceClientMock.GetPartitionParents got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetPartitionParents.t.Errorf("PartitionServiceClientMock.GetPartitionParents got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPartitionParents.t.Errorf("PartitionServiceClientMock.GetPartitionParents got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPartitionParents.GetPartitionParentsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPartitionParents.t.Fatal("No results are set for the PartitionServiceClientMock.GetPartitionParents")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetPartitionParents.funcGetPartitionParents != nil {
		return mmGetPartitionParents.funcGetPartitionParents(ctx, pp1)
	}
	mmGetPartitionParents.t.Fatalf("Unexpected call to PartitionServiceClientMock.GetPartitionParents. %v %v", ctx, pp1)
	return
}

// GetPartitionParentsAfterCounter returns a count of finished PartitionServiceClientMock.GetPartitionParents invocations
func (mmGetPartitionParents *PartitionServiceClientMock) GetPartitionParentsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartitionParents.afterGetPartitionParentsCounter)
}

// GetPartitionParentsBeforeCounter returns a count of PartitionServiceClientMock.GetPartitionParents invocations
func (mmGetPartitionParents *PartitionServiceClientMock) GetPartitionParentsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPartitionParents.beforeGetPartitionParentsCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.GetPartitionParents.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPartitionParents *mPartitionServiceClientMockGetPartitionParents) Calls() []*PartitionServiceClientMockGetPartitionParentsParams {
	mmGetPartitionParents.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockGetPartitionParentsParams, len(mmGetPartitionParents.callArgs))
	copy(argCopy, mmGetPartitionParents.callArgs)

	mmGetPartitionParents.mutex.RUnlock()

	return argCopy
}

// MinimockGetPartitionParentsDone returns true if the count of the GetPartitionParents invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockGetPartitionParentsDone() bool {
	if m.GetPartitionParentsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPartitionParentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPartitionParentsMock.invocationsDone()
}

// MinimockGetPartitionParentsInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockGetPartitionParentsInspect() {
	for _, e := range m.GetPartitionParentsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartitionParents at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPartitionParentsCounter := mm_atomic.LoadUint64(&m.afterGetPartitionParentsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPartitionParentsMock.defaultExpectation != nil && afterGetPartitionParentsCounter < 1 {
		if m.GetPartitionParentsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartitionParents at\n%s", m.GetPartitionParentsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartitionParents at\n%s with params: %#v", m.GetPartitionParentsMock.defaultExpectation.expectationOrigins.origin, *m.GetPartitionParentsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPartitionParents != nil && afterGetPartitionParentsCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.GetPartitionParents at\n%s", m.funcGetPartitionParentsOrigin)
	}

	if !m.GetPartitionParentsMock.invocationsDone() && afterGetPartitionParentsCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.GetPartitionParents at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPartitionParentsMock.expectedInvocations), m.GetPartitionParentsMock.expectedInvocationsOrigin, afterGetPartitionParentsCounter)
	}
}

type mPartitionServiceClientMockGetTenant struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockGetTenantExpectation
	expectations       []*PartitionServiceClientMockGetTenantExpectation

	callArgs []*PartitionServiceClientMockGetTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockGetTenantExpectation specifies expectation struct of the PartitionServiceClient.GetTenant
type PartitionServiceClientMockGetTenantExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockGetTenantParams
	paramPtrs          *PartitionServiceClientMockGetTenantParamPtrs
	expectationOrigins PartitionServiceClientMockGetTenantExpectationOrigins
	results            *PartitionServiceClientMockGetTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockGetTenantParams contains parameters of the PartitionServiceClient.GetTenant
type PartitionServiceClientMockGetTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.GetTenantRequest]
}

// PartitionServiceClientMockGetTenantParamPtrs contains pointers to parameters of the PartitionServiceClient.GetTenant
type PartitionServiceClientMockGetTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.GetTenantRequest]
}

// PartitionServiceClientMockGetTenantResults contains results of the PartitionServiceClient.GetTenant
type PartitionServiceClientMockGetTenantResults struct {
	pp2 *connect.Response[v1.GetTenantResponse]
	err error
}

// PartitionServiceClientMockGetTenantOrigins contains origins of expectations of the PartitionServiceClient.GetTenant
type PartitionServiceClientMockGetTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Optional() *mPartitionServiceClientMockGetTenant {
	mmGetTenant.optional = true
	return mmGetTenant
}

// Expect sets up expected params for PartitionServiceClient.GetTenant
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) *mPartitionServiceClientMockGetTenant {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceClientMockGetTenantExpectation{}
	}

	if mmGetTenant.defaultExpectation.paramPtrs != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by ExpectParams functions")
	}

	mmGetTenant.defaultExpectation.params = &PartitionServiceClientMockGetTenantParams{ctx, pp1}
	mmGetTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetTenant.expectations {
		if minimock.Equal(e.params, mmGetTenant.defaultExpectation.params) {
			mmGetTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTenant.defaultExpectation.params)
		}
	}

	return mmGetTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.GetTenant
func (mmGetTenant *mPartitionServiceClientMockGetTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockGetTenant {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceClientMockGetTenantExpectation{}
	}

	if mmGetTenant.defaultExpectation.params != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Expect")
	}

	if mmGetTenant.defaultExpectation.paramPtrs == nil {
		mmGetTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetTenantParamPtrs{}
	}
	mmGetTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.GetTenant
func (mmGetTenant *mPartitionServiceClientMockGetTenant) ExpectPp1Param2(pp1 *connect.Request[v1.GetTenantRequest]) *mPartitionServiceClientMockGetTenant {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceClientMockGetTenantExpectation{}
	}

	if mmGetTenant.defaultExpectation.params != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Expect")
	}

	if mmGetTenant.defaultExpectation.paramPtrs == nil {
		mmGetTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockGetTenantParamPtrs{}
	}
	mmGetTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmGetTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmGetTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.GetTenant
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest])) *mPartitionServiceClientMockGetTenant {
	if mmGetTenant.mock.inspectFuncGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.GetTenant")
	}

	mmGetTenant.mock.inspectFuncGetTenant = f

	return mmGetTenant
}

// Return sets up results that will be returned by PartitionServiceClient.GetTenant
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Return(pp2 *connect.Response[v1.GetTenantResponse], err error) *PartitionServiceClientMock {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Set")
	}

	if mmGetTenant.defaultExpectation == nil {
		mmGetTenant.defaultExpectation = &PartitionServiceClientMockGetTenantExpectation{mock: mmGetTenant.mock}
	}
	mmGetTenant.defaultExpectation.results = &PartitionServiceClientMockGetTenantResults{pp2, err}
	mmGetTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetTenant.mock
}

// Set uses given function f to mock the PartitionServiceClient.GetTenant method
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) (pp2 *connect.Response[v1.GetTenantResponse], err error)) *PartitionServiceClientMock {
	if mmGetTenant.defaultExpectation != nil {
		mmGetTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.GetTenant method")
	}

	if len(mmGetTenant.expectations) > 0 {
		mmGetTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.GetTenant method")
	}

	mmGetTenant.mock.funcGetTenant = f
	mmGetTenant.mock.funcGetTenantOrigin = minimock.CallerInfo(1)
	return mmGetTenant.mock
}

// When sets expectation for the PartitionServiceClient.GetTenant which will trigger the result defined by the following
// Then helper
func (mmGetTenant *mPartitionServiceClientMockGetTenant) When(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) *PartitionServiceClientMockGetTenantExpectation {
	if mmGetTenant.mock.funcGetTenant != nil {
		mmGetTenant.mock.t.Fatalf("PartitionServiceClientMock.GetTenant mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockGetTenantExpectation{
		mock:               mmGetTenant.mock,
		params:             &PartitionServiceClientMockGetTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockGetTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetTenant.expectations = append(mmGetTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.GetTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockGetTenantExpectation) Then(pp2 *connect.Response[v1.GetTenantResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockGetTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.GetTenant should be invoked
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Times(n uint64) *mPartitionServiceClientMockGetTenant {
	if n == 0 {
		mmGetTenant.mock.t.Fatalf("Times of PartitionServiceClientMock.GetTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetTenant.expectedInvocations, n)
	mmGetTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetTenant
}

func (mmGetTenant *mPartitionServiceClientMockGetTenant) invocationsDone() bool {
	if len(mmGetTenant.expectations) == 0 && mmGetTenant.defaultExpectation == nil && mmGetTenant.mock.funcGetTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetTenant.mock.afterGetTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetTenant implements mm_partitionv1connect.PartitionServiceClient
func (mmGetTenant *PartitionServiceClientMock) GetTenant(ctx context.Context, pp1 *connect.Request[v1.GetTenantRequest]) (pp2 *connect.Response[v1.GetTenantResponse], err error) {
	mm_atomic.AddUint64(&mmGetTenant.beforeGetTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTenant.afterGetTenantCounter, 1)

	mmGetTenant.t.Helper()

	if mmGetTenant.inspectFuncGetTenant != nil {
		mmGetTenant.inspectFuncGetTenant(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockGetTenantParams{ctx, pp1}

	// Record call args
	mmGetTenant.GetTenantMock.mutex.Lock()
	mmGetTenant.GetTenantMock.callArgs = append(mmGetTenant.GetTenantMock.callArgs, &mm_params)
	mmGetTenant.GetTenantMock.mutex.Unlock()

	for _, e := range mmGetTenant.GetTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetTenant.GetTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTenant.GetTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTenant.GetTenantMock.defaultExpectation.params
		mm_want_ptrs := mmGetTenant.GetTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockGetTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetTenant.t.Errorf("PartitionServiceClientMock.GetTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTenant.GetTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmGetTenant.t.Errorf("PartitionServiceClientMock.GetTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetTenant.GetTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTenant.t.Errorf("PartitionServiceClientMock.GetTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetTenant.GetTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTenant.GetTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTenant.t.Fatal("No results are set for the PartitionServiceClientMock.GetTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetTenant.funcGetTenant != nil {
		return mmGetTenant.funcGetTenant(ctx, pp1)
	}
	mmGetTenant.t.Fatalf("Unexpected call to PartitionServiceClientMock.GetTenant. %v %v", ctx, pp1)
	return
}

// GetTenantAfterCounter returns a count of finished PartitionServiceClientMock.GetTenant invocations
func (mmGetTenant *PartitionServiceClientMock) GetTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTenant.afterGetTenantCounter)
}

// GetTenantBeforeCounter returns a count of PartitionServiceClientMock.GetTenant invocations
func (mmGetTenant *PartitionServiceClientMock) GetTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTenant.beforeGetTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.GetTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTenant *mPartitionServiceClientMockGetTenant) Calls() []*PartitionServiceClientMockGetTenantParams {
	mmGetTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockGetTenantParams, len(mmGetTenant.callArgs))
	copy(argCopy, mmGetTenant.callArgs)

	mmGetTenant.mutex.RUnlock()

	return argCopy
}

// MinimockGetTenantDone returns true if the count of the GetTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockGetTenantDone() bool {
	if m.GetTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTenantMock.invocationsDone()
}

// MinimockGetTenantInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockGetTenantInspect() {
	for _, e := range m.GetTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTenantCounter := mm_atomic.LoadUint64(&m.afterGetTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTenantMock.defaultExpectation != nil && afterGetTenantCounter < 1 {
		if m.GetTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetTenant at\n%s", m.GetTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.GetTenant at\n%s with params: %#v", m.GetTenantMock.defaultExpectation.expectationOrigins.origin, *m.GetTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTenant != nil && afterGetTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.GetTenant at\n%s", m.funcGetTenantOrigin)
	}

	if !m.GetTenantMock.invocationsDone() && afterGetTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.GetTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTenantMock.expectedInvocations), m.GetTenantMock.expectedInvocationsOrigin, afterGetTenantCounter)
	}
}

type mPartitionServiceClientMockListAccessRole struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockListAccessRoleExpectation
	expectations       []*PartitionServiceClientMockListAccessRoleExpectation

	callArgs []*PartitionServiceClientMockListAccessRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockListAccessRoleExpectation specifies expectation struct of the PartitionServiceClient.ListAccessRole
type PartitionServiceClientMockListAccessRoleExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockListAccessRoleParams
	paramPtrs          *PartitionServiceClientMockListAccessRoleParamPtrs
	expectationOrigins PartitionServiceClientMockListAccessRoleExpectationOrigins
	results            *PartitionServiceClientMockListAccessRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockListAccessRoleParams contains parameters of the PartitionServiceClient.ListAccessRole
type PartitionServiceClientMockListAccessRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListAccessRoleRequest]
}

// PartitionServiceClientMockListAccessRoleParamPtrs contains pointers to parameters of the PartitionServiceClient.ListAccessRole
type PartitionServiceClientMockListAccessRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListAccessRoleRequest]
}

// PartitionServiceClientMockListAccessRoleResults contains results of the PartitionServiceClient.ListAccessRole
type PartitionServiceClientMockListAccessRoleResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListAccessRoleResponse]
	err error
}

// PartitionServiceClientMockListAccessRoleOrigins contains origins of expectations of the PartitionServiceClient.ListAccessRole
type PartitionServiceClientMockListAccessRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Optional() *mPartitionServiceClientMockListAccessRole {
	mmListAccessRole.optional = true
	return mmListAccessRole
}

// Expect sets up expected params for PartitionServiceClient.ListAccessRole
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Expect(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest]) *mPartitionServiceClientMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceClientMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.paramPtrs != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by ExpectParams functions")
	}

	mmListAccessRole.defaultExpectation.params = &PartitionServiceClientMockListAccessRoleParams{ctx, pp1}
	mmListAccessRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListAccessRole.expectations {
		if minimock.Equal(e.params, mmListAccessRole.defaultExpectation.params) {
			mmListAccessRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAccessRole.defaultExpectation.params)
		}
	}

	return mmListAccessRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.ListAccessRole
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceClientMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.params != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Expect")
	}

	if mmListAccessRole.defaultExpectation.paramPtrs == nil {
		mmListAccessRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockListAccessRoleParamPtrs{}
	}
	mmListAccessRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmListAccessRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListAccessRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.ListAccessRole
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) ExpectPp1Param2(pp1 *connect.Request[v1.ListAccessRoleRequest]) *mPartitionServiceClientMockListAccessRole {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceClientMockListAccessRoleExpectation{}
	}

	if mmListAccessRole.defaultExpectation.params != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Expect")
	}

	if mmListAccessRole.defaultExpectation.paramPtrs == nil {
		mmListAccessRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockListAccessRoleParamPtrs{}
	}
	mmListAccessRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListAccessRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListAccessRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.ListAccessRole
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest])) *mPartitionServiceClientMockListAccessRole {
	if mmListAccessRole.mock.inspectFuncListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.ListAccessRole")
	}

	mmListAccessRole.mock.inspectFuncListAccessRole = f

	return mmListAccessRole
}

// Return sets up results that will be returned by PartitionServiceClient.ListAccessRole
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Return(pp2 *connect.ServerStreamForClient[v1.ListAccessRoleResponse], err error) *PartitionServiceClientMock {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Set")
	}

	if mmListAccessRole.defaultExpectation == nil {
		mmListAccessRole.defaultExpectation = &PartitionServiceClientMockListAccessRoleExpectation{mock: mmListAccessRole.mock}
	}
	mmListAccessRole.defaultExpectation.results = &PartitionServiceClientMockListAccessRoleResults{pp2, err}
	mmListAccessRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListAccessRole.mock
}

// Set uses given function f to mock the PartitionServiceClient.ListAccessRole method
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListAccessRoleResponse], err error)) *PartitionServiceClientMock {
	if mmListAccessRole.defaultExpectation != nil {
		mmListAccessRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.ListAccessRole method")
	}

	if len(mmListAccessRole.expectations) > 0 {
		mmListAccessRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.ListAccessRole method")
	}

	mmListAccessRole.mock.funcListAccessRole = f
	mmListAccessRole.mock.funcListAccessRoleOrigin = minimock.CallerInfo(1)
	return mmListAccessRole.mock
}

// When sets expectation for the PartitionServiceClient.ListAccessRole which will trigger the result defined by the following
// Then helper
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) When(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest]) *PartitionServiceClientMockListAccessRoleExpectation {
	if mmListAccessRole.mock.funcListAccessRole != nil {
		mmListAccessRole.mock.t.Fatalf("PartitionServiceClientMock.ListAccessRole mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockListAccessRoleExpectation{
		mock:               mmListAccessRole.mock,
		params:             &PartitionServiceClientMockListAccessRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockListAccessRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListAccessRole.expectations = append(mmListAccessRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.ListAccessRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockListAccessRoleExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListAccessRoleResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockListAccessRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.ListAccessRole should be invoked
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Times(n uint64) *mPartitionServiceClientMockListAccessRole {
	if n == 0 {
		mmListAccessRole.mock.t.Fatalf("Times of PartitionServiceClientMock.ListAccessRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListAccessRole.expectedInvocations, n)
	mmListAccessRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListAccessRole
}

func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) invocationsDone() bool {
	if len(mmListAccessRole.expectations) == 0 && mmListAccessRole.defaultExpectation == nil && mmListAccessRole.mock.funcListAccessRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListAccessRole.mock.afterListAccessRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListAccessRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListAccessRole implements mm_partitionv1connect.PartitionServiceClient
func (mmListAccessRole *PartitionServiceClientMock) ListAccessRole(ctx context.Context, pp1 *connect.Request[v1.ListAccessRoleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListAccessRoleResponse], err error) {
	mm_atomic.AddUint64(&mmListAccessRole.beforeListAccessRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmListAccessRole.afterListAccessRoleCounter, 1)

	mmListAccessRole.t.Helper()

	if mmListAccessRole.inspectFuncListAccessRole != nil {
		mmListAccessRole.inspectFuncListAccessRole(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockListAccessRoleParams{ctx, pp1}

	// Record call args
	mmListAccessRole.ListAccessRoleMock.mutex.Lock()
	mmListAccessRole.ListAccessRoleMock.callArgs = append(mmListAccessRole.ListAccessRoleMock.callArgs, &mm_params)
	mmListAccessRole.ListAccessRoleMock.mutex.Unlock()

	for _, e := range mmListAccessRole.ListAccessRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListAccessRole.ListAccessRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAccessRole.ListAccessRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmListAccessRole.ListAccessRoleMock.defaultExpectation.params
		mm_want_ptrs := mmListAccessRole.ListAccessRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockListAccessRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListAccessRole.t.Errorf("PartitionServiceClientMock.ListAccessRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListAccessRole.t.Errorf("PartitionServiceClientMock.ListAccessRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAccessRole.t.Errorf("PartitionServiceClientMock.ListAccessRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListAccessRole.ListAccessRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAccessRole.ListAccessRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmListAccessRole.t.Fatal("No results are set for the PartitionServiceClientMock.ListAccessRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListAccessRole.funcListAccessRole != nil {
		return mmListAccessRole.funcListAccessRole(ctx, pp1)
	}
	mmListAccessRole.t.Fatalf("Unexpected call to PartitionServiceClientMock.ListAccessRole. %v %v", ctx, pp1)
	return
}

// ListAccessRoleAfterCounter returns a count of finished PartitionServiceClientMock.ListAccessRole invocations
func (mmListAccessRole *PartitionServiceClientMock) ListAccessRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAccessRole.afterListAccessRoleCounter)
}

// ListAccessRoleBeforeCounter returns a count of PartitionServiceClientMock.ListAccessRole invocations
func (mmListAccessRole *PartitionServiceClientMock) ListAccessRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAccessRole.beforeListAccessRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.ListAccessRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAccessRole *mPartitionServiceClientMockListAccessRole) Calls() []*PartitionServiceClientMockListAccessRoleParams {
	mmListAccessRole.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockListAccessRoleParams, len(mmListAccessRole.callArgs))
	copy(argCopy, mmListAccessRole.callArgs)

	mmListAccessRole.mutex.RUnlock()

	return argCopy
}

// MinimockListAccessRoleDone returns true if the count of the ListAccessRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockListAccessRoleDone() bool {
	if m.ListAccessRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListAccessRoleMock.invocationsDone()
}

// MinimockListAccessRoleInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockListAccessRoleInspect() {
	for _, e := range m.ListAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListAccessRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListAccessRoleCounter := mm_atomic.LoadUint64(&m.afterListAccessRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListAccessRoleMock.defaultExpectation != nil && afterListAccessRoleCounter < 1 {
		if m.ListAccessRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListAccessRole at\n%s", m.ListAccessRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListAccessRole at\n%s with params: %#v", m.ListAccessRoleMock.defaultExpectation.expectationOrigins.origin, *m.ListAccessRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAccessRole != nil && afterListAccessRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.ListAccessRole at\n%s", m.funcListAccessRoleOrigin)
	}

	if !m.ListAccessRoleMock.invocationsDone() && afterListAccessRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.ListAccessRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListAccessRoleMock.expectedInvocations), m.ListAccessRoleMock.expectedInvocationsOrigin, afterListAccessRoleCounter)
	}
}

type mPartitionServiceClientMockListPartition struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockListPartitionExpectation
	expectations       []*PartitionServiceClientMockListPartitionExpectation

	callArgs []*PartitionServiceClientMockListPartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockListPartitionExpectation specifies expectation struct of the PartitionServiceClient.ListPartition
type PartitionServiceClientMockListPartitionExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockListPartitionParams
	paramPtrs          *PartitionServiceClientMockListPartitionParamPtrs
	expectationOrigins PartitionServiceClientMockListPartitionExpectationOrigins
	results            *PartitionServiceClientMockListPartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockListPartitionParams contains parameters of the PartitionServiceClient.ListPartition
type PartitionServiceClientMockListPartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListPartitionRequest]
}

// PartitionServiceClientMockListPartitionParamPtrs contains pointers to parameters of the PartitionServiceClient.ListPartition
type PartitionServiceClientMockListPartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListPartitionRequest]
}

// PartitionServiceClientMockListPartitionResults contains results of the PartitionServiceClient.ListPartition
type PartitionServiceClientMockListPartitionResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListPartitionResponse]
	err error
}

// PartitionServiceClientMockListPartitionOrigins contains origins of expectations of the PartitionServiceClient.ListPartition
type PartitionServiceClientMockListPartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPartition *mPartitionServiceClientMockListPartition) Optional() *mPartitionServiceClientMockListPartition {
	mmListPartition.optional = true
	return mmListPartition
}

// Expect sets up expected params for PartitionServiceClient.ListPartition
func (mmListPartition *mPartitionServiceClientMockListPartition) Expect(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest]) *mPartitionServiceClientMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceClientMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.paramPtrs != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by ExpectParams functions")
	}

	mmListPartition.defaultExpectation.params = &PartitionServiceClientMockListPartitionParams{ctx, pp1}
	mmListPartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPartition.expectations {
		if minimock.Equal(e.params, mmListPartition.defaultExpectation.params) {
			mmListPartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPartition.defaultExpectation.params)
		}
	}

	return mmListPartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.ListPartition
func (mmListPartition *mPartitionServiceClientMockListPartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceClientMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.params != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Expect")
	}

	if mmListPartition.defaultExpectation.paramPtrs == nil {
		mmListPartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockListPartitionParamPtrs{}
	}
	mmListPartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.ListPartition
func (mmListPartition *mPartitionServiceClientMockListPartition) ExpectPp1Param2(pp1 *connect.Request[v1.ListPartitionRequest]) *mPartitionServiceClientMockListPartition {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceClientMockListPartitionExpectation{}
	}

	if mmListPartition.defaultExpectation.params != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Expect")
	}

	if mmListPartition.defaultExpectation.paramPtrs == nil {
		mmListPartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockListPartitionParamPtrs{}
	}
	mmListPartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListPartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListPartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.ListPartition
func (mmListPartition *mPartitionServiceClientMockListPartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest])) *mPartitionServiceClientMockListPartition {
	if mmListPartition.mock.inspectFuncListPartition != nil {
		mmListPartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.ListPartition")
	}

	mmListPartition.mock.inspectFuncListPartition = f

	return mmListPartition
}

// Return sets up results that will be returned by PartitionServiceClient.ListPartition
func (mmListPartition *mPartitionServiceClientMockListPartition) Return(pp2 *connect.ServerStreamForClient[v1.ListPartitionResponse], err error) *PartitionServiceClientMock {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Set")
	}

	if mmListPartition.defaultExpectation == nil {
		mmListPartition.defaultExpectation = &PartitionServiceClientMockListPartitionExpectation{mock: mmListPartition.mock}
	}
	mmListPartition.defaultExpectation.results = &PartitionServiceClientMockListPartitionResults{pp2, err}
	mmListPartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPartition.mock
}

// Set uses given function f to mock the PartitionServiceClient.ListPartition method
func (mmListPartition *mPartitionServiceClientMockListPartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPartitionResponse], err error)) *PartitionServiceClientMock {
	if mmListPartition.defaultExpectation != nil {
		mmListPartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.ListPartition method")
	}

	if len(mmListPartition.expectations) > 0 {
		mmListPartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.ListPartition method")
	}

	mmListPartition.mock.funcListPartition = f
	mmListPartition.mock.funcListPartitionOrigin = minimock.CallerInfo(1)
	return mmListPartition.mock
}

// When sets expectation for the PartitionServiceClient.ListPartition which will trigger the result defined by the following
// Then helper
func (mmListPartition *mPartitionServiceClientMockListPartition) When(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest]) *PartitionServiceClientMockListPartitionExpectation {
	if mmListPartition.mock.funcListPartition != nil {
		mmListPartition.mock.t.Fatalf("PartitionServiceClientMock.ListPartition mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockListPartitionExpectation{
		mock:               mmListPartition.mock,
		params:             &PartitionServiceClientMockListPartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockListPartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPartition.expectations = append(mmListPartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.ListPartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockListPartitionExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListPartitionResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockListPartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.ListPartition should be invoked
func (mmListPartition *mPartitionServiceClientMockListPartition) Times(n uint64) *mPartitionServiceClientMockListPartition {
	if n == 0 {
		mmListPartition.mock.t.Fatalf("Times of PartitionServiceClientMock.ListPartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPartition.expectedInvocations, n)
	mmListPartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPartition
}

func (mmListPartition *mPartitionServiceClientMockListPartition) invocationsDone() bool {
	if len(mmListPartition.expectations) == 0 && mmListPartition.defaultExpectation == nil && mmListPartition.mock.funcListPartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPartition.mock.afterListPartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPartition implements mm_partitionv1connect.PartitionServiceClient
func (mmListPartition *PartitionServiceClientMock) ListPartition(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPartitionResponse], err error) {
	mm_atomic.AddUint64(&mmListPartition.beforeListPartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmListPartition.afterListPartitionCounter, 1)

	mmListPartition.t.Helper()

	if mmListPartition.inspectFuncListPartition != nil {
		mmListPartition.inspectFuncListPartition(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockListPartitionParams{ctx, pp1}

	// Record call args
	mmListPartition.ListPartitionMock.mutex.Lock()
	mmListPartition.ListPartitionMock.callArgs = append(mmListPartition.ListPartitionMock.callArgs, &mm_params)
	mmListPartition.ListPartitionMock.mutex.Unlock()

	for _, e := range mmListPartition.ListPartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListPartition.ListPartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPartition.ListPartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmListPartition.ListPartitionMock.defaultExpectation.params
		mm_want_ptrs := mmListPartition.ListPartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockListPartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPartition.t.Errorf("PartitionServiceClientMock.ListPartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListPartition.t.Errorf("PartitionServiceClientMock.ListPartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPartition.t.Errorf("PartitionServiceClientMock.ListPartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPartition.ListPartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPartition.ListPartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmListPartition.t.Fatal("No results are set for the PartitionServiceClientMock.ListPartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListPartition.funcListPartition != nil {
		return mmListPartition.funcListPartition(ctx, pp1)
	}
	mmListPartition.t.Fatalf("Unexpected call to PartitionServiceClientMock.ListPartition. %v %v", ctx, pp1)
	return
}

// ListPartitionAfterCounter returns a count of finished PartitionServiceClientMock.ListPartition invocations
func (mmListPartition *PartitionServiceClientMock) ListPartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartition.afterListPartitionCounter)
}

// ListPartitionBeforeCounter returns a count of PartitionServiceClientMock.ListPartition invocations
func (mmListPartition *PartitionServiceClientMock) ListPartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartition.beforeListPartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.ListPartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPartition *mPartitionServiceClientMockListPartition) Calls() []*PartitionServiceClientMockListPartitionParams {
	mmListPartition.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockListPartitionParams, len(mmListPartition.callArgs))
	copy(argCopy, mmListPartition.callArgs)

	mmListPartition.mutex.RUnlock()

	return argCopy
}

// MinimockListPartitionDone returns true if the count of the ListPartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockListPartitionDone() bool {
	if m.ListPartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPartitionMock.invocationsDone()
}

// MinimockListPartitionInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockListPartitionInspect() {
	for _, e := range m.ListPartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPartitionCounter := mm_atomic.LoadUint64(&m.afterListPartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPartitionMock.defaultExpectation != nil && afterListPartitionCounter < 1 {
		if m.ListPartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartition at\n%s", m.ListPartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartition at\n%s with params: %#v", m.ListPartitionMock.defaultExpectation.expectationOrigins.origin, *m.ListPartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPartition != nil && afterListPartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartition at\n%s", m.funcListPartitionOrigin)
	}

	if !m.ListPartitionMock.invocationsDone() && afterListPartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.ListPartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPartitionMock.expectedInvocations), m.ListPartitionMock.expectedInvocationsOrigin, afterListPartitionCounter)
	}
}

type mPartitionServiceClientMockListPartitionRole struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockListPartitionRoleExpectation
	expectations       []*PartitionServiceClientMockListPartitionRoleExpectation

	callArgs []*PartitionServiceClientMockListPartitionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockListPartitionRoleExpectation specifies expectation struct of the PartitionServiceClient.ListPartitionRole
type PartitionServiceClientMockListPartitionRoleExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockListPartitionRoleParams
	paramPtrs          *PartitionServiceClientMockListPartitionRoleParamPtrs
	expectationOrigins PartitionServiceClientMockListPartitionRoleExpectationOrigins
	results            *PartitionServiceClientMockListPartitionRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockListPartitionRoleParams contains parameters of the PartitionServiceClient.ListPartitionRole
type PartitionServiceClientMockListPartitionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListPartitionRoleRequest]
}

// PartitionServiceClientMockListPartitionRoleParamPtrs contains pointers to parameters of the PartitionServiceClient.ListPartitionRole
type PartitionServiceClientMockListPartitionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListPartitionRoleRequest]
}

// PartitionServiceClientMockListPartitionRoleResults contains results of the PartitionServiceClient.ListPartitionRole
type PartitionServiceClientMockListPartitionRoleResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListPartitionRoleResponse]
	err error
}

// PartitionServiceClientMockListPartitionRoleOrigins contains origins of expectations of the PartitionServiceClient.ListPartitionRole
type PartitionServiceClientMockListPartitionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Optional() *mPartitionServiceClientMockListPartitionRole {
	mmListPartitionRole.optional = true
	return mmListPartitionRole
}

// Expect sets up expected params for PartitionServiceClient.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest]) *mPartitionServiceClientMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceClientMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by ExpectParams functions")
	}

	mmListPartitionRole.defaultExpectation.params = &PartitionServiceClientMockListPartitionRoleParams{ctx, pp1}
	mmListPartitionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPartitionRole.expectations {
		if minimock.Equal(e.params, mmListPartitionRole.defaultExpectation.params) {
			mmListPartitionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPartitionRole.defaultExpectation.params)
		}
	}

	return mmListPartitionRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceClientMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.params != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Expect")
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs == nil {
		mmListPartitionRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockListPartitionRoleParamPtrs{}
	}
	mmListPartitionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPartitionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPartitionRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) ExpectPp1Param2(pp1 *connect.Request[v1.ListPartitionRoleRequest]) *mPartitionServiceClientMockListPartitionRole {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceClientMockListPartitionRoleExpectation{}
	}

	if mmListPartitionRole.defaultExpectation.params != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Expect")
	}

	if mmListPartitionRole.defaultExpectation.paramPtrs == nil {
		mmListPartitionRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockListPartitionRoleParamPtrs{}
	}
	mmListPartitionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListPartitionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListPartitionRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest])) *mPartitionServiceClientMockListPartitionRole {
	if mmListPartitionRole.mock.inspectFuncListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.ListPartitionRole")
	}

	mmListPartitionRole.mock.inspectFuncListPartitionRole = f

	return mmListPartitionRole
}

// Return sets up results that will be returned by PartitionServiceClient.ListPartitionRole
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Return(pp2 *connect.ServerStreamForClient[v1.ListPartitionRoleResponse], err error) *PartitionServiceClientMock {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Set")
	}

	if mmListPartitionRole.defaultExpectation == nil {
		mmListPartitionRole.defaultExpectation = &PartitionServiceClientMockListPartitionRoleExpectation{mock: mmListPartitionRole.mock}
	}
	mmListPartitionRole.defaultExpectation.results = &PartitionServiceClientMockListPartitionRoleResults{pp2, err}
	mmListPartitionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPartitionRole.mock
}

// Set uses given function f to mock the PartitionServiceClient.ListPartitionRole method
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPartitionRoleResponse], err error)) *PartitionServiceClientMock {
	if mmListPartitionRole.defaultExpectation != nil {
		mmListPartitionRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.ListPartitionRole method")
	}

	if len(mmListPartitionRole.expectations) > 0 {
		mmListPartitionRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.ListPartitionRole method")
	}

	mmListPartitionRole.mock.funcListPartitionRole = f
	mmListPartitionRole.mock.funcListPartitionRoleOrigin = minimock.CallerInfo(1)
	return mmListPartitionRole.mock
}

// When sets expectation for the PartitionServiceClient.ListPartitionRole which will trigger the result defined by the following
// Then helper
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) When(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest]) *PartitionServiceClientMockListPartitionRoleExpectation {
	if mmListPartitionRole.mock.funcListPartitionRole != nil {
		mmListPartitionRole.mock.t.Fatalf("PartitionServiceClientMock.ListPartitionRole mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockListPartitionRoleExpectation{
		mock:               mmListPartitionRole.mock,
		params:             &PartitionServiceClientMockListPartitionRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockListPartitionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPartitionRole.expectations = append(mmListPartitionRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.ListPartitionRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockListPartitionRoleExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListPartitionRoleResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockListPartitionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.ListPartitionRole should be invoked
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Times(n uint64) *mPartitionServiceClientMockListPartitionRole {
	if n == 0 {
		mmListPartitionRole.mock.t.Fatalf("Times of PartitionServiceClientMock.ListPartitionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPartitionRole.expectedInvocations, n)
	mmListPartitionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPartitionRole
}

func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) invocationsDone() bool {
	if len(mmListPartitionRole.expectations) == 0 && mmListPartitionRole.defaultExpectation == nil && mmListPartitionRole.mock.funcListPartitionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPartitionRole.mock.afterListPartitionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPartitionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPartitionRole implements mm_partitionv1connect.PartitionServiceClient
func (mmListPartitionRole *PartitionServiceClientMock) ListPartitionRole(ctx context.Context, pp1 *connect.Request[v1.ListPartitionRoleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPartitionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmListPartitionRole.beforeListPartitionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmListPartitionRole.afterListPartitionRoleCounter, 1)

	mmListPartitionRole.t.Helper()

	if mmListPartitionRole.inspectFuncListPartitionRole != nil {
		mmListPartitionRole.inspectFuncListPartitionRole(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockListPartitionRoleParams{ctx, pp1}

	// Record call args
	mmListPartitionRole.ListPartitionRoleMock.mutex.Lock()
	mmListPartitionRole.ListPartitionRoleMock.callArgs = append(mmListPartitionRole.ListPartitionRoleMock.callArgs, &mm_params)
	mmListPartitionRole.ListPartitionRoleMock.mutex.Unlock()

	for _, e := range mmListPartitionRole.ListPartitionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListPartitionRole.ListPartitionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockListPartitionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPartitionRole.t.Errorf("PartitionServiceClientMock.ListPartitionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListPartitionRole.t.Errorf("PartitionServiceClientMock.ListPartitionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPartitionRole.t.Errorf("PartitionServiceClientMock.ListPartitionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPartitionRole.ListPartitionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmListPartitionRole.t.Fatal("No results are set for the PartitionServiceClientMock.ListPartitionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListPartitionRole.funcListPartitionRole != nil {
		return mmListPartitionRole.funcListPartitionRole(ctx, pp1)
	}
	mmListPartitionRole.t.Fatalf("Unexpected call to PartitionServiceClientMock.ListPartitionRole. %v %v", ctx, pp1)
	return
}

// ListPartitionRoleAfterCounter returns a count of finished PartitionServiceClientMock.ListPartitionRole invocations
func (mmListPartitionRole *PartitionServiceClientMock) ListPartitionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartitionRole.afterListPartitionRoleCounter)
}

// ListPartitionRoleBeforeCounter returns a count of PartitionServiceClientMock.ListPartitionRole invocations
func (mmListPartitionRole *PartitionServiceClientMock) ListPartitionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPartitionRole.beforeListPartitionRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.ListPartitionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPartitionRole *mPartitionServiceClientMockListPartitionRole) Calls() []*PartitionServiceClientMockListPartitionRoleParams {
	mmListPartitionRole.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockListPartitionRoleParams, len(mmListPartitionRole.callArgs))
	copy(argCopy, mmListPartitionRole.callArgs)

	mmListPartitionRole.mutex.RUnlock()

	return argCopy
}

// MinimockListPartitionRoleDone returns true if the count of the ListPartitionRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockListPartitionRoleDone() bool {
	if m.ListPartitionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPartitionRoleMock.invocationsDone()
}

// MinimockListPartitionRoleInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockListPartitionRoleInspect() {
	for _, e := range m.ListPartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartitionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPartitionRoleCounter := mm_atomic.LoadUint64(&m.afterListPartitionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPartitionRoleMock.defaultExpectation != nil && afterListPartitionRoleCounter < 1 {
		if m.ListPartitionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartitionRole at\n%s", m.ListPartitionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartitionRole at\n%s with params: %#v", m.ListPartitionRoleMock.defaultExpectation.expectationOrigins.origin, *m.ListPartitionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPartitionRole != nil && afterListPartitionRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.ListPartitionRole at\n%s", m.funcListPartitionRoleOrigin)
	}

	if !m.ListPartitionRoleMock.invocationsDone() && afterListPartitionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.ListPartitionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPartitionRoleMock.expectedInvocations), m.ListPartitionRoleMock.expectedInvocationsOrigin, afterListPartitionRoleCounter)
	}
}

type mPartitionServiceClientMockListTenant struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockListTenantExpectation
	expectations       []*PartitionServiceClientMockListTenantExpectation

	callArgs []*PartitionServiceClientMockListTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockListTenantExpectation specifies expectation struct of the PartitionServiceClient.ListTenant
type PartitionServiceClientMockListTenantExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockListTenantParams
	paramPtrs          *PartitionServiceClientMockListTenantParamPtrs
	expectationOrigins PartitionServiceClientMockListTenantExpectationOrigins
	results            *PartitionServiceClientMockListTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockListTenantParams contains parameters of the PartitionServiceClient.ListTenant
type PartitionServiceClientMockListTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListTenantRequest]
}

// PartitionServiceClientMockListTenantParamPtrs contains pointers to parameters of the PartitionServiceClient.ListTenant
type PartitionServiceClientMockListTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListTenantRequest]
}

// PartitionServiceClientMockListTenantResults contains results of the PartitionServiceClient.ListTenant
type PartitionServiceClientMockListTenantResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListTenantResponse]
	err error
}

// PartitionServiceClientMockListTenantOrigins contains origins of expectations of the PartitionServiceClient.ListTenant
type PartitionServiceClientMockListTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTenant *mPartitionServiceClientMockListTenant) Optional() *mPartitionServiceClientMockListTenant {
	mmListTenant.optional = true
	return mmListTenant
}

// Expect sets up expected params for PartitionServiceClient.ListTenant
func (mmListTenant *mPartitionServiceClientMockListTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest]) *mPartitionServiceClientMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceClientMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.paramPtrs != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by ExpectParams functions")
	}

	mmListTenant.defaultExpectation.params = &PartitionServiceClientMockListTenantParams{ctx, pp1}
	mmListTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTenant.expectations {
		if minimock.Equal(e.params, mmListTenant.defaultExpectation.params) {
			mmListTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTenant.defaultExpectation.params)
		}
	}

	return mmListTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.ListTenant
func (mmListTenant *mPartitionServiceClientMockListTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceClientMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.params != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Expect")
	}

	if mmListTenant.defaultExpectation.paramPtrs == nil {
		mmListTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockListTenantParamPtrs{}
	}
	mmListTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.ListTenant
func (mmListTenant *mPartitionServiceClientMockListTenant) ExpectPp1Param2(pp1 *connect.Request[v1.ListTenantRequest]) *mPartitionServiceClientMockListTenant {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceClientMockListTenantExpectation{}
	}

	if mmListTenant.defaultExpectation.params != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Expect")
	}

	if mmListTenant.defaultExpectation.paramPtrs == nil {
		mmListTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockListTenantParamPtrs{}
	}
	mmListTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.ListTenant
func (mmListTenant *mPartitionServiceClientMockListTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest])) *mPartitionServiceClientMockListTenant {
	if mmListTenant.mock.inspectFuncListTenant != nil {
		mmListTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.ListTenant")
	}

	mmListTenant.mock.inspectFuncListTenant = f

	return mmListTenant
}

// Return sets up results that will be returned by PartitionServiceClient.ListTenant
func (mmListTenant *mPartitionServiceClientMockListTenant) Return(pp2 *connect.ServerStreamForClient[v1.ListTenantResponse], err error) *PartitionServiceClientMock {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Set")
	}

	if mmListTenant.defaultExpectation == nil {
		mmListTenant.defaultExpectation = &PartitionServiceClientMockListTenantExpectation{mock: mmListTenant.mock}
	}
	mmListTenant.defaultExpectation.results = &PartitionServiceClientMockListTenantResults{pp2, err}
	mmListTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTenant.mock
}

// Set uses given function f to mock the PartitionServiceClient.ListTenant method
func (mmListTenant *mPartitionServiceClientMockListTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest]) (pp2 *connect.ServerStreamForClient[v1.ListTenantResponse], err error)) *PartitionServiceClientMock {
	if mmListTenant.defaultExpectation != nil {
		mmListTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.ListTenant method")
	}

	if len(mmListTenant.expectations) > 0 {
		mmListTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.ListTenant method")
	}

	mmListTenant.mock.funcListTenant = f
	mmListTenant.mock.funcListTenantOrigin = minimock.CallerInfo(1)
	return mmListTenant.mock
}

// When sets expectation for the PartitionServiceClient.ListTenant which will trigger the result defined by the following
// Then helper
func (mmListTenant *mPartitionServiceClientMockListTenant) When(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest]) *PartitionServiceClientMockListTenantExpectation {
	if mmListTenant.mock.funcListTenant != nil {
		mmListTenant.mock.t.Fatalf("PartitionServiceClientMock.ListTenant mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockListTenantExpectation{
		mock:               mmListTenant.mock,
		params:             &PartitionServiceClientMockListTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockListTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTenant.expectations = append(mmListTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.ListTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockListTenantExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListTenantResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockListTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.ListTenant should be invoked
func (mmListTenant *mPartitionServiceClientMockListTenant) Times(n uint64) *mPartitionServiceClientMockListTenant {
	if n == 0 {
		mmListTenant.mock.t.Fatalf("Times of PartitionServiceClientMock.ListTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTenant.expectedInvocations, n)
	mmListTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTenant
}

func (mmListTenant *mPartitionServiceClientMockListTenant) invocationsDone() bool {
	if len(mmListTenant.expectations) == 0 && mmListTenant.defaultExpectation == nil && mmListTenant.mock.funcListTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTenant.mock.afterListTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTenant implements mm_partitionv1connect.PartitionServiceClient
func (mmListTenant *PartitionServiceClientMock) ListTenant(ctx context.Context, pp1 *connect.Request[v1.ListTenantRequest]) (pp2 *connect.ServerStreamForClient[v1.ListTenantResponse], err error) {
	mm_atomic.AddUint64(&mmListTenant.beforeListTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmListTenant.afterListTenantCounter, 1)

	mmListTenant.t.Helper()

	if mmListTenant.inspectFuncListTenant != nil {
		mmListTenant.inspectFuncListTenant(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockListTenantParams{ctx, pp1}

	// Record call args
	mmListTenant.ListTenantMock.mutex.Lock()
	mmListTenant.ListTenantMock.callArgs = append(mmListTenant.ListTenantMock.callArgs, &mm_params)
	mmListTenant.ListTenantMock.mutex.Unlock()

	for _, e := range mmListTenant.ListTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListTenant.ListTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTenant.ListTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmListTenant.ListTenantMock.defaultExpectation.params
		mm_want_ptrs := mmListTenant.ListTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockListTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTenant.t.Errorf("PartitionServiceClientMock.ListTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListTenant.t.Errorf("PartitionServiceClientMock.ListTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTenant.t.Errorf("PartitionServiceClientMock.ListTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTenant.ListTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTenant.ListTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmListTenant.t.Fatal("No results are set for the PartitionServiceClientMock.ListTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListTenant.funcListTenant != nil {
		return mmListTenant.funcListTenant(ctx, pp1)
	}
	mmListTenant.t.Fatalf("Unexpected call to PartitionServiceClientMock.ListTenant. %v %v", ctx, pp1)
	return
}

// ListTenantAfterCounter returns a count of finished PartitionServiceClientMock.ListTenant invocations
func (mmListTenant *PartitionServiceClientMock) ListTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTenant.afterListTenantCounter)
}

// ListTenantBeforeCounter returns a count of PartitionServiceClientMock.ListTenant invocations
func (mmListTenant *PartitionServiceClientMock) ListTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTenant.beforeListTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.ListTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTenant *mPartitionServiceClientMockListTenant) Calls() []*PartitionServiceClientMockListTenantParams {
	mmListTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockListTenantParams, len(mmListTenant.callArgs))
	copy(argCopy, mmListTenant.callArgs)

	mmListTenant.mutex.RUnlock()

	return argCopy
}

// MinimockListTenantDone returns true if the count of the ListTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockListTenantDone() bool {
	if m.ListTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTenantMock.invocationsDone()
}

// MinimockListTenantInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockListTenantInspect() {
	for _, e := range m.ListTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTenantCounter := mm_atomic.LoadUint64(&m.afterListTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTenantMock.defaultExpectation != nil && afterListTenantCounter < 1 {
		if m.ListTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListTenant at\n%s", m.ListTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.ListTenant at\n%s with params: %#v", m.ListTenantMock.defaultExpectation.expectationOrigins.origin, *m.ListTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTenant != nil && afterListTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.ListTenant at\n%s", m.funcListTenantOrigin)
	}

	if !m.ListTenantMock.invocationsDone() && afterListTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.ListTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTenantMock.expectedInvocations), m.ListTenantMock.expectedInvocationsOrigin, afterListTenantCounter)
	}
}

type mPartitionServiceClientMockRemoveAccess struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockRemoveAccessExpectation
	expectations       []*PartitionServiceClientMockRemoveAccessExpectation

	callArgs []*PartitionServiceClientMockRemoveAccessParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockRemoveAccessExpectation specifies expectation struct of the PartitionServiceClient.RemoveAccess
type PartitionServiceClientMockRemoveAccessExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockRemoveAccessParams
	paramPtrs          *PartitionServiceClientMockRemoveAccessParamPtrs
	expectationOrigins PartitionServiceClientMockRemoveAccessExpectationOrigins
	results            *PartitionServiceClientMockRemoveAccessResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockRemoveAccessParams contains parameters of the PartitionServiceClient.RemoveAccess
type PartitionServiceClientMockRemoveAccessParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveAccessRequest]
}

// PartitionServiceClientMockRemoveAccessParamPtrs contains pointers to parameters of the PartitionServiceClient.RemoveAccess
type PartitionServiceClientMockRemoveAccessParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveAccessRequest]
}

// PartitionServiceClientMockRemoveAccessResults contains results of the PartitionServiceClient.RemoveAccess
type PartitionServiceClientMockRemoveAccessResults struct {
	pp2 *connect.Response[v1.RemoveAccessResponse]
	err error
}

// PartitionServiceClientMockRemoveAccessOrigins contains origins of expectations of the PartitionServiceClient.RemoveAccess
type PartitionServiceClientMockRemoveAccessExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Optional() *mPartitionServiceClientMockRemoveAccess {
	mmRemoveAccess.optional = true
	return mmRemoveAccess
}

// Expect sets up expected params for PartitionServiceClient.RemoveAccess
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) *mPartitionServiceClientMockRemoveAccess {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceClientMockRemoveAccessExpectation{}
	}

	if mmRemoveAccess.defaultExpectation.paramPtrs != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by ExpectParams functions")
	}

	mmRemoveAccess.defaultExpectation.params = &PartitionServiceClientMockRemoveAccessParams{ctx, pp1}
	mmRemoveAccess.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveAccess.expectations {
		if minimock.Equal(e.params, mmRemoveAccess.defaultExpectation.params) {
			mmRemoveAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAccess.defaultExpectation.params)
		}
	}

	return mmRemoveAccess
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.RemoveAccess
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockRemoveAccess {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceClientMockRemoveAccessExpectation{}
	}

	if mmRemoveAccess.defaultExpectation.params != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Expect")
	}

	if mmRemoveAccess.defaultExpectation.paramPtrs == nil {
		mmRemoveAccess.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemoveAccessParamPtrs{}
	}
	mmRemoveAccess.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveAccess.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveAccess
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.RemoveAccess
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveAccessRequest]) *mPartitionServiceClientMockRemoveAccess {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceClientMockRemoveAccessExpectation{}
	}

	if mmRemoveAccess.defaultExpectation.params != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Expect")
	}

	if mmRemoveAccess.defaultExpectation.paramPtrs == nil {
		mmRemoveAccess.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemoveAccessParamPtrs{}
	}
	mmRemoveAccess.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveAccess.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveAccess
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.RemoveAccess
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest])) *mPartitionServiceClientMockRemoveAccess {
	if mmRemoveAccess.mock.inspectFuncRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.RemoveAccess")
	}

	mmRemoveAccess.mock.inspectFuncRemoveAccess = f

	return mmRemoveAccess
}

// Return sets up results that will be returned by PartitionServiceClient.RemoveAccess
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Return(pp2 *connect.Response[v1.RemoveAccessResponse], err error) *PartitionServiceClientMock {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Set")
	}

	if mmRemoveAccess.defaultExpectation == nil {
		mmRemoveAccess.defaultExpectation = &PartitionServiceClientMockRemoveAccessExpectation{mock: mmRemoveAccess.mock}
	}
	mmRemoveAccess.defaultExpectation.results = &PartitionServiceClientMockRemoveAccessResults{pp2, err}
	mmRemoveAccess.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveAccess.mock
}

// Set uses given function f to mock the PartitionServiceClient.RemoveAccess method
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) (pp2 *connect.Response[v1.RemoveAccessResponse], err error)) *PartitionServiceClientMock {
	if mmRemoveAccess.defaultExpectation != nil {
		mmRemoveAccess.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.RemoveAccess method")
	}

	if len(mmRemoveAccess.expectations) > 0 {
		mmRemoveAccess.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.RemoveAccess method")
	}

	mmRemoveAccess.mock.funcRemoveAccess = f
	mmRemoveAccess.mock.funcRemoveAccessOrigin = minimock.CallerInfo(1)
	return mmRemoveAccess.mock
}

// When sets expectation for the PartitionServiceClient.RemoveAccess which will trigger the result defined by the following
// Then helper
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) When(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) *PartitionServiceClientMockRemoveAccessExpectation {
	if mmRemoveAccess.mock.funcRemoveAccess != nil {
		mmRemoveAccess.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccess mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockRemoveAccessExpectation{
		mock:               mmRemoveAccess.mock,
		params:             &PartitionServiceClientMockRemoveAccessParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockRemoveAccessExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveAccess.expectations = append(mmRemoveAccess.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.RemoveAccess return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockRemoveAccessExpectation) Then(pp2 *connect.Response[v1.RemoveAccessResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockRemoveAccessResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.RemoveAccess should be invoked
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Times(n uint64) *mPartitionServiceClientMockRemoveAccess {
	if n == 0 {
		mmRemoveAccess.mock.t.Fatalf("Times of PartitionServiceClientMock.RemoveAccess mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveAccess.expectedInvocations, n)
	mmRemoveAccess.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveAccess
}

func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) invocationsDone() bool {
	if len(mmRemoveAccess.expectations) == 0 && mmRemoveAccess.defaultExpectation == nil && mmRemoveAccess.mock.funcRemoveAccess == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveAccess.mock.afterRemoveAccessCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveAccess.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveAccess implements mm_partitionv1connect.PartitionServiceClient
func (mmRemoveAccess *PartitionServiceClientMock) RemoveAccess(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRequest]) (pp2 *connect.Response[v1.RemoveAccessResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAccess.beforeRemoveAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAccess.afterRemoveAccessCounter, 1)

	mmRemoveAccess.t.Helper()

	if mmRemoveAccess.inspectFuncRemoveAccess != nil {
		mmRemoveAccess.inspectFuncRemoveAccess(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockRemoveAccessParams{ctx, pp1}

	// Record call args
	mmRemoveAccess.RemoveAccessMock.mutex.Lock()
	mmRemoveAccess.RemoveAccessMock.callArgs = append(mmRemoveAccess.RemoveAccessMock.callArgs, &mm_params)
	mmRemoveAccess.RemoveAccessMock.mutex.Unlock()

	for _, e := range mmRemoveAccess.RemoveAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAccess.RemoveAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAccess.RemoveAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAccess.RemoveAccessMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveAccess.RemoveAccessMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockRemoveAccessParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveAccess.t.Errorf("PartitionServiceClientMock.RemoveAccess got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccess.RemoveAccessMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveAccess.t.Errorf("PartitionServiceClientMock.RemoveAccess got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccess.RemoveAccessMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAccess.t.Errorf("PartitionServiceClientMock.RemoveAccess got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveAccess.RemoveAccessMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAccess.RemoveAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAccess.t.Fatal("No results are set for the PartitionServiceClientMock.RemoveAccess")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAccess.funcRemoveAccess != nil {
		return mmRemoveAccess.funcRemoveAccess(ctx, pp1)
	}
	mmRemoveAccess.t.Fatalf("Unexpected call to PartitionServiceClientMock.RemoveAccess. %v %v", ctx, pp1)
	return
}

// RemoveAccessAfterCounter returns a count of finished PartitionServiceClientMock.RemoveAccess invocations
func (mmRemoveAccess *PartitionServiceClientMock) RemoveAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccess.afterRemoveAccessCounter)
}

// RemoveAccessBeforeCounter returns a count of PartitionServiceClientMock.RemoveAccess invocations
func (mmRemoveAccess *PartitionServiceClientMock) RemoveAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccess.beforeRemoveAccessCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.RemoveAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAccess *mPartitionServiceClientMockRemoveAccess) Calls() []*PartitionServiceClientMockRemoveAccessParams {
	mmRemoveAccess.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockRemoveAccessParams, len(mmRemoveAccess.callArgs))
	copy(argCopy, mmRemoveAccess.callArgs)

	mmRemoveAccess.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAccessDone returns true if the count of the RemoveAccess invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockRemoveAccessDone() bool {
	if m.RemoveAccessMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveAccessMock.invocationsDone()
}

// MinimockRemoveAccessInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockRemoveAccessInspect() {
	for _, e := range m.RemoveAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccess at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveAccessCounter := mm_atomic.LoadUint64(&m.afterRemoveAccessCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAccessMock.defaultExpectation != nil && afterRemoveAccessCounter < 1 {
		if m.RemoveAccessMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccess at\n%s", m.RemoveAccessMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccess at\n%s with params: %#v", m.RemoveAccessMock.defaultExpectation.expectationOrigins.origin, *m.RemoveAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAccess != nil && afterRemoveAccessCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccess at\n%s", m.funcRemoveAccessOrigin)
	}

	if !m.RemoveAccessMock.invocationsDone() && afterRemoveAccessCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.RemoveAccess at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveAccessMock.expectedInvocations), m.RemoveAccessMock.expectedInvocationsOrigin, afterRemoveAccessCounter)
	}
}

type mPartitionServiceClientMockRemoveAccessRole struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockRemoveAccessRoleExpectation
	expectations       []*PartitionServiceClientMockRemoveAccessRoleExpectation

	callArgs []*PartitionServiceClientMockRemoveAccessRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockRemoveAccessRoleExpectation specifies expectation struct of the PartitionServiceClient.RemoveAccessRole
type PartitionServiceClientMockRemoveAccessRoleExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockRemoveAccessRoleParams
	paramPtrs          *PartitionServiceClientMockRemoveAccessRoleParamPtrs
	expectationOrigins PartitionServiceClientMockRemoveAccessRoleExpectationOrigins
	results            *PartitionServiceClientMockRemoveAccessRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockRemoveAccessRoleParams contains parameters of the PartitionServiceClient.RemoveAccessRole
type PartitionServiceClientMockRemoveAccessRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemoveAccessRoleRequest]
}

// PartitionServiceClientMockRemoveAccessRoleParamPtrs contains pointers to parameters of the PartitionServiceClient.RemoveAccessRole
type PartitionServiceClientMockRemoveAccessRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemoveAccessRoleRequest]
}

// PartitionServiceClientMockRemoveAccessRoleResults contains results of the PartitionServiceClient.RemoveAccessRole
type PartitionServiceClientMockRemoveAccessRoleResults struct {
	pp2 *connect.Response[v1.RemoveAccessRoleResponse]
	err error
}

// PartitionServiceClientMockRemoveAccessRoleOrigins contains origins of expectations of the PartitionServiceClient.RemoveAccessRole
type PartitionServiceClientMockRemoveAccessRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Optional() *mPartitionServiceClientMockRemoveAccessRole {
	mmRemoveAccessRole.optional = true
	return mmRemoveAccessRole
}

// Expect sets up expected params for PartitionServiceClient.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Expect(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) *mPartitionServiceClientMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceClientMockRemoveAccessRoleExpectation{}
	}

	if mmRemoveAccessRole.defaultExpectation.paramPtrs != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by ExpectParams functions")
	}

	mmRemoveAccessRole.defaultExpectation.params = &PartitionServiceClientMockRemoveAccessRoleParams{ctx, pp1}
	mmRemoveAccessRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveAccessRole.expectations {
		if minimock.Equal(e.params, mmRemoveAccessRole.defaultExpectation.params) {
			mmRemoveAccessRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAccessRole.defaultExpectation.params)
		}
	}

	return mmRemoveAccessRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceClientMockRemoveAccessRoleExpectation{}
	}

	if mmRemoveAccessRole.defaultExpectation.params != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Expect")
	}

	if mmRemoveAccessRole.defaultExpectation.paramPtrs == nil {
		mmRemoveAccessRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemoveAccessRoleParamPtrs{}
	}
	mmRemoveAccessRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveAccessRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveAccessRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) ExpectPp1Param2(pp1 *connect.Request[v1.RemoveAccessRoleRequest]) *mPartitionServiceClientMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceClientMockRemoveAccessRoleExpectation{}
	}

	if mmRemoveAccessRole.defaultExpectation.params != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Expect")
	}

	if mmRemoveAccessRole.defaultExpectation.paramPtrs == nil {
		mmRemoveAccessRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemoveAccessRoleParamPtrs{}
	}
	mmRemoveAccessRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemoveAccessRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemoveAccessRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest])) *mPartitionServiceClientMockRemoveAccessRole {
	if mmRemoveAccessRole.mock.inspectFuncRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.RemoveAccessRole")
	}

	mmRemoveAccessRole.mock.inspectFuncRemoveAccessRole = f

	return mmRemoveAccessRole
}

// Return sets up results that will be returned by PartitionServiceClient.RemoveAccessRole
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Return(pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error) *PartitionServiceClientMock {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Set")
	}

	if mmRemoveAccessRole.defaultExpectation == nil {
		mmRemoveAccessRole.defaultExpectation = &PartitionServiceClientMockRemoveAccessRoleExpectation{mock: mmRemoveAccessRole.mock}
	}
	mmRemoveAccessRole.defaultExpectation.results = &PartitionServiceClientMockRemoveAccessRoleResults{pp2, err}
	mmRemoveAccessRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveAccessRole.mock
}

// Set uses given function f to mock the PartitionServiceClient.RemoveAccessRole method
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) (pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error)) *PartitionServiceClientMock {
	if mmRemoveAccessRole.defaultExpectation != nil {
		mmRemoveAccessRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.RemoveAccessRole method")
	}

	if len(mmRemoveAccessRole.expectations) > 0 {
		mmRemoveAccessRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.RemoveAccessRole method")
	}

	mmRemoveAccessRole.mock.funcRemoveAccessRole = f
	mmRemoveAccessRole.mock.funcRemoveAccessRoleOrigin = minimock.CallerInfo(1)
	return mmRemoveAccessRole.mock
}

// When sets expectation for the PartitionServiceClient.RemoveAccessRole which will trigger the result defined by the following
// Then helper
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) When(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) *PartitionServiceClientMockRemoveAccessRoleExpectation {
	if mmRemoveAccessRole.mock.funcRemoveAccessRole != nil {
		mmRemoveAccessRole.mock.t.Fatalf("PartitionServiceClientMock.RemoveAccessRole mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockRemoveAccessRoleExpectation{
		mock:               mmRemoveAccessRole.mock,
		params:             &PartitionServiceClientMockRemoveAccessRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockRemoveAccessRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveAccessRole.expectations = append(mmRemoveAccessRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.RemoveAccessRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockRemoveAccessRoleExpectation) Then(pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockRemoveAccessRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.RemoveAccessRole should be invoked
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Times(n uint64) *mPartitionServiceClientMockRemoveAccessRole {
	if n == 0 {
		mmRemoveAccessRole.mock.t.Fatalf("Times of PartitionServiceClientMock.RemoveAccessRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveAccessRole.expectedInvocations, n)
	mmRemoveAccessRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveAccessRole
}

func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) invocationsDone() bool {
	if len(mmRemoveAccessRole.expectations) == 0 && mmRemoveAccessRole.defaultExpectation == nil && mmRemoveAccessRole.mock.funcRemoveAccessRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveAccessRole.mock.afterRemoveAccessRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveAccessRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveAccessRole implements mm_partitionv1connect.PartitionServiceClient
func (mmRemoveAccessRole *PartitionServiceClientMock) RemoveAccessRole(ctx context.Context, pp1 *connect.Request[v1.RemoveAccessRoleRequest]) (pp2 *connect.Response[v1.RemoveAccessRoleResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAccessRole.beforeRemoveAccessRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAccessRole.afterRemoveAccessRoleCounter, 1)

	mmRemoveAccessRole.t.Helper()

	if mmRemoveAccessRole.inspectFuncRemoveAccessRole != nil {
		mmRemoveAccessRole.inspectFuncRemoveAccessRole(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockRemoveAccessRoleParams{ctx, pp1}

	// Record call args
	mmRemoveAccessRole.RemoveAccessRoleMock.mutex.Lock()
	mmRemoveAccessRole.RemoveAccessRoleMock.callArgs = append(mmRemoveAccessRole.RemoveAccessRoleMock.callArgs, &mm_params)
	mmRemoveAccessRole.RemoveAccessRoleMock.mutex.Unlock()

	for _, e := range mmRemoveAccessRole.RemoveAccessRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockRemoveAccessRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveAccessRole.t.Errorf("PartitionServiceClientMock.RemoveAccessRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemoveAccessRole.t.Errorf("PartitionServiceClientMock.RemoveAccessRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAccessRole.t.Errorf("PartitionServiceClientMock.RemoveAccessRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAccessRole.RemoveAccessRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAccessRole.t.Fatal("No results are set for the PartitionServiceClientMock.RemoveAccessRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAccessRole.funcRemoveAccessRole != nil {
		return mmRemoveAccessRole.funcRemoveAccessRole(ctx, pp1)
	}
	mmRemoveAccessRole.t.Fatalf("Unexpected call to PartitionServiceClientMock.RemoveAccessRole. %v %v", ctx, pp1)
	return
}

// RemoveAccessRoleAfterCounter returns a count of finished PartitionServiceClientMock.RemoveAccessRole invocations
func (mmRemoveAccessRole *PartitionServiceClientMock) RemoveAccessRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccessRole.afterRemoveAccessRoleCounter)
}

// RemoveAccessRoleBeforeCounter returns a count of PartitionServiceClientMock.RemoveAccessRole invocations
func (mmRemoveAccessRole *PartitionServiceClientMock) RemoveAccessRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAccessRole.beforeRemoveAccessRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.RemoveAccessRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAccessRole *mPartitionServiceClientMockRemoveAccessRole) Calls() []*PartitionServiceClientMockRemoveAccessRoleParams {
	mmRemoveAccessRole.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockRemoveAccessRoleParams, len(mmRemoveAccessRole.callArgs))
	copy(argCopy, mmRemoveAccessRole.callArgs)

	mmRemoveAccessRole.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAccessRoleDone returns true if the count of the RemoveAccessRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockRemoveAccessRoleDone() bool {
	if m.RemoveAccessRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveAccessRoleMock.invocationsDone()
}

// MinimockRemoveAccessRoleInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockRemoveAccessRoleInspect() {
	for _, e := range m.RemoveAccessRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccessRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveAccessRoleCounter := mm_atomic.LoadUint64(&m.afterRemoveAccessRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAccessRoleMock.defaultExpectation != nil && afterRemoveAccessRoleCounter < 1 {
		if m.RemoveAccessRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccessRole at\n%s", m.RemoveAccessRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccessRole at\n%s with params: %#v", m.RemoveAccessRoleMock.defaultExpectation.expectationOrigins.origin, *m.RemoveAccessRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAccessRole != nil && afterRemoveAccessRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.RemoveAccessRole at\n%s", m.funcRemoveAccessRoleOrigin)
	}

	if !m.RemoveAccessRoleMock.invocationsDone() && afterRemoveAccessRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.RemoveAccessRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveAccessRoleMock.expectedInvocations), m.RemoveAccessRoleMock.expectedInvocationsOrigin, afterRemoveAccessRoleCounter)
	}
}

type mPartitionServiceClientMockRemovePage struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockRemovePageExpectation
	expectations       []*PartitionServiceClientMockRemovePageExpectation

	callArgs []*PartitionServiceClientMockRemovePageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockRemovePageExpectation specifies expectation struct of the PartitionServiceClient.RemovePage
type PartitionServiceClientMockRemovePageExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockRemovePageParams
	paramPtrs          *PartitionServiceClientMockRemovePageParamPtrs
	expectationOrigins PartitionServiceClientMockRemovePageExpectationOrigins
	results            *PartitionServiceClientMockRemovePageResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockRemovePageParams contains parameters of the PartitionServiceClient.RemovePage
type PartitionServiceClientMockRemovePageParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemovePageRequest]
}

// PartitionServiceClientMockRemovePageParamPtrs contains pointers to parameters of the PartitionServiceClient.RemovePage
type PartitionServiceClientMockRemovePageParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemovePageRequest]
}

// PartitionServiceClientMockRemovePageResults contains results of the PartitionServiceClient.RemovePage
type PartitionServiceClientMockRemovePageResults struct {
	pp2 *connect.Response[v1.RemovePageResponse]
	err error
}

// PartitionServiceClientMockRemovePageOrigins contains origins of expectations of the PartitionServiceClient.RemovePage
type PartitionServiceClientMockRemovePageExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Optional() *mPartitionServiceClientMockRemovePage {
	mmRemovePage.optional = true
	return mmRemovePage
}

// Expect sets up expected params for PartitionServiceClient.RemovePage
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Expect(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) *mPartitionServiceClientMockRemovePage {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceClientMockRemovePageExpectation{}
	}

	if mmRemovePage.defaultExpectation.paramPtrs != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by ExpectParams functions")
	}

	mmRemovePage.defaultExpectation.params = &PartitionServiceClientMockRemovePageParams{ctx, pp1}
	mmRemovePage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemovePage.expectations {
		if minimock.Equal(e.params, mmRemovePage.defaultExpectation.params) {
			mmRemovePage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemovePage.defaultExpectation.params)
		}
	}

	return mmRemovePage
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.RemovePage
func (mmRemovePage *mPartitionServiceClientMockRemovePage) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockRemovePage {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceClientMockRemovePageExpectation{}
	}

	if mmRemovePage.defaultExpectation.params != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Expect")
	}

	if mmRemovePage.defaultExpectation.paramPtrs == nil {
		mmRemovePage.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemovePageParamPtrs{}
	}
	mmRemovePage.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemovePage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemovePage
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.RemovePage
func (mmRemovePage *mPartitionServiceClientMockRemovePage) ExpectPp1Param2(pp1 *connect.Request[v1.RemovePageRequest]) *mPartitionServiceClientMockRemovePage {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceClientMockRemovePageExpectation{}
	}

	if mmRemovePage.defaultExpectation.params != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Expect")
	}

	if mmRemovePage.defaultExpectation.paramPtrs == nil {
		mmRemovePage.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemovePageParamPtrs{}
	}
	mmRemovePage.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemovePage.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemovePage
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.RemovePage
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest])) *mPartitionServiceClientMockRemovePage {
	if mmRemovePage.mock.inspectFuncRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.RemovePage")
	}

	mmRemovePage.mock.inspectFuncRemovePage = f

	return mmRemovePage
}

// Return sets up results that will be returned by PartitionServiceClient.RemovePage
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Return(pp2 *connect.Response[v1.RemovePageResponse], err error) *PartitionServiceClientMock {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Set")
	}

	if mmRemovePage.defaultExpectation == nil {
		mmRemovePage.defaultExpectation = &PartitionServiceClientMockRemovePageExpectation{mock: mmRemovePage.mock}
	}
	mmRemovePage.defaultExpectation.results = &PartitionServiceClientMockRemovePageResults{pp2, err}
	mmRemovePage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemovePage.mock
}

// Set uses given function f to mock the PartitionServiceClient.RemovePage method
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) (pp2 *connect.Response[v1.RemovePageResponse], err error)) *PartitionServiceClientMock {
	if mmRemovePage.defaultExpectation != nil {
		mmRemovePage.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.RemovePage method")
	}

	if len(mmRemovePage.expectations) > 0 {
		mmRemovePage.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.RemovePage method")
	}

	mmRemovePage.mock.funcRemovePage = f
	mmRemovePage.mock.funcRemovePageOrigin = minimock.CallerInfo(1)
	return mmRemovePage.mock
}

// When sets expectation for the PartitionServiceClient.RemovePage which will trigger the result defined by the following
// Then helper
func (mmRemovePage *mPartitionServiceClientMockRemovePage) When(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) *PartitionServiceClientMockRemovePageExpectation {
	if mmRemovePage.mock.funcRemovePage != nil {
		mmRemovePage.mock.t.Fatalf("PartitionServiceClientMock.RemovePage mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockRemovePageExpectation{
		mock:               mmRemovePage.mock,
		params:             &PartitionServiceClientMockRemovePageParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockRemovePageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemovePage.expectations = append(mmRemovePage.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.RemovePage return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockRemovePageExpectation) Then(pp2 *connect.Response[v1.RemovePageResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockRemovePageResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.RemovePage should be invoked
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Times(n uint64) *mPartitionServiceClientMockRemovePage {
	if n == 0 {
		mmRemovePage.mock.t.Fatalf("Times of PartitionServiceClientMock.RemovePage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemovePage.expectedInvocations, n)
	mmRemovePage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemovePage
}

func (mmRemovePage *mPartitionServiceClientMockRemovePage) invocationsDone() bool {
	if len(mmRemovePage.expectations) == 0 && mmRemovePage.defaultExpectation == nil && mmRemovePage.mock.funcRemovePage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemovePage.mock.afterRemovePageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemovePage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemovePage implements mm_partitionv1connect.PartitionServiceClient
func (mmRemovePage *PartitionServiceClientMock) RemovePage(ctx context.Context, pp1 *connect.Request[v1.RemovePageRequest]) (pp2 *connect.Response[v1.RemovePageResponse], err error) {
	mm_atomic.AddUint64(&mmRemovePage.beforeRemovePageCounter, 1)
	defer mm_atomic.AddUint64(&mmRemovePage.afterRemovePageCounter, 1)

	mmRemovePage.t.Helper()

	if mmRemovePage.inspectFuncRemovePage != nil {
		mmRemovePage.inspectFuncRemovePage(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockRemovePageParams{ctx, pp1}

	// Record call args
	mmRemovePage.RemovePageMock.mutex.Lock()
	mmRemovePage.RemovePageMock.callArgs = append(mmRemovePage.RemovePageMock.callArgs, &mm_params)
	mmRemovePage.RemovePageMock.mutex.Unlock()

	for _, e := range mmRemovePage.RemovePageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemovePage.RemovePageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemovePage.RemovePageMock.defaultExpectation.Counter, 1)
		mm_want := mmRemovePage.RemovePageMock.defaultExpectation.params
		mm_want_ptrs := mmRemovePage.RemovePageMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockRemovePageParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemovePage.t.Errorf("PartitionServiceClientMock.RemovePage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePage.RemovePageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemovePage.t.Errorf("PartitionServiceClientMock.RemovePage got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePage.RemovePageMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemovePage.t.Errorf("PartitionServiceClientMock.RemovePage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemovePage.RemovePageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemovePage.RemovePageMock.defaultExpectation.results
		if mm_results == nil {
			mmRemovePage.t.Fatal("No results are set for the PartitionServiceClientMock.RemovePage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemovePage.funcRemovePage != nil {
		return mmRemovePage.funcRemovePage(ctx, pp1)
	}
	mmRemovePage.t.Fatalf("Unexpected call to PartitionServiceClientMock.RemovePage. %v %v", ctx, pp1)
	return
}

// RemovePageAfterCounter returns a count of finished PartitionServiceClientMock.RemovePage invocations
func (mmRemovePage *PartitionServiceClientMock) RemovePageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePage.afterRemovePageCounter)
}

// RemovePageBeforeCounter returns a count of PartitionServiceClientMock.RemovePage invocations
func (mmRemovePage *PartitionServiceClientMock) RemovePageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePage.beforeRemovePageCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.RemovePage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemovePage *mPartitionServiceClientMockRemovePage) Calls() []*PartitionServiceClientMockRemovePageParams {
	mmRemovePage.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockRemovePageParams, len(mmRemovePage.callArgs))
	copy(argCopy, mmRemovePage.callArgs)

	mmRemovePage.mutex.RUnlock()

	return argCopy
}

// MinimockRemovePageDone returns true if the count of the RemovePage invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockRemovePageDone() bool {
	if m.RemovePageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemovePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemovePageMock.invocationsDone()
}

// MinimockRemovePageInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockRemovePageInspect() {
	for _, e := range m.RemovePageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemovePageCounter := mm_atomic.LoadUint64(&m.afterRemovePageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemovePageMock.defaultExpectation != nil && afterRemovePageCounter < 1 {
		if m.RemovePageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePage at\n%s", m.RemovePageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePage at\n%s with params: %#v", m.RemovePageMock.defaultExpectation.expectationOrigins.origin, *m.RemovePageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemovePage != nil && afterRemovePageCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePage at\n%s", m.funcRemovePageOrigin)
	}

	if !m.RemovePageMock.invocationsDone() && afterRemovePageCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.RemovePage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemovePageMock.expectedInvocations), m.RemovePageMock.expectedInvocationsOrigin, afterRemovePageCounter)
	}
}

type mPartitionServiceClientMockRemovePartitionRole struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockRemovePartitionRoleExpectation
	expectations       []*PartitionServiceClientMockRemovePartitionRoleExpectation

	callArgs []*PartitionServiceClientMockRemovePartitionRoleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockRemovePartitionRoleExpectation specifies expectation struct of the PartitionServiceClient.RemovePartitionRole
type PartitionServiceClientMockRemovePartitionRoleExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockRemovePartitionRoleParams
	paramPtrs          *PartitionServiceClientMockRemovePartitionRoleParamPtrs
	expectationOrigins PartitionServiceClientMockRemovePartitionRoleExpectationOrigins
	results            *PartitionServiceClientMockRemovePartitionRoleResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockRemovePartitionRoleParams contains parameters of the PartitionServiceClient.RemovePartitionRole
type PartitionServiceClientMockRemovePartitionRoleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.RemovePartitionRoleRequest]
}

// PartitionServiceClientMockRemovePartitionRoleParamPtrs contains pointers to parameters of the PartitionServiceClient.RemovePartitionRole
type PartitionServiceClientMockRemovePartitionRoleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.RemovePartitionRoleRequest]
}

// PartitionServiceClientMockRemovePartitionRoleResults contains results of the PartitionServiceClient.RemovePartitionRole
type PartitionServiceClientMockRemovePartitionRoleResults struct {
	pp2 *connect.Response[v1.RemovePartitionRoleResponse]
	err error
}

// PartitionServiceClientMockRemovePartitionRoleOrigins contains origins of expectations of the PartitionServiceClient.RemovePartitionRole
type PartitionServiceClientMockRemovePartitionRoleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Optional() *mPartitionServiceClientMockRemovePartitionRole {
	mmRemovePartitionRole.optional = true
	return mmRemovePartitionRole
}

// Expect sets up expected params for PartitionServiceClient.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Expect(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) *mPartitionServiceClientMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceClientMockRemovePartitionRoleExpectation{}
	}

	if mmRemovePartitionRole.defaultExpectation.paramPtrs != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by ExpectParams functions")
	}

	mmRemovePartitionRole.defaultExpectation.params = &PartitionServiceClientMockRemovePartitionRoleParams{ctx, pp1}
	mmRemovePartitionRole.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemovePartitionRole.expectations {
		if minimock.Equal(e.params, mmRemovePartitionRole.defaultExpectation.params) {
			mmRemovePartitionRole.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemovePartitionRole.defaultExpectation.params)
		}
	}

	return mmRemovePartitionRole
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceClientMockRemovePartitionRoleExpectation{}
	}

	if mmRemovePartitionRole.defaultExpectation.params != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Expect")
	}

	if mmRemovePartitionRole.defaultExpectation.paramPtrs == nil {
		mmRemovePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemovePartitionRoleParamPtrs{}
	}
	mmRemovePartitionRole.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemovePartitionRole.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemovePartitionRole
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) ExpectPp1Param2(pp1 *connect.Request[v1.RemovePartitionRoleRequest]) *mPartitionServiceClientMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceClientMockRemovePartitionRoleExpectation{}
	}

	if mmRemovePartitionRole.defaultExpectation.params != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Expect")
	}

	if mmRemovePartitionRole.defaultExpectation.paramPtrs == nil {
		mmRemovePartitionRole.defaultExpectation.paramPtrs = &PartitionServiceClientMockRemovePartitionRoleParamPtrs{}
	}
	mmRemovePartitionRole.defaultExpectation.paramPtrs.pp1 = &pp1
	mmRemovePartitionRole.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmRemovePartitionRole
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest])) *mPartitionServiceClientMockRemovePartitionRole {
	if mmRemovePartitionRole.mock.inspectFuncRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.RemovePartitionRole")
	}

	mmRemovePartitionRole.mock.inspectFuncRemovePartitionRole = f

	return mmRemovePartitionRole
}

// Return sets up results that will be returned by PartitionServiceClient.RemovePartitionRole
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Return(pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error) *PartitionServiceClientMock {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Set")
	}

	if mmRemovePartitionRole.defaultExpectation == nil {
		mmRemovePartitionRole.defaultExpectation = &PartitionServiceClientMockRemovePartitionRoleExpectation{mock: mmRemovePartitionRole.mock}
	}
	mmRemovePartitionRole.defaultExpectation.results = &PartitionServiceClientMockRemovePartitionRoleResults{pp2, err}
	mmRemovePartitionRole.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemovePartitionRole.mock
}

// Set uses given function f to mock the PartitionServiceClient.RemovePartitionRole method
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Set(f func(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) (pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error)) *PartitionServiceClientMock {
	if mmRemovePartitionRole.defaultExpectation != nil {
		mmRemovePartitionRole.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.RemovePartitionRole method")
	}

	if len(mmRemovePartitionRole.expectations) > 0 {
		mmRemovePartitionRole.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.RemovePartitionRole method")
	}

	mmRemovePartitionRole.mock.funcRemovePartitionRole = f
	mmRemovePartitionRole.mock.funcRemovePartitionRoleOrigin = minimock.CallerInfo(1)
	return mmRemovePartitionRole.mock
}

// When sets expectation for the PartitionServiceClient.RemovePartitionRole which will trigger the result defined by the following
// Then helper
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) When(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) *PartitionServiceClientMockRemovePartitionRoleExpectation {
	if mmRemovePartitionRole.mock.funcRemovePartitionRole != nil {
		mmRemovePartitionRole.mock.t.Fatalf("PartitionServiceClientMock.RemovePartitionRole mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockRemovePartitionRoleExpectation{
		mock:               mmRemovePartitionRole.mock,
		params:             &PartitionServiceClientMockRemovePartitionRoleParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockRemovePartitionRoleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemovePartitionRole.expectations = append(mmRemovePartitionRole.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.RemovePartitionRole return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockRemovePartitionRoleExpectation) Then(pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockRemovePartitionRoleResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.RemovePartitionRole should be invoked
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Times(n uint64) *mPartitionServiceClientMockRemovePartitionRole {
	if n == 0 {
		mmRemovePartitionRole.mock.t.Fatalf("Times of PartitionServiceClientMock.RemovePartitionRole mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemovePartitionRole.expectedInvocations, n)
	mmRemovePartitionRole.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemovePartitionRole
}

func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) invocationsDone() bool {
	if len(mmRemovePartitionRole.expectations) == 0 && mmRemovePartitionRole.defaultExpectation == nil && mmRemovePartitionRole.mock.funcRemovePartitionRole == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemovePartitionRole.mock.afterRemovePartitionRoleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemovePartitionRole.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemovePartitionRole implements mm_partitionv1connect.PartitionServiceClient
func (mmRemovePartitionRole *PartitionServiceClientMock) RemovePartitionRole(ctx context.Context, pp1 *connect.Request[v1.RemovePartitionRoleRequest]) (pp2 *connect.Response[v1.RemovePartitionRoleResponse], err error) {
	mm_atomic.AddUint64(&mmRemovePartitionRole.beforeRemovePartitionRoleCounter, 1)
	defer mm_atomic.AddUint64(&mmRemovePartitionRole.afterRemovePartitionRoleCounter, 1)

	mmRemovePartitionRole.t.Helper()

	if mmRemovePartitionRole.inspectFuncRemovePartitionRole != nil {
		mmRemovePartitionRole.inspectFuncRemovePartitionRole(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockRemovePartitionRoleParams{ctx, pp1}

	// Record call args
	mmRemovePartitionRole.RemovePartitionRoleMock.mutex.Lock()
	mmRemovePartitionRole.RemovePartitionRoleMock.callArgs = append(mmRemovePartitionRole.RemovePartitionRoleMock.callArgs, &mm_params)
	mmRemovePartitionRole.RemovePartitionRoleMock.mutex.Unlock()

	for _, e := range mmRemovePartitionRole.RemovePartitionRoleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.Counter, 1)
		mm_want := mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.params
		mm_want_ptrs := mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockRemovePartitionRoleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemovePartitionRole.t.Errorf("PartitionServiceClientMock.RemovePartitionRole got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmRemovePartitionRole.t.Errorf("PartitionServiceClientMock.RemovePartitionRole got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemovePartitionRole.t.Errorf("PartitionServiceClientMock.RemovePartitionRole got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemovePartitionRole.RemovePartitionRoleMock.defaultExpectation.results
		if mm_results == nil {
			mmRemovePartitionRole.t.Fatal("No results are set for the PartitionServiceClientMock.RemovePartitionRole")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemovePartitionRole.funcRemovePartitionRole != nil {
		return mmRemovePartitionRole.funcRemovePartitionRole(ctx, pp1)
	}
	mmRemovePartitionRole.t.Fatalf("Unexpected call to PartitionServiceClientMock.RemovePartitionRole. %v %v", ctx, pp1)
	return
}

// RemovePartitionRoleAfterCounter returns a count of finished PartitionServiceClientMock.RemovePartitionRole invocations
func (mmRemovePartitionRole *PartitionServiceClientMock) RemovePartitionRoleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePartitionRole.afterRemovePartitionRoleCounter)
}

// RemovePartitionRoleBeforeCounter returns a count of PartitionServiceClientMock.RemovePartitionRole invocations
func (mmRemovePartitionRole *PartitionServiceClientMock) RemovePartitionRoleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemovePartitionRole.beforeRemovePartitionRoleCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.RemovePartitionRole.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemovePartitionRole *mPartitionServiceClientMockRemovePartitionRole) Calls() []*PartitionServiceClientMockRemovePartitionRoleParams {
	mmRemovePartitionRole.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockRemovePartitionRoleParams, len(mmRemovePartitionRole.callArgs))
	copy(argCopy, mmRemovePartitionRole.callArgs)

	mmRemovePartitionRole.mutex.RUnlock()

	return argCopy
}

// MinimockRemovePartitionRoleDone returns true if the count of the RemovePartitionRole invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockRemovePartitionRoleDone() bool {
	if m.RemovePartitionRoleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemovePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemovePartitionRoleMock.invocationsDone()
}

// MinimockRemovePartitionRoleInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockRemovePartitionRoleInspect() {
	for _, e := range m.RemovePartitionRoleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePartitionRole at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemovePartitionRoleCounter := mm_atomic.LoadUint64(&m.afterRemovePartitionRoleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemovePartitionRoleMock.defaultExpectation != nil && afterRemovePartitionRoleCounter < 1 {
		if m.RemovePartitionRoleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePartitionRole at\n%s", m.RemovePartitionRoleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePartitionRole at\n%s with params: %#v", m.RemovePartitionRoleMock.defaultExpectation.expectationOrigins.origin, *m.RemovePartitionRoleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemovePartitionRole != nil && afterRemovePartitionRoleCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.RemovePartitionRole at\n%s", m.funcRemovePartitionRoleOrigin)
	}

	if !m.RemovePartitionRoleMock.invocationsDone() && afterRemovePartitionRoleCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.RemovePartitionRole at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemovePartitionRoleMock.expectedInvocations), m.RemovePartitionRoleMock.expectedInvocationsOrigin, afterRemovePartitionRoleCounter)
	}
}

type mPartitionServiceClientMockUpdatePartition struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockUpdatePartitionExpectation
	expectations       []*PartitionServiceClientMockUpdatePartitionExpectation

	callArgs []*PartitionServiceClientMockUpdatePartitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockUpdatePartitionExpectation specifies expectation struct of the PartitionServiceClient.UpdatePartition
type PartitionServiceClientMockUpdatePartitionExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockUpdatePartitionParams
	paramPtrs          *PartitionServiceClientMockUpdatePartitionParamPtrs
	expectationOrigins PartitionServiceClientMockUpdatePartitionExpectationOrigins
	results            *PartitionServiceClientMockUpdatePartitionResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockUpdatePartitionParams contains parameters of the PartitionServiceClient.UpdatePartition
type PartitionServiceClientMockUpdatePartitionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdatePartitionRequest]
}

// PartitionServiceClientMockUpdatePartitionParamPtrs contains pointers to parameters of the PartitionServiceClient.UpdatePartition
type PartitionServiceClientMockUpdatePartitionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdatePartitionRequest]
}

// PartitionServiceClientMockUpdatePartitionResults contains results of the PartitionServiceClient.UpdatePartition
type PartitionServiceClientMockUpdatePartitionResults struct {
	pp2 *connect.Response[v1.UpdatePartitionResponse]
	err error
}

// PartitionServiceClientMockUpdatePartitionOrigins contains origins of expectations of the PartitionServiceClient.UpdatePartition
type PartitionServiceClientMockUpdatePartitionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Optional() *mPartitionServiceClientMockUpdatePartition {
	mmUpdatePartition.optional = true
	return mmUpdatePartition
}

// Expect sets up expected params for PartitionServiceClient.UpdatePartition
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) *mPartitionServiceClientMockUpdatePartition {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceClientMockUpdatePartitionExpectation{}
	}

	if mmUpdatePartition.defaultExpectation.paramPtrs != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by ExpectParams functions")
	}

	mmUpdatePartition.defaultExpectation.params = &PartitionServiceClientMockUpdatePartitionParams{ctx, pp1}
	mmUpdatePartition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdatePartition.expectations {
		if minimock.Equal(e.params, mmUpdatePartition.defaultExpectation.params) {
			mmUpdatePartition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePartition.defaultExpectation.params)
		}
	}

	return mmUpdatePartition
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.UpdatePartition
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockUpdatePartition {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceClientMockUpdatePartitionExpectation{}
	}

	if mmUpdatePartition.defaultExpectation.params != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Expect")
	}

	if mmUpdatePartition.defaultExpectation.paramPtrs == nil {
		mmUpdatePartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockUpdatePartitionParamPtrs{}
	}
	mmUpdatePartition.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdatePartition.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdatePartition
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.UpdatePartition
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) ExpectPp1Param2(pp1 *connect.Request[v1.UpdatePartitionRequest]) *mPartitionServiceClientMockUpdatePartition {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceClientMockUpdatePartitionExpectation{}
	}

	if mmUpdatePartition.defaultExpectation.params != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Expect")
	}

	if mmUpdatePartition.defaultExpectation.paramPtrs == nil {
		mmUpdatePartition.defaultExpectation.paramPtrs = &PartitionServiceClientMockUpdatePartitionParamPtrs{}
	}
	mmUpdatePartition.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdatePartition.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdatePartition
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.UpdatePartition
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest])) *mPartitionServiceClientMockUpdatePartition {
	if mmUpdatePartition.mock.inspectFuncUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.UpdatePartition")
	}

	mmUpdatePartition.mock.inspectFuncUpdatePartition = f

	return mmUpdatePartition
}

// Return sets up results that will be returned by PartitionServiceClient.UpdatePartition
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Return(pp2 *connect.Response[v1.UpdatePartitionResponse], err error) *PartitionServiceClientMock {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Set")
	}

	if mmUpdatePartition.defaultExpectation == nil {
		mmUpdatePartition.defaultExpectation = &PartitionServiceClientMockUpdatePartitionExpectation{mock: mmUpdatePartition.mock}
	}
	mmUpdatePartition.defaultExpectation.results = &PartitionServiceClientMockUpdatePartitionResults{pp2, err}
	mmUpdatePartition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdatePartition.mock
}

// Set uses given function f to mock the PartitionServiceClient.UpdatePartition method
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) (pp2 *connect.Response[v1.UpdatePartitionResponse], err error)) *PartitionServiceClientMock {
	if mmUpdatePartition.defaultExpectation != nil {
		mmUpdatePartition.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.UpdatePartition method")
	}

	if len(mmUpdatePartition.expectations) > 0 {
		mmUpdatePartition.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.UpdatePartition method")
	}

	mmUpdatePartition.mock.funcUpdatePartition = f
	mmUpdatePartition.mock.funcUpdatePartitionOrigin = minimock.CallerInfo(1)
	return mmUpdatePartition.mock
}

// When sets expectation for the PartitionServiceClient.UpdatePartition which will trigger the result defined by the following
// Then helper
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) When(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) *PartitionServiceClientMockUpdatePartitionExpectation {
	if mmUpdatePartition.mock.funcUpdatePartition != nil {
		mmUpdatePartition.mock.t.Fatalf("PartitionServiceClientMock.UpdatePartition mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockUpdatePartitionExpectation{
		mock:               mmUpdatePartition.mock,
		params:             &PartitionServiceClientMockUpdatePartitionParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockUpdatePartitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdatePartition.expectations = append(mmUpdatePartition.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.UpdatePartition return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockUpdatePartitionExpectation) Then(pp2 *connect.Response[v1.UpdatePartitionResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockUpdatePartitionResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.UpdatePartition should be invoked
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Times(n uint64) *mPartitionServiceClientMockUpdatePartition {
	if n == 0 {
		mmUpdatePartition.mock.t.Fatalf("Times of PartitionServiceClientMock.UpdatePartition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdatePartition.expectedInvocations, n)
	mmUpdatePartition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdatePartition
}

func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) invocationsDone() bool {
	if len(mmUpdatePartition.expectations) == 0 && mmUpdatePartition.defaultExpectation == nil && mmUpdatePartition.mock.funcUpdatePartition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdatePartition.mock.afterUpdatePartitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdatePartition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdatePartition implements mm_partitionv1connect.PartitionServiceClient
func (mmUpdatePartition *PartitionServiceClientMock) UpdatePartition(ctx context.Context, pp1 *connect.Request[v1.UpdatePartitionRequest]) (pp2 *connect.Response[v1.UpdatePartitionResponse], err error) {
	mm_atomic.AddUint64(&mmUpdatePartition.beforeUpdatePartitionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePartition.afterUpdatePartitionCounter, 1)

	mmUpdatePartition.t.Helper()

	if mmUpdatePartition.inspectFuncUpdatePartition != nil {
		mmUpdatePartition.inspectFuncUpdatePartition(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockUpdatePartitionParams{ctx, pp1}

	// Record call args
	mmUpdatePartition.UpdatePartitionMock.mutex.Lock()
	mmUpdatePartition.UpdatePartitionMock.callArgs = append(mmUpdatePartition.UpdatePartitionMock.callArgs, &mm_params)
	mmUpdatePartition.UpdatePartitionMock.mutex.Unlock()

	for _, e := range mmUpdatePartition.UpdatePartitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdatePartition.UpdatePartitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePartition.UpdatePartitionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePartition.UpdatePartitionMock.defaultExpectation.params
		mm_want_ptrs := mmUpdatePartition.UpdatePartitionMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockUpdatePartitionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdatePartition.t.Errorf("PartitionServiceClientMock.UpdatePartition got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePartition.UpdatePartitionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdatePartition.t.Errorf("PartitionServiceClientMock.UpdatePartition got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdatePartition.UpdatePartitionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePartition.t.Errorf("PartitionServiceClientMock.UpdatePartition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdatePartition.UpdatePartitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePartition.UpdatePartitionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePartition.t.Fatal("No results are set for the PartitionServiceClientMock.UpdatePartition")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdatePartition.funcUpdatePartition != nil {
		return mmUpdatePartition.funcUpdatePartition(ctx, pp1)
	}
	mmUpdatePartition.t.Fatalf("Unexpected call to PartitionServiceClientMock.UpdatePartition. %v %v", ctx, pp1)
	return
}

// UpdatePartitionAfterCounter returns a count of finished PartitionServiceClientMock.UpdatePartition invocations
func (mmUpdatePartition *PartitionServiceClientMock) UpdatePartitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePartition.afterUpdatePartitionCounter)
}

// UpdatePartitionBeforeCounter returns a count of PartitionServiceClientMock.UpdatePartition invocations
func (mmUpdatePartition *PartitionServiceClientMock) UpdatePartitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePartition.beforeUpdatePartitionCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.UpdatePartition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePartition *mPartitionServiceClientMockUpdatePartition) Calls() []*PartitionServiceClientMockUpdatePartitionParams {
	mmUpdatePartition.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockUpdatePartitionParams, len(mmUpdatePartition.callArgs))
	copy(argCopy, mmUpdatePartition.callArgs)

	mmUpdatePartition.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePartitionDone returns true if the count of the UpdatePartition invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockUpdatePartitionDone() bool {
	if m.UpdatePartitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePartitionMock.invocationsDone()
}

// MinimockUpdatePartitionInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockUpdatePartitionInspect() {
	for _, e := range m.UpdatePartitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.UpdatePartition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePartitionCounter := mm_atomic.LoadUint64(&m.afterUpdatePartitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePartitionMock.defaultExpectation != nil && afterUpdatePartitionCounter < 1 {
		if m.UpdatePartitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.UpdatePartition at\n%s", m.UpdatePartitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.UpdatePartition at\n%s with params: %#v", m.UpdatePartitionMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePartitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePartition != nil && afterUpdatePartitionCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.UpdatePartition at\n%s", m.funcUpdatePartitionOrigin)
	}

	if !m.UpdatePartitionMock.invocationsDone() && afterUpdatePartitionCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.UpdatePartition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePartitionMock.expectedInvocations), m.UpdatePartitionMock.expectedInvocationsOrigin, afterUpdatePartitionCounter)
	}
}

type mPartitionServiceClientMockUpdateTenant struct {
	optional           bool
	mock               *PartitionServiceClientMock
	defaultExpectation *PartitionServiceClientMockUpdateTenantExpectation
	expectations       []*PartitionServiceClientMockUpdateTenantExpectation

	callArgs []*PartitionServiceClientMockUpdateTenantParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PartitionServiceClientMockUpdateTenantExpectation specifies expectation struct of the PartitionServiceClient.UpdateTenant
type PartitionServiceClientMockUpdateTenantExpectation struct {
	mock               *PartitionServiceClientMock
	params             *PartitionServiceClientMockUpdateTenantParams
	paramPtrs          *PartitionServiceClientMockUpdateTenantParamPtrs
	expectationOrigins PartitionServiceClientMockUpdateTenantExpectationOrigins
	results            *PartitionServiceClientMockUpdateTenantResults
	returnOrigin       string
	Counter            uint64
}

// PartitionServiceClientMockUpdateTenantParams contains parameters of the PartitionServiceClient.UpdateTenant
type PartitionServiceClientMockUpdateTenantParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdateTenantRequest]
}

// PartitionServiceClientMockUpdateTenantParamPtrs contains pointers to parameters of the PartitionServiceClient.UpdateTenant
type PartitionServiceClientMockUpdateTenantParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdateTenantRequest]
}

// PartitionServiceClientMockUpdateTenantResults contains results of the PartitionServiceClient.UpdateTenant
type PartitionServiceClientMockUpdateTenantResults struct {
	pp2 *connect.Response[v1.UpdateTenantResponse]
	err error
}

// PartitionServiceClientMockUpdateTenantOrigins contains origins of expectations of the PartitionServiceClient.UpdateTenant
type PartitionServiceClientMockUpdateTenantExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Optional() *mPartitionServiceClientMockUpdateTenant {
	mmUpdateTenant.optional = true
	return mmUpdateTenant
}

// Expect sets up expected params for PartitionServiceClient.UpdateTenant
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) *mPartitionServiceClientMockUpdateTenant {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceClientMockUpdateTenantExpectation{}
	}

	if mmUpdateTenant.defaultExpectation.paramPtrs != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by ExpectParams functions")
	}

	mmUpdateTenant.defaultExpectation.params = &PartitionServiceClientMockUpdateTenantParams{ctx, pp1}
	mmUpdateTenant.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTenant.expectations {
		if minimock.Equal(e.params, mmUpdateTenant.defaultExpectation.params) {
			mmUpdateTenant.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTenant.defaultExpectation.params)
		}
	}

	return mmUpdateTenant
}

// ExpectCtxParam1 sets up expected param ctx for PartitionServiceClient.UpdateTenant
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) ExpectCtxParam1(ctx context.Context) *mPartitionServiceClientMockUpdateTenant {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceClientMockUpdateTenantExpectation{}
	}

	if mmUpdateTenant.defaultExpectation.params != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Expect")
	}

	if mmUpdateTenant.defaultExpectation.paramPtrs == nil {
		mmUpdateTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockUpdateTenantParamPtrs{}
	}
	mmUpdateTenant.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTenant.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTenant
}

// ExpectPp1Param2 sets up expected param pp1 for PartitionServiceClient.UpdateTenant
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) ExpectPp1Param2(pp1 *connect.Request[v1.UpdateTenantRequest]) *mPartitionServiceClientMockUpdateTenant {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceClientMockUpdateTenantExpectation{}
	}

	if mmUpdateTenant.defaultExpectation.params != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Expect")
	}

	if mmUpdateTenant.defaultExpectation.paramPtrs == nil {
		mmUpdateTenant.defaultExpectation.paramPtrs = &PartitionServiceClientMockUpdateTenantParamPtrs{}
	}
	mmUpdateTenant.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateTenant.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateTenant
}

// Inspect accepts an inspector function that has same arguments as the PartitionServiceClient.UpdateTenant
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest])) *mPartitionServiceClientMockUpdateTenant {
	if mmUpdateTenant.mock.inspectFuncUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("Inspect function is already set for PartitionServiceClientMock.UpdateTenant")
	}

	mmUpdateTenant.mock.inspectFuncUpdateTenant = f

	return mmUpdateTenant
}

// Return sets up results that will be returned by PartitionServiceClient.UpdateTenant
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Return(pp2 *connect.Response[v1.UpdateTenantResponse], err error) *PartitionServiceClientMock {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Set")
	}

	if mmUpdateTenant.defaultExpectation == nil {
		mmUpdateTenant.defaultExpectation = &PartitionServiceClientMockUpdateTenantExpectation{mock: mmUpdateTenant.mock}
	}
	mmUpdateTenant.defaultExpectation.results = &PartitionServiceClientMockUpdateTenantResults{pp2, err}
	mmUpdateTenant.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTenant.mock
}

// Set uses given function f to mock the PartitionServiceClient.UpdateTenant method
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) (pp2 *connect.Response[v1.UpdateTenantResponse], err error)) *PartitionServiceClientMock {
	if mmUpdateTenant.defaultExpectation != nil {
		mmUpdateTenant.mock.t.Fatalf("Default expectation is already set for the PartitionServiceClient.UpdateTenant method")
	}

	if len(mmUpdateTenant.expectations) > 0 {
		mmUpdateTenant.mock.t.Fatalf("Some expectations are already set for the PartitionServiceClient.UpdateTenant method")
	}

	mmUpdateTenant.mock.funcUpdateTenant = f
	mmUpdateTenant.mock.funcUpdateTenantOrigin = minimock.CallerInfo(1)
	return mmUpdateTenant.mock
}

// When sets expectation for the PartitionServiceClient.UpdateTenant which will trigger the result defined by the following
// Then helper
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) When(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) *PartitionServiceClientMockUpdateTenantExpectation {
	if mmUpdateTenant.mock.funcUpdateTenant != nil {
		mmUpdateTenant.mock.t.Fatalf("PartitionServiceClientMock.UpdateTenant mock is already set by Set")
	}

	expectation := &PartitionServiceClientMockUpdateTenantExpectation{
		mock:               mmUpdateTenant.mock,
		params:             &PartitionServiceClientMockUpdateTenantParams{ctx, pp1},
		expectationOrigins: PartitionServiceClientMockUpdateTenantExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTenant.expectations = append(mmUpdateTenant.expectations, expectation)
	return expectation
}

// Then sets up PartitionServiceClient.UpdateTenant return parameters for the expectation previously defined by the When method
func (e *PartitionServiceClientMockUpdateTenantExpectation) Then(pp2 *connect.Response[v1.UpdateTenantResponse], err error) *PartitionServiceClientMock {
	e.results = &PartitionServiceClientMockUpdateTenantResults{pp2, err}
	return e.mock
}

// Times sets number of times PartitionServiceClient.UpdateTenant should be invoked
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Times(n uint64) *mPartitionServiceClientMockUpdateTenant {
	if n == 0 {
		mmUpdateTenant.mock.t.Fatalf("Times of PartitionServiceClientMock.UpdateTenant mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTenant.expectedInvocations, n)
	mmUpdateTenant.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTenant
}

func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) invocationsDone() bool {
	if len(mmUpdateTenant.expectations) == 0 && mmUpdateTenant.defaultExpectation == nil && mmUpdateTenant.mock.funcUpdateTenant == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTenant.mock.afterUpdateTenantCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTenant.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTenant implements mm_partitionv1connect.PartitionServiceClient
func (mmUpdateTenant *PartitionServiceClientMock) UpdateTenant(ctx context.Context, pp1 *connect.Request[v1.UpdateTenantRequest]) (pp2 *connect.Response[v1.UpdateTenantResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateTenant.beforeUpdateTenantCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTenant.afterUpdateTenantCounter, 1)

	mmUpdateTenant.t.Helper()

	if mmUpdateTenant.inspectFuncUpdateTenant != nil {
		mmUpdateTenant.inspectFuncUpdateTenant(ctx, pp1)
	}

	mm_params := PartitionServiceClientMockUpdateTenantParams{ctx, pp1}

	// Record call args
	mmUpdateTenant.UpdateTenantMock.mutex.Lock()
	mmUpdateTenant.UpdateTenantMock.callArgs = append(mmUpdateTenant.UpdateTenantMock.callArgs, &mm_params)
	mmUpdateTenant.UpdateTenantMock.mutex.Unlock()

	for _, e := range mmUpdateTenant.UpdateTenantMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateTenant.UpdateTenantMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTenant.UpdateTenantMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTenant.UpdateTenantMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTenant.UpdateTenantMock.defaultExpectation.paramPtrs

		mm_got := PartitionServiceClientMockUpdateTenantParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTenant.t.Errorf("PartitionServiceClientMock.UpdateTenant got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTenant.UpdateTenantMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateTenant.t.Errorf("PartitionServiceClientMock.UpdateTenant got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTenant.UpdateTenantMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTenant.t.Errorf("PartitionServiceClientMock.UpdateTenant got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTenant.UpdateTenantMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTenant.UpdateTenantMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTenant.t.Fatal("No results are set for the PartitionServiceClientMock.UpdateTenant")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateTenant.funcUpdateTenant != nil {
		return mmUpdateTenant.funcUpdateTenant(ctx, pp1)
	}
	mmUpdateTenant.t.Fatalf("Unexpected call to PartitionServiceClientMock.UpdateTenant. %v %v", ctx, pp1)
	return
}

// UpdateTenantAfterCounter returns a count of finished PartitionServiceClientMock.UpdateTenant invocations
func (mmUpdateTenant *PartitionServiceClientMock) UpdateTenantAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTenant.afterUpdateTenantCounter)
}

// UpdateTenantBeforeCounter returns a count of PartitionServiceClientMock.UpdateTenant invocations
func (mmUpdateTenant *PartitionServiceClientMock) UpdateTenantBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTenant.beforeUpdateTenantCounter)
}

// Calls returns a list of arguments used in each call to PartitionServiceClientMock.UpdateTenant.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTenant *mPartitionServiceClientMockUpdateTenant) Calls() []*PartitionServiceClientMockUpdateTenantParams {
	mmUpdateTenant.mutex.RLock()

	argCopy := make([]*PartitionServiceClientMockUpdateTenantParams, len(mmUpdateTenant.callArgs))
	copy(argCopy, mmUpdateTenant.callArgs)

	mmUpdateTenant.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTenantDone returns true if the count of the UpdateTenant invocations corresponds
// the number of defined expectations
func (m *PartitionServiceClientMock) MinimockUpdateTenantDone() bool {
	if m.UpdateTenantMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTenantMock.invocationsDone()
}

// MinimockUpdateTenantInspect logs each unmet expectation
func (m *PartitionServiceClientMock) MinimockUpdateTenantInspect() {
	for _, e := range m.UpdateTenantMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PartitionServiceClientMock.UpdateTenant at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTenantCounter := mm_atomic.LoadUint64(&m.afterUpdateTenantCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTenantMock.defaultExpectation != nil && afterUpdateTenantCounter < 1 {
		if m.UpdateTenantMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PartitionServiceClientMock.UpdateTenant at\n%s", m.UpdateTenantMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PartitionServiceClientMock.UpdateTenant at\n%s with params: %#v", m.UpdateTenantMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTenantMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTenant != nil && afterUpdateTenantCounter < 1 {
		m.t.Errorf("Expected call to PartitionServiceClientMock.UpdateTenant at\n%s", m.funcUpdateTenantOrigin)
	}

	if !m.UpdateTenantMock.invocationsDone() && afterUpdateTenantCounter > 0 {
		m.t.Errorf("Expected %d calls to PartitionServiceClientMock.UpdateTenant at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTenantMock.expectedInvocations), m.UpdateTenantMock.expectedInvocationsOrigin, afterUpdateTenantCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PartitionServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAccessInspect()

			m.MinimockCreateAccessRoleInspect()

			m.MinimockCreatePageInspect()

			m.MinimockCreatePartitionInspect()

			m.MinimockCreatePartitionRoleInspect()

			m.MinimockCreateTenantInspect()

			m.MinimockGetAccessInspect()

			m.MinimockGetPageInspect()

			m.MinimockGetPartitionInspect()

			m.MinimockGetPartitionParentsInspect()

			m.MinimockGetTenantInspect()

			m.MinimockListAccessRoleInspect()

			m.MinimockListPartitionInspect()

			m.MinimockListPartitionRoleInspect()

			m.MinimockListTenantInspect()

			m.MinimockRemoveAccessInspect()

			m.MinimockRemoveAccessRoleInspect()

			m.MinimockRemovePageInspect()

			m.MinimockRemovePartitionRoleInspect()

			m.MinimockUpdatePartitionInspect()

			m.MinimockUpdateTenantInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PartitionServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PartitionServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAccessDone() &&
		m.MinimockCreateAccessRoleDone() &&
		m.MinimockCreatePageDone() &&
		m.MinimockCreatePartitionDone() &&
		m.MinimockCreatePartitionRoleDone() &&
		m.MinimockCreateTenantDone() &&
		m.MinimockGetAccessDone() &&
		m.MinimockGetPageDone() &&
		m.MinimockGetPartitionDone() &&
		m.MinimockGetPartitionParentsDone() &&
		m.MinimockGetTenantDone() &&
		m.MinimockListAccessRoleDone() &&
		m.MinimockListPartitionDone() &&
		m.MinimockListPartitionRoleDone() &&
		m.MinimockListTenantDone() &&
		m.MinimockRemoveAccessDone() &&
		m.MinimockRemoveAccessRoleDone() &&
		m.MinimockRemovePageDone() &&
		m.MinimockRemovePartitionRoleDone() &&
		m.MinimockUpdatePartitionDone() &&
		m.MinimockUpdateTenantDone()
}
