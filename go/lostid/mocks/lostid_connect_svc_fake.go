// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	commonv1 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	"buf.build/gen/go/antinvestor/lostid/connectrpc/go/lostid/v1/lostidv1connect"
	lostidv1 "buf.build/gen/go/antinvestor/lostid/protocolbuffers/go/lostid/v1"
	"connectrpc.com/connect"
)

type FakeLostIdServiceHandler struct {
	CollectibleStub        func(context.Context, *connect.Request[lostidv1.CollectibleRequest]) (*connect.Response[lostidv1.CollectibleResponse], error)
	collectibleMutex       sync.RWMutex
	collectibleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.CollectibleRequest]
	}
	collectibleReturns struct {
		result1 *connect.Response[lostidv1.CollectibleResponse]
		result2 error
	}
	collectibleReturnsOnCall map[int]struct {
		result1 *connect.Response[lostidv1.CollectibleResponse]
		result2 error
	}
	ListCollectibleStub        func(context.Context, *connect.Request[lostidv1.ListCollectibleRequest], *connect.ServerStream[lostidv1.ListCollectibleResponse]) error
	listCollectibleMutex       sync.RWMutex
	listCollectibleArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ListCollectibleRequest]
		arg3 *connect.ServerStream[lostidv1.ListCollectibleResponse]
	}
	listCollectibleReturns struct {
		result1 error
	}
	listCollectibleReturnsOnCall map[int]struct {
		result1 error
	}
	ListSearchStub        func(context.Context, *connect.Request[lostidv1.ListSearchRequest], *connect.ServerStream[lostidv1.ListSearchResponse]) error
	listSearchMutex       sync.RWMutex
	listSearchArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ListSearchRequest]
		arg3 *connect.ServerStream[lostidv1.ListSearchResponse]
	}
	listSearchReturns struct {
		result1 error
	}
	listSearchReturnsOnCall map[int]struct {
		result1 error
	}
	ListTransactionStub        func(context.Context, *connect.Request[lostidv1.ListTransactionRequest], *connect.ServerStream[lostidv1.ListTransactionResponse]) error
	listTransactionMutex       sync.RWMutex
	listTransactionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ListTransactionRequest]
		arg3 *connect.ServerStream[lostidv1.ListTransactionResponse]
	}
	listTransactionReturns struct {
		result1 error
	}
	listTransactionReturnsOnCall map[int]struct {
		result1 error
	}
	ProgressStub        func(context.Context, *connect.Request[lostidv1.ProgressRequest]) (*connect.Response[lostidv1.ProgressResponse], error)
	progressMutex       sync.RWMutex
	progressArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ProgressRequest]
	}
	progressReturns struct {
		result1 *connect.Response[lostidv1.ProgressResponse]
		result2 error
	}
	progressReturnsOnCall map[int]struct {
		result1 *connect.Response[lostidv1.ProgressResponse]
		result2 error
	}
	SearchStub        func(context.Context, *connect.Request[commonv1.SearchRequest]) (*connect.Response[lostidv1.SearchResponse], error)
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.SearchRequest]
	}
	searchReturns struct {
		result1 *connect.Response[lostidv1.SearchResponse]
		result2 error
	}
	searchReturnsOnCall map[int]struct {
		result1 *connect.Response[lostidv1.SearchResponse]
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLostIdServiceHandler) Collectible(arg1 context.Context, arg2 *connect.Request[lostidv1.CollectibleRequest]) (*connect.Response[lostidv1.CollectibleResponse], error) {
	fake.collectibleMutex.Lock()
	ret, specificReturn := fake.collectibleReturnsOnCall[len(fake.collectibleArgsForCall)]
	fake.collectibleArgsForCall = append(fake.collectibleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.CollectibleRequest]
	}{arg1, arg2})
	stub := fake.CollectibleStub
	fakeReturns := fake.collectibleReturns
	fake.recordInvocation("Collectible", []interface{}{arg1, arg2})
	fake.collectibleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLostIdServiceHandler) CollectibleCallCount() int {
	fake.collectibleMutex.RLock()
	defer fake.collectibleMutex.RUnlock()
	return len(fake.collectibleArgsForCall)
}

func (fake *FakeLostIdServiceHandler) CollectibleCalls(stub func(context.Context, *connect.Request[lostidv1.CollectibleRequest]) (*connect.Response[lostidv1.CollectibleResponse], error)) {
	fake.collectibleMutex.Lock()
	defer fake.collectibleMutex.Unlock()
	fake.CollectibleStub = stub
}

func (fake *FakeLostIdServiceHandler) CollectibleArgsForCall(i int) (context.Context, *connect.Request[lostidv1.CollectibleRequest]) {
	fake.collectibleMutex.RLock()
	defer fake.collectibleMutex.RUnlock()
	argsForCall := fake.collectibleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLostIdServiceHandler) CollectibleReturns(result1 *connect.Response[lostidv1.CollectibleResponse], result2 error) {
	fake.collectibleMutex.Lock()
	defer fake.collectibleMutex.Unlock()
	fake.CollectibleStub = nil
	fake.collectibleReturns = struct {
		result1 *connect.Response[lostidv1.CollectibleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeLostIdServiceHandler) CollectibleReturnsOnCall(i int, result1 *connect.Response[lostidv1.CollectibleResponse], result2 error) {
	fake.collectibleMutex.Lock()
	defer fake.collectibleMutex.Unlock()
	fake.CollectibleStub = nil
	if fake.collectibleReturnsOnCall == nil {
		fake.collectibleReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[lostidv1.CollectibleResponse]
			result2 error
		})
	}
	fake.collectibleReturnsOnCall[i] = struct {
		result1 *connect.Response[lostidv1.CollectibleResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeLostIdServiceHandler) ListCollectible(arg1 context.Context, arg2 *connect.Request[lostidv1.ListCollectibleRequest], arg3 *connect.ServerStream[lostidv1.ListCollectibleResponse]) error {
	fake.listCollectibleMutex.Lock()
	ret, specificReturn := fake.listCollectibleReturnsOnCall[len(fake.listCollectibleArgsForCall)]
	fake.listCollectibleArgsForCall = append(fake.listCollectibleArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ListCollectibleRequest]
		arg3 *connect.ServerStream[lostidv1.ListCollectibleResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListCollectibleStub
	fakeReturns := fake.listCollectibleReturns
	fake.recordInvocation("ListCollectible", []interface{}{arg1, arg2, arg3})
	fake.listCollectibleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLostIdServiceHandler) ListCollectibleCallCount() int {
	fake.listCollectibleMutex.RLock()
	defer fake.listCollectibleMutex.RUnlock()
	return len(fake.listCollectibleArgsForCall)
}

func (fake *FakeLostIdServiceHandler) ListCollectibleCalls(stub func(context.Context, *connect.Request[lostidv1.ListCollectibleRequest], *connect.ServerStream[lostidv1.ListCollectibleResponse]) error) {
	fake.listCollectibleMutex.Lock()
	defer fake.listCollectibleMutex.Unlock()
	fake.ListCollectibleStub = stub
}

func (fake *FakeLostIdServiceHandler) ListCollectibleArgsForCall(i int) (context.Context, *connect.Request[lostidv1.ListCollectibleRequest], *connect.ServerStream[lostidv1.ListCollectibleResponse]) {
	fake.listCollectibleMutex.RLock()
	defer fake.listCollectibleMutex.RUnlock()
	argsForCall := fake.listCollectibleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLostIdServiceHandler) ListCollectibleReturns(result1 error) {
	fake.listCollectibleMutex.Lock()
	defer fake.listCollectibleMutex.Unlock()
	fake.ListCollectibleStub = nil
	fake.listCollectibleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLostIdServiceHandler) ListCollectibleReturnsOnCall(i int, result1 error) {
	fake.listCollectibleMutex.Lock()
	defer fake.listCollectibleMutex.Unlock()
	fake.ListCollectibleStub = nil
	if fake.listCollectibleReturnsOnCall == nil {
		fake.listCollectibleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listCollectibleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLostIdServiceHandler) ListSearch(arg1 context.Context, arg2 *connect.Request[lostidv1.ListSearchRequest], arg3 *connect.ServerStream[lostidv1.ListSearchResponse]) error {
	fake.listSearchMutex.Lock()
	ret, specificReturn := fake.listSearchReturnsOnCall[len(fake.listSearchArgsForCall)]
	fake.listSearchArgsForCall = append(fake.listSearchArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ListSearchRequest]
		arg3 *connect.ServerStream[lostidv1.ListSearchResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListSearchStub
	fakeReturns := fake.listSearchReturns
	fake.recordInvocation("ListSearch", []interface{}{arg1, arg2, arg3})
	fake.listSearchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLostIdServiceHandler) ListSearchCallCount() int {
	fake.listSearchMutex.RLock()
	defer fake.listSearchMutex.RUnlock()
	return len(fake.listSearchArgsForCall)
}

func (fake *FakeLostIdServiceHandler) ListSearchCalls(stub func(context.Context, *connect.Request[lostidv1.ListSearchRequest], *connect.ServerStream[lostidv1.ListSearchResponse]) error) {
	fake.listSearchMutex.Lock()
	defer fake.listSearchMutex.Unlock()
	fake.ListSearchStub = stub
}

func (fake *FakeLostIdServiceHandler) ListSearchArgsForCall(i int) (context.Context, *connect.Request[lostidv1.ListSearchRequest], *connect.ServerStream[lostidv1.ListSearchResponse]) {
	fake.listSearchMutex.RLock()
	defer fake.listSearchMutex.RUnlock()
	argsForCall := fake.listSearchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLostIdServiceHandler) ListSearchReturns(result1 error) {
	fake.listSearchMutex.Lock()
	defer fake.listSearchMutex.Unlock()
	fake.ListSearchStub = nil
	fake.listSearchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLostIdServiceHandler) ListSearchReturnsOnCall(i int, result1 error) {
	fake.listSearchMutex.Lock()
	defer fake.listSearchMutex.Unlock()
	fake.ListSearchStub = nil
	if fake.listSearchReturnsOnCall == nil {
		fake.listSearchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listSearchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLostIdServiceHandler) ListTransaction(arg1 context.Context, arg2 *connect.Request[lostidv1.ListTransactionRequest], arg3 *connect.ServerStream[lostidv1.ListTransactionResponse]) error {
	fake.listTransactionMutex.Lock()
	ret, specificReturn := fake.listTransactionReturnsOnCall[len(fake.listTransactionArgsForCall)]
	fake.listTransactionArgsForCall = append(fake.listTransactionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ListTransactionRequest]
		arg3 *connect.ServerStream[lostidv1.ListTransactionResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListTransactionStub
	fakeReturns := fake.listTransactionReturns
	fake.recordInvocation("ListTransaction", []interface{}{arg1, arg2, arg3})
	fake.listTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLostIdServiceHandler) ListTransactionCallCount() int {
	fake.listTransactionMutex.RLock()
	defer fake.listTransactionMutex.RUnlock()
	return len(fake.listTransactionArgsForCall)
}

func (fake *FakeLostIdServiceHandler) ListTransactionCalls(stub func(context.Context, *connect.Request[lostidv1.ListTransactionRequest], *connect.ServerStream[lostidv1.ListTransactionResponse]) error) {
	fake.listTransactionMutex.Lock()
	defer fake.listTransactionMutex.Unlock()
	fake.ListTransactionStub = stub
}

func (fake *FakeLostIdServiceHandler) ListTransactionArgsForCall(i int) (context.Context, *connect.Request[lostidv1.ListTransactionRequest], *connect.ServerStream[lostidv1.ListTransactionResponse]) {
	fake.listTransactionMutex.RLock()
	defer fake.listTransactionMutex.RUnlock()
	argsForCall := fake.listTransactionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLostIdServiceHandler) ListTransactionReturns(result1 error) {
	fake.listTransactionMutex.Lock()
	defer fake.listTransactionMutex.Unlock()
	fake.ListTransactionStub = nil
	fake.listTransactionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLostIdServiceHandler) ListTransactionReturnsOnCall(i int, result1 error) {
	fake.listTransactionMutex.Lock()
	defer fake.listTransactionMutex.Unlock()
	fake.ListTransactionStub = nil
	if fake.listTransactionReturnsOnCall == nil {
		fake.listTransactionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listTransactionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLostIdServiceHandler) Progress(arg1 context.Context, arg2 *connect.Request[lostidv1.ProgressRequest]) (*connect.Response[lostidv1.ProgressResponse], error) {
	fake.progressMutex.Lock()
	ret, specificReturn := fake.progressReturnsOnCall[len(fake.progressArgsForCall)]
	fake.progressArgsForCall = append(fake.progressArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[lostidv1.ProgressRequest]
	}{arg1, arg2})
	stub := fake.ProgressStub
	fakeReturns := fake.progressReturns
	fake.recordInvocation("Progress", []interface{}{arg1, arg2})
	fake.progressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLostIdServiceHandler) ProgressCallCount() int {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	return len(fake.progressArgsForCall)
}

func (fake *FakeLostIdServiceHandler) ProgressCalls(stub func(context.Context, *connect.Request[lostidv1.ProgressRequest]) (*connect.Response[lostidv1.ProgressResponse], error)) {
	fake.progressMutex.Lock()
	defer fake.progressMutex.Unlock()
	fake.ProgressStub = stub
}

func (fake *FakeLostIdServiceHandler) ProgressArgsForCall(i int) (context.Context, *connect.Request[lostidv1.ProgressRequest]) {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	argsForCall := fake.progressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLostIdServiceHandler) ProgressReturns(result1 *connect.Response[lostidv1.ProgressResponse], result2 error) {
	fake.progressMutex.Lock()
	defer fake.progressMutex.Unlock()
	fake.ProgressStub = nil
	fake.progressReturns = struct {
		result1 *connect.Response[lostidv1.ProgressResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeLostIdServiceHandler) ProgressReturnsOnCall(i int, result1 *connect.Response[lostidv1.ProgressResponse], result2 error) {
	fake.progressMutex.Lock()
	defer fake.progressMutex.Unlock()
	fake.ProgressStub = nil
	if fake.progressReturnsOnCall == nil {
		fake.progressReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[lostidv1.ProgressResponse]
			result2 error
		})
	}
	fake.progressReturnsOnCall[i] = struct {
		result1 *connect.Response[lostidv1.ProgressResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeLostIdServiceHandler) Search(arg1 context.Context, arg2 *connect.Request[commonv1.SearchRequest]) (*connect.Response[lostidv1.SearchResponse], error) {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[commonv1.SearchRequest]
	}{arg1, arg2})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1, arg2})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLostIdServiceHandler) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *FakeLostIdServiceHandler) SearchCalls(stub func(context.Context, *connect.Request[commonv1.SearchRequest]) (*connect.Response[lostidv1.SearchResponse], error)) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *FakeLostIdServiceHandler) SearchArgsForCall(i int) (context.Context, *connect.Request[commonv1.SearchRequest]) {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLostIdServiceHandler) SearchReturns(result1 *connect.Response[lostidv1.SearchResponse], result2 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 *connect.Response[lostidv1.SearchResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeLostIdServiceHandler) SearchReturnsOnCall(i int, result1 *connect.Response[lostidv1.SearchResponse], result2 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[lostidv1.SearchResponse]
			result2 error
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 *connect.Response[lostidv1.SearchResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakeLostIdServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLostIdServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ lostidv1connect.LostIdServiceHandler = new(FakeLostIdServiceHandler)
