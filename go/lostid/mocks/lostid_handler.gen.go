// Copyright 2023-2024 Ant Investor Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/lostid/connectrpc/go/lostid/v1/lostidv1connect.LostIdServiceClient -o lostid_handler.gen.go -n LostIdServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v1 "buf.build/gen/go/antinvestor/lostid/protocolbuffers/go/lostid/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// LostIdServiceClientMock implements mm_lostidv1connect.LostIdServiceClient
type LostIdServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCollectible          func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) (pp2 *connect.Response[v1.CollectibleResponse], err error)
	funcCollectibleOrigin    string
	inspectFuncCollectible   func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest])
	afterCollectibleCounter  uint64
	beforeCollectibleCounter uint64
	CollectibleMock          mLostIdServiceClientMockCollectible

	funcListCollectible          func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListCollectibleResponse], err error)
	funcListCollectibleOrigin    string
	inspectFuncListCollectible   func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest])
	afterListCollectibleCounter  uint64
	beforeListCollectibleCounter uint64
	ListCollectibleMock          mLostIdServiceClientMockListCollectible

	funcListSearch          func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest]) (pp2 *connect.ServerStreamForClient[v1.ListSearchResponse], err error)
	funcListSearchOrigin    string
	inspectFuncListSearch   func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest])
	afterListSearchCounter  uint64
	beforeListSearchCounter uint64
	ListSearchMock          mLostIdServiceClientMockListSearch

	funcListTransaction          func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListTransactionResponse], err error)
	funcListTransactionOrigin    string
	inspectFuncListTransaction   func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest])
	afterListTransactionCounter  uint64
	beforeListTransactionCounter uint64
	ListTransactionMock          mLostIdServiceClientMockListTransaction

	funcProgress          func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) (pp2 *connect.Response[v1.ProgressResponse], err error)
	funcProgressOrigin    string
	inspectFuncProgress   func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest])
	afterProgressCounter  uint64
	beforeProgressCounter uint64
	ProgressMock          mLostIdServiceClientMockProgress

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.Response[v1.SearchResponse], err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mLostIdServiceClientMockSearch
}

// NewLostIdServiceClientMock returns a mock for mm_lostidv1connect.LostIdServiceClient
func NewLostIdServiceClientMock(t minimock.Tester) *LostIdServiceClientMock {
	m := &LostIdServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CollectibleMock = mLostIdServiceClientMockCollectible{mock: m}
	m.CollectibleMock.callArgs = []*LostIdServiceClientMockCollectibleParams{}

	m.ListCollectibleMock = mLostIdServiceClientMockListCollectible{mock: m}
	m.ListCollectibleMock.callArgs = []*LostIdServiceClientMockListCollectibleParams{}

	m.ListSearchMock = mLostIdServiceClientMockListSearch{mock: m}
	m.ListSearchMock.callArgs = []*LostIdServiceClientMockListSearchParams{}

	m.ListTransactionMock = mLostIdServiceClientMockListTransaction{mock: m}
	m.ListTransactionMock.callArgs = []*LostIdServiceClientMockListTransactionParams{}

	m.ProgressMock = mLostIdServiceClientMockProgress{mock: m}
	m.ProgressMock.callArgs = []*LostIdServiceClientMockProgressParams{}

	m.SearchMock = mLostIdServiceClientMockSearch{mock: m}
	m.SearchMock.callArgs = []*LostIdServiceClientMockSearchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLostIdServiceClientMockCollectible struct {
	optional           bool
	mock               *LostIdServiceClientMock
	defaultExpectation *LostIdServiceClientMockCollectibleExpectation
	expectations       []*LostIdServiceClientMockCollectibleExpectation

	callArgs []*LostIdServiceClientMockCollectibleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceClientMockCollectibleExpectation specifies expectation struct of the LostIdServiceClient.Collectible
type LostIdServiceClientMockCollectibleExpectation struct {
	mock               *LostIdServiceClientMock
	params             *LostIdServiceClientMockCollectibleParams
	paramPtrs          *LostIdServiceClientMockCollectibleParamPtrs
	expectationOrigins LostIdServiceClientMockCollectibleExpectationOrigins
	results            *LostIdServiceClientMockCollectibleResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceClientMockCollectibleParams contains parameters of the LostIdServiceClient.Collectible
type LostIdServiceClientMockCollectibleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CollectibleRequest]
}

// LostIdServiceClientMockCollectibleParamPtrs contains pointers to parameters of the LostIdServiceClient.Collectible
type LostIdServiceClientMockCollectibleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CollectibleRequest]
}

// LostIdServiceClientMockCollectibleResults contains results of the LostIdServiceClient.Collectible
type LostIdServiceClientMockCollectibleResults struct {
	pp2 *connect.Response[v1.CollectibleResponse]
	err error
}

// LostIdServiceClientMockCollectibleOrigins contains origins of expectations of the LostIdServiceClient.Collectible
type LostIdServiceClientMockCollectibleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCollectible *mLostIdServiceClientMockCollectible) Optional() *mLostIdServiceClientMockCollectible {
	mmCollectible.optional = true
	return mmCollectible
}

// Expect sets up expected params for LostIdServiceClient.Collectible
func (mmCollectible *mLostIdServiceClientMockCollectible) Expect(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) *mLostIdServiceClientMockCollectible {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceClientMockCollectibleExpectation{}
	}

	if mmCollectible.defaultExpectation.paramPtrs != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by ExpectParams functions")
	}

	mmCollectible.defaultExpectation.params = &LostIdServiceClientMockCollectibleParams{ctx, pp1}
	mmCollectible.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCollectible.expectations {
		if minimock.Equal(e.params, mmCollectible.defaultExpectation.params) {
			mmCollectible.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCollectible.defaultExpectation.params)
		}
	}

	return mmCollectible
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceClient.Collectible
func (mmCollectible *mLostIdServiceClientMockCollectible) ExpectCtxParam1(ctx context.Context) *mLostIdServiceClientMockCollectible {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceClientMockCollectibleExpectation{}
	}

	if mmCollectible.defaultExpectation.params != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Expect")
	}

	if mmCollectible.defaultExpectation.paramPtrs == nil {
		mmCollectible.defaultExpectation.paramPtrs = &LostIdServiceClientMockCollectibleParamPtrs{}
	}
	mmCollectible.defaultExpectation.paramPtrs.ctx = &ctx
	mmCollectible.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCollectible
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceClient.Collectible
func (mmCollectible *mLostIdServiceClientMockCollectible) ExpectPp1Param2(pp1 *connect.Request[v1.CollectibleRequest]) *mLostIdServiceClientMockCollectible {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceClientMockCollectibleExpectation{}
	}

	if mmCollectible.defaultExpectation.params != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Expect")
	}

	if mmCollectible.defaultExpectation.paramPtrs == nil {
		mmCollectible.defaultExpectation.paramPtrs = &LostIdServiceClientMockCollectibleParamPtrs{}
	}
	mmCollectible.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCollectible.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCollectible
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceClient.Collectible
func (mmCollectible *mLostIdServiceClientMockCollectible) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest])) *mLostIdServiceClientMockCollectible {
	if mmCollectible.mock.inspectFuncCollectible != nil {
		mmCollectible.mock.t.Fatalf("Inspect function is already set for LostIdServiceClientMock.Collectible")
	}

	mmCollectible.mock.inspectFuncCollectible = f

	return mmCollectible
}

// Return sets up results that will be returned by LostIdServiceClient.Collectible
func (mmCollectible *mLostIdServiceClientMockCollectible) Return(pp2 *connect.Response[v1.CollectibleResponse], err error) *LostIdServiceClientMock {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceClientMockCollectibleExpectation{mock: mmCollectible.mock}
	}
	mmCollectible.defaultExpectation.results = &LostIdServiceClientMockCollectibleResults{pp2, err}
	mmCollectible.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCollectible.mock
}

// Set uses given function f to mock the LostIdServiceClient.Collectible method
func (mmCollectible *mLostIdServiceClientMockCollectible) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) (pp2 *connect.Response[v1.CollectibleResponse], err error)) *LostIdServiceClientMock {
	if mmCollectible.defaultExpectation != nil {
		mmCollectible.mock.t.Fatalf("Default expectation is already set for the LostIdServiceClient.Collectible method")
	}

	if len(mmCollectible.expectations) > 0 {
		mmCollectible.mock.t.Fatalf("Some expectations are already set for the LostIdServiceClient.Collectible method")
	}

	mmCollectible.mock.funcCollectible = f
	mmCollectible.mock.funcCollectibleOrigin = minimock.CallerInfo(1)
	return mmCollectible.mock
}

// When sets expectation for the LostIdServiceClient.Collectible which will trigger the result defined by the following
// Then helper
func (mmCollectible *mLostIdServiceClientMockCollectible) When(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) *LostIdServiceClientMockCollectibleExpectation {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceClientMock.Collectible mock is already set by Set")
	}

	expectation := &LostIdServiceClientMockCollectibleExpectation{
		mock:               mmCollectible.mock,
		params:             &LostIdServiceClientMockCollectibleParams{ctx, pp1},
		expectationOrigins: LostIdServiceClientMockCollectibleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCollectible.expectations = append(mmCollectible.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceClient.Collectible return parameters for the expectation previously defined by the When method
func (e *LostIdServiceClientMockCollectibleExpectation) Then(pp2 *connect.Response[v1.CollectibleResponse], err error) *LostIdServiceClientMock {
	e.results = &LostIdServiceClientMockCollectibleResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceClient.Collectible should be invoked
func (mmCollectible *mLostIdServiceClientMockCollectible) Times(n uint64) *mLostIdServiceClientMockCollectible {
	if n == 0 {
		mmCollectible.mock.t.Fatalf("Times of LostIdServiceClientMock.Collectible mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCollectible.expectedInvocations, n)
	mmCollectible.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCollectible
}

func (mmCollectible *mLostIdServiceClientMockCollectible) invocationsDone() bool {
	if len(mmCollectible.expectations) == 0 && mmCollectible.defaultExpectation == nil && mmCollectible.mock.funcCollectible == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCollectible.mock.afterCollectibleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCollectible.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Collectible implements mm_lostidv1connect.LostIdServiceClient
func (mmCollectible *LostIdServiceClientMock) Collectible(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) (pp2 *connect.Response[v1.CollectibleResponse], err error) {
	mm_atomic.AddUint64(&mmCollectible.beforeCollectibleCounter, 1)
	defer mm_atomic.AddUint64(&mmCollectible.afterCollectibleCounter, 1)

	mmCollectible.t.Helper()

	if mmCollectible.inspectFuncCollectible != nil {
		mmCollectible.inspectFuncCollectible(ctx, pp1)
	}

	mm_params := LostIdServiceClientMockCollectibleParams{ctx, pp1}

	// Record call args
	mmCollectible.CollectibleMock.mutex.Lock()
	mmCollectible.CollectibleMock.callArgs = append(mmCollectible.CollectibleMock.callArgs, &mm_params)
	mmCollectible.CollectibleMock.mutex.Unlock()

	for _, e := range mmCollectible.CollectibleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCollectible.CollectibleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCollectible.CollectibleMock.defaultExpectation.Counter, 1)
		mm_want := mmCollectible.CollectibleMock.defaultExpectation.params
		mm_want_ptrs := mmCollectible.CollectibleMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceClientMockCollectibleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCollectible.t.Errorf("LostIdServiceClientMock.Collectible got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectible.CollectibleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCollectible.t.Errorf("LostIdServiceClientMock.Collectible got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectible.CollectibleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCollectible.t.Errorf("LostIdServiceClientMock.Collectible got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCollectible.CollectibleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCollectible.CollectibleMock.defaultExpectation.results
		if mm_results == nil {
			mmCollectible.t.Fatal("No results are set for the LostIdServiceClientMock.Collectible")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCollectible.funcCollectible != nil {
		return mmCollectible.funcCollectible(ctx, pp1)
	}
	mmCollectible.t.Fatalf("Unexpected call to LostIdServiceClientMock.Collectible. %v %v", ctx, pp1)
	return
}

// CollectibleAfterCounter returns a count of finished LostIdServiceClientMock.Collectible invocations
func (mmCollectible *LostIdServiceClientMock) CollectibleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectible.afterCollectibleCounter)
}

// CollectibleBeforeCounter returns a count of LostIdServiceClientMock.Collectible invocations
func (mmCollectible *LostIdServiceClientMock) CollectibleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectible.beforeCollectibleCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceClientMock.Collectible.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCollectible *mLostIdServiceClientMockCollectible) Calls() []*LostIdServiceClientMockCollectibleParams {
	mmCollectible.mutex.RLock()

	argCopy := make([]*LostIdServiceClientMockCollectibleParams, len(mmCollectible.callArgs))
	copy(argCopy, mmCollectible.callArgs)

	mmCollectible.mutex.RUnlock()

	return argCopy
}

// MinimockCollectibleDone returns true if the count of the Collectible invocations corresponds
// the number of defined expectations
func (m *LostIdServiceClientMock) MinimockCollectibleDone() bool {
	if m.CollectibleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CollectibleMock.invocationsDone()
}

// MinimockCollectibleInspect logs each unmet expectation
func (m *LostIdServiceClientMock) MinimockCollectibleInspect() {
	for _, e := range m.CollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Collectible at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCollectibleCounter := mm_atomic.LoadUint64(&m.afterCollectibleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CollectibleMock.defaultExpectation != nil && afterCollectibleCounter < 1 {
		if m.CollectibleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Collectible at\n%s", m.CollectibleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Collectible at\n%s with params: %#v", m.CollectibleMock.defaultExpectation.expectationOrigins.origin, *m.CollectibleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCollectible != nil && afterCollectibleCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceClientMock.Collectible at\n%s", m.funcCollectibleOrigin)
	}

	if !m.CollectibleMock.invocationsDone() && afterCollectibleCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceClientMock.Collectible at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CollectibleMock.expectedInvocations), m.CollectibleMock.expectedInvocationsOrigin, afterCollectibleCounter)
	}
}

type mLostIdServiceClientMockListCollectible struct {
	optional           bool
	mock               *LostIdServiceClientMock
	defaultExpectation *LostIdServiceClientMockListCollectibleExpectation
	expectations       []*LostIdServiceClientMockListCollectibleExpectation

	callArgs []*LostIdServiceClientMockListCollectibleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceClientMockListCollectibleExpectation specifies expectation struct of the LostIdServiceClient.ListCollectible
type LostIdServiceClientMockListCollectibleExpectation struct {
	mock               *LostIdServiceClientMock
	params             *LostIdServiceClientMockListCollectibleParams
	paramPtrs          *LostIdServiceClientMockListCollectibleParamPtrs
	expectationOrigins LostIdServiceClientMockListCollectibleExpectationOrigins
	results            *LostIdServiceClientMockListCollectibleResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceClientMockListCollectibleParams contains parameters of the LostIdServiceClient.ListCollectible
type LostIdServiceClientMockListCollectibleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListCollectibleRequest]
}

// LostIdServiceClientMockListCollectibleParamPtrs contains pointers to parameters of the LostIdServiceClient.ListCollectible
type LostIdServiceClientMockListCollectibleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListCollectibleRequest]
}

// LostIdServiceClientMockListCollectibleResults contains results of the LostIdServiceClient.ListCollectible
type LostIdServiceClientMockListCollectibleResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListCollectibleResponse]
	err error
}

// LostIdServiceClientMockListCollectibleOrigins contains origins of expectations of the LostIdServiceClient.ListCollectible
type LostIdServiceClientMockListCollectibleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Optional() *mLostIdServiceClientMockListCollectible {
	mmListCollectible.optional = true
	return mmListCollectible
}

// Expect sets up expected params for LostIdServiceClient.ListCollectible
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Expect(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest]) *mLostIdServiceClientMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceClientMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.paramPtrs != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by ExpectParams functions")
	}

	mmListCollectible.defaultExpectation.params = &LostIdServiceClientMockListCollectibleParams{ctx, pp1}
	mmListCollectible.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCollectible.expectations {
		if minimock.Equal(e.params, mmListCollectible.defaultExpectation.params) {
			mmListCollectible.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCollectible.defaultExpectation.params)
		}
	}

	return mmListCollectible
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceClient.ListCollectible
func (mmListCollectible *mLostIdServiceClientMockListCollectible) ExpectCtxParam1(ctx context.Context) *mLostIdServiceClientMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceClientMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.params != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Expect")
	}

	if mmListCollectible.defaultExpectation.paramPtrs == nil {
		mmListCollectible.defaultExpectation.paramPtrs = &LostIdServiceClientMockListCollectibleParamPtrs{}
	}
	mmListCollectible.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCollectible.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCollectible
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceClient.ListCollectible
func (mmListCollectible *mLostIdServiceClientMockListCollectible) ExpectPp1Param2(pp1 *connect.Request[v1.ListCollectibleRequest]) *mLostIdServiceClientMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceClientMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.params != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Expect")
	}

	if mmListCollectible.defaultExpectation.paramPtrs == nil {
		mmListCollectible.defaultExpectation.paramPtrs = &LostIdServiceClientMockListCollectibleParamPtrs{}
	}
	mmListCollectible.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListCollectible.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListCollectible
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceClient.ListCollectible
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest])) *mLostIdServiceClientMockListCollectible {
	if mmListCollectible.mock.inspectFuncListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("Inspect function is already set for LostIdServiceClientMock.ListCollectible")
	}

	mmListCollectible.mock.inspectFuncListCollectible = f

	return mmListCollectible
}

// Return sets up results that will be returned by LostIdServiceClient.ListCollectible
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Return(pp2 *connect.ServerStreamForClient[v1.ListCollectibleResponse], err error) *LostIdServiceClientMock {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceClientMockListCollectibleExpectation{mock: mmListCollectible.mock}
	}
	mmListCollectible.defaultExpectation.results = &LostIdServiceClientMockListCollectibleResults{pp2, err}
	mmListCollectible.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCollectible.mock
}

// Set uses given function f to mock the LostIdServiceClient.ListCollectible method
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListCollectibleResponse], err error)) *LostIdServiceClientMock {
	if mmListCollectible.defaultExpectation != nil {
		mmListCollectible.mock.t.Fatalf("Default expectation is already set for the LostIdServiceClient.ListCollectible method")
	}

	if len(mmListCollectible.expectations) > 0 {
		mmListCollectible.mock.t.Fatalf("Some expectations are already set for the LostIdServiceClient.ListCollectible method")
	}

	mmListCollectible.mock.funcListCollectible = f
	mmListCollectible.mock.funcListCollectibleOrigin = minimock.CallerInfo(1)
	return mmListCollectible.mock
}

// When sets expectation for the LostIdServiceClient.ListCollectible which will trigger the result defined by the following
// Then helper
func (mmListCollectible *mLostIdServiceClientMockListCollectible) When(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest]) *LostIdServiceClientMockListCollectibleExpectation {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceClientMock.ListCollectible mock is already set by Set")
	}

	expectation := &LostIdServiceClientMockListCollectibleExpectation{
		mock:               mmListCollectible.mock,
		params:             &LostIdServiceClientMockListCollectibleParams{ctx, pp1},
		expectationOrigins: LostIdServiceClientMockListCollectibleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCollectible.expectations = append(mmListCollectible.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceClient.ListCollectible return parameters for the expectation previously defined by the When method
func (e *LostIdServiceClientMockListCollectibleExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListCollectibleResponse], err error) *LostIdServiceClientMock {
	e.results = &LostIdServiceClientMockListCollectibleResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceClient.ListCollectible should be invoked
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Times(n uint64) *mLostIdServiceClientMockListCollectible {
	if n == 0 {
		mmListCollectible.mock.t.Fatalf("Times of LostIdServiceClientMock.ListCollectible mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCollectible.expectedInvocations, n)
	mmListCollectible.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCollectible
}

func (mmListCollectible *mLostIdServiceClientMockListCollectible) invocationsDone() bool {
	if len(mmListCollectible.expectations) == 0 && mmListCollectible.defaultExpectation == nil && mmListCollectible.mock.funcListCollectible == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCollectible.mock.afterListCollectibleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCollectible.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCollectible implements mm_lostidv1connect.LostIdServiceClient
func (mmListCollectible *LostIdServiceClientMock) ListCollectible(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest]) (pp2 *connect.ServerStreamForClient[v1.ListCollectibleResponse], err error) {
	mm_atomic.AddUint64(&mmListCollectible.beforeListCollectibleCounter, 1)
	defer mm_atomic.AddUint64(&mmListCollectible.afterListCollectibleCounter, 1)

	mmListCollectible.t.Helper()

	if mmListCollectible.inspectFuncListCollectible != nil {
		mmListCollectible.inspectFuncListCollectible(ctx, pp1)
	}

	mm_params := LostIdServiceClientMockListCollectibleParams{ctx, pp1}

	// Record call args
	mmListCollectible.ListCollectibleMock.mutex.Lock()
	mmListCollectible.ListCollectibleMock.callArgs = append(mmListCollectible.ListCollectibleMock.callArgs, &mm_params)
	mmListCollectible.ListCollectibleMock.mutex.Unlock()

	for _, e := range mmListCollectible.ListCollectibleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListCollectible.ListCollectibleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCollectible.ListCollectibleMock.defaultExpectation.Counter, 1)
		mm_want := mmListCollectible.ListCollectibleMock.defaultExpectation.params
		mm_want_ptrs := mmListCollectible.ListCollectibleMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceClientMockListCollectibleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCollectible.t.Errorf("LostIdServiceClientMock.ListCollectible got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListCollectible.t.Errorf("LostIdServiceClientMock.ListCollectible got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCollectible.t.Errorf("LostIdServiceClientMock.ListCollectible got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCollectible.ListCollectibleMock.defaultExpectation.results
		if mm_results == nil {
			mmListCollectible.t.Fatal("No results are set for the LostIdServiceClientMock.ListCollectible")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListCollectible.funcListCollectible != nil {
		return mmListCollectible.funcListCollectible(ctx, pp1)
	}
	mmListCollectible.t.Fatalf("Unexpected call to LostIdServiceClientMock.ListCollectible. %v %v", ctx, pp1)
	return
}

// ListCollectibleAfterCounter returns a count of finished LostIdServiceClientMock.ListCollectible invocations
func (mmListCollectible *LostIdServiceClientMock) ListCollectibleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCollectible.afterListCollectibleCounter)
}

// ListCollectibleBeforeCounter returns a count of LostIdServiceClientMock.ListCollectible invocations
func (mmListCollectible *LostIdServiceClientMock) ListCollectibleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCollectible.beforeListCollectibleCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceClientMock.ListCollectible.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCollectible *mLostIdServiceClientMockListCollectible) Calls() []*LostIdServiceClientMockListCollectibleParams {
	mmListCollectible.mutex.RLock()

	argCopy := make([]*LostIdServiceClientMockListCollectibleParams, len(mmListCollectible.callArgs))
	copy(argCopy, mmListCollectible.callArgs)

	mmListCollectible.mutex.RUnlock()

	return argCopy
}

// MinimockListCollectibleDone returns true if the count of the ListCollectible invocations corresponds
// the number of defined expectations
func (m *LostIdServiceClientMock) MinimockListCollectibleDone() bool {
	if m.ListCollectibleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCollectibleMock.invocationsDone()
}

// MinimockListCollectibleInspect logs each unmet expectation
func (m *LostIdServiceClientMock) MinimockListCollectibleInspect() {
	for _, e := range m.ListCollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListCollectible at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCollectibleCounter := mm_atomic.LoadUint64(&m.afterListCollectibleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCollectibleMock.defaultExpectation != nil && afterListCollectibleCounter < 1 {
		if m.ListCollectibleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListCollectible at\n%s", m.ListCollectibleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListCollectible at\n%s with params: %#v", m.ListCollectibleMock.defaultExpectation.expectationOrigins.origin, *m.ListCollectibleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCollectible != nil && afterListCollectibleCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceClientMock.ListCollectible at\n%s", m.funcListCollectibleOrigin)
	}

	if !m.ListCollectibleMock.invocationsDone() && afterListCollectibleCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceClientMock.ListCollectible at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCollectibleMock.expectedInvocations), m.ListCollectibleMock.expectedInvocationsOrigin, afterListCollectibleCounter)
	}
}

type mLostIdServiceClientMockListSearch struct {
	optional           bool
	mock               *LostIdServiceClientMock
	defaultExpectation *LostIdServiceClientMockListSearchExpectation
	expectations       []*LostIdServiceClientMockListSearchExpectation

	callArgs []*LostIdServiceClientMockListSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceClientMockListSearchExpectation specifies expectation struct of the LostIdServiceClient.ListSearch
type LostIdServiceClientMockListSearchExpectation struct {
	mock               *LostIdServiceClientMock
	params             *LostIdServiceClientMockListSearchParams
	paramPtrs          *LostIdServiceClientMockListSearchParamPtrs
	expectationOrigins LostIdServiceClientMockListSearchExpectationOrigins
	results            *LostIdServiceClientMockListSearchResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceClientMockListSearchParams contains parameters of the LostIdServiceClient.ListSearch
type LostIdServiceClientMockListSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListSearchRequest]
}

// LostIdServiceClientMockListSearchParamPtrs contains pointers to parameters of the LostIdServiceClient.ListSearch
type LostIdServiceClientMockListSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListSearchRequest]
}

// LostIdServiceClientMockListSearchResults contains results of the LostIdServiceClient.ListSearch
type LostIdServiceClientMockListSearchResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListSearchResponse]
	err error
}

// LostIdServiceClientMockListSearchOrigins contains origins of expectations of the LostIdServiceClient.ListSearch
type LostIdServiceClientMockListSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSearch *mLostIdServiceClientMockListSearch) Optional() *mLostIdServiceClientMockListSearch {
	mmListSearch.optional = true
	return mmListSearch
}

// Expect sets up expected params for LostIdServiceClient.ListSearch
func (mmListSearch *mLostIdServiceClientMockListSearch) Expect(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest]) *mLostIdServiceClientMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceClientMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.paramPtrs != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by ExpectParams functions")
	}

	mmListSearch.defaultExpectation.params = &LostIdServiceClientMockListSearchParams{ctx, pp1}
	mmListSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSearch.expectations {
		if minimock.Equal(e.params, mmListSearch.defaultExpectation.params) {
			mmListSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSearch.defaultExpectation.params)
		}
	}

	return mmListSearch
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceClient.ListSearch
func (mmListSearch *mLostIdServiceClientMockListSearch) ExpectCtxParam1(ctx context.Context) *mLostIdServiceClientMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceClientMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.params != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Expect")
	}

	if mmListSearch.defaultExpectation.paramPtrs == nil {
		mmListSearch.defaultExpectation.paramPtrs = &LostIdServiceClientMockListSearchParamPtrs{}
	}
	mmListSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSearch
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceClient.ListSearch
func (mmListSearch *mLostIdServiceClientMockListSearch) ExpectPp1Param2(pp1 *connect.Request[v1.ListSearchRequest]) *mLostIdServiceClientMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceClientMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.params != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Expect")
	}

	if mmListSearch.defaultExpectation.paramPtrs == nil {
		mmListSearch.defaultExpectation.paramPtrs = &LostIdServiceClientMockListSearchParamPtrs{}
	}
	mmListSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListSearch
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceClient.ListSearch
func (mmListSearch *mLostIdServiceClientMockListSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest])) *mLostIdServiceClientMockListSearch {
	if mmListSearch.mock.inspectFuncListSearch != nil {
		mmListSearch.mock.t.Fatalf("Inspect function is already set for LostIdServiceClientMock.ListSearch")
	}

	mmListSearch.mock.inspectFuncListSearch = f

	return mmListSearch
}

// Return sets up results that will be returned by LostIdServiceClient.ListSearch
func (mmListSearch *mLostIdServiceClientMockListSearch) Return(pp2 *connect.ServerStreamForClient[v1.ListSearchResponse], err error) *LostIdServiceClientMock {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceClientMockListSearchExpectation{mock: mmListSearch.mock}
	}
	mmListSearch.defaultExpectation.results = &LostIdServiceClientMockListSearchResults{pp2, err}
	mmListSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSearch.mock
}

// Set uses given function f to mock the LostIdServiceClient.ListSearch method
func (mmListSearch *mLostIdServiceClientMockListSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest]) (pp2 *connect.ServerStreamForClient[v1.ListSearchResponse], err error)) *LostIdServiceClientMock {
	if mmListSearch.defaultExpectation != nil {
		mmListSearch.mock.t.Fatalf("Default expectation is already set for the LostIdServiceClient.ListSearch method")
	}

	if len(mmListSearch.expectations) > 0 {
		mmListSearch.mock.t.Fatalf("Some expectations are already set for the LostIdServiceClient.ListSearch method")
	}

	mmListSearch.mock.funcListSearch = f
	mmListSearch.mock.funcListSearchOrigin = minimock.CallerInfo(1)
	return mmListSearch.mock
}

// When sets expectation for the LostIdServiceClient.ListSearch which will trigger the result defined by the following
// Then helper
func (mmListSearch *mLostIdServiceClientMockListSearch) When(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest]) *LostIdServiceClientMockListSearchExpectation {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceClientMock.ListSearch mock is already set by Set")
	}

	expectation := &LostIdServiceClientMockListSearchExpectation{
		mock:               mmListSearch.mock,
		params:             &LostIdServiceClientMockListSearchParams{ctx, pp1},
		expectationOrigins: LostIdServiceClientMockListSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSearch.expectations = append(mmListSearch.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceClient.ListSearch return parameters for the expectation previously defined by the When method
func (e *LostIdServiceClientMockListSearchExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListSearchResponse], err error) *LostIdServiceClientMock {
	e.results = &LostIdServiceClientMockListSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceClient.ListSearch should be invoked
func (mmListSearch *mLostIdServiceClientMockListSearch) Times(n uint64) *mLostIdServiceClientMockListSearch {
	if n == 0 {
		mmListSearch.mock.t.Fatalf("Times of LostIdServiceClientMock.ListSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSearch.expectedInvocations, n)
	mmListSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSearch
}

func (mmListSearch *mLostIdServiceClientMockListSearch) invocationsDone() bool {
	if len(mmListSearch.expectations) == 0 && mmListSearch.defaultExpectation == nil && mmListSearch.mock.funcListSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSearch.mock.afterListSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSearch implements mm_lostidv1connect.LostIdServiceClient
func (mmListSearch *LostIdServiceClientMock) ListSearch(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest]) (pp2 *connect.ServerStreamForClient[v1.ListSearchResponse], err error) {
	mm_atomic.AddUint64(&mmListSearch.beforeListSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmListSearch.afterListSearchCounter, 1)

	mmListSearch.t.Helper()

	if mmListSearch.inspectFuncListSearch != nil {
		mmListSearch.inspectFuncListSearch(ctx, pp1)
	}

	mm_params := LostIdServiceClientMockListSearchParams{ctx, pp1}

	// Record call args
	mmListSearch.ListSearchMock.mutex.Lock()
	mmListSearch.ListSearchMock.callArgs = append(mmListSearch.ListSearchMock.callArgs, &mm_params)
	mmListSearch.ListSearchMock.mutex.Unlock()

	for _, e := range mmListSearch.ListSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListSearch.ListSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSearch.ListSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmListSearch.ListSearchMock.defaultExpectation.params
		mm_want_ptrs := mmListSearch.ListSearchMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceClientMockListSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSearch.t.Errorf("LostIdServiceClientMock.ListSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListSearch.t.Errorf("LostIdServiceClientMock.ListSearch got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSearch.t.Errorf("LostIdServiceClientMock.ListSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSearch.ListSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmListSearch.t.Fatal("No results are set for the LostIdServiceClientMock.ListSearch")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListSearch.funcListSearch != nil {
		return mmListSearch.funcListSearch(ctx, pp1)
	}
	mmListSearch.t.Fatalf("Unexpected call to LostIdServiceClientMock.ListSearch. %v %v", ctx, pp1)
	return
}

// ListSearchAfterCounter returns a count of finished LostIdServiceClientMock.ListSearch invocations
func (mmListSearch *LostIdServiceClientMock) ListSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSearch.afterListSearchCounter)
}

// ListSearchBeforeCounter returns a count of LostIdServiceClientMock.ListSearch invocations
func (mmListSearch *LostIdServiceClientMock) ListSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSearch.beforeListSearchCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceClientMock.ListSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSearch *mLostIdServiceClientMockListSearch) Calls() []*LostIdServiceClientMockListSearchParams {
	mmListSearch.mutex.RLock()

	argCopy := make([]*LostIdServiceClientMockListSearchParams, len(mmListSearch.callArgs))
	copy(argCopy, mmListSearch.callArgs)

	mmListSearch.mutex.RUnlock()

	return argCopy
}

// MinimockListSearchDone returns true if the count of the ListSearch invocations corresponds
// the number of defined expectations
func (m *LostIdServiceClientMock) MinimockListSearchDone() bool {
	if m.ListSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSearchMock.invocationsDone()
}

// MinimockListSearchInspect logs each unmet expectation
func (m *LostIdServiceClientMock) MinimockListSearchInspect() {
	for _, e := range m.ListSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSearchCounter := mm_atomic.LoadUint64(&m.afterListSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSearchMock.defaultExpectation != nil && afterListSearchCounter < 1 {
		if m.ListSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListSearch at\n%s", m.ListSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListSearch at\n%s with params: %#v", m.ListSearchMock.defaultExpectation.expectationOrigins.origin, *m.ListSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSearch != nil && afterListSearchCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceClientMock.ListSearch at\n%s", m.funcListSearchOrigin)
	}

	if !m.ListSearchMock.invocationsDone() && afterListSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceClientMock.ListSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSearchMock.expectedInvocations), m.ListSearchMock.expectedInvocationsOrigin, afterListSearchCounter)
	}
}

type mLostIdServiceClientMockListTransaction struct {
	optional           bool
	mock               *LostIdServiceClientMock
	defaultExpectation *LostIdServiceClientMockListTransactionExpectation
	expectations       []*LostIdServiceClientMockListTransactionExpectation

	callArgs []*LostIdServiceClientMockListTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceClientMockListTransactionExpectation specifies expectation struct of the LostIdServiceClient.ListTransaction
type LostIdServiceClientMockListTransactionExpectation struct {
	mock               *LostIdServiceClientMock
	params             *LostIdServiceClientMockListTransactionParams
	paramPtrs          *LostIdServiceClientMockListTransactionParamPtrs
	expectationOrigins LostIdServiceClientMockListTransactionExpectationOrigins
	results            *LostIdServiceClientMockListTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceClientMockListTransactionParams contains parameters of the LostIdServiceClient.ListTransaction
type LostIdServiceClientMockListTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListTransactionRequest]
}

// LostIdServiceClientMockListTransactionParamPtrs contains pointers to parameters of the LostIdServiceClient.ListTransaction
type LostIdServiceClientMockListTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListTransactionRequest]
}

// LostIdServiceClientMockListTransactionResults contains results of the LostIdServiceClient.ListTransaction
type LostIdServiceClientMockListTransactionResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListTransactionResponse]
	err error
}

// LostIdServiceClientMockListTransactionOrigins contains origins of expectations of the LostIdServiceClient.ListTransaction
type LostIdServiceClientMockListTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Optional() *mLostIdServiceClientMockListTransaction {
	mmListTransaction.optional = true
	return mmListTransaction
}

// Expect sets up expected params for LostIdServiceClient.ListTransaction
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Expect(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest]) *mLostIdServiceClientMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceClientMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.paramPtrs != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by ExpectParams functions")
	}

	mmListTransaction.defaultExpectation.params = &LostIdServiceClientMockListTransactionParams{ctx, pp1}
	mmListTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTransaction.expectations {
		if minimock.Equal(e.params, mmListTransaction.defaultExpectation.params) {
			mmListTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTransaction.defaultExpectation.params)
		}
	}

	return mmListTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceClient.ListTransaction
func (mmListTransaction *mLostIdServiceClientMockListTransaction) ExpectCtxParam1(ctx context.Context) *mLostIdServiceClientMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceClientMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.params != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Expect")
	}

	if mmListTransaction.defaultExpectation.paramPtrs == nil {
		mmListTransaction.defaultExpectation.paramPtrs = &LostIdServiceClientMockListTransactionParamPtrs{}
	}
	mmListTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceClient.ListTransaction
func (mmListTransaction *mLostIdServiceClientMockListTransaction) ExpectPp1Param2(pp1 *connect.Request[v1.ListTransactionRequest]) *mLostIdServiceClientMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceClientMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.params != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Expect")
	}

	if mmListTransaction.defaultExpectation.paramPtrs == nil {
		mmListTransaction.defaultExpectation.paramPtrs = &LostIdServiceClientMockListTransactionParamPtrs{}
	}
	mmListTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListTransaction
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceClient.ListTransaction
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest])) *mLostIdServiceClientMockListTransaction {
	if mmListTransaction.mock.inspectFuncListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("Inspect function is already set for LostIdServiceClientMock.ListTransaction")
	}

	mmListTransaction.mock.inspectFuncListTransaction = f

	return mmListTransaction
}

// Return sets up results that will be returned by LostIdServiceClient.ListTransaction
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Return(pp2 *connect.ServerStreamForClient[v1.ListTransactionResponse], err error) *LostIdServiceClientMock {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceClientMockListTransactionExpectation{mock: mmListTransaction.mock}
	}
	mmListTransaction.defaultExpectation.results = &LostIdServiceClientMockListTransactionResults{pp2, err}
	mmListTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTransaction.mock
}

// Set uses given function f to mock the LostIdServiceClient.ListTransaction method
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListTransactionResponse], err error)) *LostIdServiceClientMock {
	if mmListTransaction.defaultExpectation != nil {
		mmListTransaction.mock.t.Fatalf("Default expectation is already set for the LostIdServiceClient.ListTransaction method")
	}

	if len(mmListTransaction.expectations) > 0 {
		mmListTransaction.mock.t.Fatalf("Some expectations are already set for the LostIdServiceClient.ListTransaction method")
	}

	mmListTransaction.mock.funcListTransaction = f
	mmListTransaction.mock.funcListTransactionOrigin = minimock.CallerInfo(1)
	return mmListTransaction.mock
}

// When sets expectation for the LostIdServiceClient.ListTransaction which will trigger the result defined by the following
// Then helper
func (mmListTransaction *mLostIdServiceClientMockListTransaction) When(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest]) *LostIdServiceClientMockListTransactionExpectation {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceClientMock.ListTransaction mock is already set by Set")
	}

	expectation := &LostIdServiceClientMockListTransactionExpectation{
		mock:               mmListTransaction.mock,
		params:             &LostIdServiceClientMockListTransactionParams{ctx, pp1},
		expectationOrigins: LostIdServiceClientMockListTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTransaction.expectations = append(mmListTransaction.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceClient.ListTransaction return parameters for the expectation previously defined by the When method
func (e *LostIdServiceClientMockListTransactionExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListTransactionResponse], err error) *LostIdServiceClientMock {
	e.results = &LostIdServiceClientMockListTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceClient.ListTransaction should be invoked
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Times(n uint64) *mLostIdServiceClientMockListTransaction {
	if n == 0 {
		mmListTransaction.mock.t.Fatalf("Times of LostIdServiceClientMock.ListTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTransaction.expectedInvocations, n)
	mmListTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTransaction
}

func (mmListTransaction *mLostIdServiceClientMockListTransaction) invocationsDone() bool {
	if len(mmListTransaction.expectations) == 0 && mmListTransaction.defaultExpectation == nil && mmListTransaction.mock.funcListTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTransaction.mock.afterListTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTransaction implements mm_lostidv1connect.LostIdServiceClient
func (mmListTransaction *LostIdServiceClientMock) ListTransaction(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListTransactionResponse], err error) {
	mm_atomic.AddUint64(&mmListTransaction.beforeListTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmListTransaction.afterListTransactionCounter, 1)

	mmListTransaction.t.Helper()

	if mmListTransaction.inspectFuncListTransaction != nil {
		mmListTransaction.inspectFuncListTransaction(ctx, pp1)
	}

	mm_params := LostIdServiceClientMockListTransactionParams{ctx, pp1}

	// Record call args
	mmListTransaction.ListTransactionMock.mutex.Lock()
	mmListTransaction.ListTransactionMock.callArgs = append(mmListTransaction.ListTransactionMock.callArgs, &mm_params)
	mmListTransaction.ListTransactionMock.mutex.Unlock()

	for _, e := range mmListTransaction.ListTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListTransaction.ListTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTransaction.ListTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmListTransaction.ListTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmListTransaction.ListTransactionMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceClientMockListTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTransaction.t.Errorf("LostIdServiceClientMock.ListTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListTransaction.t.Errorf("LostIdServiceClientMock.ListTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTransaction.t.Errorf("LostIdServiceClientMock.ListTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTransaction.ListTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmListTransaction.t.Fatal("No results are set for the LostIdServiceClientMock.ListTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListTransaction.funcListTransaction != nil {
		return mmListTransaction.funcListTransaction(ctx, pp1)
	}
	mmListTransaction.t.Fatalf("Unexpected call to LostIdServiceClientMock.ListTransaction. %v %v", ctx, pp1)
	return
}

// ListTransactionAfterCounter returns a count of finished LostIdServiceClientMock.ListTransaction invocations
func (mmListTransaction *LostIdServiceClientMock) ListTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTransaction.afterListTransactionCounter)
}

// ListTransactionBeforeCounter returns a count of LostIdServiceClientMock.ListTransaction invocations
func (mmListTransaction *LostIdServiceClientMock) ListTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTransaction.beforeListTransactionCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceClientMock.ListTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTransaction *mLostIdServiceClientMockListTransaction) Calls() []*LostIdServiceClientMockListTransactionParams {
	mmListTransaction.mutex.RLock()

	argCopy := make([]*LostIdServiceClientMockListTransactionParams, len(mmListTransaction.callArgs))
	copy(argCopy, mmListTransaction.callArgs)

	mmListTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockListTransactionDone returns true if the count of the ListTransaction invocations corresponds
// the number of defined expectations
func (m *LostIdServiceClientMock) MinimockListTransactionDone() bool {
	if m.ListTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTransactionMock.invocationsDone()
}

// MinimockListTransactionInspect logs each unmet expectation
func (m *LostIdServiceClientMock) MinimockListTransactionInspect() {
	for _, e := range m.ListTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTransactionCounter := mm_atomic.LoadUint64(&m.afterListTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTransactionMock.defaultExpectation != nil && afterListTransactionCounter < 1 {
		if m.ListTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListTransaction at\n%s", m.ListTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceClientMock.ListTransaction at\n%s with params: %#v", m.ListTransactionMock.defaultExpectation.expectationOrigins.origin, *m.ListTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTransaction != nil && afterListTransactionCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceClientMock.ListTransaction at\n%s", m.funcListTransactionOrigin)
	}

	if !m.ListTransactionMock.invocationsDone() && afterListTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceClientMock.ListTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTransactionMock.expectedInvocations), m.ListTransactionMock.expectedInvocationsOrigin, afterListTransactionCounter)
	}
}

type mLostIdServiceClientMockProgress struct {
	optional           bool
	mock               *LostIdServiceClientMock
	defaultExpectation *LostIdServiceClientMockProgressExpectation
	expectations       []*LostIdServiceClientMockProgressExpectation

	callArgs []*LostIdServiceClientMockProgressParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceClientMockProgressExpectation specifies expectation struct of the LostIdServiceClient.Progress
type LostIdServiceClientMockProgressExpectation struct {
	mock               *LostIdServiceClientMock
	params             *LostIdServiceClientMockProgressParams
	paramPtrs          *LostIdServiceClientMockProgressParamPtrs
	expectationOrigins LostIdServiceClientMockProgressExpectationOrigins
	results            *LostIdServiceClientMockProgressResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceClientMockProgressParams contains parameters of the LostIdServiceClient.Progress
type LostIdServiceClientMockProgressParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ProgressRequest]
}

// LostIdServiceClientMockProgressParamPtrs contains pointers to parameters of the LostIdServiceClient.Progress
type LostIdServiceClientMockProgressParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ProgressRequest]
}

// LostIdServiceClientMockProgressResults contains results of the LostIdServiceClient.Progress
type LostIdServiceClientMockProgressResults struct {
	pp2 *connect.Response[v1.ProgressResponse]
	err error
}

// LostIdServiceClientMockProgressOrigins contains origins of expectations of the LostIdServiceClient.Progress
type LostIdServiceClientMockProgressExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProgress *mLostIdServiceClientMockProgress) Optional() *mLostIdServiceClientMockProgress {
	mmProgress.optional = true
	return mmProgress
}

// Expect sets up expected params for LostIdServiceClient.Progress
func (mmProgress *mLostIdServiceClientMockProgress) Expect(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) *mLostIdServiceClientMockProgress {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceClientMockProgressExpectation{}
	}

	if mmProgress.defaultExpectation.paramPtrs != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by ExpectParams functions")
	}

	mmProgress.defaultExpectation.params = &LostIdServiceClientMockProgressParams{ctx, pp1}
	mmProgress.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProgress.expectations {
		if minimock.Equal(e.params, mmProgress.defaultExpectation.params) {
			mmProgress.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProgress.defaultExpectation.params)
		}
	}

	return mmProgress
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceClient.Progress
func (mmProgress *mLostIdServiceClientMockProgress) ExpectCtxParam1(ctx context.Context) *mLostIdServiceClientMockProgress {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceClientMockProgressExpectation{}
	}

	if mmProgress.defaultExpectation.params != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Expect")
	}

	if mmProgress.defaultExpectation.paramPtrs == nil {
		mmProgress.defaultExpectation.paramPtrs = &LostIdServiceClientMockProgressParamPtrs{}
	}
	mmProgress.defaultExpectation.paramPtrs.ctx = &ctx
	mmProgress.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProgress
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceClient.Progress
func (mmProgress *mLostIdServiceClientMockProgress) ExpectPp1Param2(pp1 *connect.Request[v1.ProgressRequest]) *mLostIdServiceClientMockProgress {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceClientMockProgressExpectation{}
	}

	if mmProgress.defaultExpectation.params != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Expect")
	}

	if mmProgress.defaultExpectation.paramPtrs == nil {
		mmProgress.defaultExpectation.paramPtrs = &LostIdServiceClientMockProgressParamPtrs{}
	}
	mmProgress.defaultExpectation.paramPtrs.pp1 = &pp1
	mmProgress.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmProgress
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceClient.Progress
func (mmProgress *mLostIdServiceClientMockProgress) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest])) *mLostIdServiceClientMockProgress {
	if mmProgress.mock.inspectFuncProgress != nil {
		mmProgress.mock.t.Fatalf("Inspect function is already set for LostIdServiceClientMock.Progress")
	}

	mmProgress.mock.inspectFuncProgress = f

	return mmProgress
}

// Return sets up results that will be returned by LostIdServiceClient.Progress
func (mmProgress *mLostIdServiceClientMockProgress) Return(pp2 *connect.Response[v1.ProgressResponse], err error) *LostIdServiceClientMock {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceClientMockProgressExpectation{mock: mmProgress.mock}
	}
	mmProgress.defaultExpectation.results = &LostIdServiceClientMockProgressResults{pp2, err}
	mmProgress.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProgress.mock
}

// Set uses given function f to mock the LostIdServiceClient.Progress method
func (mmProgress *mLostIdServiceClientMockProgress) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) (pp2 *connect.Response[v1.ProgressResponse], err error)) *LostIdServiceClientMock {
	if mmProgress.defaultExpectation != nil {
		mmProgress.mock.t.Fatalf("Default expectation is already set for the LostIdServiceClient.Progress method")
	}

	if len(mmProgress.expectations) > 0 {
		mmProgress.mock.t.Fatalf("Some expectations are already set for the LostIdServiceClient.Progress method")
	}

	mmProgress.mock.funcProgress = f
	mmProgress.mock.funcProgressOrigin = minimock.CallerInfo(1)
	return mmProgress.mock
}

// When sets expectation for the LostIdServiceClient.Progress which will trigger the result defined by the following
// Then helper
func (mmProgress *mLostIdServiceClientMockProgress) When(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) *LostIdServiceClientMockProgressExpectation {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceClientMock.Progress mock is already set by Set")
	}

	expectation := &LostIdServiceClientMockProgressExpectation{
		mock:               mmProgress.mock,
		params:             &LostIdServiceClientMockProgressParams{ctx, pp1},
		expectationOrigins: LostIdServiceClientMockProgressExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProgress.expectations = append(mmProgress.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceClient.Progress return parameters for the expectation previously defined by the When method
func (e *LostIdServiceClientMockProgressExpectation) Then(pp2 *connect.Response[v1.ProgressResponse], err error) *LostIdServiceClientMock {
	e.results = &LostIdServiceClientMockProgressResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceClient.Progress should be invoked
func (mmProgress *mLostIdServiceClientMockProgress) Times(n uint64) *mLostIdServiceClientMockProgress {
	if n == 0 {
		mmProgress.mock.t.Fatalf("Times of LostIdServiceClientMock.Progress mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProgress.expectedInvocations, n)
	mmProgress.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProgress
}

func (mmProgress *mLostIdServiceClientMockProgress) invocationsDone() bool {
	if len(mmProgress.expectations) == 0 && mmProgress.defaultExpectation == nil && mmProgress.mock.funcProgress == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProgress.mock.afterProgressCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProgress.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Progress implements mm_lostidv1connect.LostIdServiceClient
func (mmProgress *LostIdServiceClientMock) Progress(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) (pp2 *connect.Response[v1.ProgressResponse], err error) {
	mm_atomic.AddUint64(&mmProgress.beforeProgressCounter, 1)
	defer mm_atomic.AddUint64(&mmProgress.afterProgressCounter, 1)

	mmProgress.t.Helper()

	if mmProgress.inspectFuncProgress != nil {
		mmProgress.inspectFuncProgress(ctx, pp1)
	}

	mm_params := LostIdServiceClientMockProgressParams{ctx, pp1}

	// Record call args
	mmProgress.ProgressMock.mutex.Lock()
	mmProgress.ProgressMock.callArgs = append(mmProgress.ProgressMock.callArgs, &mm_params)
	mmProgress.ProgressMock.mutex.Unlock()

	for _, e := range mmProgress.ProgressMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmProgress.ProgressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProgress.ProgressMock.defaultExpectation.Counter, 1)
		mm_want := mmProgress.ProgressMock.defaultExpectation.params
		mm_want_ptrs := mmProgress.ProgressMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceClientMockProgressParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProgress.t.Errorf("LostIdServiceClientMock.Progress got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProgress.ProgressMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmProgress.t.Errorf("LostIdServiceClientMock.Progress got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProgress.ProgressMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProgress.t.Errorf("LostIdServiceClientMock.Progress got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProgress.ProgressMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProgress.ProgressMock.defaultExpectation.results
		if mm_results == nil {
			mmProgress.t.Fatal("No results are set for the LostIdServiceClientMock.Progress")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmProgress.funcProgress != nil {
		return mmProgress.funcProgress(ctx, pp1)
	}
	mmProgress.t.Fatalf("Unexpected call to LostIdServiceClientMock.Progress. %v %v", ctx, pp1)
	return
}

// ProgressAfterCounter returns a count of finished LostIdServiceClientMock.Progress invocations
func (mmProgress *LostIdServiceClientMock) ProgressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProgress.afterProgressCounter)
}

// ProgressBeforeCounter returns a count of LostIdServiceClientMock.Progress invocations
func (mmProgress *LostIdServiceClientMock) ProgressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProgress.beforeProgressCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceClientMock.Progress.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProgress *mLostIdServiceClientMockProgress) Calls() []*LostIdServiceClientMockProgressParams {
	mmProgress.mutex.RLock()

	argCopy := make([]*LostIdServiceClientMockProgressParams, len(mmProgress.callArgs))
	copy(argCopy, mmProgress.callArgs)

	mmProgress.mutex.RUnlock()

	return argCopy
}

// MinimockProgressDone returns true if the count of the Progress invocations corresponds
// the number of defined expectations
func (m *LostIdServiceClientMock) MinimockProgressDone() bool {
	if m.ProgressMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProgressMock.invocationsDone()
}

// MinimockProgressInspect logs each unmet expectation
func (m *LostIdServiceClientMock) MinimockProgressInspect() {
	for _, e := range m.ProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Progress at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProgressCounter := mm_atomic.LoadUint64(&m.afterProgressCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProgressMock.defaultExpectation != nil && afterProgressCounter < 1 {
		if m.ProgressMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Progress at\n%s", m.ProgressMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Progress at\n%s with params: %#v", m.ProgressMock.defaultExpectation.expectationOrigins.origin, *m.ProgressMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProgress != nil && afterProgressCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceClientMock.Progress at\n%s", m.funcProgressOrigin)
	}

	if !m.ProgressMock.invocationsDone() && afterProgressCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceClientMock.Progress at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProgressMock.expectedInvocations), m.ProgressMock.expectedInvocationsOrigin, afterProgressCounter)
	}
}

type mLostIdServiceClientMockSearch struct {
	optional           bool
	mock               *LostIdServiceClientMock
	defaultExpectation *LostIdServiceClientMockSearchExpectation
	expectations       []*LostIdServiceClientMockSearchExpectation

	callArgs []*LostIdServiceClientMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceClientMockSearchExpectation specifies expectation struct of the LostIdServiceClient.Search
type LostIdServiceClientMockSearchExpectation struct {
	mock               *LostIdServiceClientMock
	params             *LostIdServiceClientMockSearchParams
	paramPtrs          *LostIdServiceClientMockSearchParamPtrs
	expectationOrigins LostIdServiceClientMockSearchExpectationOrigins
	results            *LostIdServiceClientMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceClientMockSearchParams contains parameters of the LostIdServiceClient.Search
type LostIdServiceClientMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// LostIdServiceClientMockSearchParamPtrs contains pointers to parameters of the LostIdServiceClient.Search
type LostIdServiceClientMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// LostIdServiceClientMockSearchResults contains results of the LostIdServiceClient.Search
type LostIdServiceClientMockSearchResults struct {
	pp2 *connect.Response[v1.SearchResponse]
	err error
}

// LostIdServiceClientMockSearchOrigins contains origins of expectations of the LostIdServiceClient.Search
type LostIdServiceClientMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mLostIdServiceClientMockSearch) Optional() *mLostIdServiceClientMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for LostIdServiceClient.Search
func (mmSearch *mLostIdServiceClientMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mLostIdServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &LostIdServiceClientMockSearchParams{ctx, pp1}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceClient.Search
func (mmSearch *mLostIdServiceClientMockSearch) ExpectCtxParam1(ctx context.Context) *mLostIdServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &LostIdServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceClient.Search
func (mmSearch *mLostIdServiceClientMockSearch) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mLostIdServiceClientMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceClientMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &LostIdServiceClientMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceClient.Search
func (mmSearch *mLostIdServiceClientMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mLostIdServiceClientMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for LostIdServiceClientMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by LostIdServiceClient.Search
func (mmSearch *mLostIdServiceClientMockSearch) Return(pp2 *connect.Response[v1.SearchResponse], err error) *LostIdServiceClientMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceClientMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &LostIdServiceClientMockSearchResults{pp2, err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the LostIdServiceClient.Search method
func (mmSearch *mLostIdServiceClientMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.Response[v1.SearchResponse], err error)) *LostIdServiceClientMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the LostIdServiceClient.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the LostIdServiceClient.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the LostIdServiceClient.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mLostIdServiceClientMockSearch) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *LostIdServiceClientMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceClientMock.Search mock is already set by Set")
	}

	expectation := &LostIdServiceClientMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &LostIdServiceClientMockSearchParams{ctx, pp1},
		expectationOrigins: LostIdServiceClientMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceClient.Search return parameters for the expectation previously defined by the When method
func (e *LostIdServiceClientMockSearchExpectation) Then(pp2 *connect.Response[v1.SearchResponse], err error) *LostIdServiceClientMock {
	e.results = &LostIdServiceClientMockSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceClient.Search should be invoked
func (mmSearch *mLostIdServiceClientMockSearch) Times(n uint64) *mLostIdServiceClientMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of LostIdServiceClientMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mLostIdServiceClientMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_lostidv1connect.LostIdServiceClient
func (mmSearch *LostIdServiceClientMock) Search(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.Response[v1.SearchResponse], err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1)
	}

	mm_params := LostIdServiceClientMockSearchParams{ctx, pp1}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceClientMockSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("LostIdServiceClientMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("LostIdServiceClientMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("LostIdServiceClientMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the LostIdServiceClientMock.Search")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1)
	}
	mmSearch.t.Fatalf("Unexpected call to LostIdServiceClientMock.Search. %v %v", ctx, pp1)
	return
}

// SearchAfterCounter returns a count of finished LostIdServiceClientMock.Search invocations
func (mmSearch *LostIdServiceClientMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of LostIdServiceClientMock.Search invocations
func (mmSearch *LostIdServiceClientMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceClientMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mLostIdServiceClientMockSearch) Calls() []*LostIdServiceClientMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*LostIdServiceClientMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *LostIdServiceClientMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *LostIdServiceClientMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceClientMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceClientMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceClientMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LostIdServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCollectibleInspect()

			m.MinimockListCollectibleInspect()

			m.MinimockListSearchInspect()

			m.MinimockListTransactionInspect()

			m.MinimockProgressInspect()

			m.MinimockSearchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LostIdServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LostIdServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCollectibleDone() &&
		m.MinimockListCollectibleDone() &&
		m.MinimockListSearchDone() &&
		m.MinimockListTransactionDone() &&
		m.MinimockProgressDone() &&
		m.MinimockSearchDone()
}
