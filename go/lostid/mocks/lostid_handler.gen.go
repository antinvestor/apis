// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/lostid/connectrpc/go/lostid/v1/lostidv1connect.LostIdServiceHandler -o lostid_handler.gen.go -n LostIdServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v11 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v1 "buf.build/gen/go/antinvestor/lostid/protocolbuffers/go/lostid/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// LostIdServiceHandlerMock implements mm_lostidv1connect.LostIdServiceHandler
type LostIdServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCollectible          func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) (pp2 *connect.Response[v1.CollectibleResponse], err error)
	funcCollectibleOrigin    string
	inspectFuncCollectible   func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest])
	afterCollectibleCounter  uint64
	beforeCollectibleCounter uint64
	CollectibleMock          mLostIdServiceHandlerMockCollectible

	funcListCollectible          func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse]) (err error)
	funcListCollectibleOrigin    string
	inspectFuncListCollectible   func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse])
	afterListCollectibleCounter  uint64
	beforeListCollectibleCounter uint64
	ListCollectibleMock          mLostIdServiceHandlerMockListCollectible

	funcListSearch          func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse]) (err error)
	funcListSearchOrigin    string
	inspectFuncListSearch   func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse])
	afterListSearchCounter  uint64
	beforeListSearchCounter uint64
	ListSearchMock          mLostIdServiceHandlerMockListSearch

	funcListTransaction          func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse]) (err error)
	funcListTransactionOrigin    string
	inspectFuncListTransaction   func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse])
	afterListTransactionCounter  uint64
	beforeListTransactionCounter uint64
	ListTransactionMock          mLostIdServiceHandlerMockListTransaction

	funcProgress          func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) (pp2 *connect.Response[v1.ProgressResponse], err error)
	funcProgressOrigin    string
	inspectFuncProgress   func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest])
	afterProgressCounter  uint64
	beforeProgressCounter uint64
	ProgressMock          mLostIdServiceHandlerMockProgress

	funcSearch          func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.Response[v1.SearchResponse], err error)
	funcSearchOrigin    string
	inspectFuncSearch   func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])
	afterSearchCounter  uint64
	beforeSearchCounter uint64
	SearchMock          mLostIdServiceHandlerMockSearch
}

// NewLostIdServiceHandlerMock returns a mock for mm_lostidv1connect.LostIdServiceHandler
func NewLostIdServiceHandlerMock(t minimock.Tester) *LostIdServiceHandlerMock {
	m := &LostIdServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CollectibleMock = mLostIdServiceHandlerMockCollectible{mock: m}
	m.CollectibleMock.callArgs = []*LostIdServiceHandlerMockCollectibleParams{}

	m.ListCollectibleMock = mLostIdServiceHandlerMockListCollectible{mock: m}
	m.ListCollectibleMock.callArgs = []*LostIdServiceHandlerMockListCollectibleParams{}

	m.ListSearchMock = mLostIdServiceHandlerMockListSearch{mock: m}
	m.ListSearchMock.callArgs = []*LostIdServiceHandlerMockListSearchParams{}

	m.ListTransactionMock = mLostIdServiceHandlerMockListTransaction{mock: m}
	m.ListTransactionMock.callArgs = []*LostIdServiceHandlerMockListTransactionParams{}

	m.ProgressMock = mLostIdServiceHandlerMockProgress{mock: m}
	m.ProgressMock.callArgs = []*LostIdServiceHandlerMockProgressParams{}

	m.SearchMock = mLostIdServiceHandlerMockSearch{mock: m}
	m.SearchMock.callArgs = []*LostIdServiceHandlerMockSearchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLostIdServiceHandlerMockCollectible struct {
	optional           bool
	mock               *LostIdServiceHandlerMock
	defaultExpectation *LostIdServiceHandlerMockCollectibleExpectation
	expectations       []*LostIdServiceHandlerMockCollectibleExpectation

	callArgs []*LostIdServiceHandlerMockCollectibleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceHandlerMockCollectibleExpectation specifies expectation struct of the LostIdServiceHandler.Collectible
type LostIdServiceHandlerMockCollectibleExpectation struct {
	mock               *LostIdServiceHandlerMock
	params             *LostIdServiceHandlerMockCollectibleParams
	paramPtrs          *LostIdServiceHandlerMockCollectibleParamPtrs
	expectationOrigins LostIdServiceHandlerMockCollectibleExpectationOrigins
	results            *LostIdServiceHandlerMockCollectibleResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceHandlerMockCollectibleParams contains parameters of the LostIdServiceHandler.Collectible
type LostIdServiceHandlerMockCollectibleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CollectibleRequest]
}

// LostIdServiceHandlerMockCollectibleParamPtrs contains pointers to parameters of the LostIdServiceHandler.Collectible
type LostIdServiceHandlerMockCollectibleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CollectibleRequest]
}

// LostIdServiceHandlerMockCollectibleResults contains results of the LostIdServiceHandler.Collectible
type LostIdServiceHandlerMockCollectibleResults struct {
	pp2 *connect.Response[v1.CollectibleResponse]
	err error
}

// LostIdServiceHandlerMockCollectibleOrigins contains origins of expectations of the LostIdServiceHandler.Collectible
type LostIdServiceHandlerMockCollectibleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Optional() *mLostIdServiceHandlerMockCollectible {
	mmCollectible.optional = true
	return mmCollectible
}

// Expect sets up expected params for LostIdServiceHandler.Collectible
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Expect(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) *mLostIdServiceHandlerMockCollectible {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceHandlerMockCollectibleExpectation{}
	}

	if mmCollectible.defaultExpectation.paramPtrs != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by ExpectParams functions")
	}

	mmCollectible.defaultExpectation.params = &LostIdServiceHandlerMockCollectibleParams{ctx, pp1}
	mmCollectible.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCollectible.expectations {
		if minimock.Equal(e.params, mmCollectible.defaultExpectation.params) {
			mmCollectible.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCollectible.defaultExpectation.params)
		}
	}

	return mmCollectible
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceHandler.Collectible
func (mmCollectible *mLostIdServiceHandlerMockCollectible) ExpectCtxParam1(ctx context.Context) *mLostIdServiceHandlerMockCollectible {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceHandlerMockCollectibleExpectation{}
	}

	if mmCollectible.defaultExpectation.params != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Expect")
	}

	if mmCollectible.defaultExpectation.paramPtrs == nil {
		mmCollectible.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockCollectibleParamPtrs{}
	}
	mmCollectible.defaultExpectation.paramPtrs.ctx = &ctx
	mmCollectible.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCollectible
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceHandler.Collectible
func (mmCollectible *mLostIdServiceHandlerMockCollectible) ExpectPp1Param2(pp1 *connect.Request[v1.CollectibleRequest]) *mLostIdServiceHandlerMockCollectible {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceHandlerMockCollectibleExpectation{}
	}

	if mmCollectible.defaultExpectation.params != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Expect")
	}

	if mmCollectible.defaultExpectation.paramPtrs == nil {
		mmCollectible.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockCollectibleParamPtrs{}
	}
	mmCollectible.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCollectible.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCollectible
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceHandler.Collectible
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest])) *mLostIdServiceHandlerMockCollectible {
	if mmCollectible.mock.inspectFuncCollectible != nil {
		mmCollectible.mock.t.Fatalf("Inspect function is already set for LostIdServiceHandlerMock.Collectible")
	}

	mmCollectible.mock.inspectFuncCollectible = f

	return mmCollectible
}

// Return sets up results that will be returned by LostIdServiceHandler.Collectible
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Return(pp2 *connect.Response[v1.CollectibleResponse], err error) *LostIdServiceHandlerMock {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Set")
	}

	if mmCollectible.defaultExpectation == nil {
		mmCollectible.defaultExpectation = &LostIdServiceHandlerMockCollectibleExpectation{mock: mmCollectible.mock}
	}
	mmCollectible.defaultExpectation.results = &LostIdServiceHandlerMockCollectibleResults{pp2, err}
	mmCollectible.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCollectible.mock
}

// Set uses given function f to mock the LostIdServiceHandler.Collectible method
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) (pp2 *connect.Response[v1.CollectibleResponse], err error)) *LostIdServiceHandlerMock {
	if mmCollectible.defaultExpectation != nil {
		mmCollectible.mock.t.Fatalf("Default expectation is already set for the LostIdServiceHandler.Collectible method")
	}

	if len(mmCollectible.expectations) > 0 {
		mmCollectible.mock.t.Fatalf("Some expectations are already set for the LostIdServiceHandler.Collectible method")
	}

	mmCollectible.mock.funcCollectible = f
	mmCollectible.mock.funcCollectibleOrigin = minimock.CallerInfo(1)
	return mmCollectible.mock
}

// When sets expectation for the LostIdServiceHandler.Collectible which will trigger the result defined by the following
// Then helper
func (mmCollectible *mLostIdServiceHandlerMockCollectible) When(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) *LostIdServiceHandlerMockCollectibleExpectation {
	if mmCollectible.mock.funcCollectible != nil {
		mmCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.Collectible mock is already set by Set")
	}

	expectation := &LostIdServiceHandlerMockCollectibleExpectation{
		mock:               mmCollectible.mock,
		params:             &LostIdServiceHandlerMockCollectibleParams{ctx, pp1},
		expectationOrigins: LostIdServiceHandlerMockCollectibleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCollectible.expectations = append(mmCollectible.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceHandler.Collectible return parameters for the expectation previously defined by the When method
func (e *LostIdServiceHandlerMockCollectibleExpectation) Then(pp2 *connect.Response[v1.CollectibleResponse], err error) *LostIdServiceHandlerMock {
	e.results = &LostIdServiceHandlerMockCollectibleResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceHandler.Collectible should be invoked
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Times(n uint64) *mLostIdServiceHandlerMockCollectible {
	if n == 0 {
		mmCollectible.mock.t.Fatalf("Times of LostIdServiceHandlerMock.Collectible mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCollectible.expectedInvocations, n)
	mmCollectible.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCollectible
}

func (mmCollectible *mLostIdServiceHandlerMockCollectible) invocationsDone() bool {
	if len(mmCollectible.expectations) == 0 && mmCollectible.defaultExpectation == nil && mmCollectible.mock.funcCollectible == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCollectible.mock.afterCollectibleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCollectible.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Collectible implements mm_lostidv1connect.LostIdServiceHandler
func (mmCollectible *LostIdServiceHandlerMock) Collectible(ctx context.Context, pp1 *connect.Request[v1.CollectibleRequest]) (pp2 *connect.Response[v1.CollectibleResponse], err error) {
	mm_atomic.AddUint64(&mmCollectible.beforeCollectibleCounter, 1)
	defer mm_atomic.AddUint64(&mmCollectible.afterCollectibleCounter, 1)

	mmCollectible.t.Helper()

	if mmCollectible.inspectFuncCollectible != nil {
		mmCollectible.inspectFuncCollectible(ctx, pp1)
	}

	mm_params := LostIdServiceHandlerMockCollectibleParams{ctx, pp1}

	// Record call args
	mmCollectible.CollectibleMock.mutex.Lock()
	mmCollectible.CollectibleMock.callArgs = append(mmCollectible.CollectibleMock.callArgs, &mm_params)
	mmCollectible.CollectibleMock.mutex.Unlock()

	for _, e := range mmCollectible.CollectibleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCollectible.CollectibleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCollectible.CollectibleMock.defaultExpectation.Counter, 1)
		mm_want := mmCollectible.CollectibleMock.defaultExpectation.params
		mm_want_ptrs := mmCollectible.CollectibleMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceHandlerMockCollectibleParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCollectible.t.Errorf("LostIdServiceHandlerMock.Collectible got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectible.CollectibleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCollectible.t.Errorf("LostIdServiceHandlerMock.Collectible got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCollectible.CollectibleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCollectible.t.Errorf("LostIdServiceHandlerMock.Collectible got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCollectible.CollectibleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCollectible.CollectibleMock.defaultExpectation.results
		if mm_results == nil {
			mmCollectible.t.Fatal("No results are set for the LostIdServiceHandlerMock.Collectible")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCollectible.funcCollectible != nil {
		return mmCollectible.funcCollectible(ctx, pp1)
	}
	mmCollectible.t.Fatalf("Unexpected call to LostIdServiceHandlerMock.Collectible. %v %v", ctx, pp1)
	return
}

// CollectibleAfterCounter returns a count of finished LostIdServiceHandlerMock.Collectible invocations
func (mmCollectible *LostIdServiceHandlerMock) CollectibleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectible.afterCollectibleCounter)
}

// CollectibleBeforeCounter returns a count of LostIdServiceHandlerMock.Collectible invocations
func (mmCollectible *LostIdServiceHandlerMock) CollectibleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollectible.beforeCollectibleCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceHandlerMock.Collectible.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCollectible *mLostIdServiceHandlerMockCollectible) Calls() []*LostIdServiceHandlerMockCollectibleParams {
	mmCollectible.mutex.RLock()

	argCopy := make([]*LostIdServiceHandlerMockCollectibleParams, len(mmCollectible.callArgs))
	copy(argCopy, mmCollectible.callArgs)

	mmCollectible.mutex.RUnlock()

	return argCopy
}

// MinimockCollectibleDone returns true if the count of the Collectible invocations corresponds
// the number of defined expectations
func (m *LostIdServiceHandlerMock) MinimockCollectibleDone() bool {
	if m.CollectibleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CollectibleMock.invocationsDone()
}

// MinimockCollectibleInspect logs each unmet expectation
func (m *LostIdServiceHandlerMock) MinimockCollectibleInspect() {
	for _, e := range m.CollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Collectible at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCollectibleCounter := mm_atomic.LoadUint64(&m.afterCollectibleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CollectibleMock.defaultExpectation != nil && afterCollectibleCounter < 1 {
		if m.CollectibleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Collectible at\n%s", m.CollectibleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Collectible at\n%s with params: %#v", m.CollectibleMock.defaultExpectation.expectationOrigins.origin, *m.CollectibleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCollectible != nil && afterCollectibleCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceHandlerMock.Collectible at\n%s", m.funcCollectibleOrigin)
	}

	if !m.CollectibleMock.invocationsDone() && afterCollectibleCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceHandlerMock.Collectible at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CollectibleMock.expectedInvocations), m.CollectibleMock.expectedInvocationsOrigin, afterCollectibleCounter)
	}
}

type mLostIdServiceHandlerMockListCollectible struct {
	optional           bool
	mock               *LostIdServiceHandlerMock
	defaultExpectation *LostIdServiceHandlerMockListCollectibleExpectation
	expectations       []*LostIdServiceHandlerMockListCollectibleExpectation

	callArgs []*LostIdServiceHandlerMockListCollectibleParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceHandlerMockListCollectibleExpectation specifies expectation struct of the LostIdServiceHandler.ListCollectible
type LostIdServiceHandlerMockListCollectibleExpectation struct {
	mock               *LostIdServiceHandlerMock
	params             *LostIdServiceHandlerMockListCollectibleParams
	paramPtrs          *LostIdServiceHandlerMockListCollectibleParamPtrs
	expectationOrigins LostIdServiceHandlerMockListCollectibleExpectationOrigins
	results            *LostIdServiceHandlerMockListCollectibleResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceHandlerMockListCollectibleParams contains parameters of the LostIdServiceHandler.ListCollectible
type LostIdServiceHandlerMockListCollectibleParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListCollectibleRequest]
	pp2 *connect.ServerStream[v1.ListCollectibleResponse]
}

// LostIdServiceHandlerMockListCollectibleParamPtrs contains pointers to parameters of the LostIdServiceHandler.ListCollectible
type LostIdServiceHandlerMockListCollectibleParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListCollectibleRequest]
	pp2 **connect.ServerStream[v1.ListCollectibleResponse]
}

// LostIdServiceHandlerMockListCollectibleResults contains results of the LostIdServiceHandler.ListCollectible
type LostIdServiceHandlerMockListCollectibleResults struct {
	err error
}

// LostIdServiceHandlerMockListCollectibleOrigins contains origins of expectations of the LostIdServiceHandler.ListCollectible
type LostIdServiceHandlerMockListCollectibleExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Optional() *mLostIdServiceHandlerMockListCollectible {
	mmListCollectible.optional = true
	return mmListCollectible
}

// Expect sets up expected params for LostIdServiceHandler.ListCollectible
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Expect(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse]) *mLostIdServiceHandlerMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceHandlerMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.paramPtrs != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by ExpectParams functions")
	}

	mmListCollectible.defaultExpectation.params = &LostIdServiceHandlerMockListCollectibleParams{ctx, pp1, pp2}
	mmListCollectible.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCollectible.expectations {
		if minimock.Equal(e.params, mmListCollectible.defaultExpectation.params) {
			mmListCollectible.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCollectible.defaultExpectation.params)
		}
	}

	return mmListCollectible
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceHandler.ListCollectible
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) ExpectCtxParam1(ctx context.Context) *mLostIdServiceHandlerMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceHandlerMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.params != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Expect")
	}

	if mmListCollectible.defaultExpectation.paramPtrs == nil {
		mmListCollectible.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListCollectibleParamPtrs{}
	}
	mmListCollectible.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCollectible.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCollectible
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceHandler.ListCollectible
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) ExpectPp1Param2(pp1 *connect.Request[v1.ListCollectibleRequest]) *mLostIdServiceHandlerMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceHandlerMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.params != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Expect")
	}

	if mmListCollectible.defaultExpectation.paramPtrs == nil {
		mmListCollectible.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListCollectibleParamPtrs{}
	}
	mmListCollectible.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListCollectible.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListCollectible
}

// ExpectPp2Param3 sets up expected param pp2 for LostIdServiceHandler.ListCollectible
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListCollectibleResponse]) *mLostIdServiceHandlerMockListCollectible {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceHandlerMockListCollectibleExpectation{}
	}

	if mmListCollectible.defaultExpectation.params != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Expect")
	}

	if mmListCollectible.defaultExpectation.paramPtrs == nil {
		mmListCollectible.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListCollectibleParamPtrs{}
	}
	mmListCollectible.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListCollectible.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListCollectible
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceHandler.ListCollectible
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse])) *mLostIdServiceHandlerMockListCollectible {
	if mmListCollectible.mock.inspectFuncListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("Inspect function is already set for LostIdServiceHandlerMock.ListCollectible")
	}

	mmListCollectible.mock.inspectFuncListCollectible = f

	return mmListCollectible
}

// Return sets up results that will be returned by LostIdServiceHandler.ListCollectible
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Return(err error) *LostIdServiceHandlerMock {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Set")
	}

	if mmListCollectible.defaultExpectation == nil {
		mmListCollectible.defaultExpectation = &LostIdServiceHandlerMockListCollectibleExpectation{mock: mmListCollectible.mock}
	}
	mmListCollectible.defaultExpectation.results = &LostIdServiceHandlerMockListCollectibleResults{err}
	mmListCollectible.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCollectible.mock
}

// Set uses given function f to mock the LostIdServiceHandler.ListCollectible method
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse]) (err error)) *LostIdServiceHandlerMock {
	if mmListCollectible.defaultExpectation != nil {
		mmListCollectible.mock.t.Fatalf("Default expectation is already set for the LostIdServiceHandler.ListCollectible method")
	}

	if len(mmListCollectible.expectations) > 0 {
		mmListCollectible.mock.t.Fatalf("Some expectations are already set for the LostIdServiceHandler.ListCollectible method")
	}

	mmListCollectible.mock.funcListCollectible = f
	mmListCollectible.mock.funcListCollectibleOrigin = minimock.CallerInfo(1)
	return mmListCollectible.mock
}

// When sets expectation for the LostIdServiceHandler.ListCollectible which will trigger the result defined by the following
// Then helper
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) When(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse]) *LostIdServiceHandlerMockListCollectibleExpectation {
	if mmListCollectible.mock.funcListCollectible != nil {
		mmListCollectible.mock.t.Fatalf("LostIdServiceHandlerMock.ListCollectible mock is already set by Set")
	}

	expectation := &LostIdServiceHandlerMockListCollectibleExpectation{
		mock:               mmListCollectible.mock,
		params:             &LostIdServiceHandlerMockListCollectibleParams{ctx, pp1, pp2},
		expectationOrigins: LostIdServiceHandlerMockListCollectibleExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCollectible.expectations = append(mmListCollectible.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceHandler.ListCollectible return parameters for the expectation previously defined by the When method
func (e *LostIdServiceHandlerMockListCollectibleExpectation) Then(err error) *LostIdServiceHandlerMock {
	e.results = &LostIdServiceHandlerMockListCollectibleResults{err}
	return e.mock
}

// Times sets number of times LostIdServiceHandler.ListCollectible should be invoked
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Times(n uint64) *mLostIdServiceHandlerMockListCollectible {
	if n == 0 {
		mmListCollectible.mock.t.Fatalf("Times of LostIdServiceHandlerMock.ListCollectible mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCollectible.expectedInvocations, n)
	mmListCollectible.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCollectible
}

func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) invocationsDone() bool {
	if len(mmListCollectible.expectations) == 0 && mmListCollectible.defaultExpectation == nil && mmListCollectible.mock.funcListCollectible == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCollectible.mock.afterListCollectibleCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCollectible.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCollectible implements mm_lostidv1connect.LostIdServiceHandler
func (mmListCollectible *LostIdServiceHandlerMock) ListCollectible(ctx context.Context, pp1 *connect.Request[v1.ListCollectibleRequest], pp2 *connect.ServerStream[v1.ListCollectibleResponse]) (err error) {
	mm_atomic.AddUint64(&mmListCollectible.beforeListCollectibleCounter, 1)
	defer mm_atomic.AddUint64(&mmListCollectible.afterListCollectibleCounter, 1)

	mmListCollectible.t.Helper()

	if mmListCollectible.inspectFuncListCollectible != nil {
		mmListCollectible.inspectFuncListCollectible(ctx, pp1, pp2)
	}

	mm_params := LostIdServiceHandlerMockListCollectibleParams{ctx, pp1, pp2}

	// Record call args
	mmListCollectible.ListCollectibleMock.mutex.Lock()
	mmListCollectible.ListCollectibleMock.callArgs = append(mmListCollectible.ListCollectibleMock.callArgs, &mm_params)
	mmListCollectible.ListCollectibleMock.mutex.Unlock()

	for _, e := range mmListCollectible.ListCollectibleMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListCollectible.ListCollectibleMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCollectible.ListCollectibleMock.defaultExpectation.Counter, 1)
		mm_want := mmListCollectible.ListCollectibleMock.defaultExpectation.params
		mm_want_ptrs := mmListCollectible.ListCollectibleMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceHandlerMockListCollectibleParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCollectible.t.Errorf("LostIdServiceHandlerMock.ListCollectible got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListCollectible.t.Errorf("LostIdServiceHandlerMock.ListCollectible got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListCollectible.t.Errorf("LostIdServiceHandlerMock.ListCollectible got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCollectible.t.Errorf("LostIdServiceHandlerMock.ListCollectible got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCollectible.ListCollectibleMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCollectible.ListCollectibleMock.defaultExpectation.results
		if mm_results == nil {
			mmListCollectible.t.Fatal("No results are set for the LostIdServiceHandlerMock.ListCollectible")
		}
		return (*mm_results).err
	}
	if mmListCollectible.funcListCollectible != nil {
		return mmListCollectible.funcListCollectible(ctx, pp1, pp2)
	}
	mmListCollectible.t.Fatalf("Unexpected call to LostIdServiceHandlerMock.ListCollectible. %v %v %v", ctx, pp1, pp2)
	return
}

// ListCollectibleAfterCounter returns a count of finished LostIdServiceHandlerMock.ListCollectible invocations
func (mmListCollectible *LostIdServiceHandlerMock) ListCollectibleAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCollectible.afterListCollectibleCounter)
}

// ListCollectibleBeforeCounter returns a count of LostIdServiceHandlerMock.ListCollectible invocations
func (mmListCollectible *LostIdServiceHandlerMock) ListCollectibleBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCollectible.beforeListCollectibleCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceHandlerMock.ListCollectible.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCollectible *mLostIdServiceHandlerMockListCollectible) Calls() []*LostIdServiceHandlerMockListCollectibleParams {
	mmListCollectible.mutex.RLock()

	argCopy := make([]*LostIdServiceHandlerMockListCollectibleParams, len(mmListCollectible.callArgs))
	copy(argCopy, mmListCollectible.callArgs)

	mmListCollectible.mutex.RUnlock()

	return argCopy
}

// MinimockListCollectibleDone returns true if the count of the ListCollectible invocations corresponds
// the number of defined expectations
func (m *LostIdServiceHandlerMock) MinimockListCollectibleDone() bool {
	if m.ListCollectibleMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCollectibleMock.invocationsDone()
}

// MinimockListCollectibleInspect logs each unmet expectation
func (m *LostIdServiceHandlerMock) MinimockListCollectibleInspect() {
	for _, e := range m.ListCollectibleMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListCollectible at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCollectibleCounter := mm_atomic.LoadUint64(&m.afterListCollectibleCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCollectibleMock.defaultExpectation != nil && afterListCollectibleCounter < 1 {
		if m.ListCollectibleMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListCollectible at\n%s", m.ListCollectibleMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListCollectible at\n%s with params: %#v", m.ListCollectibleMock.defaultExpectation.expectationOrigins.origin, *m.ListCollectibleMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCollectible != nil && afterListCollectibleCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListCollectible at\n%s", m.funcListCollectibleOrigin)
	}

	if !m.ListCollectibleMock.invocationsDone() && afterListCollectibleCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceHandlerMock.ListCollectible at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCollectibleMock.expectedInvocations), m.ListCollectibleMock.expectedInvocationsOrigin, afterListCollectibleCounter)
	}
}

type mLostIdServiceHandlerMockListSearch struct {
	optional           bool
	mock               *LostIdServiceHandlerMock
	defaultExpectation *LostIdServiceHandlerMockListSearchExpectation
	expectations       []*LostIdServiceHandlerMockListSearchExpectation

	callArgs []*LostIdServiceHandlerMockListSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceHandlerMockListSearchExpectation specifies expectation struct of the LostIdServiceHandler.ListSearch
type LostIdServiceHandlerMockListSearchExpectation struct {
	mock               *LostIdServiceHandlerMock
	params             *LostIdServiceHandlerMockListSearchParams
	paramPtrs          *LostIdServiceHandlerMockListSearchParamPtrs
	expectationOrigins LostIdServiceHandlerMockListSearchExpectationOrigins
	results            *LostIdServiceHandlerMockListSearchResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceHandlerMockListSearchParams contains parameters of the LostIdServiceHandler.ListSearch
type LostIdServiceHandlerMockListSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListSearchRequest]
	pp2 *connect.ServerStream[v1.ListSearchResponse]
}

// LostIdServiceHandlerMockListSearchParamPtrs contains pointers to parameters of the LostIdServiceHandler.ListSearch
type LostIdServiceHandlerMockListSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListSearchRequest]
	pp2 **connect.ServerStream[v1.ListSearchResponse]
}

// LostIdServiceHandlerMockListSearchResults contains results of the LostIdServiceHandler.ListSearch
type LostIdServiceHandlerMockListSearchResults struct {
	err error
}

// LostIdServiceHandlerMockListSearchOrigins contains origins of expectations of the LostIdServiceHandler.ListSearch
type LostIdServiceHandlerMockListSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Optional() *mLostIdServiceHandlerMockListSearch {
	mmListSearch.optional = true
	return mmListSearch
}

// Expect sets up expected params for LostIdServiceHandler.ListSearch
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Expect(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse]) *mLostIdServiceHandlerMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceHandlerMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.paramPtrs != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by ExpectParams functions")
	}

	mmListSearch.defaultExpectation.params = &LostIdServiceHandlerMockListSearchParams{ctx, pp1, pp2}
	mmListSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSearch.expectations {
		if minimock.Equal(e.params, mmListSearch.defaultExpectation.params) {
			mmListSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSearch.defaultExpectation.params)
		}
	}

	return mmListSearch
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceHandler.ListSearch
func (mmListSearch *mLostIdServiceHandlerMockListSearch) ExpectCtxParam1(ctx context.Context) *mLostIdServiceHandlerMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceHandlerMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.params != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Expect")
	}

	if mmListSearch.defaultExpectation.paramPtrs == nil {
		mmListSearch.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListSearchParamPtrs{}
	}
	mmListSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSearch
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceHandler.ListSearch
func (mmListSearch *mLostIdServiceHandlerMockListSearch) ExpectPp1Param2(pp1 *connect.Request[v1.ListSearchRequest]) *mLostIdServiceHandlerMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceHandlerMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.params != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Expect")
	}

	if mmListSearch.defaultExpectation.paramPtrs == nil {
		mmListSearch.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListSearchParamPtrs{}
	}
	mmListSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListSearch
}

// ExpectPp2Param3 sets up expected param pp2 for LostIdServiceHandler.ListSearch
func (mmListSearch *mLostIdServiceHandlerMockListSearch) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListSearchResponse]) *mLostIdServiceHandlerMockListSearch {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceHandlerMockListSearchExpectation{}
	}

	if mmListSearch.defaultExpectation.params != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Expect")
	}

	if mmListSearch.defaultExpectation.paramPtrs == nil {
		mmListSearch.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListSearchParamPtrs{}
	}
	mmListSearch.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListSearch.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListSearch
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceHandler.ListSearch
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse])) *mLostIdServiceHandlerMockListSearch {
	if mmListSearch.mock.inspectFuncListSearch != nil {
		mmListSearch.mock.t.Fatalf("Inspect function is already set for LostIdServiceHandlerMock.ListSearch")
	}

	mmListSearch.mock.inspectFuncListSearch = f

	return mmListSearch
}

// Return sets up results that will be returned by LostIdServiceHandler.ListSearch
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Return(err error) *LostIdServiceHandlerMock {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Set")
	}

	if mmListSearch.defaultExpectation == nil {
		mmListSearch.defaultExpectation = &LostIdServiceHandlerMockListSearchExpectation{mock: mmListSearch.mock}
	}
	mmListSearch.defaultExpectation.results = &LostIdServiceHandlerMockListSearchResults{err}
	mmListSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSearch.mock
}

// Set uses given function f to mock the LostIdServiceHandler.ListSearch method
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse]) (err error)) *LostIdServiceHandlerMock {
	if mmListSearch.defaultExpectation != nil {
		mmListSearch.mock.t.Fatalf("Default expectation is already set for the LostIdServiceHandler.ListSearch method")
	}

	if len(mmListSearch.expectations) > 0 {
		mmListSearch.mock.t.Fatalf("Some expectations are already set for the LostIdServiceHandler.ListSearch method")
	}

	mmListSearch.mock.funcListSearch = f
	mmListSearch.mock.funcListSearchOrigin = minimock.CallerInfo(1)
	return mmListSearch.mock
}

// When sets expectation for the LostIdServiceHandler.ListSearch which will trigger the result defined by the following
// Then helper
func (mmListSearch *mLostIdServiceHandlerMockListSearch) When(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse]) *LostIdServiceHandlerMockListSearchExpectation {
	if mmListSearch.mock.funcListSearch != nil {
		mmListSearch.mock.t.Fatalf("LostIdServiceHandlerMock.ListSearch mock is already set by Set")
	}

	expectation := &LostIdServiceHandlerMockListSearchExpectation{
		mock:               mmListSearch.mock,
		params:             &LostIdServiceHandlerMockListSearchParams{ctx, pp1, pp2},
		expectationOrigins: LostIdServiceHandlerMockListSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSearch.expectations = append(mmListSearch.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceHandler.ListSearch return parameters for the expectation previously defined by the When method
func (e *LostIdServiceHandlerMockListSearchExpectation) Then(err error) *LostIdServiceHandlerMock {
	e.results = &LostIdServiceHandlerMockListSearchResults{err}
	return e.mock
}

// Times sets number of times LostIdServiceHandler.ListSearch should be invoked
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Times(n uint64) *mLostIdServiceHandlerMockListSearch {
	if n == 0 {
		mmListSearch.mock.t.Fatalf("Times of LostIdServiceHandlerMock.ListSearch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSearch.expectedInvocations, n)
	mmListSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSearch
}

func (mmListSearch *mLostIdServiceHandlerMockListSearch) invocationsDone() bool {
	if len(mmListSearch.expectations) == 0 && mmListSearch.defaultExpectation == nil && mmListSearch.mock.funcListSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSearch.mock.afterListSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSearch implements mm_lostidv1connect.LostIdServiceHandler
func (mmListSearch *LostIdServiceHandlerMock) ListSearch(ctx context.Context, pp1 *connect.Request[v1.ListSearchRequest], pp2 *connect.ServerStream[v1.ListSearchResponse]) (err error) {
	mm_atomic.AddUint64(&mmListSearch.beforeListSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmListSearch.afterListSearchCounter, 1)

	mmListSearch.t.Helper()

	if mmListSearch.inspectFuncListSearch != nil {
		mmListSearch.inspectFuncListSearch(ctx, pp1, pp2)
	}

	mm_params := LostIdServiceHandlerMockListSearchParams{ctx, pp1, pp2}

	// Record call args
	mmListSearch.ListSearchMock.mutex.Lock()
	mmListSearch.ListSearchMock.callArgs = append(mmListSearch.ListSearchMock.callArgs, &mm_params)
	mmListSearch.ListSearchMock.mutex.Unlock()

	for _, e := range mmListSearch.ListSearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListSearch.ListSearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSearch.ListSearchMock.defaultExpectation.Counter, 1)
		mm_want := mmListSearch.ListSearchMock.defaultExpectation.params
		mm_want_ptrs := mmListSearch.ListSearchMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceHandlerMockListSearchParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSearch.t.Errorf("LostIdServiceHandlerMock.ListSearch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListSearch.t.Errorf("LostIdServiceHandlerMock.ListSearch got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListSearch.t.Errorf("LostIdServiceHandlerMock.ListSearch got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSearch.t.Errorf("LostIdServiceHandlerMock.ListSearch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSearch.ListSearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSearch.ListSearchMock.defaultExpectation.results
		if mm_results == nil {
			mmListSearch.t.Fatal("No results are set for the LostIdServiceHandlerMock.ListSearch")
		}
		return (*mm_results).err
	}
	if mmListSearch.funcListSearch != nil {
		return mmListSearch.funcListSearch(ctx, pp1, pp2)
	}
	mmListSearch.t.Fatalf("Unexpected call to LostIdServiceHandlerMock.ListSearch. %v %v %v", ctx, pp1, pp2)
	return
}

// ListSearchAfterCounter returns a count of finished LostIdServiceHandlerMock.ListSearch invocations
func (mmListSearch *LostIdServiceHandlerMock) ListSearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSearch.afterListSearchCounter)
}

// ListSearchBeforeCounter returns a count of LostIdServiceHandlerMock.ListSearch invocations
func (mmListSearch *LostIdServiceHandlerMock) ListSearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSearch.beforeListSearchCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceHandlerMock.ListSearch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSearch *mLostIdServiceHandlerMockListSearch) Calls() []*LostIdServiceHandlerMockListSearchParams {
	mmListSearch.mutex.RLock()

	argCopy := make([]*LostIdServiceHandlerMockListSearchParams, len(mmListSearch.callArgs))
	copy(argCopy, mmListSearch.callArgs)

	mmListSearch.mutex.RUnlock()

	return argCopy
}

// MinimockListSearchDone returns true if the count of the ListSearch invocations corresponds
// the number of defined expectations
func (m *LostIdServiceHandlerMock) MinimockListSearchDone() bool {
	if m.ListSearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSearchMock.invocationsDone()
}

// MinimockListSearchInspect logs each unmet expectation
func (m *LostIdServiceHandlerMock) MinimockListSearchInspect() {
	for _, e := range m.ListSearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListSearch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSearchCounter := mm_atomic.LoadUint64(&m.afterListSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSearchMock.defaultExpectation != nil && afterListSearchCounter < 1 {
		if m.ListSearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListSearch at\n%s", m.ListSearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListSearch at\n%s with params: %#v", m.ListSearchMock.defaultExpectation.expectationOrigins.origin, *m.ListSearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSearch != nil && afterListSearchCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListSearch at\n%s", m.funcListSearchOrigin)
	}

	if !m.ListSearchMock.invocationsDone() && afterListSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceHandlerMock.ListSearch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSearchMock.expectedInvocations), m.ListSearchMock.expectedInvocationsOrigin, afterListSearchCounter)
	}
}

type mLostIdServiceHandlerMockListTransaction struct {
	optional           bool
	mock               *LostIdServiceHandlerMock
	defaultExpectation *LostIdServiceHandlerMockListTransactionExpectation
	expectations       []*LostIdServiceHandlerMockListTransactionExpectation

	callArgs []*LostIdServiceHandlerMockListTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceHandlerMockListTransactionExpectation specifies expectation struct of the LostIdServiceHandler.ListTransaction
type LostIdServiceHandlerMockListTransactionExpectation struct {
	mock               *LostIdServiceHandlerMock
	params             *LostIdServiceHandlerMockListTransactionParams
	paramPtrs          *LostIdServiceHandlerMockListTransactionParamPtrs
	expectationOrigins LostIdServiceHandlerMockListTransactionExpectationOrigins
	results            *LostIdServiceHandlerMockListTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceHandlerMockListTransactionParams contains parameters of the LostIdServiceHandler.ListTransaction
type LostIdServiceHandlerMockListTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListTransactionRequest]
	pp2 *connect.ServerStream[v1.ListTransactionResponse]
}

// LostIdServiceHandlerMockListTransactionParamPtrs contains pointers to parameters of the LostIdServiceHandler.ListTransaction
type LostIdServiceHandlerMockListTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListTransactionRequest]
	pp2 **connect.ServerStream[v1.ListTransactionResponse]
}

// LostIdServiceHandlerMockListTransactionResults contains results of the LostIdServiceHandler.ListTransaction
type LostIdServiceHandlerMockListTransactionResults struct {
	err error
}

// LostIdServiceHandlerMockListTransactionOrigins contains origins of expectations of the LostIdServiceHandler.ListTransaction
type LostIdServiceHandlerMockListTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Optional() *mLostIdServiceHandlerMockListTransaction {
	mmListTransaction.optional = true
	return mmListTransaction
}

// Expect sets up expected params for LostIdServiceHandler.ListTransaction
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Expect(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse]) *mLostIdServiceHandlerMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceHandlerMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.paramPtrs != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by ExpectParams functions")
	}

	mmListTransaction.defaultExpectation.params = &LostIdServiceHandlerMockListTransactionParams{ctx, pp1, pp2}
	mmListTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTransaction.expectations {
		if minimock.Equal(e.params, mmListTransaction.defaultExpectation.params) {
			mmListTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTransaction.defaultExpectation.params)
		}
	}

	return mmListTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceHandler.ListTransaction
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) ExpectCtxParam1(ctx context.Context) *mLostIdServiceHandlerMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceHandlerMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.params != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Expect")
	}

	if mmListTransaction.defaultExpectation.paramPtrs == nil {
		mmListTransaction.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListTransactionParamPtrs{}
	}
	mmListTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceHandler.ListTransaction
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) ExpectPp1Param2(pp1 *connect.Request[v1.ListTransactionRequest]) *mLostIdServiceHandlerMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceHandlerMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.params != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Expect")
	}

	if mmListTransaction.defaultExpectation.paramPtrs == nil {
		mmListTransaction.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListTransactionParamPtrs{}
	}
	mmListTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListTransaction
}

// ExpectPp2Param3 sets up expected param pp2 for LostIdServiceHandler.ListTransaction
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListTransactionResponse]) *mLostIdServiceHandlerMockListTransaction {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceHandlerMockListTransactionExpectation{}
	}

	if mmListTransaction.defaultExpectation.params != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Expect")
	}

	if mmListTransaction.defaultExpectation.paramPtrs == nil {
		mmListTransaction.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockListTransactionParamPtrs{}
	}
	mmListTransaction.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListTransaction.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListTransaction
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceHandler.ListTransaction
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse])) *mLostIdServiceHandlerMockListTransaction {
	if mmListTransaction.mock.inspectFuncListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("Inspect function is already set for LostIdServiceHandlerMock.ListTransaction")
	}

	mmListTransaction.mock.inspectFuncListTransaction = f

	return mmListTransaction
}

// Return sets up results that will be returned by LostIdServiceHandler.ListTransaction
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Return(err error) *LostIdServiceHandlerMock {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Set")
	}

	if mmListTransaction.defaultExpectation == nil {
		mmListTransaction.defaultExpectation = &LostIdServiceHandlerMockListTransactionExpectation{mock: mmListTransaction.mock}
	}
	mmListTransaction.defaultExpectation.results = &LostIdServiceHandlerMockListTransactionResults{err}
	mmListTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTransaction.mock
}

// Set uses given function f to mock the LostIdServiceHandler.ListTransaction method
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse]) (err error)) *LostIdServiceHandlerMock {
	if mmListTransaction.defaultExpectation != nil {
		mmListTransaction.mock.t.Fatalf("Default expectation is already set for the LostIdServiceHandler.ListTransaction method")
	}

	if len(mmListTransaction.expectations) > 0 {
		mmListTransaction.mock.t.Fatalf("Some expectations are already set for the LostIdServiceHandler.ListTransaction method")
	}

	mmListTransaction.mock.funcListTransaction = f
	mmListTransaction.mock.funcListTransactionOrigin = minimock.CallerInfo(1)
	return mmListTransaction.mock
}

// When sets expectation for the LostIdServiceHandler.ListTransaction which will trigger the result defined by the following
// Then helper
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) When(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse]) *LostIdServiceHandlerMockListTransactionExpectation {
	if mmListTransaction.mock.funcListTransaction != nil {
		mmListTransaction.mock.t.Fatalf("LostIdServiceHandlerMock.ListTransaction mock is already set by Set")
	}

	expectation := &LostIdServiceHandlerMockListTransactionExpectation{
		mock:               mmListTransaction.mock,
		params:             &LostIdServiceHandlerMockListTransactionParams{ctx, pp1, pp2},
		expectationOrigins: LostIdServiceHandlerMockListTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTransaction.expectations = append(mmListTransaction.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceHandler.ListTransaction return parameters for the expectation previously defined by the When method
func (e *LostIdServiceHandlerMockListTransactionExpectation) Then(err error) *LostIdServiceHandlerMock {
	e.results = &LostIdServiceHandlerMockListTransactionResults{err}
	return e.mock
}

// Times sets number of times LostIdServiceHandler.ListTransaction should be invoked
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Times(n uint64) *mLostIdServiceHandlerMockListTransaction {
	if n == 0 {
		mmListTransaction.mock.t.Fatalf("Times of LostIdServiceHandlerMock.ListTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTransaction.expectedInvocations, n)
	mmListTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTransaction
}

func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) invocationsDone() bool {
	if len(mmListTransaction.expectations) == 0 && mmListTransaction.defaultExpectation == nil && mmListTransaction.mock.funcListTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTransaction.mock.afterListTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTransaction implements mm_lostidv1connect.LostIdServiceHandler
func (mmListTransaction *LostIdServiceHandlerMock) ListTransaction(ctx context.Context, pp1 *connect.Request[v1.ListTransactionRequest], pp2 *connect.ServerStream[v1.ListTransactionResponse]) (err error) {
	mm_atomic.AddUint64(&mmListTransaction.beforeListTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmListTransaction.afterListTransactionCounter, 1)

	mmListTransaction.t.Helper()

	if mmListTransaction.inspectFuncListTransaction != nil {
		mmListTransaction.inspectFuncListTransaction(ctx, pp1, pp2)
	}

	mm_params := LostIdServiceHandlerMockListTransactionParams{ctx, pp1, pp2}

	// Record call args
	mmListTransaction.ListTransactionMock.mutex.Lock()
	mmListTransaction.ListTransactionMock.callArgs = append(mmListTransaction.ListTransactionMock.callArgs, &mm_params)
	mmListTransaction.ListTransactionMock.mutex.Unlock()

	for _, e := range mmListTransaction.ListTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListTransaction.ListTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTransaction.ListTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmListTransaction.ListTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmListTransaction.ListTransactionMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceHandlerMockListTransactionParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTransaction.t.Errorf("LostIdServiceHandlerMock.ListTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListTransaction.t.Errorf("LostIdServiceHandlerMock.ListTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListTransaction.t.Errorf("LostIdServiceHandlerMock.ListTransaction got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTransaction.t.Errorf("LostIdServiceHandlerMock.ListTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTransaction.ListTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTransaction.ListTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmListTransaction.t.Fatal("No results are set for the LostIdServiceHandlerMock.ListTransaction")
		}
		return (*mm_results).err
	}
	if mmListTransaction.funcListTransaction != nil {
		return mmListTransaction.funcListTransaction(ctx, pp1, pp2)
	}
	mmListTransaction.t.Fatalf("Unexpected call to LostIdServiceHandlerMock.ListTransaction. %v %v %v", ctx, pp1, pp2)
	return
}

// ListTransactionAfterCounter returns a count of finished LostIdServiceHandlerMock.ListTransaction invocations
func (mmListTransaction *LostIdServiceHandlerMock) ListTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTransaction.afterListTransactionCounter)
}

// ListTransactionBeforeCounter returns a count of LostIdServiceHandlerMock.ListTransaction invocations
func (mmListTransaction *LostIdServiceHandlerMock) ListTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTransaction.beforeListTransactionCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceHandlerMock.ListTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTransaction *mLostIdServiceHandlerMockListTransaction) Calls() []*LostIdServiceHandlerMockListTransactionParams {
	mmListTransaction.mutex.RLock()

	argCopy := make([]*LostIdServiceHandlerMockListTransactionParams, len(mmListTransaction.callArgs))
	copy(argCopy, mmListTransaction.callArgs)

	mmListTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockListTransactionDone returns true if the count of the ListTransaction invocations corresponds
// the number of defined expectations
func (m *LostIdServiceHandlerMock) MinimockListTransactionDone() bool {
	if m.ListTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTransactionMock.invocationsDone()
}

// MinimockListTransactionInspect logs each unmet expectation
func (m *LostIdServiceHandlerMock) MinimockListTransactionInspect() {
	for _, e := range m.ListTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTransactionCounter := mm_atomic.LoadUint64(&m.afterListTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTransactionMock.defaultExpectation != nil && afterListTransactionCounter < 1 {
		if m.ListTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListTransaction at\n%s", m.ListTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListTransaction at\n%s with params: %#v", m.ListTransactionMock.defaultExpectation.expectationOrigins.origin, *m.ListTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTransaction != nil && afterListTransactionCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceHandlerMock.ListTransaction at\n%s", m.funcListTransactionOrigin)
	}

	if !m.ListTransactionMock.invocationsDone() && afterListTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceHandlerMock.ListTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTransactionMock.expectedInvocations), m.ListTransactionMock.expectedInvocationsOrigin, afterListTransactionCounter)
	}
}

type mLostIdServiceHandlerMockProgress struct {
	optional           bool
	mock               *LostIdServiceHandlerMock
	defaultExpectation *LostIdServiceHandlerMockProgressExpectation
	expectations       []*LostIdServiceHandlerMockProgressExpectation

	callArgs []*LostIdServiceHandlerMockProgressParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceHandlerMockProgressExpectation specifies expectation struct of the LostIdServiceHandler.Progress
type LostIdServiceHandlerMockProgressExpectation struct {
	mock               *LostIdServiceHandlerMock
	params             *LostIdServiceHandlerMockProgressParams
	paramPtrs          *LostIdServiceHandlerMockProgressParamPtrs
	expectationOrigins LostIdServiceHandlerMockProgressExpectationOrigins
	results            *LostIdServiceHandlerMockProgressResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceHandlerMockProgressParams contains parameters of the LostIdServiceHandler.Progress
type LostIdServiceHandlerMockProgressParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ProgressRequest]
}

// LostIdServiceHandlerMockProgressParamPtrs contains pointers to parameters of the LostIdServiceHandler.Progress
type LostIdServiceHandlerMockProgressParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ProgressRequest]
}

// LostIdServiceHandlerMockProgressResults contains results of the LostIdServiceHandler.Progress
type LostIdServiceHandlerMockProgressResults struct {
	pp2 *connect.Response[v1.ProgressResponse]
	err error
}

// LostIdServiceHandlerMockProgressOrigins contains origins of expectations of the LostIdServiceHandler.Progress
type LostIdServiceHandlerMockProgressExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmProgress *mLostIdServiceHandlerMockProgress) Optional() *mLostIdServiceHandlerMockProgress {
	mmProgress.optional = true
	return mmProgress
}

// Expect sets up expected params for LostIdServiceHandler.Progress
func (mmProgress *mLostIdServiceHandlerMockProgress) Expect(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) *mLostIdServiceHandlerMockProgress {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceHandlerMockProgressExpectation{}
	}

	if mmProgress.defaultExpectation.paramPtrs != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by ExpectParams functions")
	}

	mmProgress.defaultExpectation.params = &LostIdServiceHandlerMockProgressParams{ctx, pp1}
	mmProgress.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmProgress.expectations {
		if minimock.Equal(e.params, mmProgress.defaultExpectation.params) {
			mmProgress.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProgress.defaultExpectation.params)
		}
	}

	return mmProgress
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceHandler.Progress
func (mmProgress *mLostIdServiceHandlerMockProgress) ExpectCtxParam1(ctx context.Context) *mLostIdServiceHandlerMockProgress {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceHandlerMockProgressExpectation{}
	}

	if mmProgress.defaultExpectation.params != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Expect")
	}

	if mmProgress.defaultExpectation.paramPtrs == nil {
		mmProgress.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockProgressParamPtrs{}
	}
	mmProgress.defaultExpectation.paramPtrs.ctx = &ctx
	mmProgress.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmProgress
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceHandler.Progress
func (mmProgress *mLostIdServiceHandlerMockProgress) ExpectPp1Param2(pp1 *connect.Request[v1.ProgressRequest]) *mLostIdServiceHandlerMockProgress {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceHandlerMockProgressExpectation{}
	}

	if mmProgress.defaultExpectation.params != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Expect")
	}

	if mmProgress.defaultExpectation.paramPtrs == nil {
		mmProgress.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockProgressParamPtrs{}
	}
	mmProgress.defaultExpectation.paramPtrs.pp1 = &pp1
	mmProgress.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmProgress
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceHandler.Progress
func (mmProgress *mLostIdServiceHandlerMockProgress) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest])) *mLostIdServiceHandlerMockProgress {
	if mmProgress.mock.inspectFuncProgress != nil {
		mmProgress.mock.t.Fatalf("Inspect function is already set for LostIdServiceHandlerMock.Progress")
	}

	mmProgress.mock.inspectFuncProgress = f

	return mmProgress
}

// Return sets up results that will be returned by LostIdServiceHandler.Progress
func (mmProgress *mLostIdServiceHandlerMockProgress) Return(pp2 *connect.Response[v1.ProgressResponse], err error) *LostIdServiceHandlerMock {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Set")
	}

	if mmProgress.defaultExpectation == nil {
		mmProgress.defaultExpectation = &LostIdServiceHandlerMockProgressExpectation{mock: mmProgress.mock}
	}
	mmProgress.defaultExpectation.results = &LostIdServiceHandlerMockProgressResults{pp2, err}
	mmProgress.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmProgress.mock
}

// Set uses given function f to mock the LostIdServiceHandler.Progress method
func (mmProgress *mLostIdServiceHandlerMockProgress) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) (pp2 *connect.Response[v1.ProgressResponse], err error)) *LostIdServiceHandlerMock {
	if mmProgress.defaultExpectation != nil {
		mmProgress.mock.t.Fatalf("Default expectation is already set for the LostIdServiceHandler.Progress method")
	}

	if len(mmProgress.expectations) > 0 {
		mmProgress.mock.t.Fatalf("Some expectations are already set for the LostIdServiceHandler.Progress method")
	}

	mmProgress.mock.funcProgress = f
	mmProgress.mock.funcProgressOrigin = minimock.CallerInfo(1)
	return mmProgress.mock
}

// When sets expectation for the LostIdServiceHandler.Progress which will trigger the result defined by the following
// Then helper
func (mmProgress *mLostIdServiceHandlerMockProgress) When(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) *LostIdServiceHandlerMockProgressExpectation {
	if mmProgress.mock.funcProgress != nil {
		mmProgress.mock.t.Fatalf("LostIdServiceHandlerMock.Progress mock is already set by Set")
	}

	expectation := &LostIdServiceHandlerMockProgressExpectation{
		mock:               mmProgress.mock,
		params:             &LostIdServiceHandlerMockProgressParams{ctx, pp1},
		expectationOrigins: LostIdServiceHandlerMockProgressExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmProgress.expectations = append(mmProgress.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceHandler.Progress return parameters for the expectation previously defined by the When method
func (e *LostIdServiceHandlerMockProgressExpectation) Then(pp2 *connect.Response[v1.ProgressResponse], err error) *LostIdServiceHandlerMock {
	e.results = &LostIdServiceHandlerMockProgressResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceHandler.Progress should be invoked
func (mmProgress *mLostIdServiceHandlerMockProgress) Times(n uint64) *mLostIdServiceHandlerMockProgress {
	if n == 0 {
		mmProgress.mock.t.Fatalf("Times of LostIdServiceHandlerMock.Progress mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmProgress.expectedInvocations, n)
	mmProgress.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmProgress
}

func (mmProgress *mLostIdServiceHandlerMockProgress) invocationsDone() bool {
	if len(mmProgress.expectations) == 0 && mmProgress.defaultExpectation == nil && mmProgress.mock.funcProgress == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmProgress.mock.afterProgressCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmProgress.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Progress implements mm_lostidv1connect.LostIdServiceHandler
func (mmProgress *LostIdServiceHandlerMock) Progress(ctx context.Context, pp1 *connect.Request[v1.ProgressRequest]) (pp2 *connect.Response[v1.ProgressResponse], err error) {
	mm_atomic.AddUint64(&mmProgress.beforeProgressCounter, 1)
	defer mm_atomic.AddUint64(&mmProgress.afterProgressCounter, 1)

	mmProgress.t.Helper()

	if mmProgress.inspectFuncProgress != nil {
		mmProgress.inspectFuncProgress(ctx, pp1)
	}

	mm_params := LostIdServiceHandlerMockProgressParams{ctx, pp1}

	// Record call args
	mmProgress.ProgressMock.mutex.Lock()
	mmProgress.ProgressMock.callArgs = append(mmProgress.ProgressMock.callArgs, &mm_params)
	mmProgress.ProgressMock.mutex.Unlock()

	for _, e := range mmProgress.ProgressMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmProgress.ProgressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProgress.ProgressMock.defaultExpectation.Counter, 1)
		mm_want := mmProgress.ProgressMock.defaultExpectation.params
		mm_want_ptrs := mmProgress.ProgressMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceHandlerMockProgressParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmProgress.t.Errorf("LostIdServiceHandlerMock.Progress got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProgress.ProgressMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmProgress.t.Errorf("LostIdServiceHandlerMock.Progress got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmProgress.ProgressMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProgress.t.Errorf("LostIdServiceHandlerMock.Progress got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmProgress.ProgressMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProgress.ProgressMock.defaultExpectation.results
		if mm_results == nil {
			mmProgress.t.Fatal("No results are set for the LostIdServiceHandlerMock.Progress")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmProgress.funcProgress != nil {
		return mmProgress.funcProgress(ctx, pp1)
	}
	mmProgress.t.Fatalf("Unexpected call to LostIdServiceHandlerMock.Progress. %v %v", ctx, pp1)
	return
}

// ProgressAfterCounter returns a count of finished LostIdServiceHandlerMock.Progress invocations
func (mmProgress *LostIdServiceHandlerMock) ProgressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProgress.afterProgressCounter)
}

// ProgressBeforeCounter returns a count of LostIdServiceHandlerMock.Progress invocations
func (mmProgress *LostIdServiceHandlerMock) ProgressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProgress.beforeProgressCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceHandlerMock.Progress.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProgress *mLostIdServiceHandlerMockProgress) Calls() []*LostIdServiceHandlerMockProgressParams {
	mmProgress.mutex.RLock()

	argCopy := make([]*LostIdServiceHandlerMockProgressParams, len(mmProgress.callArgs))
	copy(argCopy, mmProgress.callArgs)

	mmProgress.mutex.RUnlock()

	return argCopy
}

// MinimockProgressDone returns true if the count of the Progress invocations corresponds
// the number of defined expectations
func (m *LostIdServiceHandlerMock) MinimockProgressDone() bool {
	if m.ProgressMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ProgressMock.invocationsDone()
}

// MinimockProgressInspect logs each unmet expectation
func (m *LostIdServiceHandlerMock) MinimockProgressInspect() {
	for _, e := range m.ProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Progress at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterProgressCounter := mm_atomic.LoadUint64(&m.afterProgressCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ProgressMock.defaultExpectation != nil && afterProgressCounter < 1 {
		if m.ProgressMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Progress at\n%s", m.ProgressMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Progress at\n%s with params: %#v", m.ProgressMock.defaultExpectation.expectationOrigins.origin, *m.ProgressMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProgress != nil && afterProgressCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceHandlerMock.Progress at\n%s", m.funcProgressOrigin)
	}

	if !m.ProgressMock.invocationsDone() && afterProgressCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceHandlerMock.Progress at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ProgressMock.expectedInvocations), m.ProgressMock.expectedInvocationsOrigin, afterProgressCounter)
	}
}

type mLostIdServiceHandlerMockSearch struct {
	optional           bool
	mock               *LostIdServiceHandlerMock
	defaultExpectation *LostIdServiceHandlerMockSearchExpectation
	expectations       []*LostIdServiceHandlerMockSearchExpectation

	callArgs []*LostIdServiceHandlerMockSearchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LostIdServiceHandlerMockSearchExpectation specifies expectation struct of the LostIdServiceHandler.Search
type LostIdServiceHandlerMockSearchExpectation struct {
	mock               *LostIdServiceHandlerMock
	params             *LostIdServiceHandlerMockSearchParams
	paramPtrs          *LostIdServiceHandlerMockSearchParamPtrs
	expectationOrigins LostIdServiceHandlerMockSearchExpectationOrigins
	results            *LostIdServiceHandlerMockSearchResults
	returnOrigin       string
	Counter            uint64
}

// LostIdServiceHandlerMockSearchParams contains parameters of the LostIdServiceHandler.Search
type LostIdServiceHandlerMockSearchParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.SearchRequest]
}

// LostIdServiceHandlerMockSearchParamPtrs contains pointers to parameters of the LostIdServiceHandler.Search
type LostIdServiceHandlerMockSearchParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.SearchRequest]
}

// LostIdServiceHandlerMockSearchResults contains results of the LostIdServiceHandler.Search
type LostIdServiceHandlerMockSearchResults struct {
	pp2 *connect.Response[v1.SearchResponse]
	err error
}

// LostIdServiceHandlerMockSearchOrigins contains origins of expectations of the LostIdServiceHandler.Search
type LostIdServiceHandlerMockSearchExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearch *mLostIdServiceHandlerMockSearch) Optional() *mLostIdServiceHandlerMockSearch {
	mmSearch.optional = true
	return mmSearch
}

// Expect sets up expected params for LostIdServiceHandler.Search
func (mmSearch *mLostIdServiceHandlerMockSearch) Expect(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *mLostIdServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.paramPtrs != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by ExpectParams functions")
	}

	mmSearch.defaultExpectation.params = &LostIdServiceHandlerMockSearchParams{ctx, pp1}
	mmSearch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearch.expectations {
		if minimock.Equal(e.params, mmSearch.defaultExpectation.params) {
			mmSearch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearch.defaultExpectation.params)
		}
	}

	return mmSearch
}

// ExpectCtxParam1 sets up expected param ctx for LostIdServiceHandler.Search
func (mmSearch *mLostIdServiceHandlerMockSearch) ExpectCtxParam1(ctx context.Context) *mLostIdServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearch
}

// ExpectPp1Param2 sets up expected param pp1 for LostIdServiceHandler.Search
func (mmSearch *mLostIdServiceHandlerMockSearch) ExpectPp1Param2(pp1 *connect.Request[v11.SearchRequest]) *mLostIdServiceHandlerMockSearch {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceHandlerMockSearchExpectation{}
	}

	if mmSearch.defaultExpectation.params != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Expect")
	}

	if mmSearch.defaultExpectation.paramPtrs == nil {
		mmSearch.defaultExpectation.paramPtrs = &LostIdServiceHandlerMockSearchParamPtrs{}
	}
	mmSearch.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearch.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearch
}

// Inspect accepts an inspector function that has same arguments as the LostIdServiceHandler.Search
func (mmSearch *mLostIdServiceHandlerMockSearch) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest])) *mLostIdServiceHandlerMockSearch {
	if mmSearch.mock.inspectFuncSearch != nil {
		mmSearch.mock.t.Fatalf("Inspect function is already set for LostIdServiceHandlerMock.Search")
	}

	mmSearch.mock.inspectFuncSearch = f

	return mmSearch
}

// Return sets up results that will be returned by LostIdServiceHandler.Search
func (mmSearch *mLostIdServiceHandlerMockSearch) Return(pp2 *connect.Response[v1.SearchResponse], err error) *LostIdServiceHandlerMock {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Set")
	}

	if mmSearch.defaultExpectation == nil {
		mmSearch.defaultExpectation = &LostIdServiceHandlerMockSearchExpectation{mock: mmSearch.mock}
	}
	mmSearch.defaultExpectation.results = &LostIdServiceHandlerMockSearchResults{pp2, err}
	mmSearch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// Set uses given function f to mock the LostIdServiceHandler.Search method
func (mmSearch *mLostIdServiceHandlerMockSearch) Set(f func(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.Response[v1.SearchResponse], err error)) *LostIdServiceHandlerMock {
	if mmSearch.defaultExpectation != nil {
		mmSearch.mock.t.Fatalf("Default expectation is already set for the LostIdServiceHandler.Search method")
	}

	if len(mmSearch.expectations) > 0 {
		mmSearch.mock.t.Fatalf("Some expectations are already set for the LostIdServiceHandler.Search method")
	}

	mmSearch.mock.funcSearch = f
	mmSearch.mock.funcSearchOrigin = minimock.CallerInfo(1)
	return mmSearch.mock
}

// When sets expectation for the LostIdServiceHandler.Search which will trigger the result defined by the following
// Then helper
func (mmSearch *mLostIdServiceHandlerMockSearch) When(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) *LostIdServiceHandlerMockSearchExpectation {
	if mmSearch.mock.funcSearch != nil {
		mmSearch.mock.t.Fatalf("LostIdServiceHandlerMock.Search mock is already set by Set")
	}

	expectation := &LostIdServiceHandlerMockSearchExpectation{
		mock:               mmSearch.mock,
		params:             &LostIdServiceHandlerMockSearchParams{ctx, pp1},
		expectationOrigins: LostIdServiceHandlerMockSearchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearch.expectations = append(mmSearch.expectations, expectation)
	return expectation
}

// Then sets up LostIdServiceHandler.Search return parameters for the expectation previously defined by the When method
func (e *LostIdServiceHandlerMockSearchExpectation) Then(pp2 *connect.Response[v1.SearchResponse], err error) *LostIdServiceHandlerMock {
	e.results = &LostIdServiceHandlerMockSearchResults{pp2, err}
	return e.mock
}

// Times sets number of times LostIdServiceHandler.Search should be invoked
func (mmSearch *mLostIdServiceHandlerMockSearch) Times(n uint64) *mLostIdServiceHandlerMockSearch {
	if n == 0 {
		mmSearch.mock.t.Fatalf("Times of LostIdServiceHandlerMock.Search mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearch.expectedInvocations, n)
	mmSearch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearch
}

func (mmSearch *mLostIdServiceHandlerMockSearch) invocationsDone() bool {
	if len(mmSearch.expectations) == 0 && mmSearch.defaultExpectation == nil && mmSearch.mock.funcSearch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearch.mock.afterSearchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Search implements mm_lostidv1connect.LostIdServiceHandler
func (mmSearch *LostIdServiceHandlerMock) Search(ctx context.Context, pp1 *connect.Request[v11.SearchRequest]) (pp2 *connect.Response[v1.SearchResponse], err error) {
	mm_atomic.AddUint64(&mmSearch.beforeSearchCounter, 1)
	defer mm_atomic.AddUint64(&mmSearch.afterSearchCounter, 1)

	mmSearch.t.Helper()

	if mmSearch.inspectFuncSearch != nil {
		mmSearch.inspectFuncSearch(ctx, pp1)
	}

	mm_params := LostIdServiceHandlerMockSearchParams{ctx, pp1}

	// Record call args
	mmSearch.SearchMock.mutex.Lock()
	mmSearch.SearchMock.callArgs = append(mmSearch.SearchMock.callArgs, &mm_params)
	mmSearch.SearchMock.mutex.Unlock()

	for _, e := range mmSearch.SearchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearch.SearchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearch.SearchMock.defaultExpectation.Counter, 1)
		mm_want := mmSearch.SearchMock.defaultExpectation.params
		mm_want_ptrs := mmSearch.SearchMock.defaultExpectation.paramPtrs

		mm_got := LostIdServiceHandlerMockSearchParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearch.t.Errorf("LostIdServiceHandlerMock.Search got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearch.t.Errorf("LostIdServiceHandlerMock.Search got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearch.SearchMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearch.t.Errorf("LostIdServiceHandlerMock.Search got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearch.SearchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearch.SearchMock.defaultExpectation.results
		if mm_results == nil {
			mmSearch.t.Fatal("No results are set for the LostIdServiceHandlerMock.Search")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearch.funcSearch != nil {
		return mmSearch.funcSearch(ctx, pp1)
	}
	mmSearch.t.Fatalf("Unexpected call to LostIdServiceHandlerMock.Search. %v %v", ctx, pp1)
	return
}

// SearchAfterCounter returns a count of finished LostIdServiceHandlerMock.Search invocations
func (mmSearch *LostIdServiceHandlerMock) SearchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.afterSearchCounter)
}

// SearchBeforeCounter returns a count of LostIdServiceHandlerMock.Search invocations
func (mmSearch *LostIdServiceHandlerMock) SearchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearch.beforeSearchCounter)
}

// Calls returns a list of arguments used in each call to LostIdServiceHandlerMock.Search.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearch *mLostIdServiceHandlerMockSearch) Calls() []*LostIdServiceHandlerMockSearchParams {
	mmSearch.mutex.RLock()

	argCopy := make([]*LostIdServiceHandlerMockSearchParams, len(mmSearch.callArgs))
	copy(argCopy, mmSearch.callArgs)

	mmSearch.mutex.RUnlock()

	return argCopy
}

// MinimockSearchDone returns true if the count of the Search invocations corresponds
// the number of defined expectations
func (m *LostIdServiceHandlerMock) MinimockSearchDone() bool {
	if m.SearchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchMock.invocationsDone()
}

// MinimockSearchInspect logs each unmet expectation
func (m *LostIdServiceHandlerMock) MinimockSearchInspect() {
	for _, e := range m.SearchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Search at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchCounter := mm_atomic.LoadUint64(&m.afterSearchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchMock.defaultExpectation != nil && afterSearchCounter < 1 {
		if m.SearchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Search at\n%s", m.SearchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LostIdServiceHandlerMock.Search at\n%s with params: %#v", m.SearchMock.defaultExpectation.expectationOrigins.origin, *m.SearchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearch != nil && afterSearchCounter < 1 {
		m.t.Errorf("Expected call to LostIdServiceHandlerMock.Search at\n%s", m.funcSearchOrigin)
	}

	if !m.SearchMock.invocationsDone() && afterSearchCounter > 0 {
		m.t.Errorf("Expected %d calls to LostIdServiceHandlerMock.Search at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchMock.expectedInvocations), m.SearchMock.expectedInvocationsOrigin, afterSearchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LostIdServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCollectibleInspect()

			m.MinimockListCollectibleInspect()

			m.MinimockListSearchInspect()

			m.MinimockListTransactionInspect()

			m.MinimockProgressInspect()

			m.MinimockSearchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LostIdServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LostIdServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCollectibleDone() &&
		m.MinimockListCollectibleDone() &&
		m.MinimockListSearchDone() &&
		m.MinimockListTransactionDone() &&
		m.MinimockProgressDone() &&
		m.MinimockSearchDone()
}
