// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/ledger/connectrpc/go/ledger/v1/ledgerv1connect.LedgerServiceHandler -o ledger_handler.gen.go -n LedgerServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v11 "buf.build/gen/go/antinvestor/ledger/protocolbuffers/go/ledger/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// LedgerServiceHandlerMock implements mm_ledgerv1connect.LedgerServiceHandler
type LedgerServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAccount          func(ctx context.Context, pp1 *connect.Request[v11.Account]) (pp2 *connect.Response[v11.Account], err error)
	funcCreateAccountOrigin    string
	inspectFuncCreateAccount   func(ctx context.Context, pp1 *connect.Request[v11.Account])
	afterCreateAccountCounter  uint64
	beforeCreateAccountCounter uint64
	CreateAccountMock          mLedgerServiceHandlerMockCreateAccount

	funcCreateLedger          func(ctx context.Context, pp1 *connect.Request[v11.Ledger]) (pp2 *connect.Response[v11.Ledger], err error)
	funcCreateLedgerOrigin    string
	inspectFuncCreateLedger   func(ctx context.Context, pp1 *connect.Request[v11.Ledger])
	afterCreateLedgerCounter  uint64
	beforeCreateLedgerCounter uint64
	CreateLedgerMock          mLedgerServiceHandlerMockCreateLedger

	funcCreateTransaction          func(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error)
	funcCreateTransactionOrigin    string
	inspectFuncCreateTransaction   func(ctx context.Context, pp1 *connect.Request[v11.Transaction])
	afterCreateTransactionCounter  uint64
	beforeCreateTransactionCounter uint64
	CreateTransactionMock          mLedgerServiceHandlerMockCreateTransaction

	funcReverseTransaction          func(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error)
	funcReverseTransactionOrigin    string
	inspectFuncReverseTransaction   func(ctx context.Context, pp1 *connect.Request[v11.Transaction])
	afterReverseTransactionCounter  uint64
	beforeReverseTransactionCounter uint64
	ReverseTransactionMock          mLedgerServiceHandlerMockReverseTransaction

	funcSearchAccounts          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account]) (err error)
	funcSearchAccountsOrigin    string
	inspectFuncSearchAccounts   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account])
	afterSearchAccountsCounter  uint64
	beforeSearchAccountsCounter uint64
	SearchAccountsMock          mLedgerServiceHandlerMockSearchAccounts

	funcSearchLedgers          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger]) (err error)
	funcSearchLedgersOrigin    string
	inspectFuncSearchLedgers   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger])
	afterSearchLedgersCounter  uint64
	beforeSearchLedgersCounter uint64
	SearchLedgersMock          mLedgerServiceHandlerMockSearchLedgers

	funcSearchTransactionEntries          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry]) (err error)
	funcSearchTransactionEntriesOrigin    string
	inspectFuncSearchTransactionEntries   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry])
	afterSearchTransactionEntriesCounter  uint64
	beforeSearchTransactionEntriesCounter uint64
	SearchTransactionEntriesMock          mLedgerServiceHandlerMockSearchTransactionEntries

	funcSearchTransactions          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction]) (err error)
	funcSearchTransactionsOrigin    string
	inspectFuncSearchTransactions   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction])
	afterSearchTransactionsCounter  uint64
	beforeSearchTransactionsCounter uint64
	SearchTransactionsMock          mLedgerServiceHandlerMockSearchTransactions

	funcUpdateAccount          func(ctx context.Context, pp1 *connect.Request[v11.Account]) (pp2 *connect.Response[v11.Account], err error)
	funcUpdateAccountOrigin    string
	inspectFuncUpdateAccount   func(ctx context.Context, pp1 *connect.Request[v11.Account])
	afterUpdateAccountCounter  uint64
	beforeUpdateAccountCounter uint64
	UpdateAccountMock          mLedgerServiceHandlerMockUpdateAccount

	funcUpdateLedger          func(ctx context.Context, pp1 *connect.Request[v11.Ledger]) (pp2 *connect.Response[v11.Ledger], err error)
	funcUpdateLedgerOrigin    string
	inspectFuncUpdateLedger   func(ctx context.Context, pp1 *connect.Request[v11.Ledger])
	afterUpdateLedgerCounter  uint64
	beforeUpdateLedgerCounter uint64
	UpdateLedgerMock          mLedgerServiceHandlerMockUpdateLedger

	funcUpdateTransaction          func(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error)
	funcUpdateTransactionOrigin    string
	inspectFuncUpdateTransaction   func(ctx context.Context, pp1 *connect.Request[v11.Transaction])
	afterUpdateTransactionCounter  uint64
	beforeUpdateTransactionCounter uint64
	UpdateTransactionMock          mLedgerServiceHandlerMockUpdateTransaction
}

// NewLedgerServiceHandlerMock returns a mock for mm_ledgerv1connect.LedgerServiceHandler
func NewLedgerServiceHandlerMock(t minimock.Tester) *LedgerServiceHandlerMock {
	m := &LedgerServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAccountMock = mLedgerServiceHandlerMockCreateAccount{mock: m}
	m.CreateAccountMock.callArgs = []*LedgerServiceHandlerMockCreateAccountParams{}

	m.CreateLedgerMock = mLedgerServiceHandlerMockCreateLedger{mock: m}
	m.CreateLedgerMock.callArgs = []*LedgerServiceHandlerMockCreateLedgerParams{}

	m.CreateTransactionMock = mLedgerServiceHandlerMockCreateTransaction{mock: m}
	m.CreateTransactionMock.callArgs = []*LedgerServiceHandlerMockCreateTransactionParams{}

	m.ReverseTransactionMock = mLedgerServiceHandlerMockReverseTransaction{mock: m}
	m.ReverseTransactionMock.callArgs = []*LedgerServiceHandlerMockReverseTransactionParams{}

	m.SearchAccountsMock = mLedgerServiceHandlerMockSearchAccounts{mock: m}
	m.SearchAccountsMock.callArgs = []*LedgerServiceHandlerMockSearchAccountsParams{}

	m.SearchLedgersMock = mLedgerServiceHandlerMockSearchLedgers{mock: m}
	m.SearchLedgersMock.callArgs = []*LedgerServiceHandlerMockSearchLedgersParams{}

	m.SearchTransactionEntriesMock = mLedgerServiceHandlerMockSearchTransactionEntries{mock: m}
	m.SearchTransactionEntriesMock.callArgs = []*LedgerServiceHandlerMockSearchTransactionEntriesParams{}

	m.SearchTransactionsMock = mLedgerServiceHandlerMockSearchTransactions{mock: m}
	m.SearchTransactionsMock.callArgs = []*LedgerServiceHandlerMockSearchTransactionsParams{}

	m.UpdateAccountMock = mLedgerServiceHandlerMockUpdateAccount{mock: m}
	m.UpdateAccountMock.callArgs = []*LedgerServiceHandlerMockUpdateAccountParams{}

	m.UpdateLedgerMock = mLedgerServiceHandlerMockUpdateLedger{mock: m}
	m.UpdateLedgerMock.callArgs = []*LedgerServiceHandlerMockUpdateLedgerParams{}

	m.UpdateTransactionMock = mLedgerServiceHandlerMockUpdateTransaction{mock: m}
	m.UpdateTransactionMock.callArgs = []*LedgerServiceHandlerMockUpdateTransactionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLedgerServiceHandlerMockCreateAccount struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockCreateAccountExpectation
	expectations       []*LedgerServiceHandlerMockCreateAccountExpectation

	callArgs []*LedgerServiceHandlerMockCreateAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockCreateAccountExpectation specifies expectation struct of the LedgerServiceHandler.CreateAccount
type LedgerServiceHandlerMockCreateAccountExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockCreateAccountParams
	paramPtrs          *LedgerServiceHandlerMockCreateAccountParamPtrs
	expectationOrigins LedgerServiceHandlerMockCreateAccountExpectationOrigins
	results            *LedgerServiceHandlerMockCreateAccountResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockCreateAccountParams contains parameters of the LedgerServiceHandler.CreateAccount
type LedgerServiceHandlerMockCreateAccountParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Account]
}

// LedgerServiceHandlerMockCreateAccountParamPtrs contains pointers to parameters of the LedgerServiceHandler.CreateAccount
type LedgerServiceHandlerMockCreateAccountParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Account]
}

// LedgerServiceHandlerMockCreateAccountResults contains results of the LedgerServiceHandler.CreateAccount
type LedgerServiceHandlerMockCreateAccountResults struct {
	pp2 *connect.Response[v11.Account]
	err error
}

// LedgerServiceHandlerMockCreateAccountOrigins contains origins of expectations of the LedgerServiceHandler.CreateAccount
type LedgerServiceHandlerMockCreateAccountExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Optional() *mLedgerServiceHandlerMockCreateAccount {
	mmCreateAccount.optional = true
	return mmCreateAccount
}

// Expect sets up expected params for LedgerServiceHandler.CreateAccount
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Expect(ctx context.Context, pp1 *connect.Request[v11.Account]) *mLedgerServiceHandlerMockCreateAccount {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceHandlerMockCreateAccountExpectation{}
	}

	if mmCreateAccount.defaultExpectation.paramPtrs != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by ExpectParams functions")
	}

	mmCreateAccount.defaultExpectation.params = &LedgerServiceHandlerMockCreateAccountParams{ctx, pp1}
	mmCreateAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccount.expectations {
		if minimock.Equal(e.params, mmCreateAccount.defaultExpectation.params) {
			mmCreateAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccount.defaultExpectation.params)
		}
	}

	return mmCreateAccount
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.CreateAccount
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockCreateAccount {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceHandlerMockCreateAccountExpectation{}
	}

	if mmCreateAccount.defaultExpectation.params != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Expect")
	}

	if mmCreateAccount.defaultExpectation.paramPtrs == nil {
		mmCreateAccount.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockCreateAccountParamPtrs{}
	}
	mmCreateAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccount
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.CreateAccount
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) ExpectPp1Param2(pp1 *connect.Request[v11.Account]) *mLedgerServiceHandlerMockCreateAccount {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceHandlerMockCreateAccountExpectation{}
	}

	if mmCreateAccount.defaultExpectation.params != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Expect")
	}

	if mmCreateAccount.defaultExpectation.paramPtrs == nil {
		mmCreateAccount.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockCreateAccountParamPtrs{}
	}
	mmCreateAccount.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateAccount.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateAccount
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.CreateAccount
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Account])) *mLedgerServiceHandlerMockCreateAccount {
	if mmCreateAccount.mock.inspectFuncCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.CreateAccount")
	}

	mmCreateAccount.mock.inspectFuncCreateAccount = f

	return mmCreateAccount
}

// Return sets up results that will be returned by LedgerServiceHandler.CreateAccount
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Return(pp2 *connect.Response[v11.Account], err error) *LedgerServiceHandlerMock {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceHandlerMockCreateAccountExpectation{mock: mmCreateAccount.mock}
	}
	mmCreateAccount.defaultExpectation.results = &LedgerServiceHandlerMockCreateAccountResults{pp2, err}
	mmCreateAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccount.mock
}

// Set uses given function f to mock the LedgerServiceHandler.CreateAccount method
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Account]) (pp2 *connect.Response[v11.Account], err error)) *LedgerServiceHandlerMock {
	if mmCreateAccount.defaultExpectation != nil {
		mmCreateAccount.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.CreateAccount method")
	}

	if len(mmCreateAccount.expectations) > 0 {
		mmCreateAccount.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.CreateAccount method")
	}

	mmCreateAccount.mock.funcCreateAccount = f
	mmCreateAccount.mock.funcCreateAccountOrigin = minimock.CallerInfo(1)
	return mmCreateAccount.mock
}

// When sets expectation for the LedgerServiceHandler.CreateAccount which will trigger the result defined by the following
// Then helper
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) When(ctx context.Context, pp1 *connect.Request[v11.Account]) *LedgerServiceHandlerMockCreateAccountExpectation {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.CreateAccount mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockCreateAccountExpectation{
		mock:               mmCreateAccount.mock,
		params:             &LedgerServiceHandlerMockCreateAccountParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockCreateAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccount.expectations = append(mmCreateAccount.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.CreateAccount return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockCreateAccountExpectation) Then(pp2 *connect.Response[v11.Account], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockCreateAccountResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.CreateAccount should be invoked
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Times(n uint64) *mLedgerServiceHandlerMockCreateAccount {
	if n == 0 {
		mmCreateAccount.mock.t.Fatalf("Times of LedgerServiceHandlerMock.CreateAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccount.expectedInvocations, n)
	mmCreateAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccount
}

func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) invocationsDone() bool {
	if len(mmCreateAccount.expectations) == 0 && mmCreateAccount.defaultExpectation == nil && mmCreateAccount.mock.funcCreateAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccount.mock.afterCreateAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccount implements mm_ledgerv1connect.LedgerServiceHandler
func (mmCreateAccount *LedgerServiceHandlerMock) CreateAccount(ctx context.Context, pp1 *connect.Request[v11.Account]) (pp2 *connect.Response[v11.Account], err error) {
	mm_atomic.AddUint64(&mmCreateAccount.beforeCreateAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccount.afterCreateAccountCounter, 1)

	mmCreateAccount.t.Helper()

	if mmCreateAccount.inspectFuncCreateAccount != nil {
		mmCreateAccount.inspectFuncCreateAccount(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockCreateAccountParams{ctx, pp1}

	// Record call args
	mmCreateAccount.CreateAccountMock.mutex.Lock()
	mmCreateAccount.CreateAccountMock.callArgs = append(mmCreateAccount.CreateAccountMock.callArgs, &mm_params)
	mmCreateAccount.CreateAccountMock.mutex.Unlock()

	for _, e := range mmCreateAccount.CreateAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateAccount.CreateAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccount.CreateAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccount.CreateAccountMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccount.CreateAccountMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockCreateAccountParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccount.t.Errorf("LedgerServiceHandlerMock.CreateAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccount.CreateAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateAccount.t.Errorf("LedgerServiceHandlerMock.CreateAccount got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccount.CreateAccountMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccount.t.Errorf("LedgerServiceHandlerMock.CreateAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccount.CreateAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccount.CreateAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccount.t.Fatal("No results are set for the LedgerServiceHandlerMock.CreateAccount")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateAccount.funcCreateAccount != nil {
		return mmCreateAccount.funcCreateAccount(ctx, pp1)
	}
	mmCreateAccount.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.CreateAccount. %v %v", ctx, pp1)
	return
}

// CreateAccountAfterCounter returns a count of finished LedgerServiceHandlerMock.CreateAccount invocations
func (mmCreateAccount *LedgerServiceHandlerMock) CreateAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccount.afterCreateAccountCounter)
}

// CreateAccountBeforeCounter returns a count of LedgerServiceHandlerMock.CreateAccount invocations
func (mmCreateAccount *LedgerServiceHandlerMock) CreateAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccount.beforeCreateAccountCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.CreateAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccount *mLedgerServiceHandlerMockCreateAccount) Calls() []*LedgerServiceHandlerMockCreateAccountParams {
	mmCreateAccount.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockCreateAccountParams, len(mmCreateAccount.callArgs))
	copy(argCopy, mmCreateAccount.callArgs)

	mmCreateAccount.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccountDone returns true if the count of the CreateAccount invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockCreateAccountDone() bool {
	if m.CreateAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccountMock.invocationsDone()
}

// MinimockCreateAccountInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockCreateAccountInspect() {
	for _, e := range m.CreateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccountCounter := mm_atomic.LoadUint64(&m.afterCreateAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccountMock.defaultExpectation != nil && afterCreateAccountCounter < 1 {
		if m.CreateAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateAccount at\n%s", m.CreateAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateAccount at\n%s with params: %#v", m.CreateAccountMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccount != nil && afterCreateAccountCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateAccount at\n%s", m.funcCreateAccountOrigin)
	}

	if !m.CreateAccountMock.invocationsDone() && afterCreateAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.CreateAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccountMock.expectedInvocations), m.CreateAccountMock.expectedInvocationsOrigin, afterCreateAccountCounter)
	}
}

type mLedgerServiceHandlerMockCreateLedger struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockCreateLedgerExpectation
	expectations       []*LedgerServiceHandlerMockCreateLedgerExpectation

	callArgs []*LedgerServiceHandlerMockCreateLedgerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockCreateLedgerExpectation specifies expectation struct of the LedgerServiceHandler.CreateLedger
type LedgerServiceHandlerMockCreateLedgerExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockCreateLedgerParams
	paramPtrs          *LedgerServiceHandlerMockCreateLedgerParamPtrs
	expectationOrigins LedgerServiceHandlerMockCreateLedgerExpectationOrigins
	results            *LedgerServiceHandlerMockCreateLedgerResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockCreateLedgerParams contains parameters of the LedgerServiceHandler.CreateLedger
type LedgerServiceHandlerMockCreateLedgerParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Ledger]
}

// LedgerServiceHandlerMockCreateLedgerParamPtrs contains pointers to parameters of the LedgerServiceHandler.CreateLedger
type LedgerServiceHandlerMockCreateLedgerParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Ledger]
}

// LedgerServiceHandlerMockCreateLedgerResults contains results of the LedgerServiceHandler.CreateLedger
type LedgerServiceHandlerMockCreateLedgerResults struct {
	pp2 *connect.Response[v11.Ledger]
	err error
}

// LedgerServiceHandlerMockCreateLedgerOrigins contains origins of expectations of the LedgerServiceHandler.CreateLedger
type LedgerServiceHandlerMockCreateLedgerExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Optional() *mLedgerServiceHandlerMockCreateLedger {
	mmCreateLedger.optional = true
	return mmCreateLedger
}

// Expect sets up expected params for LedgerServiceHandler.CreateLedger
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Expect(ctx context.Context, pp1 *connect.Request[v11.Ledger]) *mLedgerServiceHandlerMockCreateLedger {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceHandlerMockCreateLedgerExpectation{}
	}

	if mmCreateLedger.defaultExpectation.paramPtrs != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by ExpectParams functions")
	}

	mmCreateLedger.defaultExpectation.params = &LedgerServiceHandlerMockCreateLedgerParams{ctx, pp1}
	mmCreateLedger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateLedger.expectations {
		if minimock.Equal(e.params, mmCreateLedger.defaultExpectation.params) {
			mmCreateLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateLedger.defaultExpectation.params)
		}
	}

	return mmCreateLedger
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.CreateLedger
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockCreateLedger {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceHandlerMockCreateLedgerExpectation{}
	}

	if mmCreateLedger.defaultExpectation.params != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Expect")
	}

	if mmCreateLedger.defaultExpectation.paramPtrs == nil {
		mmCreateLedger.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockCreateLedgerParamPtrs{}
	}
	mmCreateLedger.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateLedger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateLedger
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.CreateLedger
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) ExpectPp1Param2(pp1 *connect.Request[v11.Ledger]) *mLedgerServiceHandlerMockCreateLedger {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceHandlerMockCreateLedgerExpectation{}
	}

	if mmCreateLedger.defaultExpectation.params != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Expect")
	}

	if mmCreateLedger.defaultExpectation.paramPtrs == nil {
		mmCreateLedger.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockCreateLedgerParamPtrs{}
	}
	mmCreateLedger.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateLedger.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateLedger
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.CreateLedger
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Ledger])) *mLedgerServiceHandlerMockCreateLedger {
	if mmCreateLedger.mock.inspectFuncCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.CreateLedger")
	}

	mmCreateLedger.mock.inspectFuncCreateLedger = f

	return mmCreateLedger
}

// Return sets up results that will be returned by LedgerServiceHandler.CreateLedger
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Return(pp2 *connect.Response[v11.Ledger], err error) *LedgerServiceHandlerMock {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceHandlerMockCreateLedgerExpectation{mock: mmCreateLedger.mock}
	}
	mmCreateLedger.defaultExpectation.results = &LedgerServiceHandlerMockCreateLedgerResults{pp2, err}
	mmCreateLedger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateLedger.mock
}

// Set uses given function f to mock the LedgerServiceHandler.CreateLedger method
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Ledger]) (pp2 *connect.Response[v11.Ledger], err error)) *LedgerServiceHandlerMock {
	if mmCreateLedger.defaultExpectation != nil {
		mmCreateLedger.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.CreateLedger method")
	}

	if len(mmCreateLedger.expectations) > 0 {
		mmCreateLedger.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.CreateLedger method")
	}

	mmCreateLedger.mock.funcCreateLedger = f
	mmCreateLedger.mock.funcCreateLedgerOrigin = minimock.CallerInfo(1)
	return mmCreateLedger.mock
}

// When sets expectation for the LedgerServiceHandler.CreateLedger which will trigger the result defined by the following
// Then helper
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) When(ctx context.Context, pp1 *connect.Request[v11.Ledger]) *LedgerServiceHandlerMockCreateLedgerExpectation {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.CreateLedger mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockCreateLedgerExpectation{
		mock:               mmCreateLedger.mock,
		params:             &LedgerServiceHandlerMockCreateLedgerParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockCreateLedgerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateLedger.expectations = append(mmCreateLedger.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.CreateLedger return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockCreateLedgerExpectation) Then(pp2 *connect.Response[v11.Ledger], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockCreateLedgerResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.CreateLedger should be invoked
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Times(n uint64) *mLedgerServiceHandlerMockCreateLedger {
	if n == 0 {
		mmCreateLedger.mock.t.Fatalf("Times of LedgerServiceHandlerMock.CreateLedger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateLedger.expectedInvocations, n)
	mmCreateLedger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateLedger
}

func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) invocationsDone() bool {
	if len(mmCreateLedger.expectations) == 0 && mmCreateLedger.defaultExpectation == nil && mmCreateLedger.mock.funcCreateLedger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateLedger.mock.afterCreateLedgerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateLedger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateLedger implements mm_ledgerv1connect.LedgerServiceHandler
func (mmCreateLedger *LedgerServiceHandlerMock) CreateLedger(ctx context.Context, pp1 *connect.Request[v11.Ledger]) (pp2 *connect.Response[v11.Ledger], err error) {
	mm_atomic.AddUint64(&mmCreateLedger.beforeCreateLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateLedger.afterCreateLedgerCounter, 1)

	mmCreateLedger.t.Helper()

	if mmCreateLedger.inspectFuncCreateLedger != nil {
		mmCreateLedger.inspectFuncCreateLedger(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockCreateLedgerParams{ctx, pp1}

	// Record call args
	mmCreateLedger.CreateLedgerMock.mutex.Lock()
	mmCreateLedger.CreateLedgerMock.callArgs = append(mmCreateLedger.CreateLedgerMock.callArgs, &mm_params)
	mmCreateLedger.CreateLedgerMock.mutex.Unlock()

	for _, e := range mmCreateLedger.CreateLedgerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateLedger.CreateLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateLedger.CreateLedgerMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateLedger.CreateLedgerMock.defaultExpectation.params
		mm_want_ptrs := mmCreateLedger.CreateLedgerMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockCreateLedgerParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateLedger.t.Errorf("LedgerServiceHandlerMock.CreateLedger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLedger.CreateLedgerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateLedger.t.Errorf("LedgerServiceHandlerMock.CreateLedger got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLedger.CreateLedgerMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateLedger.t.Errorf("LedgerServiceHandlerMock.CreateLedger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateLedger.CreateLedgerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateLedger.CreateLedgerMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateLedger.t.Fatal("No results are set for the LedgerServiceHandlerMock.CreateLedger")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateLedger.funcCreateLedger != nil {
		return mmCreateLedger.funcCreateLedger(ctx, pp1)
	}
	mmCreateLedger.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.CreateLedger. %v %v", ctx, pp1)
	return
}

// CreateLedgerAfterCounter returns a count of finished LedgerServiceHandlerMock.CreateLedger invocations
func (mmCreateLedger *LedgerServiceHandlerMock) CreateLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLedger.afterCreateLedgerCounter)
}

// CreateLedgerBeforeCounter returns a count of LedgerServiceHandlerMock.CreateLedger invocations
func (mmCreateLedger *LedgerServiceHandlerMock) CreateLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLedger.beforeCreateLedgerCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.CreateLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateLedger *mLedgerServiceHandlerMockCreateLedger) Calls() []*LedgerServiceHandlerMockCreateLedgerParams {
	mmCreateLedger.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockCreateLedgerParams, len(mmCreateLedger.callArgs))
	copy(argCopy, mmCreateLedger.callArgs)

	mmCreateLedger.mutex.RUnlock()

	return argCopy
}

// MinimockCreateLedgerDone returns true if the count of the CreateLedger invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockCreateLedgerDone() bool {
	if m.CreateLedgerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateLedgerMock.invocationsDone()
}

// MinimockCreateLedgerInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockCreateLedgerInspect() {
	for _, e := range m.CreateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateLedger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateLedgerCounter := mm_atomic.LoadUint64(&m.afterCreateLedgerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLedgerMock.defaultExpectation != nil && afterCreateLedgerCounter < 1 {
		if m.CreateLedgerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateLedger at\n%s", m.CreateLedgerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateLedger at\n%s with params: %#v", m.CreateLedgerMock.defaultExpectation.expectationOrigins.origin, *m.CreateLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLedger != nil && afterCreateLedgerCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateLedger at\n%s", m.funcCreateLedgerOrigin)
	}

	if !m.CreateLedgerMock.invocationsDone() && afterCreateLedgerCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.CreateLedger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateLedgerMock.expectedInvocations), m.CreateLedgerMock.expectedInvocationsOrigin, afterCreateLedgerCounter)
	}
}

type mLedgerServiceHandlerMockCreateTransaction struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockCreateTransactionExpectation
	expectations       []*LedgerServiceHandlerMockCreateTransactionExpectation

	callArgs []*LedgerServiceHandlerMockCreateTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockCreateTransactionExpectation specifies expectation struct of the LedgerServiceHandler.CreateTransaction
type LedgerServiceHandlerMockCreateTransactionExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockCreateTransactionParams
	paramPtrs          *LedgerServiceHandlerMockCreateTransactionParamPtrs
	expectationOrigins LedgerServiceHandlerMockCreateTransactionExpectationOrigins
	results            *LedgerServiceHandlerMockCreateTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockCreateTransactionParams contains parameters of the LedgerServiceHandler.CreateTransaction
type LedgerServiceHandlerMockCreateTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Transaction]
}

// LedgerServiceHandlerMockCreateTransactionParamPtrs contains pointers to parameters of the LedgerServiceHandler.CreateTransaction
type LedgerServiceHandlerMockCreateTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Transaction]
}

// LedgerServiceHandlerMockCreateTransactionResults contains results of the LedgerServiceHandler.CreateTransaction
type LedgerServiceHandlerMockCreateTransactionResults struct {
	pp2 *connect.Response[v11.Transaction]
	err error
}

// LedgerServiceHandlerMockCreateTransactionOrigins contains origins of expectations of the LedgerServiceHandler.CreateTransaction
type LedgerServiceHandlerMockCreateTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Optional() *mLedgerServiceHandlerMockCreateTransaction {
	mmCreateTransaction.optional = true
	return mmCreateTransaction
}

// Expect sets up expected params for LedgerServiceHandler.CreateTransaction
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Expect(ctx context.Context, pp1 *connect.Request[v11.Transaction]) *mLedgerServiceHandlerMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceHandlerMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by ExpectParams functions")
	}

	mmCreateTransaction.defaultExpectation.params = &LedgerServiceHandlerMockCreateTransactionParams{ctx, pp1}
	mmCreateTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTransaction.expectations {
		if minimock.Equal(e.params, mmCreateTransaction.defaultExpectation.params) {
			mmCreateTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTransaction.defaultExpectation.params)
		}
	}

	return mmCreateTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.CreateTransaction
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceHandlerMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.CreateTransaction
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) ExpectPp1Param2(pp1 *connect.Request[v11.Transaction]) *mLedgerServiceHandlerMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceHandlerMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.CreateTransaction
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Transaction])) *mLedgerServiceHandlerMockCreateTransaction {
	if mmCreateTransaction.mock.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.CreateTransaction")
	}

	mmCreateTransaction.mock.inspectFuncCreateTransaction = f

	return mmCreateTransaction
}

// Return sets up results that will be returned by LedgerServiceHandler.CreateTransaction
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Return(pp2 *connect.Response[v11.Transaction], err error) *LedgerServiceHandlerMock {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceHandlerMockCreateTransactionExpectation{mock: mmCreateTransaction.mock}
	}
	mmCreateTransaction.defaultExpectation.results = &LedgerServiceHandlerMockCreateTransactionResults{pp2, err}
	mmCreateTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// Set uses given function f to mock the LedgerServiceHandler.CreateTransaction method
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error)) *LedgerServiceHandlerMock {
	if mmCreateTransaction.defaultExpectation != nil {
		mmCreateTransaction.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.CreateTransaction method")
	}

	if len(mmCreateTransaction.expectations) > 0 {
		mmCreateTransaction.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.CreateTransaction method")
	}

	mmCreateTransaction.mock.funcCreateTransaction = f
	mmCreateTransaction.mock.funcCreateTransactionOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// When sets expectation for the LedgerServiceHandler.CreateTransaction which will trigger the result defined by the following
// Then helper
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) When(ctx context.Context, pp1 *connect.Request[v11.Transaction]) *LedgerServiceHandlerMockCreateTransactionExpectation {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.CreateTransaction mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockCreateTransactionExpectation{
		mock:               mmCreateTransaction.mock,
		params:             &LedgerServiceHandlerMockCreateTransactionParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockCreateTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTransaction.expectations = append(mmCreateTransaction.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.CreateTransaction return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockCreateTransactionExpectation) Then(pp2 *connect.Response[v11.Transaction], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockCreateTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.CreateTransaction should be invoked
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Times(n uint64) *mLedgerServiceHandlerMockCreateTransaction {
	if n == 0 {
		mmCreateTransaction.mock.t.Fatalf("Times of LedgerServiceHandlerMock.CreateTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTransaction.expectedInvocations, n)
	mmCreateTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction
}

func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) invocationsDone() bool {
	if len(mmCreateTransaction.expectations) == 0 && mmCreateTransaction.defaultExpectation == nil && mmCreateTransaction.mock.funcCreateTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.mock.afterCreateTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTransaction implements mm_ledgerv1connect.LedgerServiceHandler
func (mmCreateTransaction *LedgerServiceHandlerMock) CreateTransaction(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error) {
	mm_atomic.AddUint64(&mmCreateTransaction.beforeCreateTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTransaction.afterCreateTransactionCounter, 1)

	mmCreateTransaction.t.Helper()

	if mmCreateTransaction.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.inspectFuncCreateTransaction(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockCreateTransactionParams{ctx, pp1}

	// Record call args
	mmCreateTransaction.CreateTransactionMock.mutex.Lock()
	mmCreateTransaction.CreateTransactionMock.callArgs = append(mmCreateTransaction.CreateTransactionMock.callArgs, &mm_params)
	mmCreateTransaction.CreateTransactionMock.mutex.Unlock()

	for _, e := range mmCreateTransaction.CreateTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateTransaction.CreateTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTransaction.CreateTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTransaction.CreateTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTransaction.CreateTransactionMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockCreateTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTransaction.t.Errorf("LedgerServiceHandlerMock.CreateTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateTransaction.t.Errorf("LedgerServiceHandlerMock.CreateTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTransaction.t.Errorf("LedgerServiceHandlerMock.CreateTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTransaction.CreateTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTransaction.t.Fatal("No results are set for the LedgerServiceHandlerMock.CreateTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateTransaction.funcCreateTransaction != nil {
		return mmCreateTransaction.funcCreateTransaction(ctx, pp1)
	}
	mmCreateTransaction.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.CreateTransaction. %v %v", ctx, pp1)
	return
}

// CreateTransactionAfterCounter returns a count of finished LedgerServiceHandlerMock.CreateTransaction invocations
func (mmCreateTransaction *LedgerServiceHandlerMock) CreateTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.afterCreateTransactionCounter)
}

// CreateTransactionBeforeCounter returns a count of LedgerServiceHandlerMock.CreateTransaction invocations
func (mmCreateTransaction *LedgerServiceHandlerMock) CreateTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.beforeCreateTransactionCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.CreateTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTransaction *mLedgerServiceHandlerMockCreateTransaction) Calls() []*LedgerServiceHandlerMockCreateTransactionParams {
	mmCreateTransaction.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockCreateTransactionParams, len(mmCreateTransaction.callArgs))
	copy(argCopy, mmCreateTransaction.callArgs)

	mmCreateTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTransactionDone returns true if the count of the CreateTransaction invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockCreateTransactionDone() bool {
	if m.CreateTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTransactionMock.invocationsDone()
}

// MinimockCreateTransactionInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockCreateTransactionInspect() {
	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTransactionCounter := mm_atomic.LoadUint64(&m.afterCreateTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTransactionMock.defaultExpectation != nil && afterCreateTransactionCounter < 1 {
		if m.CreateTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateTransaction at\n%s", m.CreateTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateTransaction at\n%s with params: %#v", m.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *m.CreateTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTransaction != nil && afterCreateTransactionCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.CreateTransaction at\n%s", m.funcCreateTransactionOrigin)
	}

	if !m.CreateTransactionMock.invocationsDone() && afterCreateTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.CreateTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTransactionMock.expectedInvocations), m.CreateTransactionMock.expectedInvocationsOrigin, afterCreateTransactionCounter)
	}
}

type mLedgerServiceHandlerMockReverseTransaction struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockReverseTransactionExpectation
	expectations       []*LedgerServiceHandlerMockReverseTransactionExpectation

	callArgs []*LedgerServiceHandlerMockReverseTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockReverseTransactionExpectation specifies expectation struct of the LedgerServiceHandler.ReverseTransaction
type LedgerServiceHandlerMockReverseTransactionExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockReverseTransactionParams
	paramPtrs          *LedgerServiceHandlerMockReverseTransactionParamPtrs
	expectationOrigins LedgerServiceHandlerMockReverseTransactionExpectationOrigins
	results            *LedgerServiceHandlerMockReverseTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockReverseTransactionParams contains parameters of the LedgerServiceHandler.ReverseTransaction
type LedgerServiceHandlerMockReverseTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Transaction]
}

// LedgerServiceHandlerMockReverseTransactionParamPtrs contains pointers to parameters of the LedgerServiceHandler.ReverseTransaction
type LedgerServiceHandlerMockReverseTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Transaction]
}

// LedgerServiceHandlerMockReverseTransactionResults contains results of the LedgerServiceHandler.ReverseTransaction
type LedgerServiceHandlerMockReverseTransactionResults struct {
	pp2 *connect.Response[v11.Transaction]
	err error
}

// LedgerServiceHandlerMockReverseTransactionOrigins contains origins of expectations of the LedgerServiceHandler.ReverseTransaction
type LedgerServiceHandlerMockReverseTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Optional() *mLedgerServiceHandlerMockReverseTransaction {
	mmReverseTransaction.optional = true
	return mmReverseTransaction
}

// Expect sets up expected params for LedgerServiceHandler.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Expect(ctx context.Context, pp1 *connect.Request[v11.Transaction]) *mLedgerServiceHandlerMockReverseTransaction {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceHandlerMockReverseTransactionExpectation{}
	}

	if mmReverseTransaction.defaultExpectation.paramPtrs != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by ExpectParams functions")
	}

	mmReverseTransaction.defaultExpectation.params = &LedgerServiceHandlerMockReverseTransactionParams{ctx, pp1}
	mmReverseTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReverseTransaction.expectations {
		if minimock.Equal(e.params, mmReverseTransaction.defaultExpectation.params) {
			mmReverseTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReverseTransaction.defaultExpectation.params)
		}
	}

	return mmReverseTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockReverseTransaction {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceHandlerMockReverseTransactionExpectation{}
	}

	if mmReverseTransaction.defaultExpectation.params != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Expect")
	}

	if mmReverseTransaction.defaultExpectation.paramPtrs == nil {
		mmReverseTransaction.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockReverseTransactionParamPtrs{}
	}
	mmReverseTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmReverseTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReverseTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) ExpectPp1Param2(pp1 *connect.Request[v11.Transaction]) *mLedgerServiceHandlerMockReverseTransaction {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceHandlerMockReverseTransactionExpectation{}
	}

	if mmReverseTransaction.defaultExpectation.params != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Expect")
	}

	if mmReverseTransaction.defaultExpectation.paramPtrs == nil {
		mmReverseTransaction.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockReverseTransactionParamPtrs{}
	}
	mmReverseTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReverseTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReverseTransaction
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Transaction])) *mLedgerServiceHandlerMockReverseTransaction {
	if mmReverseTransaction.mock.inspectFuncReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.ReverseTransaction")
	}

	mmReverseTransaction.mock.inspectFuncReverseTransaction = f

	return mmReverseTransaction
}

// Return sets up results that will be returned by LedgerServiceHandler.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Return(pp2 *connect.Response[v11.Transaction], err error) *LedgerServiceHandlerMock {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceHandlerMockReverseTransactionExpectation{mock: mmReverseTransaction.mock}
	}
	mmReverseTransaction.defaultExpectation.results = &LedgerServiceHandlerMockReverseTransactionResults{pp2, err}
	mmReverseTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReverseTransaction.mock
}

// Set uses given function f to mock the LedgerServiceHandler.ReverseTransaction method
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error)) *LedgerServiceHandlerMock {
	if mmReverseTransaction.defaultExpectation != nil {
		mmReverseTransaction.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.ReverseTransaction method")
	}

	if len(mmReverseTransaction.expectations) > 0 {
		mmReverseTransaction.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.ReverseTransaction method")
	}

	mmReverseTransaction.mock.funcReverseTransaction = f
	mmReverseTransaction.mock.funcReverseTransactionOrigin = minimock.CallerInfo(1)
	return mmReverseTransaction.mock
}

// When sets expectation for the LedgerServiceHandler.ReverseTransaction which will trigger the result defined by the following
// Then helper
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) When(ctx context.Context, pp1 *connect.Request[v11.Transaction]) *LedgerServiceHandlerMockReverseTransactionExpectation {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.ReverseTransaction mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockReverseTransactionExpectation{
		mock:               mmReverseTransaction.mock,
		params:             &LedgerServiceHandlerMockReverseTransactionParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockReverseTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReverseTransaction.expectations = append(mmReverseTransaction.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.ReverseTransaction return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockReverseTransactionExpectation) Then(pp2 *connect.Response[v11.Transaction], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockReverseTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.ReverseTransaction should be invoked
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Times(n uint64) *mLedgerServiceHandlerMockReverseTransaction {
	if n == 0 {
		mmReverseTransaction.mock.t.Fatalf("Times of LedgerServiceHandlerMock.ReverseTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReverseTransaction.expectedInvocations, n)
	mmReverseTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReverseTransaction
}

func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) invocationsDone() bool {
	if len(mmReverseTransaction.expectations) == 0 && mmReverseTransaction.defaultExpectation == nil && mmReverseTransaction.mock.funcReverseTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReverseTransaction.mock.afterReverseTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReverseTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReverseTransaction implements mm_ledgerv1connect.LedgerServiceHandler
func (mmReverseTransaction *LedgerServiceHandlerMock) ReverseTransaction(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error) {
	mm_atomic.AddUint64(&mmReverseTransaction.beforeReverseTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmReverseTransaction.afterReverseTransactionCounter, 1)

	mmReverseTransaction.t.Helper()

	if mmReverseTransaction.inspectFuncReverseTransaction != nil {
		mmReverseTransaction.inspectFuncReverseTransaction(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockReverseTransactionParams{ctx, pp1}

	// Record call args
	mmReverseTransaction.ReverseTransactionMock.mutex.Lock()
	mmReverseTransaction.ReverseTransactionMock.callArgs = append(mmReverseTransaction.ReverseTransactionMock.callArgs, &mm_params)
	mmReverseTransaction.ReverseTransactionMock.mutex.Unlock()

	for _, e := range mmReverseTransaction.ReverseTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReverseTransaction.ReverseTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReverseTransaction.ReverseTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmReverseTransaction.ReverseTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmReverseTransaction.ReverseTransactionMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockReverseTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReverseTransaction.t.Errorf("LedgerServiceHandlerMock.ReverseTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReverseTransaction.ReverseTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReverseTransaction.t.Errorf("LedgerServiceHandlerMock.ReverseTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReverseTransaction.ReverseTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReverseTransaction.t.Errorf("LedgerServiceHandlerMock.ReverseTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReverseTransaction.ReverseTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReverseTransaction.ReverseTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmReverseTransaction.t.Fatal("No results are set for the LedgerServiceHandlerMock.ReverseTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReverseTransaction.funcReverseTransaction != nil {
		return mmReverseTransaction.funcReverseTransaction(ctx, pp1)
	}
	mmReverseTransaction.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.ReverseTransaction. %v %v", ctx, pp1)
	return
}

// ReverseTransactionAfterCounter returns a count of finished LedgerServiceHandlerMock.ReverseTransaction invocations
func (mmReverseTransaction *LedgerServiceHandlerMock) ReverseTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReverseTransaction.afterReverseTransactionCounter)
}

// ReverseTransactionBeforeCounter returns a count of LedgerServiceHandlerMock.ReverseTransaction invocations
func (mmReverseTransaction *LedgerServiceHandlerMock) ReverseTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReverseTransaction.beforeReverseTransactionCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.ReverseTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReverseTransaction *mLedgerServiceHandlerMockReverseTransaction) Calls() []*LedgerServiceHandlerMockReverseTransactionParams {
	mmReverseTransaction.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockReverseTransactionParams, len(mmReverseTransaction.callArgs))
	copy(argCopy, mmReverseTransaction.callArgs)

	mmReverseTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockReverseTransactionDone returns true if the count of the ReverseTransaction invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockReverseTransactionDone() bool {
	if m.ReverseTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReverseTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReverseTransactionMock.invocationsDone()
}

// MinimockReverseTransactionInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockReverseTransactionInspect() {
	for _, e := range m.ReverseTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.ReverseTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReverseTransactionCounter := mm_atomic.LoadUint64(&m.afterReverseTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReverseTransactionMock.defaultExpectation != nil && afterReverseTransactionCounter < 1 {
		if m.ReverseTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.ReverseTransaction at\n%s", m.ReverseTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.ReverseTransaction at\n%s with params: %#v", m.ReverseTransactionMock.defaultExpectation.expectationOrigins.origin, *m.ReverseTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReverseTransaction != nil && afterReverseTransactionCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.ReverseTransaction at\n%s", m.funcReverseTransactionOrigin)
	}

	if !m.ReverseTransactionMock.invocationsDone() && afterReverseTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.ReverseTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReverseTransactionMock.expectedInvocations), m.ReverseTransactionMock.expectedInvocationsOrigin, afterReverseTransactionCounter)
	}
}

type mLedgerServiceHandlerMockSearchAccounts struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockSearchAccountsExpectation
	expectations       []*LedgerServiceHandlerMockSearchAccountsExpectation

	callArgs []*LedgerServiceHandlerMockSearchAccountsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockSearchAccountsExpectation specifies expectation struct of the LedgerServiceHandler.SearchAccounts
type LedgerServiceHandlerMockSearchAccountsExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockSearchAccountsParams
	paramPtrs          *LedgerServiceHandlerMockSearchAccountsParamPtrs
	expectationOrigins LedgerServiceHandlerMockSearchAccountsExpectationOrigins
	results            *LedgerServiceHandlerMockSearchAccountsResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockSearchAccountsParams contains parameters of the LedgerServiceHandler.SearchAccounts
type LedgerServiceHandlerMockSearchAccountsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
	pp2 *connect.ServerStream[v11.Account]
}

// LedgerServiceHandlerMockSearchAccountsParamPtrs contains pointers to parameters of the LedgerServiceHandler.SearchAccounts
type LedgerServiceHandlerMockSearchAccountsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
	pp2 **connect.ServerStream[v11.Account]
}

// LedgerServiceHandlerMockSearchAccountsResults contains results of the LedgerServiceHandler.SearchAccounts
type LedgerServiceHandlerMockSearchAccountsResults struct {
	err error
}

// LedgerServiceHandlerMockSearchAccountsOrigins contains origins of expectations of the LedgerServiceHandler.SearchAccounts
type LedgerServiceHandlerMockSearchAccountsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Optional() *mLedgerServiceHandlerMockSearchAccounts {
	mmSearchAccounts.optional = true
	return mmSearchAccounts
}

// Expect sets up expected params for LedgerServiceHandler.SearchAccounts
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account]) *mLedgerServiceHandlerMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceHandlerMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by ExpectParams functions")
	}

	mmSearchAccounts.defaultExpectation.params = &LedgerServiceHandlerMockSearchAccountsParams{ctx, pp1, pp2}
	mmSearchAccounts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchAccounts.expectations {
		if minimock.Equal(e.params, mmSearchAccounts.defaultExpectation.params) {
			mmSearchAccounts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchAccounts.defaultExpectation.params)
		}
	}

	return mmSearchAccounts
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.SearchAccounts
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceHandlerMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.params != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Expect")
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs == nil {
		mmSearchAccounts.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchAccountsParamPtrs{}
	}
	mmSearchAccounts.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchAccounts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchAccounts
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.SearchAccounts
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceHandlerMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceHandlerMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.params != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Expect")
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs == nil {
		mmSearchAccounts.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchAccountsParamPtrs{}
	}
	mmSearchAccounts.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchAccounts.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchAccounts
}

// ExpectPp2Param3 sets up expected param pp2 for LedgerServiceHandler.SearchAccounts
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) ExpectPp2Param3(pp2 *connect.ServerStream[v11.Account]) *mLedgerServiceHandlerMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceHandlerMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.params != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Expect")
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs == nil {
		mmSearchAccounts.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchAccountsParamPtrs{}
	}
	mmSearchAccounts.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearchAccounts.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearchAccounts
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.SearchAccounts
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account])) *mLedgerServiceHandlerMockSearchAccounts {
	if mmSearchAccounts.mock.inspectFuncSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.SearchAccounts")
	}

	mmSearchAccounts.mock.inspectFuncSearchAccounts = f

	return mmSearchAccounts
}

// Return sets up results that will be returned by LedgerServiceHandler.SearchAccounts
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Return(err error) *LedgerServiceHandlerMock {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceHandlerMockSearchAccountsExpectation{mock: mmSearchAccounts.mock}
	}
	mmSearchAccounts.defaultExpectation.results = &LedgerServiceHandlerMockSearchAccountsResults{err}
	mmSearchAccounts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchAccounts.mock
}

// Set uses given function f to mock the LedgerServiceHandler.SearchAccounts method
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account]) (err error)) *LedgerServiceHandlerMock {
	if mmSearchAccounts.defaultExpectation != nil {
		mmSearchAccounts.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.SearchAccounts method")
	}

	if len(mmSearchAccounts.expectations) > 0 {
		mmSearchAccounts.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.SearchAccounts method")
	}

	mmSearchAccounts.mock.funcSearchAccounts = f
	mmSearchAccounts.mock.funcSearchAccountsOrigin = minimock.CallerInfo(1)
	return mmSearchAccounts.mock
}

// When sets expectation for the LedgerServiceHandler.SearchAccounts which will trigger the result defined by the following
// Then helper
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account]) *LedgerServiceHandlerMockSearchAccountsExpectation {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceHandlerMock.SearchAccounts mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockSearchAccountsExpectation{
		mock:               mmSearchAccounts.mock,
		params:             &LedgerServiceHandlerMockSearchAccountsParams{ctx, pp1, pp2},
		expectationOrigins: LedgerServiceHandlerMockSearchAccountsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchAccounts.expectations = append(mmSearchAccounts.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.SearchAccounts return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockSearchAccountsExpectation) Then(err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockSearchAccountsResults{err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.SearchAccounts should be invoked
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Times(n uint64) *mLedgerServiceHandlerMockSearchAccounts {
	if n == 0 {
		mmSearchAccounts.mock.t.Fatalf("Times of LedgerServiceHandlerMock.SearchAccounts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchAccounts.expectedInvocations, n)
	mmSearchAccounts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchAccounts
}

func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) invocationsDone() bool {
	if len(mmSearchAccounts.expectations) == 0 && mmSearchAccounts.defaultExpectation == nil && mmSearchAccounts.mock.funcSearchAccounts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchAccounts.mock.afterSearchAccountsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchAccounts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchAccounts implements mm_ledgerv1connect.LedgerServiceHandler
func (mmSearchAccounts *LedgerServiceHandlerMock) SearchAccounts(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Account]) (err error) {
	mm_atomic.AddUint64(&mmSearchAccounts.beforeSearchAccountsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchAccounts.afterSearchAccountsCounter, 1)

	mmSearchAccounts.t.Helper()

	if mmSearchAccounts.inspectFuncSearchAccounts != nil {
		mmSearchAccounts.inspectFuncSearchAccounts(ctx, pp1, pp2)
	}

	mm_params := LedgerServiceHandlerMockSearchAccountsParams{ctx, pp1, pp2}

	// Record call args
	mmSearchAccounts.SearchAccountsMock.mutex.Lock()
	mmSearchAccounts.SearchAccountsMock.callArgs = append(mmSearchAccounts.SearchAccountsMock.callArgs, &mm_params)
	mmSearchAccounts.SearchAccountsMock.mutex.Unlock()

	for _, e := range mmSearchAccounts.SearchAccountsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearchAccounts.SearchAccountsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchAccounts.SearchAccountsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchAccounts.SearchAccountsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchAccounts.SearchAccountsMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockSearchAccountsParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchAccounts.t.Errorf("LedgerServiceHandlerMock.SearchAccounts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchAccounts.t.Errorf("LedgerServiceHandlerMock.SearchAccounts got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearchAccounts.t.Errorf("LedgerServiceHandlerMock.SearchAccounts got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchAccounts.t.Errorf("LedgerServiceHandlerMock.SearchAccounts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchAccounts.SearchAccountsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchAccounts.t.Fatal("No results are set for the LedgerServiceHandlerMock.SearchAccounts")
		}
		return (*mm_results).err
	}
	if mmSearchAccounts.funcSearchAccounts != nil {
		return mmSearchAccounts.funcSearchAccounts(ctx, pp1, pp2)
	}
	mmSearchAccounts.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.SearchAccounts. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchAccountsAfterCounter returns a count of finished LedgerServiceHandlerMock.SearchAccounts invocations
func (mmSearchAccounts *LedgerServiceHandlerMock) SearchAccountsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchAccounts.afterSearchAccountsCounter)
}

// SearchAccountsBeforeCounter returns a count of LedgerServiceHandlerMock.SearchAccounts invocations
func (mmSearchAccounts *LedgerServiceHandlerMock) SearchAccountsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchAccounts.beforeSearchAccountsCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.SearchAccounts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchAccounts *mLedgerServiceHandlerMockSearchAccounts) Calls() []*LedgerServiceHandlerMockSearchAccountsParams {
	mmSearchAccounts.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockSearchAccountsParams, len(mmSearchAccounts.callArgs))
	copy(argCopy, mmSearchAccounts.callArgs)

	mmSearchAccounts.mutex.RUnlock()

	return argCopy
}

// MinimockSearchAccountsDone returns true if the count of the SearchAccounts invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockSearchAccountsDone() bool {
	if m.SearchAccountsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchAccountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchAccountsMock.invocationsDone()
}

// MinimockSearchAccountsInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockSearchAccountsInspect() {
	for _, e := range m.SearchAccountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchAccounts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchAccountsCounter := mm_atomic.LoadUint64(&m.afterSearchAccountsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchAccountsMock.defaultExpectation != nil && afterSearchAccountsCounter < 1 {
		if m.SearchAccountsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchAccounts at\n%s", m.SearchAccountsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchAccounts at\n%s with params: %#v", m.SearchAccountsMock.defaultExpectation.expectationOrigins.origin, *m.SearchAccountsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchAccounts != nil && afterSearchAccountsCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchAccounts at\n%s", m.funcSearchAccountsOrigin)
	}

	if !m.SearchAccountsMock.invocationsDone() && afterSearchAccountsCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.SearchAccounts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchAccountsMock.expectedInvocations), m.SearchAccountsMock.expectedInvocationsOrigin, afterSearchAccountsCounter)
	}
}

type mLedgerServiceHandlerMockSearchLedgers struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockSearchLedgersExpectation
	expectations       []*LedgerServiceHandlerMockSearchLedgersExpectation

	callArgs []*LedgerServiceHandlerMockSearchLedgersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockSearchLedgersExpectation specifies expectation struct of the LedgerServiceHandler.SearchLedgers
type LedgerServiceHandlerMockSearchLedgersExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockSearchLedgersParams
	paramPtrs          *LedgerServiceHandlerMockSearchLedgersParamPtrs
	expectationOrigins LedgerServiceHandlerMockSearchLedgersExpectationOrigins
	results            *LedgerServiceHandlerMockSearchLedgersResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockSearchLedgersParams contains parameters of the LedgerServiceHandler.SearchLedgers
type LedgerServiceHandlerMockSearchLedgersParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
	pp2 *connect.ServerStream[v11.Ledger]
}

// LedgerServiceHandlerMockSearchLedgersParamPtrs contains pointers to parameters of the LedgerServiceHandler.SearchLedgers
type LedgerServiceHandlerMockSearchLedgersParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
	pp2 **connect.ServerStream[v11.Ledger]
}

// LedgerServiceHandlerMockSearchLedgersResults contains results of the LedgerServiceHandler.SearchLedgers
type LedgerServiceHandlerMockSearchLedgersResults struct {
	err error
}

// LedgerServiceHandlerMockSearchLedgersOrigins contains origins of expectations of the LedgerServiceHandler.SearchLedgers
type LedgerServiceHandlerMockSearchLedgersExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Optional() *mLedgerServiceHandlerMockSearchLedgers {
	mmSearchLedgers.optional = true
	return mmSearchLedgers
}

// Expect sets up expected params for LedgerServiceHandler.SearchLedgers
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger]) *mLedgerServiceHandlerMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceHandlerMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by ExpectParams functions")
	}

	mmSearchLedgers.defaultExpectation.params = &LedgerServiceHandlerMockSearchLedgersParams{ctx, pp1, pp2}
	mmSearchLedgers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchLedgers.expectations {
		if minimock.Equal(e.params, mmSearchLedgers.defaultExpectation.params) {
			mmSearchLedgers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchLedgers.defaultExpectation.params)
		}
	}

	return mmSearchLedgers
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.SearchLedgers
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceHandlerMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.params != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Expect")
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs == nil {
		mmSearchLedgers.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchLedgersParamPtrs{}
	}
	mmSearchLedgers.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchLedgers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchLedgers
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.SearchLedgers
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceHandlerMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceHandlerMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.params != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Expect")
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs == nil {
		mmSearchLedgers.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchLedgersParamPtrs{}
	}
	mmSearchLedgers.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchLedgers.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchLedgers
}

// ExpectPp2Param3 sets up expected param pp2 for LedgerServiceHandler.SearchLedgers
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) ExpectPp2Param3(pp2 *connect.ServerStream[v11.Ledger]) *mLedgerServiceHandlerMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceHandlerMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.params != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Expect")
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs == nil {
		mmSearchLedgers.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchLedgersParamPtrs{}
	}
	mmSearchLedgers.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearchLedgers.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearchLedgers
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.SearchLedgers
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger])) *mLedgerServiceHandlerMockSearchLedgers {
	if mmSearchLedgers.mock.inspectFuncSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.SearchLedgers")
	}

	mmSearchLedgers.mock.inspectFuncSearchLedgers = f

	return mmSearchLedgers
}

// Return sets up results that will be returned by LedgerServiceHandler.SearchLedgers
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Return(err error) *LedgerServiceHandlerMock {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceHandlerMockSearchLedgersExpectation{mock: mmSearchLedgers.mock}
	}
	mmSearchLedgers.defaultExpectation.results = &LedgerServiceHandlerMockSearchLedgersResults{err}
	mmSearchLedgers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchLedgers.mock
}

// Set uses given function f to mock the LedgerServiceHandler.SearchLedgers method
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger]) (err error)) *LedgerServiceHandlerMock {
	if mmSearchLedgers.defaultExpectation != nil {
		mmSearchLedgers.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.SearchLedgers method")
	}

	if len(mmSearchLedgers.expectations) > 0 {
		mmSearchLedgers.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.SearchLedgers method")
	}

	mmSearchLedgers.mock.funcSearchLedgers = f
	mmSearchLedgers.mock.funcSearchLedgersOrigin = minimock.CallerInfo(1)
	return mmSearchLedgers.mock
}

// When sets expectation for the LedgerServiceHandler.SearchLedgers which will trigger the result defined by the following
// Then helper
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger]) *LedgerServiceHandlerMockSearchLedgersExpectation {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceHandlerMock.SearchLedgers mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockSearchLedgersExpectation{
		mock:               mmSearchLedgers.mock,
		params:             &LedgerServiceHandlerMockSearchLedgersParams{ctx, pp1, pp2},
		expectationOrigins: LedgerServiceHandlerMockSearchLedgersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchLedgers.expectations = append(mmSearchLedgers.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.SearchLedgers return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockSearchLedgersExpectation) Then(err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockSearchLedgersResults{err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.SearchLedgers should be invoked
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Times(n uint64) *mLedgerServiceHandlerMockSearchLedgers {
	if n == 0 {
		mmSearchLedgers.mock.t.Fatalf("Times of LedgerServiceHandlerMock.SearchLedgers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchLedgers.expectedInvocations, n)
	mmSearchLedgers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchLedgers
}

func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) invocationsDone() bool {
	if len(mmSearchLedgers.expectations) == 0 && mmSearchLedgers.defaultExpectation == nil && mmSearchLedgers.mock.funcSearchLedgers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchLedgers.mock.afterSearchLedgersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchLedgers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchLedgers implements mm_ledgerv1connect.LedgerServiceHandler
func (mmSearchLedgers *LedgerServiceHandlerMock) SearchLedgers(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Ledger]) (err error) {
	mm_atomic.AddUint64(&mmSearchLedgers.beforeSearchLedgersCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchLedgers.afterSearchLedgersCounter, 1)

	mmSearchLedgers.t.Helper()

	if mmSearchLedgers.inspectFuncSearchLedgers != nil {
		mmSearchLedgers.inspectFuncSearchLedgers(ctx, pp1, pp2)
	}

	mm_params := LedgerServiceHandlerMockSearchLedgersParams{ctx, pp1, pp2}

	// Record call args
	mmSearchLedgers.SearchLedgersMock.mutex.Lock()
	mmSearchLedgers.SearchLedgersMock.callArgs = append(mmSearchLedgers.SearchLedgersMock.callArgs, &mm_params)
	mmSearchLedgers.SearchLedgersMock.mutex.Unlock()

	for _, e := range mmSearchLedgers.SearchLedgersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearchLedgers.SearchLedgersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchLedgers.SearchLedgersMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchLedgers.SearchLedgersMock.defaultExpectation.params
		mm_want_ptrs := mmSearchLedgers.SearchLedgersMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockSearchLedgersParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchLedgers.t.Errorf("LedgerServiceHandlerMock.SearchLedgers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchLedgers.t.Errorf("LedgerServiceHandlerMock.SearchLedgers got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearchLedgers.t.Errorf("LedgerServiceHandlerMock.SearchLedgers got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchLedgers.t.Errorf("LedgerServiceHandlerMock.SearchLedgers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchLedgers.SearchLedgersMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchLedgers.t.Fatal("No results are set for the LedgerServiceHandlerMock.SearchLedgers")
		}
		return (*mm_results).err
	}
	if mmSearchLedgers.funcSearchLedgers != nil {
		return mmSearchLedgers.funcSearchLedgers(ctx, pp1, pp2)
	}
	mmSearchLedgers.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.SearchLedgers. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchLedgersAfterCounter returns a count of finished LedgerServiceHandlerMock.SearchLedgers invocations
func (mmSearchLedgers *LedgerServiceHandlerMock) SearchLedgersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchLedgers.afterSearchLedgersCounter)
}

// SearchLedgersBeforeCounter returns a count of LedgerServiceHandlerMock.SearchLedgers invocations
func (mmSearchLedgers *LedgerServiceHandlerMock) SearchLedgersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchLedgers.beforeSearchLedgersCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.SearchLedgers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchLedgers *mLedgerServiceHandlerMockSearchLedgers) Calls() []*LedgerServiceHandlerMockSearchLedgersParams {
	mmSearchLedgers.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockSearchLedgersParams, len(mmSearchLedgers.callArgs))
	copy(argCopy, mmSearchLedgers.callArgs)

	mmSearchLedgers.mutex.RUnlock()

	return argCopy
}

// MinimockSearchLedgersDone returns true if the count of the SearchLedgers invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockSearchLedgersDone() bool {
	if m.SearchLedgersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchLedgersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchLedgersMock.invocationsDone()
}

// MinimockSearchLedgersInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockSearchLedgersInspect() {
	for _, e := range m.SearchLedgersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchLedgers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchLedgersCounter := mm_atomic.LoadUint64(&m.afterSearchLedgersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchLedgersMock.defaultExpectation != nil && afterSearchLedgersCounter < 1 {
		if m.SearchLedgersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchLedgers at\n%s", m.SearchLedgersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchLedgers at\n%s with params: %#v", m.SearchLedgersMock.defaultExpectation.expectationOrigins.origin, *m.SearchLedgersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchLedgers != nil && afterSearchLedgersCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchLedgers at\n%s", m.funcSearchLedgersOrigin)
	}

	if !m.SearchLedgersMock.invocationsDone() && afterSearchLedgersCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.SearchLedgers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchLedgersMock.expectedInvocations), m.SearchLedgersMock.expectedInvocationsOrigin, afterSearchLedgersCounter)
	}
}

type mLedgerServiceHandlerMockSearchTransactionEntries struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockSearchTransactionEntriesExpectation
	expectations       []*LedgerServiceHandlerMockSearchTransactionEntriesExpectation

	callArgs []*LedgerServiceHandlerMockSearchTransactionEntriesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockSearchTransactionEntriesExpectation specifies expectation struct of the LedgerServiceHandler.SearchTransactionEntries
type LedgerServiceHandlerMockSearchTransactionEntriesExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockSearchTransactionEntriesParams
	paramPtrs          *LedgerServiceHandlerMockSearchTransactionEntriesParamPtrs
	expectationOrigins LedgerServiceHandlerMockSearchTransactionEntriesExpectationOrigins
	results            *LedgerServiceHandlerMockSearchTransactionEntriesResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockSearchTransactionEntriesParams contains parameters of the LedgerServiceHandler.SearchTransactionEntries
type LedgerServiceHandlerMockSearchTransactionEntriesParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
	pp2 *connect.ServerStream[v11.TransactionEntry]
}

// LedgerServiceHandlerMockSearchTransactionEntriesParamPtrs contains pointers to parameters of the LedgerServiceHandler.SearchTransactionEntries
type LedgerServiceHandlerMockSearchTransactionEntriesParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
	pp2 **connect.ServerStream[v11.TransactionEntry]
}

// LedgerServiceHandlerMockSearchTransactionEntriesResults contains results of the LedgerServiceHandler.SearchTransactionEntries
type LedgerServiceHandlerMockSearchTransactionEntriesResults struct {
	err error
}

// LedgerServiceHandlerMockSearchTransactionEntriesOrigins contains origins of expectations of the LedgerServiceHandler.SearchTransactionEntries
type LedgerServiceHandlerMockSearchTransactionEntriesExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Optional() *mLedgerServiceHandlerMockSearchTransactionEntries {
	mmSearchTransactionEntries.optional = true
	return mmSearchTransactionEntries
}

// Expect sets up expected params for LedgerServiceHandler.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry]) *mLedgerServiceHandlerMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by ExpectParams functions")
	}

	mmSearchTransactionEntries.defaultExpectation.params = &LedgerServiceHandlerMockSearchTransactionEntriesParams{ctx, pp1, pp2}
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchTransactionEntries.expectations {
		if minimock.Equal(e.params, mmSearchTransactionEntries.defaultExpectation.params) {
			mmSearchTransactionEntries.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchTransactionEntries.defaultExpectation.params)
		}
	}

	return mmSearchTransactionEntries
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.params != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Expect")
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs == nil {
		mmSearchTransactionEntries.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchTransactionEntriesParamPtrs{}
	}
	mmSearchTransactionEntries.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchTransactionEntries
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceHandlerMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.params != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Expect")
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs == nil {
		mmSearchTransactionEntries.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchTransactionEntriesParamPtrs{}
	}
	mmSearchTransactionEntries.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchTransactionEntries
}

// ExpectPp2Param3 sets up expected param pp2 for LedgerServiceHandler.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) ExpectPp2Param3(pp2 *connect.ServerStream[v11.TransactionEntry]) *mLedgerServiceHandlerMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.params != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Expect")
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs == nil {
		mmSearchTransactionEntries.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchTransactionEntriesParamPtrs{}
	}
	mmSearchTransactionEntries.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearchTransactionEntries
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry])) *mLedgerServiceHandlerMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.inspectFuncSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.SearchTransactionEntries")
	}

	mmSearchTransactionEntries.mock.inspectFuncSearchTransactionEntries = f

	return mmSearchTransactionEntries
}

// Return sets up results that will be returned by LedgerServiceHandler.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Return(err error) *LedgerServiceHandlerMock {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionEntriesExpectation{mock: mmSearchTransactionEntries.mock}
	}
	mmSearchTransactionEntries.defaultExpectation.results = &LedgerServiceHandlerMockSearchTransactionEntriesResults{err}
	mmSearchTransactionEntries.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchTransactionEntries.mock
}

// Set uses given function f to mock the LedgerServiceHandler.SearchTransactionEntries method
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry]) (err error)) *LedgerServiceHandlerMock {
	if mmSearchTransactionEntries.defaultExpectation != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.SearchTransactionEntries method")
	}

	if len(mmSearchTransactionEntries.expectations) > 0 {
		mmSearchTransactionEntries.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.SearchTransactionEntries method")
	}

	mmSearchTransactionEntries.mock.funcSearchTransactionEntries = f
	mmSearchTransactionEntries.mock.funcSearchTransactionEntriesOrigin = minimock.CallerInfo(1)
	return mmSearchTransactionEntries.mock
}

// When sets expectation for the LedgerServiceHandler.SearchTransactionEntries which will trigger the result defined by the following
// Then helper
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry]) *LedgerServiceHandlerMockSearchTransactionEntriesExpectation {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactionEntries mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockSearchTransactionEntriesExpectation{
		mock:               mmSearchTransactionEntries.mock,
		params:             &LedgerServiceHandlerMockSearchTransactionEntriesParams{ctx, pp1, pp2},
		expectationOrigins: LedgerServiceHandlerMockSearchTransactionEntriesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchTransactionEntries.expectations = append(mmSearchTransactionEntries.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.SearchTransactionEntries return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockSearchTransactionEntriesExpectation) Then(err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockSearchTransactionEntriesResults{err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.SearchTransactionEntries should be invoked
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Times(n uint64) *mLedgerServiceHandlerMockSearchTransactionEntries {
	if n == 0 {
		mmSearchTransactionEntries.mock.t.Fatalf("Times of LedgerServiceHandlerMock.SearchTransactionEntries mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchTransactionEntries.expectedInvocations, n)
	mmSearchTransactionEntries.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchTransactionEntries
}

func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) invocationsDone() bool {
	if len(mmSearchTransactionEntries.expectations) == 0 && mmSearchTransactionEntries.defaultExpectation == nil && mmSearchTransactionEntries.mock.funcSearchTransactionEntries == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchTransactionEntries.mock.afterSearchTransactionEntriesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchTransactionEntries.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchTransactionEntries implements mm_ledgerv1connect.LedgerServiceHandler
func (mmSearchTransactionEntries *LedgerServiceHandlerMock) SearchTransactionEntries(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.TransactionEntry]) (err error) {
	mm_atomic.AddUint64(&mmSearchTransactionEntries.beforeSearchTransactionEntriesCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchTransactionEntries.afterSearchTransactionEntriesCounter, 1)

	mmSearchTransactionEntries.t.Helper()

	if mmSearchTransactionEntries.inspectFuncSearchTransactionEntries != nil {
		mmSearchTransactionEntries.inspectFuncSearchTransactionEntries(ctx, pp1, pp2)
	}

	mm_params := LedgerServiceHandlerMockSearchTransactionEntriesParams{ctx, pp1, pp2}

	// Record call args
	mmSearchTransactionEntries.SearchTransactionEntriesMock.mutex.Lock()
	mmSearchTransactionEntries.SearchTransactionEntriesMock.callArgs = append(mmSearchTransactionEntries.SearchTransactionEntriesMock.callArgs, &mm_params)
	mmSearchTransactionEntries.SearchTransactionEntriesMock.mutex.Unlock()

	for _, e := range mmSearchTransactionEntries.SearchTransactionEntriesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.params
		mm_want_ptrs := mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockSearchTransactionEntriesParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchTransactionEntries.t.Errorf("LedgerServiceHandlerMock.SearchTransactionEntries got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchTransactionEntries.t.Errorf("LedgerServiceHandlerMock.SearchTransactionEntries got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearchTransactionEntries.t.Errorf("LedgerServiceHandlerMock.SearchTransactionEntries got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchTransactionEntries.t.Errorf("LedgerServiceHandlerMock.SearchTransactionEntries got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchTransactionEntries.t.Fatal("No results are set for the LedgerServiceHandlerMock.SearchTransactionEntries")
		}
		return (*mm_results).err
	}
	if mmSearchTransactionEntries.funcSearchTransactionEntries != nil {
		return mmSearchTransactionEntries.funcSearchTransactionEntries(ctx, pp1, pp2)
	}
	mmSearchTransactionEntries.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.SearchTransactionEntries. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchTransactionEntriesAfterCounter returns a count of finished LedgerServiceHandlerMock.SearchTransactionEntries invocations
func (mmSearchTransactionEntries *LedgerServiceHandlerMock) SearchTransactionEntriesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactionEntries.afterSearchTransactionEntriesCounter)
}

// SearchTransactionEntriesBeforeCounter returns a count of LedgerServiceHandlerMock.SearchTransactionEntries invocations
func (mmSearchTransactionEntries *LedgerServiceHandlerMock) SearchTransactionEntriesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactionEntries.beforeSearchTransactionEntriesCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.SearchTransactionEntries.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchTransactionEntries *mLedgerServiceHandlerMockSearchTransactionEntries) Calls() []*LedgerServiceHandlerMockSearchTransactionEntriesParams {
	mmSearchTransactionEntries.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockSearchTransactionEntriesParams, len(mmSearchTransactionEntries.callArgs))
	copy(argCopy, mmSearchTransactionEntries.callArgs)

	mmSearchTransactionEntries.mutex.RUnlock()

	return argCopy
}

// MinimockSearchTransactionEntriesDone returns true if the count of the SearchTransactionEntries invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockSearchTransactionEntriesDone() bool {
	if m.SearchTransactionEntriesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchTransactionEntriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchTransactionEntriesMock.invocationsDone()
}

// MinimockSearchTransactionEntriesInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockSearchTransactionEntriesInspect() {
	for _, e := range m.SearchTransactionEntriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactionEntries at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchTransactionEntriesCounter := mm_atomic.LoadUint64(&m.afterSearchTransactionEntriesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchTransactionEntriesMock.defaultExpectation != nil && afterSearchTransactionEntriesCounter < 1 {
		if m.SearchTransactionEntriesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactionEntries at\n%s", m.SearchTransactionEntriesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactionEntries at\n%s with params: %#v", m.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.origin, *m.SearchTransactionEntriesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchTransactionEntries != nil && afterSearchTransactionEntriesCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactionEntries at\n%s", m.funcSearchTransactionEntriesOrigin)
	}

	if !m.SearchTransactionEntriesMock.invocationsDone() && afterSearchTransactionEntriesCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.SearchTransactionEntries at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchTransactionEntriesMock.expectedInvocations), m.SearchTransactionEntriesMock.expectedInvocationsOrigin, afterSearchTransactionEntriesCounter)
	}
}

type mLedgerServiceHandlerMockSearchTransactions struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockSearchTransactionsExpectation
	expectations       []*LedgerServiceHandlerMockSearchTransactionsExpectation

	callArgs []*LedgerServiceHandlerMockSearchTransactionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockSearchTransactionsExpectation specifies expectation struct of the LedgerServiceHandler.SearchTransactions
type LedgerServiceHandlerMockSearchTransactionsExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockSearchTransactionsParams
	paramPtrs          *LedgerServiceHandlerMockSearchTransactionsParamPtrs
	expectationOrigins LedgerServiceHandlerMockSearchTransactionsExpectationOrigins
	results            *LedgerServiceHandlerMockSearchTransactionsResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockSearchTransactionsParams contains parameters of the LedgerServiceHandler.SearchTransactions
type LedgerServiceHandlerMockSearchTransactionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
	pp2 *connect.ServerStream[v11.Transaction]
}

// LedgerServiceHandlerMockSearchTransactionsParamPtrs contains pointers to parameters of the LedgerServiceHandler.SearchTransactions
type LedgerServiceHandlerMockSearchTransactionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
	pp2 **connect.ServerStream[v11.Transaction]
}

// LedgerServiceHandlerMockSearchTransactionsResults contains results of the LedgerServiceHandler.SearchTransactions
type LedgerServiceHandlerMockSearchTransactionsResults struct {
	err error
}

// LedgerServiceHandlerMockSearchTransactionsOrigins contains origins of expectations of the LedgerServiceHandler.SearchTransactions
type LedgerServiceHandlerMockSearchTransactionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Optional() *mLedgerServiceHandlerMockSearchTransactions {
	mmSearchTransactions.optional = true
	return mmSearchTransactions
}

// Expect sets up expected params for LedgerServiceHandler.SearchTransactions
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction]) *mLedgerServiceHandlerMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by ExpectParams functions")
	}

	mmSearchTransactions.defaultExpectation.params = &LedgerServiceHandlerMockSearchTransactionsParams{ctx, pp1, pp2}
	mmSearchTransactions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchTransactions.expectations {
		if minimock.Equal(e.params, mmSearchTransactions.defaultExpectation.params) {
			mmSearchTransactions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchTransactions.defaultExpectation.params)
		}
	}

	return mmSearchTransactions
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.SearchTransactions
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.params != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Expect")
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs == nil {
		mmSearchTransactions.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchTransactionsParamPtrs{}
	}
	mmSearchTransactions.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchTransactions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchTransactions
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.SearchTransactions
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceHandlerMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.params != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Expect")
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs == nil {
		mmSearchTransactions.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchTransactionsParamPtrs{}
	}
	mmSearchTransactions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchTransactions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchTransactions
}

// ExpectPp2Param3 sets up expected param pp2 for LedgerServiceHandler.SearchTransactions
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) ExpectPp2Param3(pp2 *connect.ServerStream[v11.Transaction]) *mLedgerServiceHandlerMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.params != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Expect")
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs == nil {
		mmSearchTransactions.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockSearchTransactionsParamPtrs{}
	}
	mmSearchTransactions.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearchTransactions.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearchTransactions
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.SearchTransactions
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction])) *mLedgerServiceHandlerMockSearchTransactions {
	if mmSearchTransactions.mock.inspectFuncSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.SearchTransactions")
	}

	mmSearchTransactions.mock.inspectFuncSearchTransactions = f

	return mmSearchTransactions
}

// Return sets up results that will be returned by LedgerServiceHandler.SearchTransactions
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Return(err error) *LedgerServiceHandlerMock {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceHandlerMockSearchTransactionsExpectation{mock: mmSearchTransactions.mock}
	}
	mmSearchTransactions.defaultExpectation.results = &LedgerServiceHandlerMockSearchTransactionsResults{err}
	mmSearchTransactions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchTransactions.mock
}

// Set uses given function f to mock the LedgerServiceHandler.SearchTransactions method
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction]) (err error)) *LedgerServiceHandlerMock {
	if mmSearchTransactions.defaultExpectation != nil {
		mmSearchTransactions.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.SearchTransactions method")
	}

	if len(mmSearchTransactions.expectations) > 0 {
		mmSearchTransactions.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.SearchTransactions method")
	}

	mmSearchTransactions.mock.funcSearchTransactions = f
	mmSearchTransactions.mock.funcSearchTransactionsOrigin = minimock.CallerInfo(1)
	return mmSearchTransactions.mock
}

// When sets expectation for the LedgerServiceHandler.SearchTransactions which will trigger the result defined by the following
// Then helper
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction]) *LedgerServiceHandlerMockSearchTransactionsExpectation {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceHandlerMock.SearchTransactions mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockSearchTransactionsExpectation{
		mock:               mmSearchTransactions.mock,
		params:             &LedgerServiceHandlerMockSearchTransactionsParams{ctx, pp1, pp2},
		expectationOrigins: LedgerServiceHandlerMockSearchTransactionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchTransactions.expectations = append(mmSearchTransactions.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.SearchTransactions return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockSearchTransactionsExpectation) Then(err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockSearchTransactionsResults{err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.SearchTransactions should be invoked
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Times(n uint64) *mLedgerServiceHandlerMockSearchTransactions {
	if n == 0 {
		mmSearchTransactions.mock.t.Fatalf("Times of LedgerServiceHandlerMock.SearchTransactions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchTransactions.expectedInvocations, n)
	mmSearchTransactions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchTransactions
}

func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) invocationsDone() bool {
	if len(mmSearchTransactions.expectations) == 0 && mmSearchTransactions.defaultExpectation == nil && mmSearchTransactions.mock.funcSearchTransactions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchTransactions.mock.afterSearchTransactionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchTransactions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchTransactions implements mm_ledgerv1connect.LedgerServiceHandler
func (mmSearchTransactions *LedgerServiceHandlerMock) SearchTransactions(ctx context.Context, pp1 *connect.Request[v1.SearchRequest], pp2 *connect.ServerStream[v11.Transaction]) (err error) {
	mm_atomic.AddUint64(&mmSearchTransactions.beforeSearchTransactionsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchTransactions.afterSearchTransactionsCounter, 1)

	mmSearchTransactions.t.Helper()

	if mmSearchTransactions.inspectFuncSearchTransactions != nil {
		mmSearchTransactions.inspectFuncSearchTransactions(ctx, pp1, pp2)
	}

	mm_params := LedgerServiceHandlerMockSearchTransactionsParams{ctx, pp1, pp2}

	// Record call args
	mmSearchTransactions.SearchTransactionsMock.mutex.Lock()
	mmSearchTransactions.SearchTransactionsMock.callArgs = append(mmSearchTransactions.SearchTransactionsMock.callArgs, &mm_params)
	mmSearchTransactions.SearchTransactionsMock.mutex.Unlock()

	for _, e := range mmSearchTransactions.SearchTransactionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearchTransactions.SearchTransactionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchTransactions.SearchTransactionsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchTransactions.SearchTransactionsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchTransactions.SearchTransactionsMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockSearchTransactionsParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchTransactions.t.Errorf("LedgerServiceHandlerMock.SearchTransactions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchTransactions.t.Errorf("LedgerServiceHandlerMock.SearchTransactions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearchTransactions.t.Errorf("LedgerServiceHandlerMock.SearchTransactions got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchTransactions.t.Errorf("LedgerServiceHandlerMock.SearchTransactions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchTransactions.SearchTransactionsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchTransactions.t.Fatal("No results are set for the LedgerServiceHandlerMock.SearchTransactions")
		}
		return (*mm_results).err
	}
	if mmSearchTransactions.funcSearchTransactions != nil {
		return mmSearchTransactions.funcSearchTransactions(ctx, pp1, pp2)
	}
	mmSearchTransactions.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.SearchTransactions. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchTransactionsAfterCounter returns a count of finished LedgerServiceHandlerMock.SearchTransactions invocations
func (mmSearchTransactions *LedgerServiceHandlerMock) SearchTransactionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactions.afterSearchTransactionsCounter)
}

// SearchTransactionsBeforeCounter returns a count of LedgerServiceHandlerMock.SearchTransactions invocations
func (mmSearchTransactions *LedgerServiceHandlerMock) SearchTransactionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactions.beforeSearchTransactionsCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.SearchTransactions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchTransactions *mLedgerServiceHandlerMockSearchTransactions) Calls() []*LedgerServiceHandlerMockSearchTransactionsParams {
	mmSearchTransactions.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockSearchTransactionsParams, len(mmSearchTransactions.callArgs))
	copy(argCopy, mmSearchTransactions.callArgs)

	mmSearchTransactions.mutex.RUnlock()

	return argCopy
}

// MinimockSearchTransactionsDone returns true if the count of the SearchTransactions invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockSearchTransactionsDone() bool {
	if m.SearchTransactionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchTransactionsMock.invocationsDone()
}

// MinimockSearchTransactionsInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockSearchTransactionsInspect() {
	for _, e := range m.SearchTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchTransactionsCounter := mm_atomic.LoadUint64(&m.afterSearchTransactionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchTransactionsMock.defaultExpectation != nil && afterSearchTransactionsCounter < 1 {
		if m.SearchTransactionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactions at\n%s", m.SearchTransactionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactions at\n%s with params: %#v", m.SearchTransactionsMock.defaultExpectation.expectationOrigins.origin, *m.SearchTransactionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchTransactions != nil && afterSearchTransactionsCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.SearchTransactions at\n%s", m.funcSearchTransactionsOrigin)
	}

	if !m.SearchTransactionsMock.invocationsDone() && afterSearchTransactionsCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.SearchTransactions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchTransactionsMock.expectedInvocations), m.SearchTransactionsMock.expectedInvocationsOrigin, afterSearchTransactionsCounter)
	}
}

type mLedgerServiceHandlerMockUpdateAccount struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockUpdateAccountExpectation
	expectations       []*LedgerServiceHandlerMockUpdateAccountExpectation

	callArgs []*LedgerServiceHandlerMockUpdateAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockUpdateAccountExpectation specifies expectation struct of the LedgerServiceHandler.UpdateAccount
type LedgerServiceHandlerMockUpdateAccountExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockUpdateAccountParams
	paramPtrs          *LedgerServiceHandlerMockUpdateAccountParamPtrs
	expectationOrigins LedgerServiceHandlerMockUpdateAccountExpectationOrigins
	results            *LedgerServiceHandlerMockUpdateAccountResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockUpdateAccountParams contains parameters of the LedgerServiceHandler.UpdateAccount
type LedgerServiceHandlerMockUpdateAccountParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Account]
}

// LedgerServiceHandlerMockUpdateAccountParamPtrs contains pointers to parameters of the LedgerServiceHandler.UpdateAccount
type LedgerServiceHandlerMockUpdateAccountParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Account]
}

// LedgerServiceHandlerMockUpdateAccountResults contains results of the LedgerServiceHandler.UpdateAccount
type LedgerServiceHandlerMockUpdateAccountResults struct {
	pp2 *connect.Response[v11.Account]
	err error
}

// LedgerServiceHandlerMockUpdateAccountOrigins contains origins of expectations of the LedgerServiceHandler.UpdateAccount
type LedgerServiceHandlerMockUpdateAccountExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Optional() *mLedgerServiceHandlerMockUpdateAccount {
	mmUpdateAccount.optional = true
	return mmUpdateAccount
}

// Expect sets up expected params for LedgerServiceHandler.UpdateAccount
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Expect(ctx context.Context, pp1 *connect.Request[v11.Account]) *mLedgerServiceHandlerMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceHandlerMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by ExpectParams functions")
	}

	mmUpdateAccount.defaultExpectation.params = &LedgerServiceHandlerMockUpdateAccountParams{ctx, pp1}
	mmUpdateAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateAccount.expectations {
		if minimock.Equal(e.params, mmUpdateAccount.defaultExpectation.params) {
			mmUpdateAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAccount.defaultExpectation.params)
		}
	}

	return mmUpdateAccount
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.UpdateAccount
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceHandlerMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.params != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Expect")
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs == nil {
		mmUpdateAccount.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockUpdateAccountParamPtrs{}
	}
	mmUpdateAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateAccount
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.UpdateAccount
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) ExpectPp1Param2(pp1 *connect.Request[v11.Account]) *mLedgerServiceHandlerMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceHandlerMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.params != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Expect")
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs == nil {
		mmUpdateAccount.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockUpdateAccountParamPtrs{}
	}
	mmUpdateAccount.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateAccount.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateAccount
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.UpdateAccount
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Account])) *mLedgerServiceHandlerMockUpdateAccount {
	if mmUpdateAccount.mock.inspectFuncUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.UpdateAccount")
	}

	mmUpdateAccount.mock.inspectFuncUpdateAccount = f

	return mmUpdateAccount
}

// Return sets up results that will be returned by LedgerServiceHandler.UpdateAccount
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Return(pp2 *connect.Response[v11.Account], err error) *LedgerServiceHandlerMock {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceHandlerMockUpdateAccountExpectation{mock: mmUpdateAccount.mock}
	}
	mmUpdateAccount.defaultExpectation.results = &LedgerServiceHandlerMockUpdateAccountResults{pp2, err}
	mmUpdateAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount.mock
}

// Set uses given function f to mock the LedgerServiceHandler.UpdateAccount method
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Account]) (pp2 *connect.Response[v11.Account], err error)) *LedgerServiceHandlerMock {
	if mmUpdateAccount.defaultExpectation != nil {
		mmUpdateAccount.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.UpdateAccount method")
	}

	if len(mmUpdateAccount.expectations) > 0 {
		mmUpdateAccount.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.UpdateAccount method")
	}

	mmUpdateAccount.mock.funcUpdateAccount = f
	mmUpdateAccount.mock.funcUpdateAccountOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount.mock
}

// When sets expectation for the LedgerServiceHandler.UpdateAccount which will trigger the result defined by the following
// Then helper
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) When(ctx context.Context, pp1 *connect.Request[v11.Account]) *LedgerServiceHandlerMockUpdateAccountExpectation {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateAccount mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockUpdateAccountExpectation{
		mock:               mmUpdateAccount.mock,
		params:             &LedgerServiceHandlerMockUpdateAccountParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockUpdateAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateAccount.expectations = append(mmUpdateAccount.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.UpdateAccount return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockUpdateAccountExpectation) Then(pp2 *connect.Response[v11.Account], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockUpdateAccountResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.UpdateAccount should be invoked
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Times(n uint64) *mLedgerServiceHandlerMockUpdateAccount {
	if n == 0 {
		mmUpdateAccount.mock.t.Fatalf("Times of LedgerServiceHandlerMock.UpdateAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateAccount.expectedInvocations, n)
	mmUpdateAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount
}

func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) invocationsDone() bool {
	if len(mmUpdateAccount.expectations) == 0 && mmUpdateAccount.defaultExpectation == nil && mmUpdateAccount.mock.funcUpdateAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateAccount.mock.afterUpdateAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateAccount implements mm_ledgerv1connect.LedgerServiceHandler
func (mmUpdateAccount *LedgerServiceHandlerMock) UpdateAccount(ctx context.Context, pp1 *connect.Request[v11.Account]) (pp2 *connect.Response[v11.Account], err error) {
	mm_atomic.AddUint64(&mmUpdateAccount.beforeUpdateAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAccount.afterUpdateAccountCounter, 1)

	mmUpdateAccount.t.Helper()

	if mmUpdateAccount.inspectFuncUpdateAccount != nil {
		mmUpdateAccount.inspectFuncUpdateAccount(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockUpdateAccountParams{ctx, pp1}

	// Record call args
	mmUpdateAccount.UpdateAccountMock.mutex.Lock()
	mmUpdateAccount.UpdateAccountMock.callArgs = append(mmUpdateAccount.UpdateAccountMock.callArgs, &mm_params)
	mmUpdateAccount.UpdateAccountMock.mutex.Unlock()

	for _, e := range mmUpdateAccount.UpdateAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateAccount.UpdateAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAccount.UpdateAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAccount.UpdateAccountMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateAccount.UpdateAccountMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockUpdateAccountParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateAccount.t.Errorf("LedgerServiceHandlerMock.UpdateAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateAccount.t.Errorf("LedgerServiceHandlerMock.UpdateAccount got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAccount.t.Errorf("LedgerServiceHandlerMock.UpdateAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAccount.UpdateAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAccount.t.Fatal("No results are set for the LedgerServiceHandlerMock.UpdateAccount")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateAccount.funcUpdateAccount != nil {
		return mmUpdateAccount.funcUpdateAccount(ctx, pp1)
	}
	mmUpdateAccount.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.UpdateAccount. %v %v", ctx, pp1)
	return
}

// UpdateAccountAfterCounter returns a count of finished LedgerServiceHandlerMock.UpdateAccount invocations
func (mmUpdateAccount *LedgerServiceHandlerMock) UpdateAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccount.afterUpdateAccountCounter)
}

// UpdateAccountBeforeCounter returns a count of LedgerServiceHandlerMock.UpdateAccount invocations
func (mmUpdateAccount *LedgerServiceHandlerMock) UpdateAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccount.beforeUpdateAccountCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.UpdateAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAccount *mLedgerServiceHandlerMockUpdateAccount) Calls() []*LedgerServiceHandlerMockUpdateAccountParams {
	mmUpdateAccount.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockUpdateAccountParams, len(mmUpdateAccount.callArgs))
	copy(argCopy, mmUpdateAccount.callArgs)

	mmUpdateAccount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAccountDone returns true if the count of the UpdateAccount invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockUpdateAccountDone() bool {
	if m.UpdateAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateAccountMock.invocationsDone()
}

// MinimockUpdateAccountInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockUpdateAccountInspect() {
	for _, e := range m.UpdateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateAccountCounter := mm_atomic.LoadUint64(&m.afterUpdateAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccountMock.defaultExpectation != nil && afterUpdateAccountCounter < 1 {
		if m.UpdateAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateAccount at\n%s", m.UpdateAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateAccount at\n%s with params: %#v", m.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *m.UpdateAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccount != nil && afterUpdateAccountCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateAccount at\n%s", m.funcUpdateAccountOrigin)
	}

	if !m.UpdateAccountMock.invocationsDone() && afterUpdateAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.UpdateAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateAccountMock.expectedInvocations), m.UpdateAccountMock.expectedInvocationsOrigin, afterUpdateAccountCounter)
	}
}

type mLedgerServiceHandlerMockUpdateLedger struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockUpdateLedgerExpectation
	expectations       []*LedgerServiceHandlerMockUpdateLedgerExpectation

	callArgs []*LedgerServiceHandlerMockUpdateLedgerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockUpdateLedgerExpectation specifies expectation struct of the LedgerServiceHandler.UpdateLedger
type LedgerServiceHandlerMockUpdateLedgerExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockUpdateLedgerParams
	paramPtrs          *LedgerServiceHandlerMockUpdateLedgerParamPtrs
	expectationOrigins LedgerServiceHandlerMockUpdateLedgerExpectationOrigins
	results            *LedgerServiceHandlerMockUpdateLedgerResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockUpdateLedgerParams contains parameters of the LedgerServiceHandler.UpdateLedger
type LedgerServiceHandlerMockUpdateLedgerParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Ledger]
}

// LedgerServiceHandlerMockUpdateLedgerParamPtrs contains pointers to parameters of the LedgerServiceHandler.UpdateLedger
type LedgerServiceHandlerMockUpdateLedgerParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Ledger]
}

// LedgerServiceHandlerMockUpdateLedgerResults contains results of the LedgerServiceHandler.UpdateLedger
type LedgerServiceHandlerMockUpdateLedgerResults struct {
	pp2 *connect.Response[v11.Ledger]
	err error
}

// LedgerServiceHandlerMockUpdateLedgerOrigins contains origins of expectations of the LedgerServiceHandler.UpdateLedger
type LedgerServiceHandlerMockUpdateLedgerExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Optional() *mLedgerServiceHandlerMockUpdateLedger {
	mmUpdateLedger.optional = true
	return mmUpdateLedger
}

// Expect sets up expected params for LedgerServiceHandler.UpdateLedger
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Expect(ctx context.Context, pp1 *connect.Request[v11.Ledger]) *mLedgerServiceHandlerMockUpdateLedger {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceHandlerMockUpdateLedgerExpectation{}
	}

	if mmUpdateLedger.defaultExpectation.paramPtrs != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by ExpectParams functions")
	}

	mmUpdateLedger.defaultExpectation.params = &LedgerServiceHandlerMockUpdateLedgerParams{ctx, pp1}
	mmUpdateLedger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateLedger.expectations {
		if minimock.Equal(e.params, mmUpdateLedger.defaultExpectation.params) {
			mmUpdateLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateLedger.defaultExpectation.params)
		}
	}

	return mmUpdateLedger
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.UpdateLedger
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockUpdateLedger {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceHandlerMockUpdateLedgerExpectation{}
	}

	if mmUpdateLedger.defaultExpectation.params != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Expect")
	}

	if mmUpdateLedger.defaultExpectation.paramPtrs == nil {
		mmUpdateLedger.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockUpdateLedgerParamPtrs{}
	}
	mmUpdateLedger.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateLedger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateLedger
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.UpdateLedger
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) ExpectPp1Param2(pp1 *connect.Request[v11.Ledger]) *mLedgerServiceHandlerMockUpdateLedger {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceHandlerMockUpdateLedgerExpectation{}
	}

	if mmUpdateLedger.defaultExpectation.params != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Expect")
	}

	if mmUpdateLedger.defaultExpectation.paramPtrs == nil {
		mmUpdateLedger.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockUpdateLedgerParamPtrs{}
	}
	mmUpdateLedger.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateLedger.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateLedger
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.UpdateLedger
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Ledger])) *mLedgerServiceHandlerMockUpdateLedger {
	if mmUpdateLedger.mock.inspectFuncUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.UpdateLedger")
	}

	mmUpdateLedger.mock.inspectFuncUpdateLedger = f

	return mmUpdateLedger
}

// Return sets up results that will be returned by LedgerServiceHandler.UpdateLedger
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Return(pp2 *connect.Response[v11.Ledger], err error) *LedgerServiceHandlerMock {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceHandlerMockUpdateLedgerExpectation{mock: mmUpdateLedger.mock}
	}
	mmUpdateLedger.defaultExpectation.results = &LedgerServiceHandlerMockUpdateLedgerResults{pp2, err}
	mmUpdateLedger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateLedger.mock
}

// Set uses given function f to mock the LedgerServiceHandler.UpdateLedger method
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Ledger]) (pp2 *connect.Response[v11.Ledger], err error)) *LedgerServiceHandlerMock {
	if mmUpdateLedger.defaultExpectation != nil {
		mmUpdateLedger.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.UpdateLedger method")
	}

	if len(mmUpdateLedger.expectations) > 0 {
		mmUpdateLedger.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.UpdateLedger method")
	}

	mmUpdateLedger.mock.funcUpdateLedger = f
	mmUpdateLedger.mock.funcUpdateLedgerOrigin = minimock.CallerInfo(1)
	return mmUpdateLedger.mock
}

// When sets expectation for the LedgerServiceHandler.UpdateLedger which will trigger the result defined by the following
// Then helper
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) When(ctx context.Context, pp1 *connect.Request[v11.Ledger]) *LedgerServiceHandlerMockUpdateLedgerExpectation {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateLedger mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockUpdateLedgerExpectation{
		mock:               mmUpdateLedger.mock,
		params:             &LedgerServiceHandlerMockUpdateLedgerParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockUpdateLedgerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateLedger.expectations = append(mmUpdateLedger.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.UpdateLedger return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockUpdateLedgerExpectation) Then(pp2 *connect.Response[v11.Ledger], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockUpdateLedgerResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.UpdateLedger should be invoked
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Times(n uint64) *mLedgerServiceHandlerMockUpdateLedger {
	if n == 0 {
		mmUpdateLedger.mock.t.Fatalf("Times of LedgerServiceHandlerMock.UpdateLedger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateLedger.expectedInvocations, n)
	mmUpdateLedger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateLedger
}

func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) invocationsDone() bool {
	if len(mmUpdateLedger.expectations) == 0 && mmUpdateLedger.defaultExpectation == nil && mmUpdateLedger.mock.funcUpdateLedger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateLedger.mock.afterUpdateLedgerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateLedger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateLedger implements mm_ledgerv1connect.LedgerServiceHandler
func (mmUpdateLedger *LedgerServiceHandlerMock) UpdateLedger(ctx context.Context, pp1 *connect.Request[v11.Ledger]) (pp2 *connect.Response[v11.Ledger], err error) {
	mm_atomic.AddUint64(&mmUpdateLedger.beforeUpdateLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateLedger.afterUpdateLedgerCounter, 1)

	mmUpdateLedger.t.Helper()

	if mmUpdateLedger.inspectFuncUpdateLedger != nil {
		mmUpdateLedger.inspectFuncUpdateLedger(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockUpdateLedgerParams{ctx, pp1}

	// Record call args
	mmUpdateLedger.UpdateLedgerMock.mutex.Lock()
	mmUpdateLedger.UpdateLedgerMock.callArgs = append(mmUpdateLedger.UpdateLedgerMock.callArgs, &mm_params)
	mmUpdateLedger.UpdateLedgerMock.mutex.Unlock()

	for _, e := range mmUpdateLedger.UpdateLedgerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateLedger.UpdateLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateLedger.UpdateLedgerMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateLedger.UpdateLedgerMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateLedger.UpdateLedgerMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockUpdateLedgerParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateLedger.t.Errorf("LedgerServiceHandlerMock.UpdateLedger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLedger.UpdateLedgerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateLedger.t.Errorf("LedgerServiceHandlerMock.UpdateLedger got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLedger.UpdateLedgerMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateLedger.t.Errorf("LedgerServiceHandlerMock.UpdateLedger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateLedger.UpdateLedgerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateLedger.UpdateLedgerMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateLedger.t.Fatal("No results are set for the LedgerServiceHandlerMock.UpdateLedger")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateLedger.funcUpdateLedger != nil {
		return mmUpdateLedger.funcUpdateLedger(ctx, pp1)
	}
	mmUpdateLedger.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.UpdateLedger. %v %v", ctx, pp1)
	return
}

// UpdateLedgerAfterCounter returns a count of finished LedgerServiceHandlerMock.UpdateLedger invocations
func (mmUpdateLedger *LedgerServiceHandlerMock) UpdateLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLedger.afterUpdateLedgerCounter)
}

// UpdateLedgerBeforeCounter returns a count of LedgerServiceHandlerMock.UpdateLedger invocations
func (mmUpdateLedger *LedgerServiceHandlerMock) UpdateLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLedger.beforeUpdateLedgerCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.UpdateLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateLedger *mLedgerServiceHandlerMockUpdateLedger) Calls() []*LedgerServiceHandlerMockUpdateLedgerParams {
	mmUpdateLedger.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockUpdateLedgerParams, len(mmUpdateLedger.callArgs))
	copy(argCopy, mmUpdateLedger.callArgs)

	mmUpdateLedger.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateLedgerDone returns true if the count of the UpdateLedger invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockUpdateLedgerDone() bool {
	if m.UpdateLedgerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateLedgerMock.invocationsDone()
}

// MinimockUpdateLedgerInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockUpdateLedgerInspect() {
	for _, e := range m.UpdateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateLedger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateLedgerCounter := mm_atomic.LoadUint64(&m.afterUpdateLedgerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateLedgerMock.defaultExpectation != nil && afterUpdateLedgerCounter < 1 {
		if m.UpdateLedgerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateLedger at\n%s", m.UpdateLedgerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateLedger at\n%s with params: %#v", m.UpdateLedgerMock.defaultExpectation.expectationOrigins.origin, *m.UpdateLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateLedger != nil && afterUpdateLedgerCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateLedger at\n%s", m.funcUpdateLedgerOrigin)
	}

	if !m.UpdateLedgerMock.invocationsDone() && afterUpdateLedgerCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.UpdateLedger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateLedgerMock.expectedInvocations), m.UpdateLedgerMock.expectedInvocationsOrigin, afterUpdateLedgerCounter)
	}
}

type mLedgerServiceHandlerMockUpdateTransaction struct {
	optional           bool
	mock               *LedgerServiceHandlerMock
	defaultExpectation *LedgerServiceHandlerMockUpdateTransactionExpectation
	expectations       []*LedgerServiceHandlerMockUpdateTransactionExpectation

	callArgs []*LedgerServiceHandlerMockUpdateTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceHandlerMockUpdateTransactionExpectation specifies expectation struct of the LedgerServiceHandler.UpdateTransaction
type LedgerServiceHandlerMockUpdateTransactionExpectation struct {
	mock               *LedgerServiceHandlerMock
	params             *LedgerServiceHandlerMockUpdateTransactionParams
	paramPtrs          *LedgerServiceHandlerMockUpdateTransactionParamPtrs
	expectationOrigins LedgerServiceHandlerMockUpdateTransactionExpectationOrigins
	results            *LedgerServiceHandlerMockUpdateTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceHandlerMockUpdateTransactionParams contains parameters of the LedgerServiceHandler.UpdateTransaction
type LedgerServiceHandlerMockUpdateTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.Transaction]
}

// LedgerServiceHandlerMockUpdateTransactionParamPtrs contains pointers to parameters of the LedgerServiceHandler.UpdateTransaction
type LedgerServiceHandlerMockUpdateTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.Transaction]
}

// LedgerServiceHandlerMockUpdateTransactionResults contains results of the LedgerServiceHandler.UpdateTransaction
type LedgerServiceHandlerMockUpdateTransactionResults struct {
	pp2 *connect.Response[v11.Transaction]
	err error
}

// LedgerServiceHandlerMockUpdateTransactionOrigins contains origins of expectations of the LedgerServiceHandler.UpdateTransaction
type LedgerServiceHandlerMockUpdateTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Optional() *mLedgerServiceHandlerMockUpdateTransaction {
	mmUpdateTransaction.optional = true
	return mmUpdateTransaction
}

// Expect sets up expected params for LedgerServiceHandler.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Expect(ctx context.Context, pp1 *connect.Request[v11.Transaction]) *mLedgerServiceHandlerMockUpdateTransaction {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceHandlerMockUpdateTransactionExpectation{}
	}

	if mmUpdateTransaction.defaultExpectation.paramPtrs != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by ExpectParams functions")
	}

	mmUpdateTransaction.defaultExpectation.params = &LedgerServiceHandlerMockUpdateTransactionParams{ctx, pp1}
	mmUpdateTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTransaction.expectations {
		if minimock.Equal(e.params, mmUpdateTransaction.defaultExpectation.params) {
			mmUpdateTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTransaction.defaultExpectation.params)
		}
	}

	return mmUpdateTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceHandler.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) ExpectCtxParam1(ctx context.Context) *mLedgerServiceHandlerMockUpdateTransaction {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceHandlerMockUpdateTransactionExpectation{}
	}

	if mmUpdateTransaction.defaultExpectation.params != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Expect")
	}

	if mmUpdateTransaction.defaultExpectation.paramPtrs == nil {
		mmUpdateTransaction.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockUpdateTransactionParamPtrs{}
	}
	mmUpdateTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceHandler.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) ExpectPp1Param2(pp1 *connect.Request[v11.Transaction]) *mLedgerServiceHandlerMockUpdateTransaction {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceHandlerMockUpdateTransactionExpectation{}
	}

	if mmUpdateTransaction.defaultExpectation.params != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Expect")
	}

	if mmUpdateTransaction.defaultExpectation.paramPtrs == nil {
		mmUpdateTransaction.defaultExpectation.paramPtrs = &LedgerServiceHandlerMockUpdateTransactionParamPtrs{}
	}
	mmUpdateTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateTransaction
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceHandler.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.Transaction])) *mLedgerServiceHandlerMockUpdateTransaction {
	if mmUpdateTransaction.mock.inspectFuncUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("Inspect function is already set for LedgerServiceHandlerMock.UpdateTransaction")
	}

	mmUpdateTransaction.mock.inspectFuncUpdateTransaction = f

	return mmUpdateTransaction
}

// Return sets up results that will be returned by LedgerServiceHandler.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Return(pp2 *connect.Response[v11.Transaction], err error) *LedgerServiceHandlerMock {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceHandlerMockUpdateTransactionExpectation{mock: mmUpdateTransaction.mock}
	}
	mmUpdateTransaction.defaultExpectation.results = &LedgerServiceHandlerMockUpdateTransactionResults{pp2, err}
	mmUpdateTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTransaction.mock
}

// Set uses given function f to mock the LedgerServiceHandler.UpdateTransaction method
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error)) *LedgerServiceHandlerMock {
	if mmUpdateTransaction.defaultExpectation != nil {
		mmUpdateTransaction.mock.t.Fatalf("Default expectation is already set for the LedgerServiceHandler.UpdateTransaction method")
	}

	if len(mmUpdateTransaction.expectations) > 0 {
		mmUpdateTransaction.mock.t.Fatalf("Some expectations are already set for the LedgerServiceHandler.UpdateTransaction method")
	}

	mmUpdateTransaction.mock.funcUpdateTransaction = f
	mmUpdateTransaction.mock.funcUpdateTransactionOrigin = minimock.CallerInfo(1)
	return mmUpdateTransaction.mock
}

// When sets expectation for the LedgerServiceHandler.UpdateTransaction which will trigger the result defined by the following
// Then helper
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) When(ctx context.Context, pp1 *connect.Request[v11.Transaction]) *LedgerServiceHandlerMockUpdateTransactionExpectation {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceHandlerMock.UpdateTransaction mock is already set by Set")
	}

	expectation := &LedgerServiceHandlerMockUpdateTransactionExpectation{
		mock:               mmUpdateTransaction.mock,
		params:             &LedgerServiceHandlerMockUpdateTransactionParams{ctx, pp1},
		expectationOrigins: LedgerServiceHandlerMockUpdateTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTransaction.expectations = append(mmUpdateTransaction.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceHandler.UpdateTransaction return parameters for the expectation previously defined by the When method
func (e *LedgerServiceHandlerMockUpdateTransactionExpectation) Then(pp2 *connect.Response[v11.Transaction], err error) *LedgerServiceHandlerMock {
	e.results = &LedgerServiceHandlerMockUpdateTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceHandler.UpdateTransaction should be invoked
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Times(n uint64) *mLedgerServiceHandlerMockUpdateTransaction {
	if n == 0 {
		mmUpdateTransaction.mock.t.Fatalf("Times of LedgerServiceHandlerMock.UpdateTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTransaction.expectedInvocations, n)
	mmUpdateTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTransaction
}

func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) invocationsDone() bool {
	if len(mmUpdateTransaction.expectations) == 0 && mmUpdateTransaction.defaultExpectation == nil && mmUpdateTransaction.mock.funcUpdateTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTransaction.mock.afterUpdateTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTransaction implements mm_ledgerv1connect.LedgerServiceHandler
func (mmUpdateTransaction *LedgerServiceHandlerMock) UpdateTransaction(ctx context.Context, pp1 *connect.Request[v11.Transaction]) (pp2 *connect.Response[v11.Transaction], err error) {
	mm_atomic.AddUint64(&mmUpdateTransaction.beforeUpdateTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTransaction.afterUpdateTransactionCounter, 1)

	mmUpdateTransaction.t.Helper()

	if mmUpdateTransaction.inspectFuncUpdateTransaction != nil {
		mmUpdateTransaction.inspectFuncUpdateTransaction(ctx, pp1)
	}

	mm_params := LedgerServiceHandlerMockUpdateTransactionParams{ctx, pp1}

	// Record call args
	mmUpdateTransaction.UpdateTransactionMock.mutex.Lock()
	mmUpdateTransaction.UpdateTransactionMock.callArgs = append(mmUpdateTransaction.UpdateTransactionMock.callArgs, &mm_params)
	mmUpdateTransaction.UpdateTransactionMock.mutex.Unlock()

	for _, e := range mmUpdateTransaction.UpdateTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateTransaction.UpdateTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceHandlerMockUpdateTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTransaction.t.Errorf("LedgerServiceHandlerMock.UpdateTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateTransaction.t.Errorf("LedgerServiceHandlerMock.UpdateTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTransaction.t.Errorf("LedgerServiceHandlerMock.UpdateTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTransaction.t.Fatal("No results are set for the LedgerServiceHandlerMock.UpdateTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateTransaction.funcUpdateTransaction != nil {
		return mmUpdateTransaction.funcUpdateTransaction(ctx, pp1)
	}
	mmUpdateTransaction.t.Fatalf("Unexpected call to LedgerServiceHandlerMock.UpdateTransaction. %v %v", ctx, pp1)
	return
}

// UpdateTransactionAfterCounter returns a count of finished LedgerServiceHandlerMock.UpdateTransaction invocations
func (mmUpdateTransaction *LedgerServiceHandlerMock) UpdateTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTransaction.afterUpdateTransactionCounter)
}

// UpdateTransactionBeforeCounter returns a count of LedgerServiceHandlerMock.UpdateTransaction invocations
func (mmUpdateTransaction *LedgerServiceHandlerMock) UpdateTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTransaction.beforeUpdateTransactionCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceHandlerMock.UpdateTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTransaction *mLedgerServiceHandlerMockUpdateTransaction) Calls() []*LedgerServiceHandlerMockUpdateTransactionParams {
	mmUpdateTransaction.mutex.RLock()

	argCopy := make([]*LedgerServiceHandlerMockUpdateTransactionParams, len(mmUpdateTransaction.callArgs))
	copy(argCopy, mmUpdateTransaction.callArgs)

	mmUpdateTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTransactionDone returns true if the count of the UpdateTransaction invocations corresponds
// the number of defined expectations
func (m *LedgerServiceHandlerMock) MinimockUpdateTransactionDone() bool {
	if m.UpdateTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTransactionMock.invocationsDone()
}

// MinimockUpdateTransactionInspect logs each unmet expectation
func (m *LedgerServiceHandlerMock) MinimockUpdateTransactionInspect() {
	for _, e := range m.UpdateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTransactionCounter := mm_atomic.LoadUint64(&m.afterUpdateTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTransactionMock.defaultExpectation != nil && afterUpdateTransactionCounter < 1 {
		if m.UpdateTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateTransaction at\n%s", m.UpdateTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateTransaction at\n%s with params: %#v", m.UpdateTransactionMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTransaction != nil && afterUpdateTransactionCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceHandlerMock.UpdateTransaction at\n%s", m.funcUpdateTransactionOrigin)
	}

	if !m.UpdateTransactionMock.invocationsDone() && afterUpdateTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceHandlerMock.UpdateTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTransactionMock.expectedInvocations), m.UpdateTransactionMock.expectedInvocationsOrigin, afterUpdateTransactionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LedgerServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAccountInspect()

			m.MinimockCreateLedgerInspect()

			m.MinimockCreateTransactionInspect()

			m.MinimockReverseTransactionInspect()

			m.MinimockSearchAccountsInspect()

			m.MinimockSearchLedgersInspect()

			m.MinimockSearchTransactionEntriesInspect()

			m.MinimockSearchTransactionsInspect()

			m.MinimockUpdateAccountInspect()

			m.MinimockUpdateLedgerInspect()

			m.MinimockUpdateTransactionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LedgerServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LedgerServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAccountDone() &&
		m.MinimockCreateLedgerDone() &&
		m.MinimockCreateTransactionDone() &&
		m.MinimockReverseTransactionDone() &&
		m.MinimockSearchAccountsDone() &&
		m.MinimockSearchLedgersDone() &&
		m.MinimockSearchTransactionEntriesDone() &&
		m.MinimockSearchTransactionsDone() &&
		m.MinimockUpdateAccountDone() &&
		m.MinimockUpdateLedgerDone() &&
		m.MinimockUpdateTransactionDone()
}
