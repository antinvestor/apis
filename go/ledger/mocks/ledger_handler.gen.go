// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/ledger/connectrpc/go/ledger/v1/ledgerv1connect.LedgerServiceClient -o ledger_handler.gen.go -n LedgerServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/common/protocolbuffers/go/common/v1"
	v11 "buf.build/gen/go/antinvestor/ledger/protocolbuffers/go/ledger/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// LedgerServiceClientMock implements mm_ledgerv1connect.LedgerServiceClient
type LedgerServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAccount          func(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest]) (pp2 *connect.Response[v11.CreateAccountResponse], err error)
	funcCreateAccountOrigin    string
	inspectFuncCreateAccount   func(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest])
	afterCreateAccountCounter  uint64
	beforeCreateAccountCounter uint64
	CreateAccountMock          mLedgerServiceClientMockCreateAccount

	funcCreateLedger          func(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest]) (pp2 *connect.Response[v11.CreateLedgerResponse], err error)
	funcCreateLedgerOrigin    string
	inspectFuncCreateLedger   func(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest])
	afterCreateLedgerCounter  uint64
	beforeCreateLedgerCounter uint64
	CreateLedgerMock          mLedgerServiceClientMockCreateLedger

	funcCreateTransaction          func(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest]) (pp2 *connect.Response[v11.CreateTransactionResponse], err error)
	funcCreateTransactionOrigin    string
	inspectFuncCreateTransaction   func(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest])
	afterCreateTransactionCounter  uint64
	beforeCreateTransactionCounter uint64
	CreateTransactionMock          mLedgerServiceClientMockCreateTransaction

	funcReverseTransaction          func(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest]) (pp2 *connect.Response[v11.ReverseTransactionResponse], err error)
	funcReverseTransactionOrigin    string
	inspectFuncReverseTransaction   func(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest])
	afterReverseTransactionCounter  uint64
	beforeReverseTransactionCounter uint64
	ReverseTransactionMock          mLedgerServiceClientMockReverseTransaction

	funcSearchAccounts          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchAccountsResponse], err error)
	funcSearchAccountsOrigin    string
	inspectFuncSearchAccounts   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])
	afterSearchAccountsCounter  uint64
	beforeSearchAccountsCounter uint64
	SearchAccountsMock          mLedgerServiceClientMockSearchAccounts

	funcSearchLedgers          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchLedgersResponse], err error)
	funcSearchLedgersOrigin    string
	inspectFuncSearchLedgers   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])
	afterSearchLedgersCounter  uint64
	beforeSearchLedgersCounter uint64
	SearchLedgersMock          mLedgerServiceClientMockSearchLedgers

	funcSearchTransactionEntries          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchTransactionEntriesResponse], err error)
	funcSearchTransactionEntriesOrigin    string
	inspectFuncSearchTransactionEntries   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])
	afterSearchTransactionEntriesCounter  uint64
	beforeSearchTransactionEntriesCounter uint64
	SearchTransactionEntriesMock          mLedgerServiceClientMockSearchTransactionEntries

	funcSearchTransactions          func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchTransactionsResponse], err error)
	funcSearchTransactionsOrigin    string
	inspectFuncSearchTransactions   func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])
	afterSearchTransactionsCounter  uint64
	beforeSearchTransactionsCounter uint64
	SearchTransactionsMock          mLedgerServiceClientMockSearchTransactions

	funcUpdateAccount          func(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest]) (pp2 *connect.Response[v11.UpdateAccountResponse], err error)
	funcUpdateAccountOrigin    string
	inspectFuncUpdateAccount   func(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest])
	afterUpdateAccountCounter  uint64
	beforeUpdateAccountCounter uint64
	UpdateAccountMock          mLedgerServiceClientMockUpdateAccount

	funcUpdateLedger          func(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest]) (pp2 *connect.Response[v11.UpdateLedgerResponse], err error)
	funcUpdateLedgerOrigin    string
	inspectFuncUpdateLedger   func(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest])
	afterUpdateLedgerCounter  uint64
	beforeUpdateLedgerCounter uint64
	UpdateLedgerMock          mLedgerServiceClientMockUpdateLedger

	funcUpdateTransaction          func(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest]) (pp2 *connect.Response[v11.UpdateTransactionResponse], err error)
	funcUpdateTransactionOrigin    string
	inspectFuncUpdateTransaction   func(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest])
	afterUpdateTransactionCounter  uint64
	beforeUpdateTransactionCounter uint64
	UpdateTransactionMock          mLedgerServiceClientMockUpdateTransaction
}

// NewLedgerServiceClientMock returns a mock for mm_ledgerv1connect.LedgerServiceClient
func NewLedgerServiceClientMock(t minimock.Tester) *LedgerServiceClientMock {
	m := &LedgerServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAccountMock = mLedgerServiceClientMockCreateAccount{mock: m}
	m.CreateAccountMock.callArgs = []*LedgerServiceClientMockCreateAccountParams{}

	m.CreateLedgerMock = mLedgerServiceClientMockCreateLedger{mock: m}
	m.CreateLedgerMock.callArgs = []*LedgerServiceClientMockCreateLedgerParams{}

	m.CreateTransactionMock = mLedgerServiceClientMockCreateTransaction{mock: m}
	m.CreateTransactionMock.callArgs = []*LedgerServiceClientMockCreateTransactionParams{}

	m.ReverseTransactionMock = mLedgerServiceClientMockReverseTransaction{mock: m}
	m.ReverseTransactionMock.callArgs = []*LedgerServiceClientMockReverseTransactionParams{}

	m.SearchAccountsMock = mLedgerServiceClientMockSearchAccounts{mock: m}
	m.SearchAccountsMock.callArgs = []*LedgerServiceClientMockSearchAccountsParams{}

	m.SearchLedgersMock = mLedgerServiceClientMockSearchLedgers{mock: m}
	m.SearchLedgersMock.callArgs = []*LedgerServiceClientMockSearchLedgersParams{}

	m.SearchTransactionEntriesMock = mLedgerServiceClientMockSearchTransactionEntries{mock: m}
	m.SearchTransactionEntriesMock.callArgs = []*LedgerServiceClientMockSearchTransactionEntriesParams{}

	m.SearchTransactionsMock = mLedgerServiceClientMockSearchTransactions{mock: m}
	m.SearchTransactionsMock.callArgs = []*LedgerServiceClientMockSearchTransactionsParams{}

	m.UpdateAccountMock = mLedgerServiceClientMockUpdateAccount{mock: m}
	m.UpdateAccountMock.callArgs = []*LedgerServiceClientMockUpdateAccountParams{}

	m.UpdateLedgerMock = mLedgerServiceClientMockUpdateLedger{mock: m}
	m.UpdateLedgerMock.callArgs = []*LedgerServiceClientMockUpdateLedgerParams{}

	m.UpdateTransactionMock = mLedgerServiceClientMockUpdateTransaction{mock: m}
	m.UpdateTransactionMock.callArgs = []*LedgerServiceClientMockUpdateTransactionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLedgerServiceClientMockCreateAccount struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockCreateAccountExpectation
	expectations       []*LedgerServiceClientMockCreateAccountExpectation

	callArgs []*LedgerServiceClientMockCreateAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockCreateAccountExpectation specifies expectation struct of the LedgerServiceClient.CreateAccount
type LedgerServiceClientMockCreateAccountExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockCreateAccountParams
	paramPtrs          *LedgerServiceClientMockCreateAccountParamPtrs
	expectationOrigins LedgerServiceClientMockCreateAccountExpectationOrigins
	results            *LedgerServiceClientMockCreateAccountResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockCreateAccountParams contains parameters of the LedgerServiceClient.CreateAccount
type LedgerServiceClientMockCreateAccountParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.CreateAccountRequest]
}

// LedgerServiceClientMockCreateAccountParamPtrs contains pointers to parameters of the LedgerServiceClient.CreateAccount
type LedgerServiceClientMockCreateAccountParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.CreateAccountRequest]
}

// LedgerServiceClientMockCreateAccountResults contains results of the LedgerServiceClient.CreateAccount
type LedgerServiceClientMockCreateAccountResults struct {
	pp2 *connect.Response[v11.CreateAccountResponse]
	err error
}

// LedgerServiceClientMockCreateAccountOrigins contains origins of expectations of the LedgerServiceClient.CreateAccount
type LedgerServiceClientMockCreateAccountExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Optional() *mLedgerServiceClientMockCreateAccount {
	mmCreateAccount.optional = true
	return mmCreateAccount
}

// Expect sets up expected params for LedgerServiceClient.CreateAccount
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Expect(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest]) *mLedgerServiceClientMockCreateAccount {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceClientMockCreateAccountExpectation{}
	}

	if mmCreateAccount.defaultExpectation.paramPtrs != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by ExpectParams functions")
	}

	mmCreateAccount.defaultExpectation.params = &LedgerServiceClientMockCreateAccountParams{ctx, pp1}
	mmCreateAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateAccount.expectations {
		if minimock.Equal(e.params, mmCreateAccount.defaultExpectation.params) {
			mmCreateAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccount.defaultExpectation.params)
		}
	}

	return mmCreateAccount
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.CreateAccount
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockCreateAccount {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceClientMockCreateAccountExpectation{}
	}

	if mmCreateAccount.defaultExpectation.params != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Expect")
	}

	if mmCreateAccount.defaultExpectation.paramPtrs == nil {
		mmCreateAccount.defaultExpectation.paramPtrs = &LedgerServiceClientMockCreateAccountParamPtrs{}
	}
	mmCreateAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateAccount
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.CreateAccount
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) ExpectPp1Param2(pp1 *connect.Request[v11.CreateAccountRequest]) *mLedgerServiceClientMockCreateAccount {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceClientMockCreateAccountExpectation{}
	}

	if mmCreateAccount.defaultExpectation.params != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Expect")
	}

	if mmCreateAccount.defaultExpectation.paramPtrs == nil {
		mmCreateAccount.defaultExpectation.paramPtrs = &LedgerServiceClientMockCreateAccountParamPtrs{}
	}
	mmCreateAccount.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateAccount.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateAccount
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.CreateAccount
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest])) *mLedgerServiceClientMockCreateAccount {
	if mmCreateAccount.mock.inspectFuncCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.CreateAccount")
	}

	mmCreateAccount.mock.inspectFuncCreateAccount = f

	return mmCreateAccount
}

// Return sets up results that will be returned by LedgerServiceClient.CreateAccount
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Return(pp2 *connect.Response[v11.CreateAccountResponse], err error) *LedgerServiceClientMock {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Set")
	}

	if mmCreateAccount.defaultExpectation == nil {
		mmCreateAccount.defaultExpectation = &LedgerServiceClientMockCreateAccountExpectation{mock: mmCreateAccount.mock}
	}
	mmCreateAccount.defaultExpectation.results = &LedgerServiceClientMockCreateAccountResults{pp2, err}
	mmCreateAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateAccount.mock
}

// Set uses given function f to mock the LedgerServiceClient.CreateAccount method
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Set(f func(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest]) (pp2 *connect.Response[v11.CreateAccountResponse], err error)) *LedgerServiceClientMock {
	if mmCreateAccount.defaultExpectation != nil {
		mmCreateAccount.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.CreateAccount method")
	}

	if len(mmCreateAccount.expectations) > 0 {
		mmCreateAccount.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.CreateAccount method")
	}

	mmCreateAccount.mock.funcCreateAccount = f
	mmCreateAccount.mock.funcCreateAccountOrigin = minimock.CallerInfo(1)
	return mmCreateAccount.mock
}

// When sets expectation for the LedgerServiceClient.CreateAccount which will trigger the result defined by the following
// Then helper
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) When(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest]) *LedgerServiceClientMockCreateAccountExpectation {
	if mmCreateAccount.mock.funcCreateAccount != nil {
		mmCreateAccount.mock.t.Fatalf("LedgerServiceClientMock.CreateAccount mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockCreateAccountExpectation{
		mock:               mmCreateAccount.mock,
		params:             &LedgerServiceClientMockCreateAccountParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockCreateAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateAccount.expectations = append(mmCreateAccount.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.CreateAccount return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockCreateAccountExpectation) Then(pp2 *connect.Response[v11.CreateAccountResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockCreateAccountResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.CreateAccount should be invoked
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Times(n uint64) *mLedgerServiceClientMockCreateAccount {
	if n == 0 {
		mmCreateAccount.mock.t.Fatalf("Times of LedgerServiceClientMock.CreateAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAccount.expectedInvocations, n)
	mmCreateAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateAccount
}

func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) invocationsDone() bool {
	if len(mmCreateAccount.expectations) == 0 && mmCreateAccount.defaultExpectation == nil && mmCreateAccount.mock.funcCreateAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAccount.mock.afterCreateAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAccount implements mm_ledgerv1connect.LedgerServiceClient
func (mmCreateAccount *LedgerServiceClientMock) CreateAccount(ctx context.Context, pp1 *connect.Request[v11.CreateAccountRequest]) (pp2 *connect.Response[v11.CreateAccountResponse], err error) {
	mm_atomic.AddUint64(&mmCreateAccount.beforeCreateAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccount.afterCreateAccountCounter, 1)

	mmCreateAccount.t.Helper()

	if mmCreateAccount.inspectFuncCreateAccount != nil {
		mmCreateAccount.inspectFuncCreateAccount(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockCreateAccountParams{ctx, pp1}

	// Record call args
	mmCreateAccount.CreateAccountMock.mutex.Lock()
	mmCreateAccount.CreateAccountMock.callArgs = append(mmCreateAccount.CreateAccountMock.callArgs, &mm_params)
	mmCreateAccount.CreateAccountMock.mutex.Unlock()

	for _, e := range mmCreateAccount.CreateAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateAccount.CreateAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccount.CreateAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccount.CreateAccountMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAccount.CreateAccountMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockCreateAccountParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAccount.t.Errorf("LedgerServiceClientMock.CreateAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccount.CreateAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateAccount.t.Errorf("LedgerServiceClientMock.CreateAccount got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateAccount.CreateAccountMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccount.t.Errorf("LedgerServiceClientMock.CreateAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateAccount.CreateAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccount.CreateAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccount.t.Fatal("No results are set for the LedgerServiceClientMock.CreateAccount")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateAccount.funcCreateAccount != nil {
		return mmCreateAccount.funcCreateAccount(ctx, pp1)
	}
	mmCreateAccount.t.Fatalf("Unexpected call to LedgerServiceClientMock.CreateAccount. %v %v", ctx, pp1)
	return
}

// CreateAccountAfterCounter returns a count of finished LedgerServiceClientMock.CreateAccount invocations
func (mmCreateAccount *LedgerServiceClientMock) CreateAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccount.afterCreateAccountCounter)
}

// CreateAccountBeforeCounter returns a count of LedgerServiceClientMock.CreateAccount invocations
func (mmCreateAccount *LedgerServiceClientMock) CreateAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccount.beforeCreateAccountCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.CreateAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccount *mLedgerServiceClientMockCreateAccount) Calls() []*LedgerServiceClientMockCreateAccountParams {
	mmCreateAccount.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockCreateAccountParams, len(mmCreateAccount.callArgs))
	copy(argCopy, mmCreateAccount.callArgs)

	mmCreateAccount.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccountDone returns true if the count of the CreateAccount invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockCreateAccountDone() bool {
	if m.CreateAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAccountMock.invocationsDone()
}

// MinimockCreateAccountInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockCreateAccountInspect() {
	for _, e := range m.CreateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateAccountCounter := mm_atomic.LoadUint64(&m.afterCreateAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccountMock.defaultExpectation != nil && afterCreateAccountCounter < 1 {
		if m.CreateAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateAccount at\n%s", m.CreateAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateAccount at\n%s with params: %#v", m.CreateAccountMock.defaultExpectation.expectationOrigins.origin, *m.CreateAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccount != nil && afterCreateAccountCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.CreateAccount at\n%s", m.funcCreateAccountOrigin)
	}

	if !m.CreateAccountMock.invocationsDone() && afterCreateAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.CreateAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAccountMock.expectedInvocations), m.CreateAccountMock.expectedInvocationsOrigin, afterCreateAccountCounter)
	}
}

type mLedgerServiceClientMockCreateLedger struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockCreateLedgerExpectation
	expectations       []*LedgerServiceClientMockCreateLedgerExpectation

	callArgs []*LedgerServiceClientMockCreateLedgerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockCreateLedgerExpectation specifies expectation struct of the LedgerServiceClient.CreateLedger
type LedgerServiceClientMockCreateLedgerExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockCreateLedgerParams
	paramPtrs          *LedgerServiceClientMockCreateLedgerParamPtrs
	expectationOrigins LedgerServiceClientMockCreateLedgerExpectationOrigins
	results            *LedgerServiceClientMockCreateLedgerResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockCreateLedgerParams contains parameters of the LedgerServiceClient.CreateLedger
type LedgerServiceClientMockCreateLedgerParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.CreateLedgerRequest]
}

// LedgerServiceClientMockCreateLedgerParamPtrs contains pointers to parameters of the LedgerServiceClient.CreateLedger
type LedgerServiceClientMockCreateLedgerParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.CreateLedgerRequest]
}

// LedgerServiceClientMockCreateLedgerResults contains results of the LedgerServiceClient.CreateLedger
type LedgerServiceClientMockCreateLedgerResults struct {
	pp2 *connect.Response[v11.CreateLedgerResponse]
	err error
}

// LedgerServiceClientMockCreateLedgerOrigins contains origins of expectations of the LedgerServiceClient.CreateLedger
type LedgerServiceClientMockCreateLedgerExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Optional() *mLedgerServiceClientMockCreateLedger {
	mmCreateLedger.optional = true
	return mmCreateLedger
}

// Expect sets up expected params for LedgerServiceClient.CreateLedger
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Expect(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest]) *mLedgerServiceClientMockCreateLedger {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceClientMockCreateLedgerExpectation{}
	}

	if mmCreateLedger.defaultExpectation.paramPtrs != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by ExpectParams functions")
	}

	mmCreateLedger.defaultExpectation.params = &LedgerServiceClientMockCreateLedgerParams{ctx, pp1}
	mmCreateLedger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateLedger.expectations {
		if minimock.Equal(e.params, mmCreateLedger.defaultExpectation.params) {
			mmCreateLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateLedger.defaultExpectation.params)
		}
	}

	return mmCreateLedger
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.CreateLedger
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockCreateLedger {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceClientMockCreateLedgerExpectation{}
	}

	if mmCreateLedger.defaultExpectation.params != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Expect")
	}

	if mmCreateLedger.defaultExpectation.paramPtrs == nil {
		mmCreateLedger.defaultExpectation.paramPtrs = &LedgerServiceClientMockCreateLedgerParamPtrs{}
	}
	mmCreateLedger.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateLedger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateLedger
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.CreateLedger
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) ExpectPp1Param2(pp1 *connect.Request[v11.CreateLedgerRequest]) *mLedgerServiceClientMockCreateLedger {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceClientMockCreateLedgerExpectation{}
	}

	if mmCreateLedger.defaultExpectation.params != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Expect")
	}

	if mmCreateLedger.defaultExpectation.paramPtrs == nil {
		mmCreateLedger.defaultExpectation.paramPtrs = &LedgerServiceClientMockCreateLedgerParamPtrs{}
	}
	mmCreateLedger.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateLedger.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateLedger
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.CreateLedger
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest])) *mLedgerServiceClientMockCreateLedger {
	if mmCreateLedger.mock.inspectFuncCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.CreateLedger")
	}

	mmCreateLedger.mock.inspectFuncCreateLedger = f

	return mmCreateLedger
}

// Return sets up results that will be returned by LedgerServiceClient.CreateLedger
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Return(pp2 *connect.Response[v11.CreateLedgerResponse], err error) *LedgerServiceClientMock {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Set")
	}

	if mmCreateLedger.defaultExpectation == nil {
		mmCreateLedger.defaultExpectation = &LedgerServiceClientMockCreateLedgerExpectation{mock: mmCreateLedger.mock}
	}
	mmCreateLedger.defaultExpectation.results = &LedgerServiceClientMockCreateLedgerResults{pp2, err}
	mmCreateLedger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateLedger.mock
}

// Set uses given function f to mock the LedgerServiceClient.CreateLedger method
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Set(f func(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest]) (pp2 *connect.Response[v11.CreateLedgerResponse], err error)) *LedgerServiceClientMock {
	if mmCreateLedger.defaultExpectation != nil {
		mmCreateLedger.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.CreateLedger method")
	}

	if len(mmCreateLedger.expectations) > 0 {
		mmCreateLedger.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.CreateLedger method")
	}

	mmCreateLedger.mock.funcCreateLedger = f
	mmCreateLedger.mock.funcCreateLedgerOrigin = minimock.CallerInfo(1)
	return mmCreateLedger.mock
}

// When sets expectation for the LedgerServiceClient.CreateLedger which will trigger the result defined by the following
// Then helper
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) When(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest]) *LedgerServiceClientMockCreateLedgerExpectation {
	if mmCreateLedger.mock.funcCreateLedger != nil {
		mmCreateLedger.mock.t.Fatalf("LedgerServiceClientMock.CreateLedger mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockCreateLedgerExpectation{
		mock:               mmCreateLedger.mock,
		params:             &LedgerServiceClientMockCreateLedgerParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockCreateLedgerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateLedger.expectations = append(mmCreateLedger.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.CreateLedger return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockCreateLedgerExpectation) Then(pp2 *connect.Response[v11.CreateLedgerResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockCreateLedgerResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.CreateLedger should be invoked
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Times(n uint64) *mLedgerServiceClientMockCreateLedger {
	if n == 0 {
		mmCreateLedger.mock.t.Fatalf("Times of LedgerServiceClientMock.CreateLedger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateLedger.expectedInvocations, n)
	mmCreateLedger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateLedger
}

func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) invocationsDone() bool {
	if len(mmCreateLedger.expectations) == 0 && mmCreateLedger.defaultExpectation == nil && mmCreateLedger.mock.funcCreateLedger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateLedger.mock.afterCreateLedgerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateLedger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateLedger implements mm_ledgerv1connect.LedgerServiceClient
func (mmCreateLedger *LedgerServiceClientMock) CreateLedger(ctx context.Context, pp1 *connect.Request[v11.CreateLedgerRequest]) (pp2 *connect.Response[v11.CreateLedgerResponse], err error) {
	mm_atomic.AddUint64(&mmCreateLedger.beforeCreateLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateLedger.afterCreateLedgerCounter, 1)

	mmCreateLedger.t.Helper()

	if mmCreateLedger.inspectFuncCreateLedger != nil {
		mmCreateLedger.inspectFuncCreateLedger(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockCreateLedgerParams{ctx, pp1}

	// Record call args
	mmCreateLedger.CreateLedgerMock.mutex.Lock()
	mmCreateLedger.CreateLedgerMock.callArgs = append(mmCreateLedger.CreateLedgerMock.callArgs, &mm_params)
	mmCreateLedger.CreateLedgerMock.mutex.Unlock()

	for _, e := range mmCreateLedger.CreateLedgerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateLedger.CreateLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateLedger.CreateLedgerMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateLedger.CreateLedgerMock.defaultExpectation.params
		mm_want_ptrs := mmCreateLedger.CreateLedgerMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockCreateLedgerParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateLedger.t.Errorf("LedgerServiceClientMock.CreateLedger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLedger.CreateLedgerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateLedger.t.Errorf("LedgerServiceClientMock.CreateLedger got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateLedger.CreateLedgerMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateLedger.t.Errorf("LedgerServiceClientMock.CreateLedger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateLedger.CreateLedgerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateLedger.CreateLedgerMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateLedger.t.Fatal("No results are set for the LedgerServiceClientMock.CreateLedger")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateLedger.funcCreateLedger != nil {
		return mmCreateLedger.funcCreateLedger(ctx, pp1)
	}
	mmCreateLedger.t.Fatalf("Unexpected call to LedgerServiceClientMock.CreateLedger. %v %v", ctx, pp1)
	return
}

// CreateLedgerAfterCounter returns a count of finished LedgerServiceClientMock.CreateLedger invocations
func (mmCreateLedger *LedgerServiceClientMock) CreateLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLedger.afterCreateLedgerCounter)
}

// CreateLedgerBeforeCounter returns a count of LedgerServiceClientMock.CreateLedger invocations
func (mmCreateLedger *LedgerServiceClientMock) CreateLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLedger.beforeCreateLedgerCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.CreateLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateLedger *mLedgerServiceClientMockCreateLedger) Calls() []*LedgerServiceClientMockCreateLedgerParams {
	mmCreateLedger.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockCreateLedgerParams, len(mmCreateLedger.callArgs))
	copy(argCopy, mmCreateLedger.callArgs)

	mmCreateLedger.mutex.RUnlock()

	return argCopy
}

// MinimockCreateLedgerDone returns true if the count of the CreateLedger invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockCreateLedgerDone() bool {
	if m.CreateLedgerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateLedgerMock.invocationsDone()
}

// MinimockCreateLedgerInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockCreateLedgerInspect() {
	for _, e := range m.CreateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateLedger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateLedgerCounter := mm_atomic.LoadUint64(&m.afterCreateLedgerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLedgerMock.defaultExpectation != nil && afterCreateLedgerCounter < 1 {
		if m.CreateLedgerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateLedger at\n%s", m.CreateLedgerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateLedger at\n%s with params: %#v", m.CreateLedgerMock.defaultExpectation.expectationOrigins.origin, *m.CreateLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLedger != nil && afterCreateLedgerCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.CreateLedger at\n%s", m.funcCreateLedgerOrigin)
	}

	if !m.CreateLedgerMock.invocationsDone() && afterCreateLedgerCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.CreateLedger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateLedgerMock.expectedInvocations), m.CreateLedgerMock.expectedInvocationsOrigin, afterCreateLedgerCounter)
	}
}

type mLedgerServiceClientMockCreateTransaction struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockCreateTransactionExpectation
	expectations       []*LedgerServiceClientMockCreateTransactionExpectation

	callArgs []*LedgerServiceClientMockCreateTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockCreateTransactionExpectation specifies expectation struct of the LedgerServiceClient.CreateTransaction
type LedgerServiceClientMockCreateTransactionExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockCreateTransactionParams
	paramPtrs          *LedgerServiceClientMockCreateTransactionParamPtrs
	expectationOrigins LedgerServiceClientMockCreateTransactionExpectationOrigins
	results            *LedgerServiceClientMockCreateTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockCreateTransactionParams contains parameters of the LedgerServiceClient.CreateTransaction
type LedgerServiceClientMockCreateTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.CreateTransactionRequest]
}

// LedgerServiceClientMockCreateTransactionParamPtrs contains pointers to parameters of the LedgerServiceClient.CreateTransaction
type LedgerServiceClientMockCreateTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.CreateTransactionRequest]
}

// LedgerServiceClientMockCreateTransactionResults contains results of the LedgerServiceClient.CreateTransaction
type LedgerServiceClientMockCreateTransactionResults struct {
	pp2 *connect.Response[v11.CreateTransactionResponse]
	err error
}

// LedgerServiceClientMockCreateTransactionOrigins contains origins of expectations of the LedgerServiceClient.CreateTransaction
type LedgerServiceClientMockCreateTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Optional() *mLedgerServiceClientMockCreateTransaction {
	mmCreateTransaction.optional = true
	return mmCreateTransaction
}

// Expect sets up expected params for LedgerServiceClient.CreateTransaction
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Expect(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest]) *mLedgerServiceClientMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceClientMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by ExpectParams functions")
	}

	mmCreateTransaction.defaultExpectation.params = &LedgerServiceClientMockCreateTransactionParams{ctx, pp1}
	mmCreateTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateTransaction.expectations {
		if minimock.Equal(e.params, mmCreateTransaction.defaultExpectation.params) {
			mmCreateTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateTransaction.defaultExpectation.params)
		}
	}

	return mmCreateTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.CreateTransaction
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceClientMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &LedgerServiceClientMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.CreateTransaction
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) ExpectPp1Param2(pp1 *connect.Request[v11.CreateTransactionRequest]) *mLedgerServiceClientMockCreateTransaction {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceClientMockCreateTransactionExpectation{}
	}

	if mmCreateTransaction.defaultExpectation.params != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Expect")
	}

	if mmCreateTransaction.defaultExpectation.paramPtrs == nil {
		mmCreateTransaction.defaultExpectation.paramPtrs = &LedgerServiceClientMockCreateTransactionParamPtrs{}
	}
	mmCreateTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateTransaction
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.CreateTransaction
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest])) *mLedgerServiceClientMockCreateTransaction {
	if mmCreateTransaction.mock.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.CreateTransaction")
	}

	mmCreateTransaction.mock.inspectFuncCreateTransaction = f

	return mmCreateTransaction
}

// Return sets up results that will be returned by LedgerServiceClient.CreateTransaction
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Return(pp2 *connect.Response[v11.CreateTransactionResponse], err error) *LedgerServiceClientMock {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Set")
	}

	if mmCreateTransaction.defaultExpectation == nil {
		mmCreateTransaction.defaultExpectation = &LedgerServiceClientMockCreateTransactionExpectation{mock: mmCreateTransaction.mock}
	}
	mmCreateTransaction.defaultExpectation.results = &LedgerServiceClientMockCreateTransactionResults{pp2, err}
	mmCreateTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// Set uses given function f to mock the LedgerServiceClient.CreateTransaction method
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest]) (pp2 *connect.Response[v11.CreateTransactionResponse], err error)) *LedgerServiceClientMock {
	if mmCreateTransaction.defaultExpectation != nil {
		mmCreateTransaction.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.CreateTransaction method")
	}

	if len(mmCreateTransaction.expectations) > 0 {
		mmCreateTransaction.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.CreateTransaction method")
	}

	mmCreateTransaction.mock.funcCreateTransaction = f
	mmCreateTransaction.mock.funcCreateTransactionOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction.mock
}

// When sets expectation for the LedgerServiceClient.CreateTransaction which will trigger the result defined by the following
// Then helper
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) When(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest]) *LedgerServiceClientMockCreateTransactionExpectation {
	if mmCreateTransaction.mock.funcCreateTransaction != nil {
		mmCreateTransaction.mock.t.Fatalf("LedgerServiceClientMock.CreateTransaction mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockCreateTransactionExpectation{
		mock:               mmCreateTransaction.mock,
		params:             &LedgerServiceClientMockCreateTransactionParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockCreateTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateTransaction.expectations = append(mmCreateTransaction.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.CreateTransaction return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockCreateTransactionExpectation) Then(pp2 *connect.Response[v11.CreateTransactionResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockCreateTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.CreateTransaction should be invoked
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Times(n uint64) *mLedgerServiceClientMockCreateTransaction {
	if n == 0 {
		mmCreateTransaction.mock.t.Fatalf("Times of LedgerServiceClientMock.CreateTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateTransaction.expectedInvocations, n)
	mmCreateTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateTransaction
}

func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) invocationsDone() bool {
	if len(mmCreateTransaction.expectations) == 0 && mmCreateTransaction.defaultExpectation == nil && mmCreateTransaction.mock.funcCreateTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.mock.afterCreateTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateTransaction implements mm_ledgerv1connect.LedgerServiceClient
func (mmCreateTransaction *LedgerServiceClientMock) CreateTransaction(ctx context.Context, pp1 *connect.Request[v11.CreateTransactionRequest]) (pp2 *connect.Response[v11.CreateTransactionResponse], err error) {
	mm_atomic.AddUint64(&mmCreateTransaction.beforeCreateTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateTransaction.afterCreateTransactionCounter, 1)

	mmCreateTransaction.t.Helper()

	if mmCreateTransaction.inspectFuncCreateTransaction != nil {
		mmCreateTransaction.inspectFuncCreateTransaction(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockCreateTransactionParams{ctx, pp1}

	// Record call args
	mmCreateTransaction.CreateTransactionMock.mutex.Lock()
	mmCreateTransaction.CreateTransactionMock.callArgs = append(mmCreateTransaction.CreateTransactionMock.callArgs, &mm_params)
	mmCreateTransaction.CreateTransactionMock.mutex.Unlock()

	for _, e := range mmCreateTransaction.CreateTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateTransaction.CreateTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateTransaction.CreateTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateTransaction.CreateTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateTransaction.CreateTransactionMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockCreateTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateTransaction.t.Errorf("LedgerServiceClientMock.CreateTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateTransaction.t.Errorf("LedgerServiceClientMock.CreateTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateTransaction.t.Errorf("LedgerServiceClientMock.CreateTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateTransaction.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateTransaction.CreateTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateTransaction.t.Fatal("No results are set for the LedgerServiceClientMock.CreateTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateTransaction.funcCreateTransaction != nil {
		return mmCreateTransaction.funcCreateTransaction(ctx, pp1)
	}
	mmCreateTransaction.t.Fatalf("Unexpected call to LedgerServiceClientMock.CreateTransaction. %v %v", ctx, pp1)
	return
}

// CreateTransactionAfterCounter returns a count of finished LedgerServiceClientMock.CreateTransaction invocations
func (mmCreateTransaction *LedgerServiceClientMock) CreateTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.afterCreateTransactionCounter)
}

// CreateTransactionBeforeCounter returns a count of LedgerServiceClientMock.CreateTransaction invocations
func (mmCreateTransaction *LedgerServiceClientMock) CreateTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateTransaction.beforeCreateTransactionCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.CreateTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateTransaction *mLedgerServiceClientMockCreateTransaction) Calls() []*LedgerServiceClientMockCreateTransactionParams {
	mmCreateTransaction.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockCreateTransactionParams, len(mmCreateTransaction.callArgs))
	copy(argCopy, mmCreateTransaction.callArgs)

	mmCreateTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockCreateTransactionDone returns true if the count of the CreateTransaction invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockCreateTransactionDone() bool {
	if m.CreateTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateTransactionMock.invocationsDone()
}

// MinimockCreateTransactionInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockCreateTransactionInspect() {
	for _, e := range m.CreateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateTransactionCounter := mm_atomic.LoadUint64(&m.afterCreateTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateTransactionMock.defaultExpectation != nil && afterCreateTransactionCounter < 1 {
		if m.CreateTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateTransaction at\n%s", m.CreateTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.CreateTransaction at\n%s with params: %#v", m.CreateTransactionMock.defaultExpectation.expectationOrigins.origin, *m.CreateTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateTransaction != nil && afterCreateTransactionCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.CreateTransaction at\n%s", m.funcCreateTransactionOrigin)
	}

	if !m.CreateTransactionMock.invocationsDone() && afterCreateTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.CreateTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateTransactionMock.expectedInvocations), m.CreateTransactionMock.expectedInvocationsOrigin, afterCreateTransactionCounter)
	}
}

type mLedgerServiceClientMockReverseTransaction struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockReverseTransactionExpectation
	expectations       []*LedgerServiceClientMockReverseTransactionExpectation

	callArgs []*LedgerServiceClientMockReverseTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockReverseTransactionExpectation specifies expectation struct of the LedgerServiceClient.ReverseTransaction
type LedgerServiceClientMockReverseTransactionExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockReverseTransactionParams
	paramPtrs          *LedgerServiceClientMockReverseTransactionParamPtrs
	expectationOrigins LedgerServiceClientMockReverseTransactionExpectationOrigins
	results            *LedgerServiceClientMockReverseTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockReverseTransactionParams contains parameters of the LedgerServiceClient.ReverseTransaction
type LedgerServiceClientMockReverseTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.ReverseTransactionRequest]
}

// LedgerServiceClientMockReverseTransactionParamPtrs contains pointers to parameters of the LedgerServiceClient.ReverseTransaction
type LedgerServiceClientMockReverseTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.ReverseTransactionRequest]
}

// LedgerServiceClientMockReverseTransactionResults contains results of the LedgerServiceClient.ReverseTransaction
type LedgerServiceClientMockReverseTransactionResults struct {
	pp2 *connect.Response[v11.ReverseTransactionResponse]
	err error
}

// LedgerServiceClientMockReverseTransactionOrigins contains origins of expectations of the LedgerServiceClient.ReverseTransaction
type LedgerServiceClientMockReverseTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Optional() *mLedgerServiceClientMockReverseTransaction {
	mmReverseTransaction.optional = true
	return mmReverseTransaction
}

// Expect sets up expected params for LedgerServiceClient.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Expect(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest]) *mLedgerServiceClientMockReverseTransaction {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceClientMockReverseTransactionExpectation{}
	}

	if mmReverseTransaction.defaultExpectation.paramPtrs != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by ExpectParams functions")
	}

	mmReverseTransaction.defaultExpectation.params = &LedgerServiceClientMockReverseTransactionParams{ctx, pp1}
	mmReverseTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReverseTransaction.expectations {
		if minimock.Equal(e.params, mmReverseTransaction.defaultExpectation.params) {
			mmReverseTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReverseTransaction.defaultExpectation.params)
		}
	}

	return mmReverseTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockReverseTransaction {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceClientMockReverseTransactionExpectation{}
	}

	if mmReverseTransaction.defaultExpectation.params != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Expect")
	}

	if mmReverseTransaction.defaultExpectation.paramPtrs == nil {
		mmReverseTransaction.defaultExpectation.paramPtrs = &LedgerServiceClientMockReverseTransactionParamPtrs{}
	}
	mmReverseTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmReverseTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReverseTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) ExpectPp1Param2(pp1 *connect.Request[v11.ReverseTransactionRequest]) *mLedgerServiceClientMockReverseTransaction {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceClientMockReverseTransactionExpectation{}
	}

	if mmReverseTransaction.defaultExpectation.params != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Expect")
	}

	if mmReverseTransaction.defaultExpectation.paramPtrs == nil {
		mmReverseTransaction.defaultExpectation.paramPtrs = &LedgerServiceClientMockReverseTransactionParamPtrs{}
	}
	mmReverseTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmReverseTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmReverseTransaction
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest])) *mLedgerServiceClientMockReverseTransaction {
	if mmReverseTransaction.mock.inspectFuncReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.ReverseTransaction")
	}

	mmReverseTransaction.mock.inspectFuncReverseTransaction = f

	return mmReverseTransaction
}

// Return sets up results that will be returned by LedgerServiceClient.ReverseTransaction
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Return(pp2 *connect.Response[v11.ReverseTransactionResponse], err error) *LedgerServiceClientMock {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Set")
	}

	if mmReverseTransaction.defaultExpectation == nil {
		mmReverseTransaction.defaultExpectation = &LedgerServiceClientMockReverseTransactionExpectation{mock: mmReverseTransaction.mock}
	}
	mmReverseTransaction.defaultExpectation.results = &LedgerServiceClientMockReverseTransactionResults{pp2, err}
	mmReverseTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReverseTransaction.mock
}

// Set uses given function f to mock the LedgerServiceClient.ReverseTransaction method
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest]) (pp2 *connect.Response[v11.ReverseTransactionResponse], err error)) *LedgerServiceClientMock {
	if mmReverseTransaction.defaultExpectation != nil {
		mmReverseTransaction.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.ReverseTransaction method")
	}

	if len(mmReverseTransaction.expectations) > 0 {
		mmReverseTransaction.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.ReverseTransaction method")
	}

	mmReverseTransaction.mock.funcReverseTransaction = f
	mmReverseTransaction.mock.funcReverseTransactionOrigin = minimock.CallerInfo(1)
	return mmReverseTransaction.mock
}

// When sets expectation for the LedgerServiceClient.ReverseTransaction which will trigger the result defined by the following
// Then helper
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) When(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest]) *LedgerServiceClientMockReverseTransactionExpectation {
	if mmReverseTransaction.mock.funcReverseTransaction != nil {
		mmReverseTransaction.mock.t.Fatalf("LedgerServiceClientMock.ReverseTransaction mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockReverseTransactionExpectation{
		mock:               mmReverseTransaction.mock,
		params:             &LedgerServiceClientMockReverseTransactionParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockReverseTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReverseTransaction.expectations = append(mmReverseTransaction.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.ReverseTransaction return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockReverseTransactionExpectation) Then(pp2 *connect.Response[v11.ReverseTransactionResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockReverseTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.ReverseTransaction should be invoked
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Times(n uint64) *mLedgerServiceClientMockReverseTransaction {
	if n == 0 {
		mmReverseTransaction.mock.t.Fatalf("Times of LedgerServiceClientMock.ReverseTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReverseTransaction.expectedInvocations, n)
	mmReverseTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReverseTransaction
}

func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) invocationsDone() bool {
	if len(mmReverseTransaction.expectations) == 0 && mmReverseTransaction.defaultExpectation == nil && mmReverseTransaction.mock.funcReverseTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReverseTransaction.mock.afterReverseTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReverseTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReverseTransaction implements mm_ledgerv1connect.LedgerServiceClient
func (mmReverseTransaction *LedgerServiceClientMock) ReverseTransaction(ctx context.Context, pp1 *connect.Request[v11.ReverseTransactionRequest]) (pp2 *connect.Response[v11.ReverseTransactionResponse], err error) {
	mm_atomic.AddUint64(&mmReverseTransaction.beforeReverseTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmReverseTransaction.afterReverseTransactionCounter, 1)

	mmReverseTransaction.t.Helper()

	if mmReverseTransaction.inspectFuncReverseTransaction != nil {
		mmReverseTransaction.inspectFuncReverseTransaction(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockReverseTransactionParams{ctx, pp1}

	// Record call args
	mmReverseTransaction.ReverseTransactionMock.mutex.Lock()
	mmReverseTransaction.ReverseTransactionMock.callArgs = append(mmReverseTransaction.ReverseTransactionMock.callArgs, &mm_params)
	mmReverseTransaction.ReverseTransactionMock.mutex.Unlock()

	for _, e := range mmReverseTransaction.ReverseTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmReverseTransaction.ReverseTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReverseTransaction.ReverseTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmReverseTransaction.ReverseTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmReverseTransaction.ReverseTransactionMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockReverseTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReverseTransaction.t.Errorf("LedgerServiceClientMock.ReverseTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReverseTransaction.ReverseTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmReverseTransaction.t.Errorf("LedgerServiceClientMock.ReverseTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReverseTransaction.ReverseTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReverseTransaction.t.Errorf("LedgerServiceClientMock.ReverseTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReverseTransaction.ReverseTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReverseTransaction.ReverseTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmReverseTransaction.t.Fatal("No results are set for the LedgerServiceClientMock.ReverseTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmReverseTransaction.funcReverseTransaction != nil {
		return mmReverseTransaction.funcReverseTransaction(ctx, pp1)
	}
	mmReverseTransaction.t.Fatalf("Unexpected call to LedgerServiceClientMock.ReverseTransaction. %v %v", ctx, pp1)
	return
}

// ReverseTransactionAfterCounter returns a count of finished LedgerServiceClientMock.ReverseTransaction invocations
func (mmReverseTransaction *LedgerServiceClientMock) ReverseTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReverseTransaction.afterReverseTransactionCounter)
}

// ReverseTransactionBeforeCounter returns a count of LedgerServiceClientMock.ReverseTransaction invocations
func (mmReverseTransaction *LedgerServiceClientMock) ReverseTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReverseTransaction.beforeReverseTransactionCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.ReverseTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReverseTransaction *mLedgerServiceClientMockReverseTransaction) Calls() []*LedgerServiceClientMockReverseTransactionParams {
	mmReverseTransaction.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockReverseTransactionParams, len(mmReverseTransaction.callArgs))
	copy(argCopy, mmReverseTransaction.callArgs)

	mmReverseTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockReverseTransactionDone returns true if the count of the ReverseTransaction invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockReverseTransactionDone() bool {
	if m.ReverseTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReverseTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReverseTransactionMock.invocationsDone()
}

// MinimockReverseTransactionInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockReverseTransactionInspect() {
	for _, e := range m.ReverseTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.ReverseTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReverseTransactionCounter := mm_atomic.LoadUint64(&m.afterReverseTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReverseTransactionMock.defaultExpectation != nil && afterReverseTransactionCounter < 1 {
		if m.ReverseTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.ReverseTransaction at\n%s", m.ReverseTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.ReverseTransaction at\n%s with params: %#v", m.ReverseTransactionMock.defaultExpectation.expectationOrigins.origin, *m.ReverseTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReverseTransaction != nil && afterReverseTransactionCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.ReverseTransaction at\n%s", m.funcReverseTransactionOrigin)
	}

	if !m.ReverseTransactionMock.invocationsDone() && afterReverseTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.ReverseTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReverseTransactionMock.expectedInvocations), m.ReverseTransactionMock.expectedInvocationsOrigin, afterReverseTransactionCounter)
	}
}

type mLedgerServiceClientMockSearchAccounts struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockSearchAccountsExpectation
	expectations       []*LedgerServiceClientMockSearchAccountsExpectation

	callArgs []*LedgerServiceClientMockSearchAccountsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockSearchAccountsExpectation specifies expectation struct of the LedgerServiceClient.SearchAccounts
type LedgerServiceClientMockSearchAccountsExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockSearchAccountsParams
	paramPtrs          *LedgerServiceClientMockSearchAccountsParamPtrs
	expectationOrigins LedgerServiceClientMockSearchAccountsExpectationOrigins
	results            *LedgerServiceClientMockSearchAccountsResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockSearchAccountsParams contains parameters of the LedgerServiceClient.SearchAccounts
type LedgerServiceClientMockSearchAccountsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchAccountsParamPtrs contains pointers to parameters of the LedgerServiceClient.SearchAccounts
type LedgerServiceClientMockSearchAccountsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchAccountsResults contains results of the LedgerServiceClient.SearchAccounts
type LedgerServiceClientMockSearchAccountsResults struct {
	pp2 *connect.ServerStreamForClient[v11.SearchAccountsResponse]
	err error
}

// LedgerServiceClientMockSearchAccountsOrigins contains origins of expectations of the LedgerServiceClient.SearchAccounts
type LedgerServiceClientMockSearchAccountsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Optional() *mLedgerServiceClientMockSearchAccounts {
	mmSearchAccounts.optional = true
	return mmSearchAccounts
}

// Expect sets up expected params for LedgerServiceClient.SearchAccounts
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceClientMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by ExpectParams functions")
	}

	mmSearchAccounts.defaultExpectation.params = &LedgerServiceClientMockSearchAccountsParams{ctx, pp1}
	mmSearchAccounts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchAccounts.expectations {
		if minimock.Equal(e.params, mmSearchAccounts.defaultExpectation.params) {
			mmSearchAccounts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchAccounts.defaultExpectation.params)
		}
	}

	return mmSearchAccounts
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.SearchAccounts
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceClientMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.params != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Expect")
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs == nil {
		mmSearchAccounts.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchAccountsParamPtrs{}
	}
	mmSearchAccounts.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchAccounts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchAccounts
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.SearchAccounts
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchAccounts {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceClientMockSearchAccountsExpectation{}
	}

	if mmSearchAccounts.defaultExpectation.params != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Expect")
	}

	if mmSearchAccounts.defaultExpectation.paramPtrs == nil {
		mmSearchAccounts.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchAccountsParamPtrs{}
	}
	mmSearchAccounts.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchAccounts.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchAccounts
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.SearchAccounts
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])) *mLedgerServiceClientMockSearchAccounts {
	if mmSearchAccounts.mock.inspectFuncSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.SearchAccounts")
	}

	mmSearchAccounts.mock.inspectFuncSearchAccounts = f

	return mmSearchAccounts
}

// Return sets up results that will be returned by LedgerServiceClient.SearchAccounts
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Return(pp2 *connect.ServerStreamForClient[v11.SearchAccountsResponse], err error) *LedgerServiceClientMock {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Set")
	}

	if mmSearchAccounts.defaultExpectation == nil {
		mmSearchAccounts.defaultExpectation = &LedgerServiceClientMockSearchAccountsExpectation{mock: mmSearchAccounts.mock}
	}
	mmSearchAccounts.defaultExpectation.results = &LedgerServiceClientMockSearchAccountsResults{pp2, err}
	mmSearchAccounts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchAccounts.mock
}

// Set uses given function f to mock the LedgerServiceClient.SearchAccounts method
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchAccountsResponse], err error)) *LedgerServiceClientMock {
	if mmSearchAccounts.defaultExpectation != nil {
		mmSearchAccounts.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.SearchAccounts method")
	}

	if len(mmSearchAccounts.expectations) > 0 {
		mmSearchAccounts.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.SearchAccounts method")
	}

	mmSearchAccounts.mock.funcSearchAccounts = f
	mmSearchAccounts.mock.funcSearchAccountsOrigin = minimock.CallerInfo(1)
	return mmSearchAccounts.mock
}

// When sets expectation for the LedgerServiceClient.SearchAccounts which will trigger the result defined by the following
// Then helper
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *LedgerServiceClientMockSearchAccountsExpectation {
	if mmSearchAccounts.mock.funcSearchAccounts != nil {
		mmSearchAccounts.mock.t.Fatalf("LedgerServiceClientMock.SearchAccounts mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockSearchAccountsExpectation{
		mock:               mmSearchAccounts.mock,
		params:             &LedgerServiceClientMockSearchAccountsParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockSearchAccountsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchAccounts.expectations = append(mmSearchAccounts.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.SearchAccounts return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockSearchAccountsExpectation) Then(pp2 *connect.ServerStreamForClient[v11.SearchAccountsResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockSearchAccountsResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.SearchAccounts should be invoked
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Times(n uint64) *mLedgerServiceClientMockSearchAccounts {
	if n == 0 {
		mmSearchAccounts.mock.t.Fatalf("Times of LedgerServiceClientMock.SearchAccounts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchAccounts.expectedInvocations, n)
	mmSearchAccounts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchAccounts
}

func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) invocationsDone() bool {
	if len(mmSearchAccounts.expectations) == 0 && mmSearchAccounts.defaultExpectation == nil && mmSearchAccounts.mock.funcSearchAccounts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchAccounts.mock.afterSearchAccountsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchAccounts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchAccounts implements mm_ledgerv1connect.LedgerServiceClient
func (mmSearchAccounts *LedgerServiceClientMock) SearchAccounts(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchAccountsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchAccounts.beforeSearchAccountsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchAccounts.afterSearchAccountsCounter, 1)

	mmSearchAccounts.t.Helper()

	if mmSearchAccounts.inspectFuncSearchAccounts != nil {
		mmSearchAccounts.inspectFuncSearchAccounts(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockSearchAccountsParams{ctx, pp1}

	// Record call args
	mmSearchAccounts.SearchAccountsMock.mutex.Lock()
	mmSearchAccounts.SearchAccountsMock.callArgs = append(mmSearchAccounts.SearchAccountsMock.callArgs, &mm_params)
	mmSearchAccounts.SearchAccountsMock.mutex.Unlock()

	for _, e := range mmSearchAccounts.SearchAccountsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchAccounts.SearchAccountsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchAccounts.SearchAccountsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchAccounts.SearchAccountsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchAccounts.SearchAccountsMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockSearchAccountsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchAccounts.t.Errorf("LedgerServiceClientMock.SearchAccounts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchAccounts.t.Errorf("LedgerServiceClientMock.SearchAccounts got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchAccounts.t.Errorf("LedgerServiceClientMock.SearchAccounts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchAccounts.SearchAccountsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchAccounts.SearchAccountsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchAccounts.t.Fatal("No results are set for the LedgerServiceClientMock.SearchAccounts")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchAccounts.funcSearchAccounts != nil {
		return mmSearchAccounts.funcSearchAccounts(ctx, pp1)
	}
	mmSearchAccounts.t.Fatalf("Unexpected call to LedgerServiceClientMock.SearchAccounts. %v %v", ctx, pp1)
	return
}

// SearchAccountsAfterCounter returns a count of finished LedgerServiceClientMock.SearchAccounts invocations
func (mmSearchAccounts *LedgerServiceClientMock) SearchAccountsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchAccounts.afterSearchAccountsCounter)
}

// SearchAccountsBeforeCounter returns a count of LedgerServiceClientMock.SearchAccounts invocations
func (mmSearchAccounts *LedgerServiceClientMock) SearchAccountsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchAccounts.beforeSearchAccountsCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.SearchAccounts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchAccounts *mLedgerServiceClientMockSearchAccounts) Calls() []*LedgerServiceClientMockSearchAccountsParams {
	mmSearchAccounts.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockSearchAccountsParams, len(mmSearchAccounts.callArgs))
	copy(argCopy, mmSearchAccounts.callArgs)

	mmSearchAccounts.mutex.RUnlock()

	return argCopy
}

// MinimockSearchAccountsDone returns true if the count of the SearchAccounts invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockSearchAccountsDone() bool {
	if m.SearchAccountsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchAccountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchAccountsMock.invocationsDone()
}

// MinimockSearchAccountsInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockSearchAccountsInspect() {
	for _, e := range m.SearchAccountsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchAccounts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchAccountsCounter := mm_atomic.LoadUint64(&m.afterSearchAccountsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchAccountsMock.defaultExpectation != nil && afterSearchAccountsCounter < 1 {
		if m.SearchAccountsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchAccounts at\n%s", m.SearchAccountsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchAccounts at\n%s with params: %#v", m.SearchAccountsMock.defaultExpectation.expectationOrigins.origin, *m.SearchAccountsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchAccounts != nil && afterSearchAccountsCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.SearchAccounts at\n%s", m.funcSearchAccountsOrigin)
	}

	if !m.SearchAccountsMock.invocationsDone() && afterSearchAccountsCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.SearchAccounts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchAccountsMock.expectedInvocations), m.SearchAccountsMock.expectedInvocationsOrigin, afterSearchAccountsCounter)
	}
}

type mLedgerServiceClientMockSearchLedgers struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockSearchLedgersExpectation
	expectations       []*LedgerServiceClientMockSearchLedgersExpectation

	callArgs []*LedgerServiceClientMockSearchLedgersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockSearchLedgersExpectation specifies expectation struct of the LedgerServiceClient.SearchLedgers
type LedgerServiceClientMockSearchLedgersExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockSearchLedgersParams
	paramPtrs          *LedgerServiceClientMockSearchLedgersParamPtrs
	expectationOrigins LedgerServiceClientMockSearchLedgersExpectationOrigins
	results            *LedgerServiceClientMockSearchLedgersResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockSearchLedgersParams contains parameters of the LedgerServiceClient.SearchLedgers
type LedgerServiceClientMockSearchLedgersParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchLedgersParamPtrs contains pointers to parameters of the LedgerServiceClient.SearchLedgers
type LedgerServiceClientMockSearchLedgersParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchLedgersResults contains results of the LedgerServiceClient.SearchLedgers
type LedgerServiceClientMockSearchLedgersResults struct {
	pp2 *connect.ServerStreamForClient[v11.SearchLedgersResponse]
	err error
}

// LedgerServiceClientMockSearchLedgersOrigins contains origins of expectations of the LedgerServiceClient.SearchLedgers
type LedgerServiceClientMockSearchLedgersExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Optional() *mLedgerServiceClientMockSearchLedgers {
	mmSearchLedgers.optional = true
	return mmSearchLedgers
}

// Expect sets up expected params for LedgerServiceClient.SearchLedgers
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceClientMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by ExpectParams functions")
	}

	mmSearchLedgers.defaultExpectation.params = &LedgerServiceClientMockSearchLedgersParams{ctx, pp1}
	mmSearchLedgers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchLedgers.expectations {
		if minimock.Equal(e.params, mmSearchLedgers.defaultExpectation.params) {
			mmSearchLedgers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchLedgers.defaultExpectation.params)
		}
	}

	return mmSearchLedgers
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.SearchLedgers
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceClientMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.params != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Expect")
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs == nil {
		mmSearchLedgers.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchLedgersParamPtrs{}
	}
	mmSearchLedgers.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchLedgers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchLedgers
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.SearchLedgers
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchLedgers {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceClientMockSearchLedgersExpectation{}
	}

	if mmSearchLedgers.defaultExpectation.params != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Expect")
	}

	if mmSearchLedgers.defaultExpectation.paramPtrs == nil {
		mmSearchLedgers.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchLedgersParamPtrs{}
	}
	mmSearchLedgers.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchLedgers.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchLedgers
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.SearchLedgers
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])) *mLedgerServiceClientMockSearchLedgers {
	if mmSearchLedgers.mock.inspectFuncSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.SearchLedgers")
	}

	mmSearchLedgers.mock.inspectFuncSearchLedgers = f

	return mmSearchLedgers
}

// Return sets up results that will be returned by LedgerServiceClient.SearchLedgers
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Return(pp2 *connect.ServerStreamForClient[v11.SearchLedgersResponse], err error) *LedgerServiceClientMock {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Set")
	}

	if mmSearchLedgers.defaultExpectation == nil {
		mmSearchLedgers.defaultExpectation = &LedgerServiceClientMockSearchLedgersExpectation{mock: mmSearchLedgers.mock}
	}
	mmSearchLedgers.defaultExpectation.results = &LedgerServiceClientMockSearchLedgersResults{pp2, err}
	mmSearchLedgers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchLedgers.mock
}

// Set uses given function f to mock the LedgerServiceClient.SearchLedgers method
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchLedgersResponse], err error)) *LedgerServiceClientMock {
	if mmSearchLedgers.defaultExpectation != nil {
		mmSearchLedgers.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.SearchLedgers method")
	}

	if len(mmSearchLedgers.expectations) > 0 {
		mmSearchLedgers.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.SearchLedgers method")
	}

	mmSearchLedgers.mock.funcSearchLedgers = f
	mmSearchLedgers.mock.funcSearchLedgersOrigin = minimock.CallerInfo(1)
	return mmSearchLedgers.mock
}

// When sets expectation for the LedgerServiceClient.SearchLedgers which will trigger the result defined by the following
// Then helper
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *LedgerServiceClientMockSearchLedgersExpectation {
	if mmSearchLedgers.mock.funcSearchLedgers != nil {
		mmSearchLedgers.mock.t.Fatalf("LedgerServiceClientMock.SearchLedgers mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockSearchLedgersExpectation{
		mock:               mmSearchLedgers.mock,
		params:             &LedgerServiceClientMockSearchLedgersParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockSearchLedgersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchLedgers.expectations = append(mmSearchLedgers.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.SearchLedgers return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockSearchLedgersExpectation) Then(pp2 *connect.ServerStreamForClient[v11.SearchLedgersResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockSearchLedgersResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.SearchLedgers should be invoked
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Times(n uint64) *mLedgerServiceClientMockSearchLedgers {
	if n == 0 {
		mmSearchLedgers.mock.t.Fatalf("Times of LedgerServiceClientMock.SearchLedgers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchLedgers.expectedInvocations, n)
	mmSearchLedgers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchLedgers
}

func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) invocationsDone() bool {
	if len(mmSearchLedgers.expectations) == 0 && mmSearchLedgers.defaultExpectation == nil && mmSearchLedgers.mock.funcSearchLedgers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchLedgers.mock.afterSearchLedgersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchLedgers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchLedgers implements mm_ledgerv1connect.LedgerServiceClient
func (mmSearchLedgers *LedgerServiceClientMock) SearchLedgers(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchLedgersResponse], err error) {
	mm_atomic.AddUint64(&mmSearchLedgers.beforeSearchLedgersCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchLedgers.afterSearchLedgersCounter, 1)

	mmSearchLedgers.t.Helper()

	if mmSearchLedgers.inspectFuncSearchLedgers != nil {
		mmSearchLedgers.inspectFuncSearchLedgers(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockSearchLedgersParams{ctx, pp1}

	// Record call args
	mmSearchLedgers.SearchLedgersMock.mutex.Lock()
	mmSearchLedgers.SearchLedgersMock.callArgs = append(mmSearchLedgers.SearchLedgersMock.callArgs, &mm_params)
	mmSearchLedgers.SearchLedgersMock.mutex.Unlock()

	for _, e := range mmSearchLedgers.SearchLedgersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchLedgers.SearchLedgersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchLedgers.SearchLedgersMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchLedgers.SearchLedgersMock.defaultExpectation.params
		mm_want_ptrs := mmSearchLedgers.SearchLedgersMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockSearchLedgersParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchLedgers.t.Errorf("LedgerServiceClientMock.SearchLedgers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchLedgers.t.Errorf("LedgerServiceClientMock.SearchLedgers got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchLedgers.t.Errorf("LedgerServiceClientMock.SearchLedgers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchLedgers.SearchLedgersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchLedgers.SearchLedgersMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchLedgers.t.Fatal("No results are set for the LedgerServiceClientMock.SearchLedgers")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchLedgers.funcSearchLedgers != nil {
		return mmSearchLedgers.funcSearchLedgers(ctx, pp1)
	}
	mmSearchLedgers.t.Fatalf("Unexpected call to LedgerServiceClientMock.SearchLedgers. %v %v", ctx, pp1)
	return
}

// SearchLedgersAfterCounter returns a count of finished LedgerServiceClientMock.SearchLedgers invocations
func (mmSearchLedgers *LedgerServiceClientMock) SearchLedgersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchLedgers.afterSearchLedgersCounter)
}

// SearchLedgersBeforeCounter returns a count of LedgerServiceClientMock.SearchLedgers invocations
func (mmSearchLedgers *LedgerServiceClientMock) SearchLedgersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchLedgers.beforeSearchLedgersCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.SearchLedgers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchLedgers *mLedgerServiceClientMockSearchLedgers) Calls() []*LedgerServiceClientMockSearchLedgersParams {
	mmSearchLedgers.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockSearchLedgersParams, len(mmSearchLedgers.callArgs))
	copy(argCopy, mmSearchLedgers.callArgs)

	mmSearchLedgers.mutex.RUnlock()

	return argCopy
}

// MinimockSearchLedgersDone returns true if the count of the SearchLedgers invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockSearchLedgersDone() bool {
	if m.SearchLedgersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchLedgersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchLedgersMock.invocationsDone()
}

// MinimockSearchLedgersInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockSearchLedgersInspect() {
	for _, e := range m.SearchLedgersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchLedgers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchLedgersCounter := mm_atomic.LoadUint64(&m.afterSearchLedgersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchLedgersMock.defaultExpectation != nil && afterSearchLedgersCounter < 1 {
		if m.SearchLedgersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchLedgers at\n%s", m.SearchLedgersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchLedgers at\n%s with params: %#v", m.SearchLedgersMock.defaultExpectation.expectationOrigins.origin, *m.SearchLedgersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchLedgers != nil && afterSearchLedgersCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.SearchLedgers at\n%s", m.funcSearchLedgersOrigin)
	}

	if !m.SearchLedgersMock.invocationsDone() && afterSearchLedgersCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.SearchLedgers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchLedgersMock.expectedInvocations), m.SearchLedgersMock.expectedInvocationsOrigin, afterSearchLedgersCounter)
	}
}

type mLedgerServiceClientMockSearchTransactionEntries struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockSearchTransactionEntriesExpectation
	expectations       []*LedgerServiceClientMockSearchTransactionEntriesExpectation

	callArgs []*LedgerServiceClientMockSearchTransactionEntriesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockSearchTransactionEntriesExpectation specifies expectation struct of the LedgerServiceClient.SearchTransactionEntries
type LedgerServiceClientMockSearchTransactionEntriesExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockSearchTransactionEntriesParams
	paramPtrs          *LedgerServiceClientMockSearchTransactionEntriesParamPtrs
	expectationOrigins LedgerServiceClientMockSearchTransactionEntriesExpectationOrigins
	results            *LedgerServiceClientMockSearchTransactionEntriesResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockSearchTransactionEntriesParams contains parameters of the LedgerServiceClient.SearchTransactionEntries
type LedgerServiceClientMockSearchTransactionEntriesParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchTransactionEntriesParamPtrs contains pointers to parameters of the LedgerServiceClient.SearchTransactionEntries
type LedgerServiceClientMockSearchTransactionEntriesParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchTransactionEntriesResults contains results of the LedgerServiceClient.SearchTransactionEntries
type LedgerServiceClientMockSearchTransactionEntriesResults struct {
	pp2 *connect.ServerStreamForClient[v11.SearchTransactionEntriesResponse]
	err error
}

// LedgerServiceClientMockSearchTransactionEntriesOrigins contains origins of expectations of the LedgerServiceClient.SearchTransactionEntries
type LedgerServiceClientMockSearchTransactionEntriesExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Optional() *mLedgerServiceClientMockSearchTransactionEntries {
	mmSearchTransactionEntries.optional = true
	return mmSearchTransactionEntries
}

// Expect sets up expected params for LedgerServiceClient.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceClientMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by ExpectParams functions")
	}

	mmSearchTransactionEntries.defaultExpectation.params = &LedgerServiceClientMockSearchTransactionEntriesParams{ctx, pp1}
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchTransactionEntries.expectations {
		if minimock.Equal(e.params, mmSearchTransactionEntries.defaultExpectation.params) {
			mmSearchTransactionEntries.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchTransactionEntries.defaultExpectation.params)
		}
	}

	return mmSearchTransactionEntries
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceClientMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.params != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Expect")
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs == nil {
		mmSearchTransactionEntries.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchTransactionEntriesParamPtrs{}
	}
	mmSearchTransactionEntries.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchTransactionEntries
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceClientMockSearchTransactionEntriesExpectation{}
	}

	if mmSearchTransactionEntries.defaultExpectation.params != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Expect")
	}

	if mmSearchTransactionEntries.defaultExpectation.paramPtrs == nil {
		mmSearchTransactionEntries.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchTransactionEntriesParamPtrs{}
	}
	mmSearchTransactionEntries.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchTransactionEntries.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchTransactionEntries
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])) *mLedgerServiceClientMockSearchTransactionEntries {
	if mmSearchTransactionEntries.mock.inspectFuncSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.SearchTransactionEntries")
	}

	mmSearchTransactionEntries.mock.inspectFuncSearchTransactionEntries = f

	return mmSearchTransactionEntries
}

// Return sets up results that will be returned by LedgerServiceClient.SearchTransactionEntries
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Return(pp2 *connect.ServerStreamForClient[v11.SearchTransactionEntriesResponse], err error) *LedgerServiceClientMock {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Set")
	}

	if mmSearchTransactionEntries.defaultExpectation == nil {
		mmSearchTransactionEntries.defaultExpectation = &LedgerServiceClientMockSearchTransactionEntriesExpectation{mock: mmSearchTransactionEntries.mock}
	}
	mmSearchTransactionEntries.defaultExpectation.results = &LedgerServiceClientMockSearchTransactionEntriesResults{pp2, err}
	mmSearchTransactionEntries.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchTransactionEntries.mock
}

// Set uses given function f to mock the LedgerServiceClient.SearchTransactionEntries method
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchTransactionEntriesResponse], err error)) *LedgerServiceClientMock {
	if mmSearchTransactionEntries.defaultExpectation != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.SearchTransactionEntries method")
	}

	if len(mmSearchTransactionEntries.expectations) > 0 {
		mmSearchTransactionEntries.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.SearchTransactionEntries method")
	}

	mmSearchTransactionEntries.mock.funcSearchTransactionEntries = f
	mmSearchTransactionEntries.mock.funcSearchTransactionEntriesOrigin = minimock.CallerInfo(1)
	return mmSearchTransactionEntries.mock
}

// When sets expectation for the LedgerServiceClient.SearchTransactionEntries which will trigger the result defined by the following
// Then helper
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *LedgerServiceClientMockSearchTransactionEntriesExpectation {
	if mmSearchTransactionEntries.mock.funcSearchTransactionEntries != nil {
		mmSearchTransactionEntries.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactionEntries mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockSearchTransactionEntriesExpectation{
		mock:               mmSearchTransactionEntries.mock,
		params:             &LedgerServiceClientMockSearchTransactionEntriesParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockSearchTransactionEntriesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchTransactionEntries.expectations = append(mmSearchTransactionEntries.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.SearchTransactionEntries return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockSearchTransactionEntriesExpectation) Then(pp2 *connect.ServerStreamForClient[v11.SearchTransactionEntriesResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockSearchTransactionEntriesResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.SearchTransactionEntries should be invoked
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Times(n uint64) *mLedgerServiceClientMockSearchTransactionEntries {
	if n == 0 {
		mmSearchTransactionEntries.mock.t.Fatalf("Times of LedgerServiceClientMock.SearchTransactionEntries mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchTransactionEntries.expectedInvocations, n)
	mmSearchTransactionEntries.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchTransactionEntries
}

func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) invocationsDone() bool {
	if len(mmSearchTransactionEntries.expectations) == 0 && mmSearchTransactionEntries.defaultExpectation == nil && mmSearchTransactionEntries.mock.funcSearchTransactionEntries == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchTransactionEntries.mock.afterSearchTransactionEntriesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchTransactionEntries.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchTransactionEntries implements mm_ledgerv1connect.LedgerServiceClient
func (mmSearchTransactionEntries *LedgerServiceClientMock) SearchTransactionEntries(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchTransactionEntriesResponse], err error) {
	mm_atomic.AddUint64(&mmSearchTransactionEntries.beforeSearchTransactionEntriesCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchTransactionEntries.afterSearchTransactionEntriesCounter, 1)

	mmSearchTransactionEntries.t.Helper()

	if mmSearchTransactionEntries.inspectFuncSearchTransactionEntries != nil {
		mmSearchTransactionEntries.inspectFuncSearchTransactionEntries(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockSearchTransactionEntriesParams{ctx, pp1}

	// Record call args
	mmSearchTransactionEntries.SearchTransactionEntriesMock.mutex.Lock()
	mmSearchTransactionEntries.SearchTransactionEntriesMock.callArgs = append(mmSearchTransactionEntries.SearchTransactionEntriesMock.callArgs, &mm_params)
	mmSearchTransactionEntries.SearchTransactionEntriesMock.mutex.Unlock()

	for _, e := range mmSearchTransactionEntries.SearchTransactionEntriesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.params
		mm_want_ptrs := mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockSearchTransactionEntriesParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchTransactionEntries.t.Errorf("LedgerServiceClientMock.SearchTransactionEntries got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchTransactionEntries.t.Errorf("LedgerServiceClientMock.SearchTransactionEntries got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchTransactionEntries.t.Errorf("LedgerServiceClientMock.SearchTransactionEntries got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchTransactionEntries.SearchTransactionEntriesMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchTransactionEntries.t.Fatal("No results are set for the LedgerServiceClientMock.SearchTransactionEntries")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchTransactionEntries.funcSearchTransactionEntries != nil {
		return mmSearchTransactionEntries.funcSearchTransactionEntries(ctx, pp1)
	}
	mmSearchTransactionEntries.t.Fatalf("Unexpected call to LedgerServiceClientMock.SearchTransactionEntries. %v %v", ctx, pp1)
	return
}

// SearchTransactionEntriesAfterCounter returns a count of finished LedgerServiceClientMock.SearchTransactionEntries invocations
func (mmSearchTransactionEntries *LedgerServiceClientMock) SearchTransactionEntriesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactionEntries.afterSearchTransactionEntriesCounter)
}

// SearchTransactionEntriesBeforeCounter returns a count of LedgerServiceClientMock.SearchTransactionEntries invocations
func (mmSearchTransactionEntries *LedgerServiceClientMock) SearchTransactionEntriesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactionEntries.beforeSearchTransactionEntriesCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.SearchTransactionEntries.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchTransactionEntries *mLedgerServiceClientMockSearchTransactionEntries) Calls() []*LedgerServiceClientMockSearchTransactionEntriesParams {
	mmSearchTransactionEntries.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockSearchTransactionEntriesParams, len(mmSearchTransactionEntries.callArgs))
	copy(argCopy, mmSearchTransactionEntries.callArgs)

	mmSearchTransactionEntries.mutex.RUnlock()

	return argCopy
}

// MinimockSearchTransactionEntriesDone returns true if the count of the SearchTransactionEntries invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockSearchTransactionEntriesDone() bool {
	if m.SearchTransactionEntriesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchTransactionEntriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchTransactionEntriesMock.invocationsDone()
}

// MinimockSearchTransactionEntriesInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockSearchTransactionEntriesInspect() {
	for _, e := range m.SearchTransactionEntriesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactionEntries at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchTransactionEntriesCounter := mm_atomic.LoadUint64(&m.afterSearchTransactionEntriesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchTransactionEntriesMock.defaultExpectation != nil && afterSearchTransactionEntriesCounter < 1 {
		if m.SearchTransactionEntriesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactionEntries at\n%s", m.SearchTransactionEntriesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactionEntries at\n%s with params: %#v", m.SearchTransactionEntriesMock.defaultExpectation.expectationOrigins.origin, *m.SearchTransactionEntriesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchTransactionEntries != nil && afterSearchTransactionEntriesCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactionEntries at\n%s", m.funcSearchTransactionEntriesOrigin)
	}

	if !m.SearchTransactionEntriesMock.invocationsDone() && afterSearchTransactionEntriesCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.SearchTransactionEntries at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchTransactionEntriesMock.expectedInvocations), m.SearchTransactionEntriesMock.expectedInvocationsOrigin, afterSearchTransactionEntriesCounter)
	}
}

type mLedgerServiceClientMockSearchTransactions struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockSearchTransactionsExpectation
	expectations       []*LedgerServiceClientMockSearchTransactionsExpectation

	callArgs []*LedgerServiceClientMockSearchTransactionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockSearchTransactionsExpectation specifies expectation struct of the LedgerServiceClient.SearchTransactions
type LedgerServiceClientMockSearchTransactionsExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockSearchTransactionsParams
	paramPtrs          *LedgerServiceClientMockSearchTransactionsParamPtrs
	expectationOrigins LedgerServiceClientMockSearchTransactionsExpectationOrigins
	results            *LedgerServiceClientMockSearchTransactionsResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockSearchTransactionsParams contains parameters of the LedgerServiceClient.SearchTransactions
type LedgerServiceClientMockSearchTransactionsParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchTransactionsParamPtrs contains pointers to parameters of the LedgerServiceClient.SearchTransactions
type LedgerServiceClientMockSearchTransactionsParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchRequest]
}

// LedgerServiceClientMockSearchTransactionsResults contains results of the LedgerServiceClient.SearchTransactions
type LedgerServiceClientMockSearchTransactionsResults struct {
	pp2 *connect.ServerStreamForClient[v11.SearchTransactionsResponse]
	err error
}

// LedgerServiceClientMockSearchTransactionsOrigins contains origins of expectations of the LedgerServiceClient.SearchTransactions
type LedgerServiceClientMockSearchTransactionsExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Optional() *mLedgerServiceClientMockSearchTransactions {
	mmSearchTransactions.optional = true
	return mmSearchTransactions
}

// Expect sets up expected params for LedgerServiceClient.SearchTransactions
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceClientMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by ExpectParams functions")
	}

	mmSearchTransactions.defaultExpectation.params = &LedgerServiceClientMockSearchTransactionsParams{ctx, pp1}
	mmSearchTransactions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchTransactions.expectations {
		if minimock.Equal(e.params, mmSearchTransactions.defaultExpectation.params) {
			mmSearchTransactions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchTransactions.defaultExpectation.params)
		}
	}

	return mmSearchTransactions
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.SearchTransactions
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceClientMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.params != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Expect")
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs == nil {
		mmSearchTransactions.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchTransactionsParamPtrs{}
	}
	mmSearchTransactions.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchTransactions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchTransactions
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.SearchTransactions
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) ExpectPp1Param2(pp1 *connect.Request[v1.SearchRequest]) *mLedgerServiceClientMockSearchTransactions {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceClientMockSearchTransactionsExpectation{}
	}

	if mmSearchTransactions.defaultExpectation.params != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Expect")
	}

	if mmSearchTransactions.defaultExpectation.paramPtrs == nil {
		mmSearchTransactions.defaultExpectation.paramPtrs = &LedgerServiceClientMockSearchTransactionsParamPtrs{}
	}
	mmSearchTransactions.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchTransactions.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchTransactions
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.SearchTransactions
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest])) *mLedgerServiceClientMockSearchTransactions {
	if mmSearchTransactions.mock.inspectFuncSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.SearchTransactions")
	}

	mmSearchTransactions.mock.inspectFuncSearchTransactions = f

	return mmSearchTransactions
}

// Return sets up results that will be returned by LedgerServiceClient.SearchTransactions
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Return(pp2 *connect.ServerStreamForClient[v11.SearchTransactionsResponse], err error) *LedgerServiceClientMock {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Set")
	}

	if mmSearchTransactions.defaultExpectation == nil {
		mmSearchTransactions.defaultExpectation = &LedgerServiceClientMockSearchTransactionsExpectation{mock: mmSearchTransactions.mock}
	}
	mmSearchTransactions.defaultExpectation.results = &LedgerServiceClientMockSearchTransactionsResults{pp2, err}
	mmSearchTransactions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchTransactions.mock
}

// Set uses given function f to mock the LedgerServiceClient.SearchTransactions method
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchTransactionsResponse], err error)) *LedgerServiceClientMock {
	if mmSearchTransactions.defaultExpectation != nil {
		mmSearchTransactions.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.SearchTransactions method")
	}

	if len(mmSearchTransactions.expectations) > 0 {
		mmSearchTransactions.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.SearchTransactions method")
	}

	mmSearchTransactions.mock.funcSearchTransactions = f
	mmSearchTransactions.mock.funcSearchTransactionsOrigin = minimock.CallerInfo(1)
	return mmSearchTransactions.mock
}

// When sets expectation for the LedgerServiceClient.SearchTransactions which will trigger the result defined by the following
// Then helper
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) When(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) *LedgerServiceClientMockSearchTransactionsExpectation {
	if mmSearchTransactions.mock.funcSearchTransactions != nil {
		mmSearchTransactions.mock.t.Fatalf("LedgerServiceClientMock.SearchTransactions mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockSearchTransactionsExpectation{
		mock:               mmSearchTransactions.mock,
		params:             &LedgerServiceClientMockSearchTransactionsParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockSearchTransactionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchTransactions.expectations = append(mmSearchTransactions.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.SearchTransactions return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockSearchTransactionsExpectation) Then(pp2 *connect.ServerStreamForClient[v11.SearchTransactionsResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockSearchTransactionsResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.SearchTransactions should be invoked
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Times(n uint64) *mLedgerServiceClientMockSearchTransactions {
	if n == 0 {
		mmSearchTransactions.mock.t.Fatalf("Times of LedgerServiceClientMock.SearchTransactions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchTransactions.expectedInvocations, n)
	mmSearchTransactions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchTransactions
}

func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) invocationsDone() bool {
	if len(mmSearchTransactions.expectations) == 0 && mmSearchTransactions.defaultExpectation == nil && mmSearchTransactions.mock.funcSearchTransactions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchTransactions.mock.afterSearchTransactionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchTransactions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchTransactions implements mm_ledgerv1connect.LedgerServiceClient
func (mmSearchTransactions *LedgerServiceClientMock) SearchTransactions(ctx context.Context, pp1 *connect.Request[v1.SearchRequest]) (pp2 *connect.ServerStreamForClient[v11.SearchTransactionsResponse], err error) {
	mm_atomic.AddUint64(&mmSearchTransactions.beforeSearchTransactionsCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchTransactions.afterSearchTransactionsCounter, 1)

	mmSearchTransactions.t.Helper()

	if mmSearchTransactions.inspectFuncSearchTransactions != nil {
		mmSearchTransactions.inspectFuncSearchTransactions(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockSearchTransactionsParams{ctx, pp1}

	// Record call args
	mmSearchTransactions.SearchTransactionsMock.mutex.Lock()
	mmSearchTransactions.SearchTransactionsMock.callArgs = append(mmSearchTransactions.SearchTransactionsMock.callArgs, &mm_params)
	mmSearchTransactions.SearchTransactionsMock.mutex.Unlock()

	for _, e := range mmSearchTransactions.SearchTransactionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchTransactions.SearchTransactionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchTransactions.SearchTransactionsMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchTransactions.SearchTransactionsMock.defaultExpectation.params
		mm_want_ptrs := mmSearchTransactions.SearchTransactionsMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockSearchTransactionsParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchTransactions.t.Errorf("LedgerServiceClientMock.SearchTransactions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchTransactions.t.Errorf("LedgerServiceClientMock.SearchTransactions got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchTransactions.t.Errorf("LedgerServiceClientMock.SearchTransactions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchTransactions.SearchTransactionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchTransactions.SearchTransactionsMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchTransactions.t.Fatal("No results are set for the LedgerServiceClientMock.SearchTransactions")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchTransactions.funcSearchTransactions != nil {
		return mmSearchTransactions.funcSearchTransactions(ctx, pp1)
	}
	mmSearchTransactions.t.Fatalf("Unexpected call to LedgerServiceClientMock.SearchTransactions. %v %v", ctx, pp1)
	return
}

// SearchTransactionsAfterCounter returns a count of finished LedgerServiceClientMock.SearchTransactions invocations
func (mmSearchTransactions *LedgerServiceClientMock) SearchTransactionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactions.afterSearchTransactionsCounter)
}

// SearchTransactionsBeforeCounter returns a count of LedgerServiceClientMock.SearchTransactions invocations
func (mmSearchTransactions *LedgerServiceClientMock) SearchTransactionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchTransactions.beforeSearchTransactionsCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.SearchTransactions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchTransactions *mLedgerServiceClientMockSearchTransactions) Calls() []*LedgerServiceClientMockSearchTransactionsParams {
	mmSearchTransactions.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockSearchTransactionsParams, len(mmSearchTransactions.callArgs))
	copy(argCopy, mmSearchTransactions.callArgs)

	mmSearchTransactions.mutex.RUnlock()

	return argCopy
}

// MinimockSearchTransactionsDone returns true if the count of the SearchTransactions invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockSearchTransactionsDone() bool {
	if m.SearchTransactionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchTransactionsMock.invocationsDone()
}

// MinimockSearchTransactionsInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockSearchTransactionsInspect() {
	for _, e := range m.SearchTransactionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchTransactionsCounter := mm_atomic.LoadUint64(&m.afterSearchTransactionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchTransactionsMock.defaultExpectation != nil && afterSearchTransactionsCounter < 1 {
		if m.SearchTransactionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactions at\n%s", m.SearchTransactionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactions at\n%s with params: %#v", m.SearchTransactionsMock.defaultExpectation.expectationOrigins.origin, *m.SearchTransactionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchTransactions != nil && afterSearchTransactionsCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.SearchTransactions at\n%s", m.funcSearchTransactionsOrigin)
	}

	if !m.SearchTransactionsMock.invocationsDone() && afterSearchTransactionsCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.SearchTransactions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchTransactionsMock.expectedInvocations), m.SearchTransactionsMock.expectedInvocationsOrigin, afterSearchTransactionsCounter)
	}
}

type mLedgerServiceClientMockUpdateAccount struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockUpdateAccountExpectation
	expectations       []*LedgerServiceClientMockUpdateAccountExpectation

	callArgs []*LedgerServiceClientMockUpdateAccountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockUpdateAccountExpectation specifies expectation struct of the LedgerServiceClient.UpdateAccount
type LedgerServiceClientMockUpdateAccountExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockUpdateAccountParams
	paramPtrs          *LedgerServiceClientMockUpdateAccountParamPtrs
	expectationOrigins LedgerServiceClientMockUpdateAccountExpectationOrigins
	results            *LedgerServiceClientMockUpdateAccountResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockUpdateAccountParams contains parameters of the LedgerServiceClient.UpdateAccount
type LedgerServiceClientMockUpdateAccountParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.UpdateAccountRequest]
}

// LedgerServiceClientMockUpdateAccountParamPtrs contains pointers to parameters of the LedgerServiceClient.UpdateAccount
type LedgerServiceClientMockUpdateAccountParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.UpdateAccountRequest]
}

// LedgerServiceClientMockUpdateAccountResults contains results of the LedgerServiceClient.UpdateAccount
type LedgerServiceClientMockUpdateAccountResults struct {
	pp2 *connect.Response[v11.UpdateAccountResponse]
	err error
}

// LedgerServiceClientMockUpdateAccountOrigins contains origins of expectations of the LedgerServiceClient.UpdateAccount
type LedgerServiceClientMockUpdateAccountExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Optional() *mLedgerServiceClientMockUpdateAccount {
	mmUpdateAccount.optional = true
	return mmUpdateAccount
}

// Expect sets up expected params for LedgerServiceClient.UpdateAccount
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Expect(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest]) *mLedgerServiceClientMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceClientMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by ExpectParams functions")
	}

	mmUpdateAccount.defaultExpectation.params = &LedgerServiceClientMockUpdateAccountParams{ctx, pp1}
	mmUpdateAccount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateAccount.expectations {
		if minimock.Equal(e.params, mmUpdateAccount.defaultExpectation.params) {
			mmUpdateAccount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAccount.defaultExpectation.params)
		}
	}

	return mmUpdateAccount
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.UpdateAccount
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceClientMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.params != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Expect")
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs == nil {
		mmUpdateAccount.defaultExpectation.paramPtrs = &LedgerServiceClientMockUpdateAccountParamPtrs{}
	}
	mmUpdateAccount.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateAccount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateAccount
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.UpdateAccount
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) ExpectPp1Param2(pp1 *connect.Request[v11.UpdateAccountRequest]) *mLedgerServiceClientMockUpdateAccount {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceClientMockUpdateAccountExpectation{}
	}

	if mmUpdateAccount.defaultExpectation.params != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Expect")
	}

	if mmUpdateAccount.defaultExpectation.paramPtrs == nil {
		mmUpdateAccount.defaultExpectation.paramPtrs = &LedgerServiceClientMockUpdateAccountParamPtrs{}
	}
	mmUpdateAccount.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateAccount.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateAccount
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.UpdateAccount
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest])) *mLedgerServiceClientMockUpdateAccount {
	if mmUpdateAccount.mock.inspectFuncUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.UpdateAccount")
	}

	mmUpdateAccount.mock.inspectFuncUpdateAccount = f

	return mmUpdateAccount
}

// Return sets up results that will be returned by LedgerServiceClient.UpdateAccount
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Return(pp2 *connect.Response[v11.UpdateAccountResponse], err error) *LedgerServiceClientMock {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Set")
	}

	if mmUpdateAccount.defaultExpectation == nil {
		mmUpdateAccount.defaultExpectation = &LedgerServiceClientMockUpdateAccountExpectation{mock: mmUpdateAccount.mock}
	}
	mmUpdateAccount.defaultExpectation.results = &LedgerServiceClientMockUpdateAccountResults{pp2, err}
	mmUpdateAccount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount.mock
}

// Set uses given function f to mock the LedgerServiceClient.UpdateAccount method
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Set(f func(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest]) (pp2 *connect.Response[v11.UpdateAccountResponse], err error)) *LedgerServiceClientMock {
	if mmUpdateAccount.defaultExpectation != nil {
		mmUpdateAccount.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.UpdateAccount method")
	}

	if len(mmUpdateAccount.expectations) > 0 {
		mmUpdateAccount.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.UpdateAccount method")
	}

	mmUpdateAccount.mock.funcUpdateAccount = f
	mmUpdateAccount.mock.funcUpdateAccountOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount.mock
}

// When sets expectation for the LedgerServiceClient.UpdateAccount which will trigger the result defined by the following
// Then helper
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) When(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest]) *LedgerServiceClientMockUpdateAccountExpectation {
	if mmUpdateAccount.mock.funcUpdateAccount != nil {
		mmUpdateAccount.mock.t.Fatalf("LedgerServiceClientMock.UpdateAccount mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockUpdateAccountExpectation{
		mock:               mmUpdateAccount.mock,
		params:             &LedgerServiceClientMockUpdateAccountParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockUpdateAccountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateAccount.expectations = append(mmUpdateAccount.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.UpdateAccount return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockUpdateAccountExpectation) Then(pp2 *connect.Response[v11.UpdateAccountResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockUpdateAccountResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.UpdateAccount should be invoked
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Times(n uint64) *mLedgerServiceClientMockUpdateAccount {
	if n == 0 {
		mmUpdateAccount.mock.t.Fatalf("Times of LedgerServiceClientMock.UpdateAccount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateAccount.expectedInvocations, n)
	mmUpdateAccount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateAccount
}

func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) invocationsDone() bool {
	if len(mmUpdateAccount.expectations) == 0 && mmUpdateAccount.defaultExpectation == nil && mmUpdateAccount.mock.funcUpdateAccount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateAccount.mock.afterUpdateAccountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateAccount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateAccount implements mm_ledgerv1connect.LedgerServiceClient
func (mmUpdateAccount *LedgerServiceClientMock) UpdateAccount(ctx context.Context, pp1 *connect.Request[v11.UpdateAccountRequest]) (pp2 *connect.Response[v11.UpdateAccountResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateAccount.beforeUpdateAccountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAccount.afterUpdateAccountCounter, 1)

	mmUpdateAccount.t.Helper()

	if mmUpdateAccount.inspectFuncUpdateAccount != nil {
		mmUpdateAccount.inspectFuncUpdateAccount(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockUpdateAccountParams{ctx, pp1}

	// Record call args
	mmUpdateAccount.UpdateAccountMock.mutex.Lock()
	mmUpdateAccount.UpdateAccountMock.callArgs = append(mmUpdateAccount.UpdateAccountMock.callArgs, &mm_params)
	mmUpdateAccount.UpdateAccountMock.mutex.Unlock()

	for _, e := range mmUpdateAccount.UpdateAccountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateAccount.UpdateAccountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAccount.UpdateAccountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAccount.UpdateAccountMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateAccount.UpdateAccountMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockUpdateAccountParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateAccount.t.Errorf("LedgerServiceClientMock.UpdateAccount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateAccount.t.Errorf("LedgerServiceClientMock.UpdateAccount got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAccount.t.Errorf("LedgerServiceClientMock.UpdateAccount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateAccount.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAccount.UpdateAccountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAccount.t.Fatal("No results are set for the LedgerServiceClientMock.UpdateAccount")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateAccount.funcUpdateAccount != nil {
		return mmUpdateAccount.funcUpdateAccount(ctx, pp1)
	}
	mmUpdateAccount.t.Fatalf("Unexpected call to LedgerServiceClientMock.UpdateAccount. %v %v", ctx, pp1)
	return
}

// UpdateAccountAfterCounter returns a count of finished LedgerServiceClientMock.UpdateAccount invocations
func (mmUpdateAccount *LedgerServiceClientMock) UpdateAccountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccount.afterUpdateAccountCounter)
}

// UpdateAccountBeforeCounter returns a count of LedgerServiceClientMock.UpdateAccount invocations
func (mmUpdateAccount *LedgerServiceClientMock) UpdateAccountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccount.beforeUpdateAccountCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.UpdateAccount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAccount *mLedgerServiceClientMockUpdateAccount) Calls() []*LedgerServiceClientMockUpdateAccountParams {
	mmUpdateAccount.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockUpdateAccountParams, len(mmUpdateAccount.callArgs))
	copy(argCopy, mmUpdateAccount.callArgs)

	mmUpdateAccount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAccountDone returns true if the count of the UpdateAccount invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockUpdateAccountDone() bool {
	if m.UpdateAccountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateAccountMock.invocationsDone()
}

// MinimockUpdateAccountInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockUpdateAccountInspect() {
	for _, e := range m.UpdateAccountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateAccount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateAccountCounter := mm_atomic.LoadUint64(&m.afterUpdateAccountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccountMock.defaultExpectation != nil && afterUpdateAccountCounter < 1 {
		if m.UpdateAccountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateAccount at\n%s", m.UpdateAccountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateAccount at\n%s with params: %#v", m.UpdateAccountMock.defaultExpectation.expectationOrigins.origin, *m.UpdateAccountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccount != nil && afterUpdateAccountCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateAccount at\n%s", m.funcUpdateAccountOrigin)
	}

	if !m.UpdateAccountMock.invocationsDone() && afterUpdateAccountCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.UpdateAccount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateAccountMock.expectedInvocations), m.UpdateAccountMock.expectedInvocationsOrigin, afterUpdateAccountCounter)
	}
}

type mLedgerServiceClientMockUpdateLedger struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockUpdateLedgerExpectation
	expectations       []*LedgerServiceClientMockUpdateLedgerExpectation

	callArgs []*LedgerServiceClientMockUpdateLedgerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockUpdateLedgerExpectation specifies expectation struct of the LedgerServiceClient.UpdateLedger
type LedgerServiceClientMockUpdateLedgerExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockUpdateLedgerParams
	paramPtrs          *LedgerServiceClientMockUpdateLedgerParamPtrs
	expectationOrigins LedgerServiceClientMockUpdateLedgerExpectationOrigins
	results            *LedgerServiceClientMockUpdateLedgerResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockUpdateLedgerParams contains parameters of the LedgerServiceClient.UpdateLedger
type LedgerServiceClientMockUpdateLedgerParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.UpdateLedgerRequest]
}

// LedgerServiceClientMockUpdateLedgerParamPtrs contains pointers to parameters of the LedgerServiceClient.UpdateLedger
type LedgerServiceClientMockUpdateLedgerParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.UpdateLedgerRequest]
}

// LedgerServiceClientMockUpdateLedgerResults contains results of the LedgerServiceClient.UpdateLedger
type LedgerServiceClientMockUpdateLedgerResults struct {
	pp2 *connect.Response[v11.UpdateLedgerResponse]
	err error
}

// LedgerServiceClientMockUpdateLedgerOrigins contains origins of expectations of the LedgerServiceClient.UpdateLedger
type LedgerServiceClientMockUpdateLedgerExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Optional() *mLedgerServiceClientMockUpdateLedger {
	mmUpdateLedger.optional = true
	return mmUpdateLedger
}

// Expect sets up expected params for LedgerServiceClient.UpdateLedger
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Expect(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest]) *mLedgerServiceClientMockUpdateLedger {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceClientMockUpdateLedgerExpectation{}
	}

	if mmUpdateLedger.defaultExpectation.paramPtrs != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by ExpectParams functions")
	}

	mmUpdateLedger.defaultExpectation.params = &LedgerServiceClientMockUpdateLedgerParams{ctx, pp1}
	mmUpdateLedger.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateLedger.expectations {
		if minimock.Equal(e.params, mmUpdateLedger.defaultExpectation.params) {
			mmUpdateLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateLedger.defaultExpectation.params)
		}
	}

	return mmUpdateLedger
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.UpdateLedger
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockUpdateLedger {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceClientMockUpdateLedgerExpectation{}
	}

	if mmUpdateLedger.defaultExpectation.params != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Expect")
	}

	if mmUpdateLedger.defaultExpectation.paramPtrs == nil {
		mmUpdateLedger.defaultExpectation.paramPtrs = &LedgerServiceClientMockUpdateLedgerParamPtrs{}
	}
	mmUpdateLedger.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateLedger.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateLedger
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.UpdateLedger
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) ExpectPp1Param2(pp1 *connect.Request[v11.UpdateLedgerRequest]) *mLedgerServiceClientMockUpdateLedger {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceClientMockUpdateLedgerExpectation{}
	}

	if mmUpdateLedger.defaultExpectation.params != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Expect")
	}

	if mmUpdateLedger.defaultExpectation.paramPtrs == nil {
		mmUpdateLedger.defaultExpectation.paramPtrs = &LedgerServiceClientMockUpdateLedgerParamPtrs{}
	}
	mmUpdateLedger.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateLedger.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateLedger
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.UpdateLedger
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest])) *mLedgerServiceClientMockUpdateLedger {
	if mmUpdateLedger.mock.inspectFuncUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.UpdateLedger")
	}

	mmUpdateLedger.mock.inspectFuncUpdateLedger = f

	return mmUpdateLedger
}

// Return sets up results that will be returned by LedgerServiceClient.UpdateLedger
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Return(pp2 *connect.Response[v11.UpdateLedgerResponse], err error) *LedgerServiceClientMock {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Set")
	}

	if mmUpdateLedger.defaultExpectation == nil {
		mmUpdateLedger.defaultExpectation = &LedgerServiceClientMockUpdateLedgerExpectation{mock: mmUpdateLedger.mock}
	}
	mmUpdateLedger.defaultExpectation.results = &LedgerServiceClientMockUpdateLedgerResults{pp2, err}
	mmUpdateLedger.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateLedger.mock
}

// Set uses given function f to mock the LedgerServiceClient.UpdateLedger method
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Set(f func(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest]) (pp2 *connect.Response[v11.UpdateLedgerResponse], err error)) *LedgerServiceClientMock {
	if mmUpdateLedger.defaultExpectation != nil {
		mmUpdateLedger.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.UpdateLedger method")
	}

	if len(mmUpdateLedger.expectations) > 0 {
		mmUpdateLedger.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.UpdateLedger method")
	}

	mmUpdateLedger.mock.funcUpdateLedger = f
	mmUpdateLedger.mock.funcUpdateLedgerOrigin = minimock.CallerInfo(1)
	return mmUpdateLedger.mock
}

// When sets expectation for the LedgerServiceClient.UpdateLedger which will trigger the result defined by the following
// Then helper
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) When(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest]) *LedgerServiceClientMockUpdateLedgerExpectation {
	if mmUpdateLedger.mock.funcUpdateLedger != nil {
		mmUpdateLedger.mock.t.Fatalf("LedgerServiceClientMock.UpdateLedger mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockUpdateLedgerExpectation{
		mock:               mmUpdateLedger.mock,
		params:             &LedgerServiceClientMockUpdateLedgerParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockUpdateLedgerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateLedger.expectations = append(mmUpdateLedger.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.UpdateLedger return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockUpdateLedgerExpectation) Then(pp2 *connect.Response[v11.UpdateLedgerResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockUpdateLedgerResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.UpdateLedger should be invoked
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Times(n uint64) *mLedgerServiceClientMockUpdateLedger {
	if n == 0 {
		mmUpdateLedger.mock.t.Fatalf("Times of LedgerServiceClientMock.UpdateLedger mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateLedger.expectedInvocations, n)
	mmUpdateLedger.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateLedger
}

func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) invocationsDone() bool {
	if len(mmUpdateLedger.expectations) == 0 && mmUpdateLedger.defaultExpectation == nil && mmUpdateLedger.mock.funcUpdateLedger == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateLedger.mock.afterUpdateLedgerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateLedger.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateLedger implements mm_ledgerv1connect.LedgerServiceClient
func (mmUpdateLedger *LedgerServiceClientMock) UpdateLedger(ctx context.Context, pp1 *connect.Request[v11.UpdateLedgerRequest]) (pp2 *connect.Response[v11.UpdateLedgerResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateLedger.beforeUpdateLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateLedger.afterUpdateLedgerCounter, 1)

	mmUpdateLedger.t.Helper()

	if mmUpdateLedger.inspectFuncUpdateLedger != nil {
		mmUpdateLedger.inspectFuncUpdateLedger(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockUpdateLedgerParams{ctx, pp1}

	// Record call args
	mmUpdateLedger.UpdateLedgerMock.mutex.Lock()
	mmUpdateLedger.UpdateLedgerMock.callArgs = append(mmUpdateLedger.UpdateLedgerMock.callArgs, &mm_params)
	mmUpdateLedger.UpdateLedgerMock.mutex.Unlock()

	for _, e := range mmUpdateLedger.UpdateLedgerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateLedger.UpdateLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateLedger.UpdateLedgerMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateLedger.UpdateLedgerMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateLedger.UpdateLedgerMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockUpdateLedgerParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateLedger.t.Errorf("LedgerServiceClientMock.UpdateLedger got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLedger.UpdateLedgerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateLedger.t.Errorf("LedgerServiceClientMock.UpdateLedger got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateLedger.UpdateLedgerMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateLedger.t.Errorf("LedgerServiceClientMock.UpdateLedger got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateLedger.UpdateLedgerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateLedger.UpdateLedgerMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateLedger.t.Fatal("No results are set for the LedgerServiceClientMock.UpdateLedger")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateLedger.funcUpdateLedger != nil {
		return mmUpdateLedger.funcUpdateLedger(ctx, pp1)
	}
	mmUpdateLedger.t.Fatalf("Unexpected call to LedgerServiceClientMock.UpdateLedger. %v %v", ctx, pp1)
	return
}

// UpdateLedgerAfterCounter returns a count of finished LedgerServiceClientMock.UpdateLedger invocations
func (mmUpdateLedger *LedgerServiceClientMock) UpdateLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLedger.afterUpdateLedgerCounter)
}

// UpdateLedgerBeforeCounter returns a count of LedgerServiceClientMock.UpdateLedger invocations
func (mmUpdateLedger *LedgerServiceClientMock) UpdateLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateLedger.beforeUpdateLedgerCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.UpdateLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateLedger *mLedgerServiceClientMockUpdateLedger) Calls() []*LedgerServiceClientMockUpdateLedgerParams {
	mmUpdateLedger.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockUpdateLedgerParams, len(mmUpdateLedger.callArgs))
	copy(argCopy, mmUpdateLedger.callArgs)

	mmUpdateLedger.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateLedgerDone returns true if the count of the UpdateLedger invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockUpdateLedgerDone() bool {
	if m.UpdateLedgerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateLedgerMock.invocationsDone()
}

// MinimockUpdateLedgerInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockUpdateLedgerInspect() {
	for _, e := range m.UpdateLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateLedger at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateLedgerCounter := mm_atomic.LoadUint64(&m.afterUpdateLedgerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateLedgerMock.defaultExpectation != nil && afterUpdateLedgerCounter < 1 {
		if m.UpdateLedgerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateLedger at\n%s", m.UpdateLedgerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateLedger at\n%s with params: %#v", m.UpdateLedgerMock.defaultExpectation.expectationOrigins.origin, *m.UpdateLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateLedger != nil && afterUpdateLedgerCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateLedger at\n%s", m.funcUpdateLedgerOrigin)
	}

	if !m.UpdateLedgerMock.invocationsDone() && afterUpdateLedgerCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.UpdateLedger at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateLedgerMock.expectedInvocations), m.UpdateLedgerMock.expectedInvocationsOrigin, afterUpdateLedgerCounter)
	}
}

type mLedgerServiceClientMockUpdateTransaction struct {
	optional           bool
	mock               *LedgerServiceClientMock
	defaultExpectation *LedgerServiceClientMockUpdateTransactionExpectation
	expectations       []*LedgerServiceClientMockUpdateTransactionExpectation

	callArgs []*LedgerServiceClientMockUpdateTransactionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LedgerServiceClientMockUpdateTransactionExpectation specifies expectation struct of the LedgerServiceClient.UpdateTransaction
type LedgerServiceClientMockUpdateTransactionExpectation struct {
	mock               *LedgerServiceClientMock
	params             *LedgerServiceClientMockUpdateTransactionParams
	paramPtrs          *LedgerServiceClientMockUpdateTransactionParamPtrs
	expectationOrigins LedgerServiceClientMockUpdateTransactionExpectationOrigins
	results            *LedgerServiceClientMockUpdateTransactionResults
	returnOrigin       string
	Counter            uint64
}

// LedgerServiceClientMockUpdateTransactionParams contains parameters of the LedgerServiceClient.UpdateTransaction
type LedgerServiceClientMockUpdateTransactionParams struct {
	ctx context.Context
	pp1 *connect.Request[v11.UpdateTransactionRequest]
}

// LedgerServiceClientMockUpdateTransactionParamPtrs contains pointers to parameters of the LedgerServiceClient.UpdateTransaction
type LedgerServiceClientMockUpdateTransactionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v11.UpdateTransactionRequest]
}

// LedgerServiceClientMockUpdateTransactionResults contains results of the LedgerServiceClient.UpdateTransaction
type LedgerServiceClientMockUpdateTransactionResults struct {
	pp2 *connect.Response[v11.UpdateTransactionResponse]
	err error
}

// LedgerServiceClientMockUpdateTransactionOrigins contains origins of expectations of the LedgerServiceClient.UpdateTransaction
type LedgerServiceClientMockUpdateTransactionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Optional() *mLedgerServiceClientMockUpdateTransaction {
	mmUpdateTransaction.optional = true
	return mmUpdateTransaction
}

// Expect sets up expected params for LedgerServiceClient.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Expect(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest]) *mLedgerServiceClientMockUpdateTransaction {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceClientMockUpdateTransactionExpectation{}
	}

	if mmUpdateTransaction.defaultExpectation.paramPtrs != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by ExpectParams functions")
	}

	mmUpdateTransaction.defaultExpectation.params = &LedgerServiceClientMockUpdateTransactionParams{ctx, pp1}
	mmUpdateTransaction.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateTransaction.expectations {
		if minimock.Equal(e.params, mmUpdateTransaction.defaultExpectation.params) {
			mmUpdateTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateTransaction.defaultExpectation.params)
		}
	}

	return mmUpdateTransaction
}

// ExpectCtxParam1 sets up expected param ctx for LedgerServiceClient.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) ExpectCtxParam1(ctx context.Context) *mLedgerServiceClientMockUpdateTransaction {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceClientMockUpdateTransactionExpectation{}
	}

	if mmUpdateTransaction.defaultExpectation.params != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Expect")
	}

	if mmUpdateTransaction.defaultExpectation.paramPtrs == nil {
		mmUpdateTransaction.defaultExpectation.paramPtrs = &LedgerServiceClientMockUpdateTransactionParamPtrs{}
	}
	mmUpdateTransaction.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateTransaction.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateTransaction
}

// ExpectPp1Param2 sets up expected param pp1 for LedgerServiceClient.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) ExpectPp1Param2(pp1 *connect.Request[v11.UpdateTransactionRequest]) *mLedgerServiceClientMockUpdateTransaction {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceClientMockUpdateTransactionExpectation{}
	}

	if mmUpdateTransaction.defaultExpectation.params != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Expect")
	}

	if mmUpdateTransaction.defaultExpectation.paramPtrs == nil {
		mmUpdateTransaction.defaultExpectation.paramPtrs = &LedgerServiceClientMockUpdateTransactionParamPtrs{}
	}
	mmUpdateTransaction.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateTransaction.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateTransaction
}

// Inspect accepts an inspector function that has same arguments as the LedgerServiceClient.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Inspect(f func(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest])) *mLedgerServiceClientMockUpdateTransaction {
	if mmUpdateTransaction.mock.inspectFuncUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("Inspect function is already set for LedgerServiceClientMock.UpdateTransaction")
	}

	mmUpdateTransaction.mock.inspectFuncUpdateTransaction = f

	return mmUpdateTransaction
}

// Return sets up results that will be returned by LedgerServiceClient.UpdateTransaction
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Return(pp2 *connect.Response[v11.UpdateTransactionResponse], err error) *LedgerServiceClientMock {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Set")
	}

	if mmUpdateTransaction.defaultExpectation == nil {
		mmUpdateTransaction.defaultExpectation = &LedgerServiceClientMockUpdateTransactionExpectation{mock: mmUpdateTransaction.mock}
	}
	mmUpdateTransaction.defaultExpectation.results = &LedgerServiceClientMockUpdateTransactionResults{pp2, err}
	mmUpdateTransaction.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateTransaction.mock
}

// Set uses given function f to mock the LedgerServiceClient.UpdateTransaction method
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Set(f func(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest]) (pp2 *connect.Response[v11.UpdateTransactionResponse], err error)) *LedgerServiceClientMock {
	if mmUpdateTransaction.defaultExpectation != nil {
		mmUpdateTransaction.mock.t.Fatalf("Default expectation is already set for the LedgerServiceClient.UpdateTransaction method")
	}

	if len(mmUpdateTransaction.expectations) > 0 {
		mmUpdateTransaction.mock.t.Fatalf("Some expectations are already set for the LedgerServiceClient.UpdateTransaction method")
	}

	mmUpdateTransaction.mock.funcUpdateTransaction = f
	mmUpdateTransaction.mock.funcUpdateTransactionOrigin = minimock.CallerInfo(1)
	return mmUpdateTransaction.mock
}

// When sets expectation for the LedgerServiceClient.UpdateTransaction which will trigger the result defined by the following
// Then helper
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) When(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest]) *LedgerServiceClientMockUpdateTransactionExpectation {
	if mmUpdateTransaction.mock.funcUpdateTransaction != nil {
		mmUpdateTransaction.mock.t.Fatalf("LedgerServiceClientMock.UpdateTransaction mock is already set by Set")
	}

	expectation := &LedgerServiceClientMockUpdateTransactionExpectation{
		mock:               mmUpdateTransaction.mock,
		params:             &LedgerServiceClientMockUpdateTransactionParams{ctx, pp1},
		expectationOrigins: LedgerServiceClientMockUpdateTransactionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateTransaction.expectations = append(mmUpdateTransaction.expectations, expectation)
	return expectation
}

// Then sets up LedgerServiceClient.UpdateTransaction return parameters for the expectation previously defined by the When method
func (e *LedgerServiceClientMockUpdateTransactionExpectation) Then(pp2 *connect.Response[v11.UpdateTransactionResponse], err error) *LedgerServiceClientMock {
	e.results = &LedgerServiceClientMockUpdateTransactionResults{pp2, err}
	return e.mock
}

// Times sets number of times LedgerServiceClient.UpdateTransaction should be invoked
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Times(n uint64) *mLedgerServiceClientMockUpdateTransaction {
	if n == 0 {
		mmUpdateTransaction.mock.t.Fatalf("Times of LedgerServiceClientMock.UpdateTransaction mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateTransaction.expectedInvocations, n)
	mmUpdateTransaction.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateTransaction
}

func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) invocationsDone() bool {
	if len(mmUpdateTransaction.expectations) == 0 && mmUpdateTransaction.defaultExpectation == nil && mmUpdateTransaction.mock.funcUpdateTransaction == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateTransaction.mock.afterUpdateTransactionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateTransaction.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateTransaction implements mm_ledgerv1connect.LedgerServiceClient
func (mmUpdateTransaction *LedgerServiceClientMock) UpdateTransaction(ctx context.Context, pp1 *connect.Request[v11.UpdateTransactionRequest]) (pp2 *connect.Response[v11.UpdateTransactionResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateTransaction.beforeUpdateTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateTransaction.afterUpdateTransactionCounter, 1)

	mmUpdateTransaction.t.Helper()

	if mmUpdateTransaction.inspectFuncUpdateTransaction != nil {
		mmUpdateTransaction.inspectFuncUpdateTransaction(ctx, pp1)
	}

	mm_params := LedgerServiceClientMockUpdateTransactionParams{ctx, pp1}

	// Record call args
	mmUpdateTransaction.UpdateTransactionMock.mutex.Lock()
	mmUpdateTransaction.UpdateTransactionMock.callArgs = append(mmUpdateTransaction.UpdateTransactionMock.callArgs, &mm_params)
	mmUpdateTransaction.UpdateTransactionMock.mutex.Unlock()

	for _, e := range mmUpdateTransaction.UpdateTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateTransaction.UpdateTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.paramPtrs

		mm_got := LedgerServiceClientMockUpdateTransactionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateTransaction.t.Errorf("LedgerServiceClientMock.UpdateTransaction got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateTransaction.t.Errorf("LedgerServiceClientMock.UpdateTransaction got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateTransaction.t.Errorf("LedgerServiceClientMock.UpdateTransaction got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateTransaction.UpdateTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateTransaction.t.Fatal("No results are set for the LedgerServiceClientMock.UpdateTransaction")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateTransaction.funcUpdateTransaction != nil {
		return mmUpdateTransaction.funcUpdateTransaction(ctx, pp1)
	}
	mmUpdateTransaction.t.Fatalf("Unexpected call to LedgerServiceClientMock.UpdateTransaction. %v %v", ctx, pp1)
	return
}

// UpdateTransactionAfterCounter returns a count of finished LedgerServiceClientMock.UpdateTransaction invocations
func (mmUpdateTransaction *LedgerServiceClientMock) UpdateTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTransaction.afterUpdateTransactionCounter)
}

// UpdateTransactionBeforeCounter returns a count of LedgerServiceClientMock.UpdateTransaction invocations
func (mmUpdateTransaction *LedgerServiceClientMock) UpdateTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateTransaction.beforeUpdateTransactionCounter)
}

// Calls returns a list of arguments used in each call to LedgerServiceClientMock.UpdateTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateTransaction *mLedgerServiceClientMockUpdateTransaction) Calls() []*LedgerServiceClientMockUpdateTransactionParams {
	mmUpdateTransaction.mutex.RLock()

	argCopy := make([]*LedgerServiceClientMockUpdateTransactionParams, len(mmUpdateTransaction.callArgs))
	copy(argCopy, mmUpdateTransaction.callArgs)

	mmUpdateTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateTransactionDone returns true if the count of the UpdateTransaction invocations corresponds
// the number of defined expectations
func (m *LedgerServiceClientMock) MinimockUpdateTransactionDone() bool {
	if m.UpdateTransactionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateTransactionMock.invocationsDone()
}

// MinimockUpdateTransactionInspect logs each unmet expectation
func (m *LedgerServiceClientMock) MinimockUpdateTransactionInspect() {
	for _, e := range m.UpdateTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateTransaction at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateTransactionCounter := mm_atomic.LoadUint64(&m.afterUpdateTransactionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateTransactionMock.defaultExpectation != nil && afterUpdateTransactionCounter < 1 {
		if m.UpdateTransactionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateTransaction at\n%s", m.UpdateTransactionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateTransaction at\n%s with params: %#v", m.UpdateTransactionMock.defaultExpectation.expectationOrigins.origin, *m.UpdateTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateTransaction != nil && afterUpdateTransactionCounter < 1 {
		m.t.Errorf("Expected call to LedgerServiceClientMock.UpdateTransaction at\n%s", m.funcUpdateTransactionOrigin)
	}

	if !m.UpdateTransactionMock.invocationsDone() && afterUpdateTransactionCounter > 0 {
		m.t.Errorf("Expected %d calls to LedgerServiceClientMock.UpdateTransaction at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateTransactionMock.expectedInvocations), m.UpdateTransactionMock.expectedInvocationsOrigin, afterUpdateTransactionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LedgerServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAccountInspect()

			m.MinimockCreateLedgerInspect()

			m.MinimockCreateTransactionInspect()

			m.MinimockReverseTransactionInspect()

			m.MinimockSearchAccountsInspect()

			m.MinimockSearchLedgersInspect()

			m.MinimockSearchTransactionEntriesInspect()

			m.MinimockSearchTransactionsInspect()

			m.MinimockUpdateAccountInspect()

			m.MinimockUpdateLedgerInspect()

			m.MinimockUpdateTransactionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LedgerServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LedgerServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAccountDone() &&
		m.MinimockCreateLedgerDone() &&
		m.MinimockCreateTransactionDone() &&
		m.MinimockReverseTransactionDone() &&
		m.MinimockSearchAccountsDone() &&
		m.MinimockSearchLedgersDone() &&
		m.MinimockSearchTransactionEntriesDone() &&
		m.MinimockSearchTransactionsDone() &&
		m.MinimockUpdateAccountDone() &&
		m.MinimockUpdateLedgerDone() &&
		m.MinimockUpdateTransactionDone()
}
