// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"buf.build/gen/go/antinvestor/property/connectrpc/go/property/v1/propertyv1connect"
	propertyv1 "buf.build/gen/go/antinvestor/property/protocolbuffers/go/property/v1"
	"connectrpc.com/connect"
)

type FakePropertyServiceHandler struct {
	AddLocalityStub        func(context.Context, *connect.Request[propertyv1.AddLocalityRequest]) (*connect.Response[propertyv1.AddLocalityResponse], error)
	addLocalityMutex       sync.RWMutex
	addLocalityArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.AddLocalityRequest]
	}
	addLocalityReturns struct {
		result1 *connect.Response[propertyv1.AddLocalityResponse]
		result2 error
	}
	addLocalityReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.AddLocalityResponse]
		result2 error
	}
	AddPropertyTypeStub        func(context.Context, *connect.Request[propertyv1.AddPropertyTypeRequest]) (*connect.Response[propertyv1.AddPropertyTypeResponse], error)
	addPropertyTypeMutex       sync.RWMutex
	addPropertyTypeArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.AddPropertyTypeRequest]
	}
	addPropertyTypeReturns struct {
		result1 *connect.Response[propertyv1.AddPropertyTypeResponse]
		result2 error
	}
	addPropertyTypeReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.AddPropertyTypeResponse]
		result2 error
	}
	AddSubscriptionStub        func(context.Context, *connect.Request[propertyv1.AddSubscriptionRequest]) (*connect.Response[propertyv1.AddSubscriptionResponse], error)
	addSubscriptionMutex       sync.RWMutex
	addSubscriptionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.AddSubscriptionRequest]
	}
	addSubscriptionReturns struct {
		result1 *connect.Response[propertyv1.AddSubscriptionResponse]
		result2 error
	}
	addSubscriptionReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.AddSubscriptionResponse]
		result2 error
	}
	CreatePropertyStub        func(context.Context, *connect.Request[propertyv1.CreatePropertyRequest]) (*connect.Response[propertyv1.CreatePropertyResponse], error)
	createPropertyMutex       sync.RWMutex
	createPropertyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.CreatePropertyRequest]
	}
	createPropertyReturns struct {
		result1 *connect.Response[propertyv1.CreatePropertyResponse]
		result2 error
	}
	createPropertyReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.CreatePropertyResponse]
		result2 error
	}
	DeleteLocalityStub        func(context.Context, *connect.Request[propertyv1.DeleteLocalityRequest]) (*connect.Response[propertyv1.DeleteLocalityResponse], error)
	deleteLocalityMutex       sync.RWMutex
	deleteLocalityArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.DeleteLocalityRequest]
	}
	deleteLocalityReturns struct {
		result1 *connect.Response[propertyv1.DeleteLocalityResponse]
		result2 error
	}
	deleteLocalityReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.DeleteLocalityResponse]
		result2 error
	}
	DeletePropertyStub        func(context.Context, *connect.Request[propertyv1.DeletePropertyRequest]) (*connect.Response[propertyv1.DeletePropertyResponse], error)
	deletePropertyMutex       sync.RWMutex
	deletePropertyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.DeletePropertyRequest]
	}
	deletePropertyReturns struct {
		result1 *connect.Response[propertyv1.DeletePropertyResponse]
		result2 error
	}
	deletePropertyReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.DeletePropertyResponse]
		result2 error
	}
	DeleteSubscriptionStub        func(context.Context, *connect.Request[propertyv1.DeleteSubscriptionRequest]) (*connect.Response[propertyv1.DeleteSubscriptionResponse], error)
	deleteSubscriptionMutex       sync.RWMutex
	deleteSubscriptionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.DeleteSubscriptionRequest]
	}
	deleteSubscriptionReturns struct {
		result1 *connect.Response[propertyv1.DeleteSubscriptionResponse]
		result2 error
	}
	deleteSubscriptionReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.DeleteSubscriptionResponse]
		result2 error
	}
	HistoryOfPropertyStub        func(context.Context, *connect.Request[propertyv1.HistoryOfPropertyRequest], *connect.ServerStream[propertyv1.HistoryOfPropertyResponse]) error
	historyOfPropertyMutex       sync.RWMutex
	historyOfPropertyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.HistoryOfPropertyRequest]
		arg3 *connect.ServerStream[propertyv1.HistoryOfPropertyResponse]
	}
	historyOfPropertyReturns struct {
		result1 error
	}
	historyOfPropertyReturnsOnCall map[int]struct {
		result1 error
	}
	ListPropertyTypeStub        func(context.Context, *connect.Request[propertyv1.ListPropertyTypeRequest], *connect.ServerStream[propertyv1.ListPropertyTypeResponse]) error
	listPropertyTypeMutex       sync.RWMutex
	listPropertyTypeArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.ListPropertyTypeRequest]
		arg3 *connect.ServerStream[propertyv1.ListPropertyTypeResponse]
	}
	listPropertyTypeReturns struct {
		result1 error
	}
	listPropertyTypeReturnsOnCall map[int]struct {
		result1 error
	}
	ListSubscriptionStub        func(context.Context, *connect.Request[propertyv1.ListSubscriptionRequest], *connect.ServerStream[propertyv1.ListSubscriptionResponse]) error
	listSubscriptionMutex       sync.RWMutex
	listSubscriptionArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.ListSubscriptionRequest]
		arg3 *connect.ServerStream[propertyv1.ListSubscriptionResponse]
	}
	listSubscriptionReturns struct {
		result1 error
	}
	listSubscriptionReturnsOnCall map[int]struct {
		result1 error
	}
	SearchPropertyStub        func(context.Context, *connect.Request[propertyv1.SearchPropertyRequest], *connect.ServerStream[propertyv1.SearchPropertyResponse]) error
	searchPropertyMutex       sync.RWMutex
	searchPropertyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.SearchPropertyRequest]
		arg3 *connect.ServerStream[propertyv1.SearchPropertyResponse]
	}
	searchPropertyReturns struct {
		result1 error
	}
	searchPropertyReturnsOnCall map[int]struct {
		result1 error
	}
	StateOfPropertyStub        func(context.Context, *connect.Request[propertyv1.StateOfPropertyRequest]) (*connect.Response[propertyv1.StateOfPropertyResponse], error)
	stateOfPropertyMutex       sync.RWMutex
	stateOfPropertyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.StateOfPropertyRequest]
	}
	stateOfPropertyReturns struct {
		result1 *connect.Response[propertyv1.StateOfPropertyResponse]
		result2 error
	}
	stateOfPropertyReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.StateOfPropertyResponse]
		result2 error
	}
	UpdatePropertyStub        func(context.Context, *connect.Request[propertyv1.UpdatePropertyRequest]) (*connect.Response[propertyv1.UpdatePropertyResponse], error)
	updatePropertyMutex       sync.RWMutex
	updatePropertyArgsForCall []struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.UpdatePropertyRequest]
	}
	updatePropertyReturns struct {
		result1 *connect.Response[propertyv1.UpdatePropertyResponse]
		result2 error
	}
	updatePropertyReturnsOnCall map[int]struct {
		result1 *connect.Response[propertyv1.UpdatePropertyResponse]
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePropertyServiceHandler) AddLocality(arg1 context.Context, arg2 *connect.Request[propertyv1.AddLocalityRequest]) (*connect.Response[propertyv1.AddLocalityResponse], error) {
	fake.addLocalityMutex.Lock()
	ret, specificReturn := fake.addLocalityReturnsOnCall[len(fake.addLocalityArgsForCall)]
	fake.addLocalityArgsForCall = append(fake.addLocalityArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.AddLocalityRequest]
	}{arg1, arg2})
	stub := fake.AddLocalityStub
	fakeReturns := fake.addLocalityReturns
	fake.recordInvocation("AddLocality", []interface{}{arg1, arg2})
	fake.addLocalityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) AddLocalityCallCount() int {
	fake.addLocalityMutex.RLock()
	defer fake.addLocalityMutex.RUnlock()
	return len(fake.addLocalityArgsForCall)
}

func (fake *FakePropertyServiceHandler) AddLocalityCalls(stub func(context.Context, *connect.Request[propertyv1.AddLocalityRequest]) (*connect.Response[propertyv1.AddLocalityResponse], error)) {
	fake.addLocalityMutex.Lock()
	defer fake.addLocalityMutex.Unlock()
	fake.AddLocalityStub = stub
}

func (fake *FakePropertyServiceHandler) AddLocalityArgsForCall(i int) (context.Context, *connect.Request[propertyv1.AddLocalityRequest]) {
	fake.addLocalityMutex.RLock()
	defer fake.addLocalityMutex.RUnlock()
	argsForCall := fake.addLocalityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) AddLocalityReturns(result1 *connect.Response[propertyv1.AddLocalityResponse], result2 error) {
	fake.addLocalityMutex.Lock()
	defer fake.addLocalityMutex.Unlock()
	fake.AddLocalityStub = nil
	fake.addLocalityReturns = struct {
		result1 *connect.Response[propertyv1.AddLocalityResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) AddLocalityReturnsOnCall(i int, result1 *connect.Response[propertyv1.AddLocalityResponse], result2 error) {
	fake.addLocalityMutex.Lock()
	defer fake.addLocalityMutex.Unlock()
	fake.AddLocalityStub = nil
	if fake.addLocalityReturnsOnCall == nil {
		fake.addLocalityReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.AddLocalityResponse]
			result2 error
		})
	}
	fake.addLocalityReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.AddLocalityResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) AddPropertyType(arg1 context.Context, arg2 *connect.Request[propertyv1.AddPropertyTypeRequest]) (*connect.Response[propertyv1.AddPropertyTypeResponse], error) {
	fake.addPropertyTypeMutex.Lock()
	ret, specificReturn := fake.addPropertyTypeReturnsOnCall[len(fake.addPropertyTypeArgsForCall)]
	fake.addPropertyTypeArgsForCall = append(fake.addPropertyTypeArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.AddPropertyTypeRequest]
	}{arg1, arg2})
	stub := fake.AddPropertyTypeStub
	fakeReturns := fake.addPropertyTypeReturns
	fake.recordInvocation("AddPropertyType", []interface{}{arg1, arg2})
	fake.addPropertyTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) AddPropertyTypeCallCount() int {
	fake.addPropertyTypeMutex.RLock()
	defer fake.addPropertyTypeMutex.RUnlock()
	return len(fake.addPropertyTypeArgsForCall)
}

func (fake *FakePropertyServiceHandler) AddPropertyTypeCalls(stub func(context.Context, *connect.Request[propertyv1.AddPropertyTypeRequest]) (*connect.Response[propertyv1.AddPropertyTypeResponse], error)) {
	fake.addPropertyTypeMutex.Lock()
	defer fake.addPropertyTypeMutex.Unlock()
	fake.AddPropertyTypeStub = stub
}

func (fake *FakePropertyServiceHandler) AddPropertyTypeArgsForCall(i int) (context.Context, *connect.Request[propertyv1.AddPropertyTypeRequest]) {
	fake.addPropertyTypeMutex.RLock()
	defer fake.addPropertyTypeMutex.RUnlock()
	argsForCall := fake.addPropertyTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) AddPropertyTypeReturns(result1 *connect.Response[propertyv1.AddPropertyTypeResponse], result2 error) {
	fake.addPropertyTypeMutex.Lock()
	defer fake.addPropertyTypeMutex.Unlock()
	fake.AddPropertyTypeStub = nil
	fake.addPropertyTypeReturns = struct {
		result1 *connect.Response[propertyv1.AddPropertyTypeResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) AddPropertyTypeReturnsOnCall(i int, result1 *connect.Response[propertyv1.AddPropertyTypeResponse], result2 error) {
	fake.addPropertyTypeMutex.Lock()
	defer fake.addPropertyTypeMutex.Unlock()
	fake.AddPropertyTypeStub = nil
	if fake.addPropertyTypeReturnsOnCall == nil {
		fake.addPropertyTypeReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.AddPropertyTypeResponse]
			result2 error
		})
	}
	fake.addPropertyTypeReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.AddPropertyTypeResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) AddSubscription(arg1 context.Context, arg2 *connect.Request[propertyv1.AddSubscriptionRequest]) (*connect.Response[propertyv1.AddSubscriptionResponse], error) {
	fake.addSubscriptionMutex.Lock()
	ret, specificReturn := fake.addSubscriptionReturnsOnCall[len(fake.addSubscriptionArgsForCall)]
	fake.addSubscriptionArgsForCall = append(fake.addSubscriptionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.AddSubscriptionRequest]
	}{arg1, arg2})
	stub := fake.AddSubscriptionStub
	fakeReturns := fake.addSubscriptionReturns
	fake.recordInvocation("AddSubscription", []interface{}{arg1, arg2})
	fake.addSubscriptionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) AddSubscriptionCallCount() int {
	fake.addSubscriptionMutex.RLock()
	defer fake.addSubscriptionMutex.RUnlock()
	return len(fake.addSubscriptionArgsForCall)
}

func (fake *FakePropertyServiceHandler) AddSubscriptionCalls(stub func(context.Context, *connect.Request[propertyv1.AddSubscriptionRequest]) (*connect.Response[propertyv1.AddSubscriptionResponse], error)) {
	fake.addSubscriptionMutex.Lock()
	defer fake.addSubscriptionMutex.Unlock()
	fake.AddSubscriptionStub = stub
}

func (fake *FakePropertyServiceHandler) AddSubscriptionArgsForCall(i int) (context.Context, *connect.Request[propertyv1.AddSubscriptionRequest]) {
	fake.addSubscriptionMutex.RLock()
	defer fake.addSubscriptionMutex.RUnlock()
	argsForCall := fake.addSubscriptionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) AddSubscriptionReturns(result1 *connect.Response[propertyv1.AddSubscriptionResponse], result2 error) {
	fake.addSubscriptionMutex.Lock()
	defer fake.addSubscriptionMutex.Unlock()
	fake.AddSubscriptionStub = nil
	fake.addSubscriptionReturns = struct {
		result1 *connect.Response[propertyv1.AddSubscriptionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) AddSubscriptionReturnsOnCall(i int, result1 *connect.Response[propertyv1.AddSubscriptionResponse], result2 error) {
	fake.addSubscriptionMutex.Lock()
	defer fake.addSubscriptionMutex.Unlock()
	fake.AddSubscriptionStub = nil
	if fake.addSubscriptionReturnsOnCall == nil {
		fake.addSubscriptionReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.AddSubscriptionResponse]
			result2 error
		})
	}
	fake.addSubscriptionReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.AddSubscriptionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) CreateProperty(arg1 context.Context, arg2 *connect.Request[propertyv1.CreatePropertyRequest]) (*connect.Response[propertyv1.CreatePropertyResponse], error) {
	fake.createPropertyMutex.Lock()
	ret, specificReturn := fake.createPropertyReturnsOnCall[len(fake.createPropertyArgsForCall)]
	fake.createPropertyArgsForCall = append(fake.createPropertyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.CreatePropertyRequest]
	}{arg1, arg2})
	stub := fake.CreatePropertyStub
	fakeReturns := fake.createPropertyReturns
	fake.recordInvocation("CreateProperty", []interface{}{arg1, arg2})
	fake.createPropertyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) CreatePropertyCallCount() int {
	fake.createPropertyMutex.RLock()
	defer fake.createPropertyMutex.RUnlock()
	return len(fake.createPropertyArgsForCall)
}

func (fake *FakePropertyServiceHandler) CreatePropertyCalls(stub func(context.Context, *connect.Request[propertyv1.CreatePropertyRequest]) (*connect.Response[propertyv1.CreatePropertyResponse], error)) {
	fake.createPropertyMutex.Lock()
	defer fake.createPropertyMutex.Unlock()
	fake.CreatePropertyStub = stub
}

func (fake *FakePropertyServiceHandler) CreatePropertyArgsForCall(i int) (context.Context, *connect.Request[propertyv1.CreatePropertyRequest]) {
	fake.createPropertyMutex.RLock()
	defer fake.createPropertyMutex.RUnlock()
	argsForCall := fake.createPropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) CreatePropertyReturns(result1 *connect.Response[propertyv1.CreatePropertyResponse], result2 error) {
	fake.createPropertyMutex.Lock()
	defer fake.createPropertyMutex.Unlock()
	fake.CreatePropertyStub = nil
	fake.createPropertyReturns = struct {
		result1 *connect.Response[propertyv1.CreatePropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) CreatePropertyReturnsOnCall(i int, result1 *connect.Response[propertyv1.CreatePropertyResponse], result2 error) {
	fake.createPropertyMutex.Lock()
	defer fake.createPropertyMutex.Unlock()
	fake.CreatePropertyStub = nil
	if fake.createPropertyReturnsOnCall == nil {
		fake.createPropertyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.CreatePropertyResponse]
			result2 error
		})
	}
	fake.createPropertyReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.CreatePropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) DeleteLocality(arg1 context.Context, arg2 *connect.Request[propertyv1.DeleteLocalityRequest]) (*connect.Response[propertyv1.DeleteLocalityResponse], error) {
	fake.deleteLocalityMutex.Lock()
	ret, specificReturn := fake.deleteLocalityReturnsOnCall[len(fake.deleteLocalityArgsForCall)]
	fake.deleteLocalityArgsForCall = append(fake.deleteLocalityArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.DeleteLocalityRequest]
	}{arg1, arg2})
	stub := fake.DeleteLocalityStub
	fakeReturns := fake.deleteLocalityReturns
	fake.recordInvocation("DeleteLocality", []interface{}{arg1, arg2})
	fake.deleteLocalityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) DeleteLocalityCallCount() int {
	fake.deleteLocalityMutex.RLock()
	defer fake.deleteLocalityMutex.RUnlock()
	return len(fake.deleteLocalityArgsForCall)
}

func (fake *FakePropertyServiceHandler) DeleteLocalityCalls(stub func(context.Context, *connect.Request[propertyv1.DeleteLocalityRequest]) (*connect.Response[propertyv1.DeleteLocalityResponse], error)) {
	fake.deleteLocalityMutex.Lock()
	defer fake.deleteLocalityMutex.Unlock()
	fake.DeleteLocalityStub = stub
}

func (fake *FakePropertyServiceHandler) DeleteLocalityArgsForCall(i int) (context.Context, *connect.Request[propertyv1.DeleteLocalityRequest]) {
	fake.deleteLocalityMutex.RLock()
	defer fake.deleteLocalityMutex.RUnlock()
	argsForCall := fake.deleteLocalityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) DeleteLocalityReturns(result1 *connect.Response[propertyv1.DeleteLocalityResponse], result2 error) {
	fake.deleteLocalityMutex.Lock()
	defer fake.deleteLocalityMutex.Unlock()
	fake.DeleteLocalityStub = nil
	fake.deleteLocalityReturns = struct {
		result1 *connect.Response[propertyv1.DeleteLocalityResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) DeleteLocalityReturnsOnCall(i int, result1 *connect.Response[propertyv1.DeleteLocalityResponse], result2 error) {
	fake.deleteLocalityMutex.Lock()
	defer fake.deleteLocalityMutex.Unlock()
	fake.DeleteLocalityStub = nil
	if fake.deleteLocalityReturnsOnCall == nil {
		fake.deleteLocalityReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.DeleteLocalityResponse]
			result2 error
		})
	}
	fake.deleteLocalityReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.DeleteLocalityResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) DeleteProperty(arg1 context.Context, arg2 *connect.Request[propertyv1.DeletePropertyRequest]) (*connect.Response[propertyv1.DeletePropertyResponse], error) {
	fake.deletePropertyMutex.Lock()
	ret, specificReturn := fake.deletePropertyReturnsOnCall[len(fake.deletePropertyArgsForCall)]
	fake.deletePropertyArgsForCall = append(fake.deletePropertyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.DeletePropertyRequest]
	}{arg1, arg2})
	stub := fake.DeletePropertyStub
	fakeReturns := fake.deletePropertyReturns
	fake.recordInvocation("DeleteProperty", []interface{}{arg1, arg2})
	fake.deletePropertyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) DeletePropertyCallCount() int {
	fake.deletePropertyMutex.RLock()
	defer fake.deletePropertyMutex.RUnlock()
	return len(fake.deletePropertyArgsForCall)
}

func (fake *FakePropertyServiceHandler) DeletePropertyCalls(stub func(context.Context, *connect.Request[propertyv1.DeletePropertyRequest]) (*connect.Response[propertyv1.DeletePropertyResponse], error)) {
	fake.deletePropertyMutex.Lock()
	defer fake.deletePropertyMutex.Unlock()
	fake.DeletePropertyStub = stub
}

func (fake *FakePropertyServiceHandler) DeletePropertyArgsForCall(i int) (context.Context, *connect.Request[propertyv1.DeletePropertyRequest]) {
	fake.deletePropertyMutex.RLock()
	defer fake.deletePropertyMutex.RUnlock()
	argsForCall := fake.deletePropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) DeletePropertyReturns(result1 *connect.Response[propertyv1.DeletePropertyResponse], result2 error) {
	fake.deletePropertyMutex.Lock()
	defer fake.deletePropertyMutex.Unlock()
	fake.DeletePropertyStub = nil
	fake.deletePropertyReturns = struct {
		result1 *connect.Response[propertyv1.DeletePropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) DeletePropertyReturnsOnCall(i int, result1 *connect.Response[propertyv1.DeletePropertyResponse], result2 error) {
	fake.deletePropertyMutex.Lock()
	defer fake.deletePropertyMutex.Unlock()
	fake.DeletePropertyStub = nil
	if fake.deletePropertyReturnsOnCall == nil {
		fake.deletePropertyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.DeletePropertyResponse]
			result2 error
		})
	}
	fake.deletePropertyReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.DeletePropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) DeleteSubscription(arg1 context.Context, arg2 *connect.Request[propertyv1.DeleteSubscriptionRequest]) (*connect.Response[propertyv1.DeleteSubscriptionResponse], error) {
	fake.deleteSubscriptionMutex.Lock()
	ret, specificReturn := fake.deleteSubscriptionReturnsOnCall[len(fake.deleteSubscriptionArgsForCall)]
	fake.deleteSubscriptionArgsForCall = append(fake.deleteSubscriptionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.DeleteSubscriptionRequest]
	}{arg1, arg2})
	stub := fake.DeleteSubscriptionStub
	fakeReturns := fake.deleteSubscriptionReturns
	fake.recordInvocation("DeleteSubscription", []interface{}{arg1, arg2})
	fake.deleteSubscriptionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) DeleteSubscriptionCallCount() int {
	fake.deleteSubscriptionMutex.RLock()
	defer fake.deleteSubscriptionMutex.RUnlock()
	return len(fake.deleteSubscriptionArgsForCall)
}

func (fake *FakePropertyServiceHandler) DeleteSubscriptionCalls(stub func(context.Context, *connect.Request[propertyv1.DeleteSubscriptionRequest]) (*connect.Response[propertyv1.DeleteSubscriptionResponse], error)) {
	fake.deleteSubscriptionMutex.Lock()
	defer fake.deleteSubscriptionMutex.Unlock()
	fake.DeleteSubscriptionStub = stub
}

func (fake *FakePropertyServiceHandler) DeleteSubscriptionArgsForCall(i int) (context.Context, *connect.Request[propertyv1.DeleteSubscriptionRequest]) {
	fake.deleteSubscriptionMutex.RLock()
	defer fake.deleteSubscriptionMutex.RUnlock()
	argsForCall := fake.deleteSubscriptionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) DeleteSubscriptionReturns(result1 *connect.Response[propertyv1.DeleteSubscriptionResponse], result2 error) {
	fake.deleteSubscriptionMutex.Lock()
	defer fake.deleteSubscriptionMutex.Unlock()
	fake.DeleteSubscriptionStub = nil
	fake.deleteSubscriptionReturns = struct {
		result1 *connect.Response[propertyv1.DeleteSubscriptionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) DeleteSubscriptionReturnsOnCall(i int, result1 *connect.Response[propertyv1.DeleteSubscriptionResponse], result2 error) {
	fake.deleteSubscriptionMutex.Lock()
	defer fake.deleteSubscriptionMutex.Unlock()
	fake.DeleteSubscriptionStub = nil
	if fake.deleteSubscriptionReturnsOnCall == nil {
		fake.deleteSubscriptionReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.DeleteSubscriptionResponse]
			result2 error
		})
	}
	fake.deleteSubscriptionReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.DeleteSubscriptionResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) HistoryOfProperty(arg1 context.Context, arg2 *connect.Request[propertyv1.HistoryOfPropertyRequest], arg3 *connect.ServerStream[propertyv1.HistoryOfPropertyResponse]) error {
	fake.historyOfPropertyMutex.Lock()
	ret, specificReturn := fake.historyOfPropertyReturnsOnCall[len(fake.historyOfPropertyArgsForCall)]
	fake.historyOfPropertyArgsForCall = append(fake.historyOfPropertyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.HistoryOfPropertyRequest]
		arg3 *connect.ServerStream[propertyv1.HistoryOfPropertyResponse]
	}{arg1, arg2, arg3})
	stub := fake.HistoryOfPropertyStub
	fakeReturns := fake.historyOfPropertyReturns
	fake.recordInvocation("HistoryOfProperty", []interface{}{arg1, arg2, arg3})
	fake.historyOfPropertyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePropertyServiceHandler) HistoryOfPropertyCallCount() int {
	fake.historyOfPropertyMutex.RLock()
	defer fake.historyOfPropertyMutex.RUnlock()
	return len(fake.historyOfPropertyArgsForCall)
}

func (fake *FakePropertyServiceHandler) HistoryOfPropertyCalls(stub func(context.Context, *connect.Request[propertyv1.HistoryOfPropertyRequest], *connect.ServerStream[propertyv1.HistoryOfPropertyResponse]) error) {
	fake.historyOfPropertyMutex.Lock()
	defer fake.historyOfPropertyMutex.Unlock()
	fake.HistoryOfPropertyStub = stub
}

func (fake *FakePropertyServiceHandler) HistoryOfPropertyArgsForCall(i int) (context.Context, *connect.Request[propertyv1.HistoryOfPropertyRequest], *connect.ServerStream[propertyv1.HistoryOfPropertyResponse]) {
	fake.historyOfPropertyMutex.RLock()
	defer fake.historyOfPropertyMutex.RUnlock()
	argsForCall := fake.historyOfPropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePropertyServiceHandler) HistoryOfPropertyReturns(result1 error) {
	fake.historyOfPropertyMutex.Lock()
	defer fake.historyOfPropertyMutex.Unlock()
	fake.HistoryOfPropertyStub = nil
	fake.historyOfPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) HistoryOfPropertyReturnsOnCall(i int, result1 error) {
	fake.historyOfPropertyMutex.Lock()
	defer fake.historyOfPropertyMutex.Unlock()
	fake.HistoryOfPropertyStub = nil
	if fake.historyOfPropertyReturnsOnCall == nil {
		fake.historyOfPropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.historyOfPropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) ListPropertyType(arg1 context.Context, arg2 *connect.Request[propertyv1.ListPropertyTypeRequest], arg3 *connect.ServerStream[propertyv1.ListPropertyTypeResponse]) error {
	fake.listPropertyTypeMutex.Lock()
	ret, specificReturn := fake.listPropertyTypeReturnsOnCall[len(fake.listPropertyTypeArgsForCall)]
	fake.listPropertyTypeArgsForCall = append(fake.listPropertyTypeArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.ListPropertyTypeRequest]
		arg3 *connect.ServerStream[propertyv1.ListPropertyTypeResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListPropertyTypeStub
	fakeReturns := fake.listPropertyTypeReturns
	fake.recordInvocation("ListPropertyType", []interface{}{arg1, arg2, arg3})
	fake.listPropertyTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePropertyServiceHandler) ListPropertyTypeCallCount() int {
	fake.listPropertyTypeMutex.RLock()
	defer fake.listPropertyTypeMutex.RUnlock()
	return len(fake.listPropertyTypeArgsForCall)
}

func (fake *FakePropertyServiceHandler) ListPropertyTypeCalls(stub func(context.Context, *connect.Request[propertyv1.ListPropertyTypeRequest], *connect.ServerStream[propertyv1.ListPropertyTypeResponse]) error) {
	fake.listPropertyTypeMutex.Lock()
	defer fake.listPropertyTypeMutex.Unlock()
	fake.ListPropertyTypeStub = stub
}

func (fake *FakePropertyServiceHandler) ListPropertyTypeArgsForCall(i int) (context.Context, *connect.Request[propertyv1.ListPropertyTypeRequest], *connect.ServerStream[propertyv1.ListPropertyTypeResponse]) {
	fake.listPropertyTypeMutex.RLock()
	defer fake.listPropertyTypeMutex.RUnlock()
	argsForCall := fake.listPropertyTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePropertyServiceHandler) ListPropertyTypeReturns(result1 error) {
	fake.listPropertyTypeMutex.Lock()
	defer fake.listPropertyTypeMutex.Unlock()
	fake.ListPropertyTypeStub = nil
	fake.listPropertyTypeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) ListPropertyTypeReturnsOnCall(i int, result1 error) {
	fake.listPropertyTypeMutex.Lock()
	defer fake.listPropertyTypeMutex.Unlock()
	fake.ListPropertyTypeStub = nil
	if fake.listPropertyTypeReturnsOnCall == nil {
		fake.listPropertyTypeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listPropertyTypeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) ListSubscription(arg1 context.Context, arg2 *connect.Request[propertyv1.ListSubscriptionRequest], arg3 *connect.ServerStream[propertyv1.ListSubscriptionResponse]) error {
	fake.listSubscriptionMutex.Lock()
	ret, specificReturn := fake.listSubscriptionReturnsOnCall[len(fake.listSubscriptionArgsForCall)]
	fake.listSubscriptionArgsForCall = append(fake.listSubscriptionArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.ListSubscriptionRequest]
		arg3 *connect.ServerStream[propertyv1.ListSubscriptionResponse]
	}{arg1, arg2, arg3})
	stub := fake.ListSubscriptionStub
	fakeReturns := fake.listSubscriptionReturns
	fake.recordInvocation("ListSubscription", []interface{}{arg1, arg2, arg3})
	fake.listSubscriptionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePropertyServiceHandler) ListSubscriptionCallCount() int {
	fake.listSubscriptionMutex.RLock()
	defer fake.listSubscriptionMutex.RUnlock()
	return len(fake.listSubscriptionArgsForCall)
}

func (fake *FakePropertyServiceHandler) ListSubscriptionCalls(stub func(context.Context, *connect.Request[propertyv1.ListSubscriptionRequest], *connect.ServerStream[propertyv1.ListSubscriptionResponse]) error) {
	fake.listSubscriptionMutex.Lock()
	defer fake.listSubscriptionMutex.Unlock()
	fake.ListSubscriptionStub = stub
}

func (fake *FakePropertyServiceHandler) ListSubscriptionArgsForCall(i int) (context.Context, *connect.Request[propertyv1.ListSubscriptionRequest], *connect.ServerStream[propertyv1.ListSubscriptionResponse]) {
	fake.listSubscriptionMutex.RLock()
	defer fake.listSubscriptionMutex.RUnlock()
	argsForCall := fake.listSubscriptionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePropertyServiceHandler) ListSubscriptionReturns(result1 error) {
	fake.listSubscriptionMutex.Lock()
	defer fake.listSubscriptionMutex.Unlock()
	fake.ListSubscriptionStub = nil
	fake.listSubscriptionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) ListSubscriptionReturnsOnCall(i int, result1 error) {
	fake.listSubscriptionMutex.Lock()
	defer fake.listSubscriptionMutex.Unlock()
	fake.ListSubscriptionStub = nil
	if fake.listSubscriptionReturnsOnCall == nil {
		fake.listSubscriptionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listSubscriptionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) SearchProperty(arg1 context.Context, arg2 *connect.Request[propertyv1.SearchPropertyRequest], arg3 *connect.ServerStream[propertyv1.SearchPropertyResponse]) error {
	fake.searchPropertyMutex.Lock()
	ret, specificReturn := fake.searchPropertyReturnsOnCall[len(fake.searchPropertyArgsForCall)]
	fake.searchPropertyArgsForCall = append(fake.searchPropertyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.SearchPropertyRequest]
		arg3 *connect.ServerStream[propertyv1.SearchPropertyResponse]
	}{arg1, arg2, arg3})
	stub := fake.SearchPropertyStub
	fakeReturns := fake.searchPropertyReturns
	fake.recordInvocation("SearchProperty", []interface{}{arg1, arg2, arg3})
	fake.searchPropertyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePropertyServiceHandler) SearchPropertyCallCount() int {
	fake.searchPropertyMutex.RLock()
	defer fake.searchPropertyMutex.RUnlock()
	return len(fake.searchPropertyArgsForCall)
}

func (fake *FakePropertyServiceHandler) SearchPropertyCalls(stub func(context.Context, *connect.Request[propertyv1.SearchPropertyRequest], *connect.ServerStream[propertyv1.SearchPropertyResponse]) error) {
	fake.searchPropertyMutex.Lock()
	defer fake.searchPropertyMutex.Unlock()
	fake.SearchPropertyStub = stub
}

func (fake *FakePropertyServiceHandler) SearchPropertyArgsForCall(i int) (context.Context, *connect.Request[propertyv1.SearchPropertyRequest], *connect.ServerStream[propertyv1.SearchPropertyResponse]) {
	fake.searchPropertyMutex.RLock()
	defer fake.searchPropertyMutex.RUnlock()
	argsForCall := fake.searchPropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePropertyServiceHandler) SearchPropertyReturns(result1 error) {
	fake.searchPropertyMutex.Lock()
	defer fake.searchPropertyMutex.Unlock()
	fake.SearchPropertyStub = nil
	fake.searchPropertyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) SearchPropertyReturnsOnCall(i int, result1 error) {
	fake.searchPropertyMutex.Lock()
	defer fake.searchPropertyMutex.Unlock()
	fake.SearchPropertyStub = nil
	if fake.searchPropertyReturnsOnCall == nil {
		fake.searchPropertyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.searchPropertyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePropertyServiceHandler) StateOfProperty(arg1 context.Context, arg2 *connect.Request[propertyv1.StateOfPropertyRequest]) (*connect.Response[propertyv1.StateOfPropertyResponse], error) {
	fake.stateOfPropertyMutex.Lock()
	ret, specificReturn := fake.stateOfPropertyReturnsOnCall[len(fake.stateOfPropertyArgsForCall)]
	fake.stateOfPropertyArgsForCall = append(fake.stateOfPropertyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.StateOfPropertyRequest]
	}{arg1, arg2})
	stub := fake.StateOfPropertyStub
	fakeReturns := fake.stateOfPropertyReturns
	fake.recordInvocation("StateOfProperty", []interface{}{arg1, arg2})
	fake.stateOfPropertyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) StateOfPropertyCallCount() int {
	fake.stateOfPropertyMutex.RLock()
	defer fake.stateOfPropertyMutex.RUnlock()
	return len(fake.stateOfPropertyArgsForCall)
}

func (fake *FakePropertyServiceHandler) StateOfPropertyCalls(stub func(context.Context, *connect.Request[propertyv1.StateOfPropertyRequest]) (*connect.Response[propertyv1.StateOfPropertyResponse], error)) {
	fake.stateOfPropertyMutex.Lock()
	defer fake.stateOfPropertyMutex.Unlock()
	fake.StateOfPropertyStub = stub
}

func (fake *FakePropertyServiceHandler) StateOfPropertyArgsForCall(i int) (context.Context, *connect.Request[propertyv1.StateOfPropertyRequest]) {
	fake.stateOfPropertyMutex.RLock()
	defer fake.stateOfPropertyMutex.RUnlock()
	argsForCall := fake.stateOfPropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) StateOfPropertyReturns(result1 *connect.Response[propertyv1.StateOfPropertyResponse], result2 error) {
	fake.stateOfPropertyMutex.Lock()
	defer fake.stateOfPropertyMutex.Unlock()
	fake.StateOfPropertyStub = nil
	fake.stateOfPropertyReturns = struct {
		result1 *connect.Response[propertyv1.StateOfPropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) StateOfPropertyReturnsOnCall(i int, result1 *connect.Response[propertyv1.StateOfPropertyResponse], result2 error) {
	fake.stateOfPropertyMutex.Lock()
	defer fake.stateOfPropertyMutex.Unlock()
	fake.StateOfPropertyStub = nil
	if fake.stateOfPropertyReturnsOnCall == nil {
		fake.stateOfPropertyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.StateOfPropertyResponse]
			result2 error
		})
	}
	fake.stateOfPropertyReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.StateOfPropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) UpdateProperty(arg1 context.Context, arg2 *connect.Request[propertyv1.UpdatePropertyRequest]) (*connect.Response[propertyv1.UpdatePropertyResponse], error) {
	fake.updatePropertyMutex.Lock()
	ret, specificReturn := fake.updatePropertyReturnsOnCall[len(fake.updatePropertyArgsForCall)]
	fake.updatePropertyArgsForCall = append(fake.updatePropertyArgsForCall, struct {
		arg1 context.Context
		arg2 *connect.Request[propertyv1.UpdatePropertyRequest]
	}{arg1, arg2})
	stub := fake.UpdatePropertyStub
	fakeReturns := fake.updatePropertyReturns
	fake.recordInvocation("UpdateProperty", []interface{}{arg1, arg2})
	fake.updatePropertyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePropertyServiceHandler) UpdatePropertyCallCount() int {
	fake.updatePropertyMutex.RLock()
	defer fake.updatePropertyMutex.RUnlock()
	return len(fake.updatePropertyArgsForCall)
}

func (fake *FakePropertyServiceHandler) UpdatePropertyCalls(stub func(context.Context, *connect.Request[propertyv1.UpdatePropertyRequest]) (*connect.Response[propertyv1.UpdatePropertyResponse], error)) {
	fake.updatePropertyMutex.Lock()
	defer fake.updatePropertyMutex.Unlock()
	fake.UpdatePropertyStub = stub
}

func (fake *FakePropertyServiceHandler) UpdatePropertyArgsForCall(i int) (context.Context, *connect.Request[propertyv1.UpdatePropertyRequest]) {
	fake.updatePropertyMutex.RLock()
	defer fake.updatePropertyMutex.RUnlock()
	argsForCall := fake.updatePropertyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePropertyServiceHandler) UpdatePropertyReturns(result1 *connect.Response[propertyv1.UpdatePropertyResponse], result2 error) {
	fake.updatePropertyMutex.Lock()
	defer fake.updatePropertyMutex.Unlock()
	fake.UpdatePropertyStub = nil
	fake.updatePropertyReturns = struct {
		result1 *connect.Response[propertyv1.UpdatePropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) UpdatePropertyReturnsOnCall(i int, result1 *connect.Response[propertyv1.UpdatePropertyResponse], result2 error) {
	fake.updatePropertyMutex.Lock()
	defer fake.updatePropertyMutex.Unlock()
	fake.UpdatePropertyStub = nil
	if fake.updatePropertyReturnsOnCall == nil {
		fake.updatePropertyReturnsOnCall = make(map[int]struct {
			result1 *connect.Response[propertyv1.UpdatePropertyResponse]
			result2 error
		})
	}
	fake.updatePropertyReturnsOnCall[i] = struct {
		result1 *connect.Response[propertyv1.UpdatePropertyResponse]
		result2 error
	}{result1, result2}
}

func (fake *FakePropertyServiceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePropertyServiceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ propertyv1connect.PropertyServiceHandler = new(FakePropertyServiceHandler)
