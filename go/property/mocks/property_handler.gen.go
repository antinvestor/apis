// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/property/connectrpc/go/property/v1/propertyv1connect.PropertyServiceHandler -o property_handler.gen.go -n PropertyServiceHandlerMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/property/protocolbuffers/go/property/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// PropertyServiceHandlerMock implements mm_propertyv1connect.PropertyServiceHandler
type PropertyServiceHandlerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddLocality          func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) (pp2 *connect.Response[v1.AddLocalityResponse], err error)
	funcAddLocalityOrigin    string
	inspectFuncAddLocality   func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest])
	afterAddLocalityCounter  uint64
	beforeAddLocalityCounter uint64
	AddLocalityMock          mPropertyServiceHandlerMockAddLocality

	funcAddPropertyType          func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) (pp2 *connect.Response[v1.AddPropertyTypeResponse], err error)
	funcAddPropertyTypeOrigin    string
	inspectFuncAddPropertyType   func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest])
	afterAddPropertyTypeCounter  uint64
	beforeAddPropertyTypeCounter uint64
	AddPropertyTypeMock          mPropertyServiceHandlerMockAddPropertyType

	funcAddSubscription          func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) (pp2 *connect.Response[v1.AddSubscriptionResponse], err error)
	funcAddSubscriptionOrigin    string
	inspectFuncAddSubscription   func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest])
	afterAddSubscriptionCounter  uint64
	beforeAddSubscriptionCounter uint64
	AddSubscriptionMock          mPropertyServiceHandlerMockAddSubscription

	funcCreateProperty          func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) (pp2 *connect.Response[v1.CreatePropertyResponse], err error)
	funcCreatePropertyOrigin    string
	inspectFuncCreateProperty   func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest])
	afterCreatePropertyCounter  uint64
	beforeCreatePropertyCounter uint64
	CreatePropertyMock          mPropertyServiceHandlerMockCreateProperty

	funcDeleteLocality          func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) (pp2 *connect.Response[v1.DeleteLocalityResponse], err error)
	funcDeleteLocalityOrigin    string
	inspectFuncDeleteLocality   func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest])
	afterDeleteLocalityCounter  uint64
	beforeDeleteLocalityCounter uint64
	DeleteLocalityMock          mPropertyServiceHandlerMockDeleteLocality

	funcDeleteProperty          func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) (pp2 *connect.Response[v1.DeletePropertyResponse], err error)
	funcDeletePropertyOrigin    string
	inspectFuncDeleteProperty   func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest])
	afterDeletePropertyCounter  uint64
	beforeDeletePropertyCounter uint64
	DeletePropertyMock          mPropertyServiceHandlerMockDeleteProperty

	funcDeleteSubscription          func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) (pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error)
	funcDeleteSubscriptionOrigin    string
	inspectFuncDeleteSubscription   func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest])
	afterDeleteSubscriptionCounter  uint64
	beforeDeleteSubscriptionCounter uint64
	DeleteSubscriptionMock          mPropertyServiceHandlerMockDeleteSubscription

	funcHistoryOfProperty          func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]) (err error)
	funcHistoryOfPropertyOrigin    string
	inspectFuncHistoryOfProperty   func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse])
	afterHistoryOfPropertyCounter  uint64
	beforeHistoryOfPropertyCounter uint64
	HistoryOfPropertyMock          mPropertyServiceHandlerMockHistoryOfProperty

	funcListPropertyType          func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]) (err error)
	funcListPropertyTypeOrigin    string
	inspectFuncListPropertyType   func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse])
	afterListPropertyTypeCounter  uint64
	beforeListPropertyTypeCounter uint64
	ListPropertyTypeMock          mPropertyServiceHandlerMockListPropertyType

	funcListSubscription          func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse]) (err error)
	funcListSubscriptionOrigin    string
	inspectFuncListSubscription   func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse])
	afterListSubscriptionCounter  uint64
	beforeListSubscriptionCounter uint64
	ListSubscriptionMock          mPropertyServiceHandlerMockListSubscription

	funcSearchProperty          func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse]) (err error)
	funcSearchPropertyOrigin    string
	inspectFuncSearchProperty   func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse])
	afterSearchPropertyCounter  uint64
	beforeSearchPropertyCounter uint64
	SearchPropertyMock          mPropertyServiceHandlerMockSearchProperty

	funcStateOfProperty          func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) (pp2 *connect.Response[v1.StateOfPropertyResponse], err error)
	funcStateOfPropertyOrigin    string
	inspectFuncStateOfProperty   func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest])
	afterStateOfPropertyCounter  uint64
	beforeStateOfPropertyCounter uint64
	StateOfPropertyMock          mPropertyServiceHandlerMockStateOfProperty

	funcUpdateProperty          func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) (pp2 *connect.Response[v1.UpdatePropertyResponse], err error)
	funcUpdatePropertyOrigin    string
	inspectFuncUpdateProperty   func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest])
	afterUpdatePropertyCounter  uint64
	beforeUpdatePropertyCounter uint64
	UpdatePropertyMock          mPropertyServiceHandlerMockUpdateProperty
}

// NewPropertyServiceHandlerMock returns a mock for mm_propertyv1connect.PropertyServiceHandler
func NewPropertyServiceHandlerMock(t minimock.Tester) *PropertyServiceHandlerMock {
	m := &PropertyServiceHandlerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddLocalityMock = mPropertyServiceHandlerMockAddLocality{mock: m}
	m.AddLocalityMock.callArgs = []*PropertyServiceHandlerMockAddLocalityParams{}

	m.AddPropertyTypeMock = mPropertyServiceHandlerMockAddPropertyType{mock: m}
	m.AddPropertyTypeMock.callArgs = []*PropertyServiceHandlerMockAddPropertyTypeParams{}

	m.AddSubscriptionMock = mPropertyServiceHandlerMockAddSubscription{mock: m}
	m.AddSubscriptionMock.callArgs = []*PropertyServiceHandlerMockAddSubscriptionParams{}

	m.CreatePropertyMock = mPropertyServiceHandlerMockCreateProperty{mock: m}
	m.CreatePropertyMock.callArgs = []*PropertyServiceHandlerMockCreatePropertyParams{}

	m.DeleteLocalityMock = mPropertyServiceHandlerMockDeleteLocality{mock: m}
	m.DeleteLocalityMock.callArgs = []*PropertyServiceHandlerMockDeleteLocalityParams{}

	m.DeletePropertyMock = mPropertyServiceHandlerMockDeleteProperty{mock: m}
	m.DeletePropertyMock.callArgs = []*PropertyServiceHandlerMockDeletePropertyParams{}

	m.DeleteSubscriptionMock = mPropertyServiceHandlerMockDeleteSubscription{mock: m}
	m.DeleteSubscriptionMock.callArgs = []*PropertyServiceHandlerMockDeleteSubscriptionParams{}

	m.HistoryOfPropertyMock = mPropertyServiceHandlerMockHistoryOfProperty{mock: m}
	m.HistoryOfPropertyMock.callArgs = []*PropertyServiceHandlerMockHistoryOfPropertyParams{}

	m.ListPropertyTypeMock = mPropertyServiceHandlerMockListPropertyType{mock: m}
	m.ListPropertyTypeMock.callArgs = []*PropertyServiceHandlerMockListPropertyTypeParams{}

	m.ListSubscriptionMock = mPropertyServiceHandlerMockListSubscription{mock: m}
	m.ListSubscriptionMock.callArgs = []*PropertyServiceHandlerMockListSubscriptionParams{}

	m.SearchPropertyMock = mPropertyServiceHandlerMockSearchProperty{mock: m}
	m.SearchPropertyMock.callArgs = []*PropertyServiceHandlerMockSearchPropertyParams{}

	m.StateOfPropertyMock = mPropertyServiceHandlerMockStateOfProperty{mock: m}
	m.StateOfPropertyMock.callArgs = []*PropertyServiceHandlerMockStateOfPropertyParams{}

	m.UpdatePropertyMock = mPropertyServiceHandlerMockUpdateProperty{mock: m}
	m.UpdatePropertyMock.callArgs = []*PropertyServiceHandlerMockUpdatePropertyParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPropertyServiceHandlerMockAddLocality struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockAddLocalityExpectation
	expectations       []*PropertyServiceHandlerMockAddLocalityExpectation

	callArgs []*PropertyServiceHandlerMockAddLocalityParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockAddLocalityExpectation specifies expectation struct of the PropertyServiceHandler.AddLocality
type PropertyServiceHandlerMockAddLocalityExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockAddLocalityParams
	paramPtrs          *PropertyServiceHandlerMockAddLocalityParamPtrs
	expectationOrigins PropertyServiceHandlerMockAddLocalityExpectationOrigins
	results            *PropertyServiceHandlerMockAddLocalityResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockAddLocalityParams contains parameters of the PropertyServiceHandler.AddLocality
type PropertyServiceHandlerMockAddLocalityParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddLocalityRequest]
}

// PropertyServiceHandlerMockAddLocalityParamPtrs contains pointers to parameters of the PropertyServiceHandler.AddLocality
type PropertyServiceHandlerMockAddLocalityParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddLocalityRequest]
}

// PropertyServiceHandlerMockAddLocalityResults contains results of the PropertyServiceHandler.AddLocality
type PropertyServiceHandlerMockAddLocalityResults struct {
	pp2 *connect.Response[v1.AddLocalityResponse]
	err error
}

// PropertyServiceHandlerMockAddLocalityOrigins contains origins of expectations of the PropertyServiceHandler.AddLocality
type PropertyServiceHandlerMockAddLocalityExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Optional() *mPropertyServiceHandlerMockAddLocality {
	mmAddLocality.optional = true
	return mmAddLocality
}

// Expect sets up expected params for PropertyServiceHandler.AddLocality
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Expect(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) *mPropertyServiceHandlerMockAddLocality {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceHandlerMockAddLocalityExpectation{}
	}

	if mmAddLocality.defaultExpectation.paramPtrs != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by ExpectParams functions")
	}

	mmAddLocality.defaultExpectation.params = &PropertyServiceHandlerMockAddLocalityParams{ctx, pp1}
	mmAddLocality.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddLocality.expectations {
		if minimock.Equal(e.params, mmAddLocality.defaultExpectation.params) {
			mmAddLocality.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddLocality.defaultExpectation.params)
		}
	}

	return mmAddLocality
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.AddLocality
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockAddLocality {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceHandlerMockAddLocalityExpectation{}
	}

	if mmAddLocality.defaultExpectation.params != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Expect")
	}

	if mmAddLocality.defaultExpectation.paramPtrs == nil {
		mmAddLocality.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockAddLocalityParamPtrs{}
	}
	mmAddLocality.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddLocality.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddLocality
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.AddLocality
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) ExpectPp1Param2(pp1 *connect.Request[v1.AddLocalityRequest]) *mPropertyServiceHandlerMockAddLocality {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceHandlerMockAddLocalityExpectation{}
	}

	if mmAddLocality.defaultExpectation.params != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Expect")
	}

	if mmAddLocality.defaultExpectation.paramPtrs == nil {
		mmAddLocality.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockAddLocalityParamPtrs{}
	}
	mmAddLocality.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddLocality.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddLocality
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.AddLocality
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest])) *mPropertyServiceHandlerMockAddLocality {
	if mmAddLocality.mock.inspectFuncAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.AddLocality")
	}

	mmAddLocality.mock.inspectFuncAddLocality = f

	return mmAddLocality
}

// Return sets up results that will be returned by PropertyServiceHandler.AddLocality
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Return(pp2 *connect.Response[v1.AddLocalityResponse], err error) *PropertyServiceHandlerMock {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceHandlerMockAddLocalityExpectation{mock: mmAddLocality.mock}
	}
	mmAddLocality.defaultExpectation.results = &PropertyServiceHandlerMockAddLocalityResults{pp2, err}
	mmAddLocality.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddLocality.mock
}

// Set uses given function f to mock the PropertyServiceHandler.AddLocality method
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) (pp2 *connect.Response[v1.AddLocalityResponse], err error)) *PropertyServiceHandlerMock {
	if mmAddLocality.defaultExpectation != nil {
		mmAddLocality.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.AddLocality method")
	}

	if len(mmAddLocality.expectations) > 0 {
		mmAddLocality.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.AddLocality method")
	}

	mmAddLocality.mock.funcAddLocality = f
	mmAddLocality.mock.funcAddLocalityOrigin = minimock.CallerInfo(1)
	return mmAddLocality.mock
}

// When sets expectation for the PropertyServiceHandler.AddLocality which will trigger the result defined by the following
// Then helper
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) When(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) *PropertyServiceHandlerMockAddLocalityExpectation {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceHandlerMock.AddLocality mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockAddLocalityExpectation{
		mock:               mmAddLocality.mock,
		params:             &PropertyServiceHandlerMockAddLocalityParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockAddLocalityExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddLocality.expectations = append(mmAddLocality.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.AddLocality return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockAddLocalityExpectation) Then(pp2 *connect.Response[v1.AddLocalityResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockAddLocalityResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.AddLocality should be invoked
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Times(n uint64) *mPropertyServiceHandlerMockAddLocality {
	if n == 0 {
		mmAddLocality.mock.t.Fatalf("Times of PropertyServiceHandlerMock.AddLocality mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddLocality.expectedInvocations, n)
	mmAddLocality.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddLocality
}

func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) invocationsDone() bool {
	if len(mmAddLocality.expectations) == 0 && mmAddLocality.defaultExpectation == nil && mmAddLocality.mock.funcAddLocality == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddLocality.mock.afterAddLocalityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddLocality.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddLocality implements mm_propertyv1connect.PropertyServiceHandler
func (mmAddLocality *PropertyServiceHandlerMock) AddLocality(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) (pp2 *connect.Response[v1.AddLocalityResponse], err error) {
	mm_atomic.AddUint64(&mmAddLocality.beforeAddLocalityCounter, 1)
	defer mm_atomic.AddUint64(&mmAddLocality.afterAddLocalityCounter, 1)

	mmAddLocality.t.Helper()

	if mmAddLocality.inspectFuncAddLocality != nil {
		mmAddLocality.inspectFuncAddLocality(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockAddLocalityParams{ctx, pp1}

	// Record call args
	mmAddLocality.AddLocalityMock.mutex.Lock()
	mmAddLocality.AddLocalityMock.callArgs = append(mmAddLocality.AddLocalityMock.callArgs, &mm_params)
	mmAddLocality.AddLocalityMock.mutex.Unlock()

	for _, e := range mmAddLocality.AddLocalityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddLocality.AddLocalityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddLocality.AddLocalityMock.defaultExpectation.Counter, 1)
		mm_want := mmAddLocality.AddLocalityMock.defaultExpectation.params
		mm_want_ptrs := mmAddLocality.AddLocalityMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockAddLocalityParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddLocality.t.Errorf("PropertyServiceHandlerMock.AddLocality got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddLocality.AddLocalityMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddLocality.t.Errorf("PropertyServiceHandlerMock.AddLocality got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddLocality.AddLocalityMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddLocality.t.Errorf("PropertyServiceHandlerMock.AddLocality got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddLocality.AddLocalityMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddLocality.AddLocalityMock.defaultExpectation.results
		if mm_results == nil {
			mmAddLocality.t.Fatal("No results are set for the PropertyServiceHandlerMock.AddLocality")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddLocality.funcAddLocality != nil {
		return mmAddLocality.funcAddLocality(ctx, pp1)
	}
	mmAddLocality.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.AddLocality. %v %v", ctx, pp1)
	return
}

// AddLocalityAfterCounter returns a count of finished PropertyServiceHandlerMock.AddLocality invocations
func (mmAddLocality *PropertyServiceHandlerMock) AddLocalityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLocality.afterAddLocalityCounter)
}

// AddLocalityBeforeCounter returns a count of PropertyServiceHandlerMock.AddLocality invocations
func (mmAddLocality *PropertyServiceHandlerMock) AddLocalityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLocality.beforeAddLocalityCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.AddLocality.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddLocality *mPropertyServiceHandlerMockAddLocality) Calls() []*PropertyServiceHandlerMockAddLocalityParams {
	mmAddLocality.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockAddLocalityParams, len(mmAddLocality.callArgs))
	copy(argCopy, mmAddLocality.callArgs)

	mmAddLocality.mutex.RUnlock()

	return argCopy
}

// MinimockAddLocalityDone returns true if the count of the AddLocality invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockAddLocalityDone() bool {
	if m.AddLocalityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddLocalityMock.invocationsDone()
}

// MinimockAddLocalityInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockAddLocalityInspect() {
	for _, e := range m.AddLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddLocality at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddLocalityCounter := mm_atomic.LoadUint64(&m.afterAddLocalityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddLocalityMock.defaultExpectation != nil && afterAddLocalityCounter < 1 {
		if m.AddLocalityMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddLocality at\n%s", m.AddLocalityMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddLocality at\n%s with params: %#v", m.AddLocalityMock.defaultExpectation.expectationOrigins.origin, *m.AddLocalityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddLocality != nil && afterAddLocalityCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddLocality at\n%s", m.funcAddLocalityOrigin)
	}

	if !m.AddLocalityMock.invocationsDone() && afterAddLocalityCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.AddLocality at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddLocalityMock.expectedInvocations), m.AddLocalityMock.expectedInvocationsOrigin, afterAddLocalityCounter)
	}
}

type mPropertyServiceHandlerMockAddPropertyType struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockAddPropertyTypeExpectation
	expectations       []*PropertyServiceHandlerMockAddPropertyTypeExpectation

	callArgs []*PropertyServiceHandlerMockAddPropertyTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockAddPropertyTypeExpectation specifies expectation struct of the PropertyServiceHandler.AddPropertyType
type PropertyServiceHandlerMockAddPropertyTypeExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockAddPropertyTypeParams
	paramPtrs          *PropertyServiceHandlerMockAddPropertyTypeParamPtrs
	expectationOrigins PropertyServiceHandlerMockAddPropertyTypeExpectationOrigins
	results            *PropertyServiceHandlerMockAddPropertyTypeResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockAddPropertyTypeParams contains parameters of the PropertyServiceHandler.AddPropertyType
type PropertyServiceHandlerMockAddPropertyTypeParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddPropertyTypeRequest]
}

// PropertyServiceHandlerMockAddPropertyTypeParamPtrs contains pointers to parameters of the PropertyServiceHandler.AddPropertyType
type PropertyServiceHandlerMockAddPropertyTypeParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddPropertyTypeRequest]
}

// PropertyServiceHandlerMockAddPropertyTypeResults contains results of the PropertyServiceHandler.AddPropertyType
type PropertyServiceHandlerMockAddPropertyTypeResults struct {
	pp2 *connect.Response[v1.AddPropertyTypeResponse]
	err error
}

// PropertyServiceHandlerMockAddPropertyTypeOrigins contains origins of expectations of the PropertyServiceHandler.AddPropertyType
type PropertyServiceHandlerMockAddPropertyTypeExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Optional() *mPropertyServiceHandlerMockAddPropertyType {
	mmAddPropertyType.optional = true
	return mmAddPropertyType
}

// Expect sets up expected params for PropertyServiceHandler.AddPropertyType
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Expect(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) *mPropertyServiceHandlerMockAddPropertyType {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceHandlerMockAddPropertyTypeExpectation{}
	}

	if mmAddPropertyType.defaultExpectation.paramPtrs != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by ExpectParams functions")
	}

	mmAddPropertyType.defaultExpectation.params = &PropertyServiceHandlerMockAddPropertyTypeParams{ctx, pp1}
	mmAddPropertyType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPropertyType.expectations {
		if minimock.Equal(e.params, mmAddPropertyType.defaultExpectation.params) {
			mmAddPropertyType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPropertyType.defaultExpectation.params)
		}
	}

	return mmAddPropertyType
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.AddPropertyType
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockAddPropertyType {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceHandlerMockAddPropertyTypeExpectation{}
	}

	if mmAddPropertyType.defaultExpectation.params != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Expect")
	}

	if mmAddPropertyType.defaultExpectation.paramPtrs == nil {
		mmAddPropertyType.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockAddPropertyTypeParamPtrs{}
	}
	mmAddPropertyType.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPropertyType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPropertyType
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.AddPropertyType
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) ExpectPp1Param2(pp1 *connect.Request[v1.AddPropertyTypeRequest]) *mPropertyServiceHandlerMockAddPropertyType {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceHandlerMockAddPropertyTypeExpectation{}
	}

	if mmAddPropertyType.defaultExpectation.params != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Expect")
	}

	if mmAddPropertyType.defaultExpectation.paramPtrs == nil {
		mmAddPropertyType.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockAddPropertyTypeParamPtrs{}
	}
	mmAddPropertyType.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddPropertyType.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddPropertyType
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.AddPropertyType
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest])) *mPropertyServiceHandlerMockAddPropertyType {
	if mmAddPropertyType.mock.inspectFuncAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.AddPropertyType")
	}

	mmAddPropertyType.mock.inspectFuncAddPropertyType = f

	return mmAddPropertyType
}

// Return sets up results that will be returned by PropertyServiceHandler.AddPropertyType
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Return(pp2 *connect.Response[v1.AddPropertyTypeResponse], err error) *PropertyServiceHandlerMock {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceHandlerMockAddPropertyTypeExpectation{mock: mmAddPropertyType.mock}
	}
	mmAddPropertyType.defaultExpectation.results = &PropertyServiceHandlerMockAddPropertyTypeResults{pp2, err}
	mmAddPropertyType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPropertyType.mock
}

// Set uses given function f to mock the PropertyServiceHandler.AddPropertyType method
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) (pp2 *connect.Response[v1.AddPropertyTypeResponse], err error)) *PropertyServiceHandlerMock {
	if mmAddPropertyType.defaultExpectation != nil {
		mmAddPropertyType.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.AddPropertyType method")
	}

	if len(mmAddPropertyType.expectations) > 0 {
		mmAddPropertyType.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.AddPropertyType method")
	}

	mmAddPropertyType.mock.funcAddPropertyType = f
	mmAddPropertyType.mock.funcAddPropertyTypeOrigin = minimock.CallerInfo(1)
	return mmAddPropertyType.mock
}

// When sets expectation for the PropertyServiceHandler.AddPropertyType which will trigger the result defined by the following
// Then helper
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) When(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) *PropertyServiceHandlerMockAddPropertyTypeExpectation {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.AddPropertyType mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockAddPropertyTypeExpectation{
		mock:               mmAddPropertyType.mock,
		params:             &PropertyServiceHandlerMockAddPropertyTypeParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockAddPropertyTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPropertyType.expectations = append(mmAddPropertyType.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.AddPropertyType return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockAddPropertyTypeExpectation) Then(pp2 *connect.Response[v1.AddPropertyTypeResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockAddPropertyTypeResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.AddPropertyType should be invoked
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Times(n uint64) *mPropertyServiceHandlerMockAddPropertyType {
	if n == 0 {
		mmAddPropertyType.mock.t.Fatalf("Times of PropertyServiceHandlerMock.AddPropertyType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPropertyType.expectedInvocations, n)
	mmAddPropertyType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPropertyType
}

func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) invocationsDone() bool {
	if len(mmAddPropertyType.expectations) == 0 && mmAddPropertyType.defaultExpectation == nil && mmAddPropertyType.mock.funcAddPropertyType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPropertyType.mock.afterAddPropertyTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPropertyType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPropertyType implements mm_propertyv1connect.PropertyServiceHandler
func (mmAddPropertyType *PropertyServiceHandlerMock) AddPropertyType(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) (pp2 *connect.Response[v1.AddPropertyTypeResponse], err error) {
	mm_atomic.AddUint64(&mmAddPropertyType.beforeAddPropertyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPropertyType.afterAddPropertyTypeCounter, 1)

	mmAddPropertyType.t.Helper()

	if mmAddPropertyType.inspectFuncAddPropertyType != nil {
		mmAddPropertyType.inspectFuncAddPropertyType(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockAddPropertyTypeParams{ctx, pp1}

	// Record call args
	mmAddPropertyType.AddPropertyTypeMock.mutex.Lock()
	mmAddPropertyType.AddPropertyTypeMock.callArgs = append(mmAddPropertyType.AddPropertyTypeMock.callArgs, &mm_params)
	mmAddPropertyType.AddPropertyTypeMock.mutex.Unlock()

	for _, e := range mmAddPropertyType.AddPropertyTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddPropertyType.AddPropertyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.params
		mm_want_ptrs := mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockAddPropertyTypeParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPropertyType.t.Errorf("PropertyServiceHandlerMock.AddPropertyType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddPropertyType.t.Errorf("PropertyServiceHandlerMock.AddPropertyType got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPropertyType.t.Errorf("PropertyServiceHandlerMock.AddPropertyType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPropertyType.t.Fatal("No results are set for the PropertyServiceHandlerMock.AddPropertyType")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddPropertyType.funcAddPropertyType != nil {
		return mmAddPropertyType.funcAddPropertyType(ctx, pp1)
	}
	mmAddPropertyType.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.AddPropertyType. %v %v", ctx, pp1)
	return
}

// AddPropertyTypeAfterCounter returns a count of finished PropertyServiceHandlerMock.AddPropertyType invocations
func (mmAddPropertyType *PropertyServiceHandlerMock) AddPropertyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPropertyType.afterAddPropertyTypeCounter)
}

// AddPropertyTypeBeforeCounter returns a count of PropertyServiceHandlerMock.AddPropertyType invocations
func (mmAddPropertyType *PropertyServiceHandlerMock) AddPropertyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPropertyType.beforeAddPropertyTypeCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.AddPropertyType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPropertyType *mPropertyServiceHandlerMockAddPropertyType) Calls() []*PropertyServiceHandlerMockAddPropertyTypeParams {
	mmAddPropertyType.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockAddPropertyTypeParams, len(mmAddPropertyType.callArgs))
	copy(argCopy, mmAddPropertyType.callArgs)

	mmAddPropertyType.mutex.RUnlock()

	return argCopy
}

// MinimockAddPropertyTypeDone returns true if the count of the AddPropertyType invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockAddPropertyTypeDone() bool {
	if m.AddPropertyTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPropertyTypeMock.invocationsDone()
}

// MinimockAddPropertyTypeInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockAddPropertyTypeInspect() {
	for _, e := range m.AddPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddPropertyType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPropertyTypeCounter := mm_atomic.LoadUint64(&m.afterAddPropertyTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPropertyTypeMock.defaultExpectation != nil && afterAddPropertyTypeCounter < 1 {
		if m.AddPropertyTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddPropertyType at\n%s", m.AddPropertyTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddPropertyType at\n%s with params: %#v", m.AddPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *m.AddPropertyTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPropertyType != nil && afterAddPropertyTypeCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddPropertyType at\n%s", m.funcAddPropertyTypeOrigin)
	}

	if !m.AddPropertyTypeMock.invocationsDone() && afterAddPropertyTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.AddPropertyType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPropertyTypeMock.expectedInvocations), m.AddPropertyTypeMock.expectedInvocationsOrigin, afterAddPropertyTypeCounter)
	}
}

type mPropertyServiceHandlerMockAddSubscription struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockAddSubscriptionExpectation
	expectations       []*PropertyServiceHandlerMockAddSubscriptionExpectation

	callArgs []*PropertyServiceHandlerMockAddSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockAddSubscriptionExpectation specifies expectation struct of the PropertyServiceHandler.AddSubscription
type PropertyServiceHandlerMockAddSubscriptionExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockAddSubscriptionParams
	paramPtrs          *PropertyServiceHandlerMockAddSubscriptionParamPtrs
	expectationOrigins PropertyServiceHandlerMockAddSubscriptionExpectationOrigins
	results            *PropertyServiceHandlerMockAddSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockAddSubscriptionParams contains parameters of the PropertyServiceHandler.AddSubscription
type PropertyServiceHandlerMockAddSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddSubscriptionRequest]
}

// PropertyServiceHandlerMockAddSubscriptionParamPtrs contains pointers to parameters of the PropertyServiceHandler.AddSubscription
type PropertyServiceHandlerMockAddSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddSubscriptionRequest]
}

// PropertyServiceHandlerMockAddSubscriptionResults contains results of the PropertyServiceHandler.AddSubscription
type PropertyServiceHandlerMockAddSubscriptionResults struct {
	pp2 *connect.Response[v1.AddSubscriptionResponse]
	err error
}

// PropertyServiceHandlerMockAddSubscriptionOrigins contains origins of expectations of the PropertyServiceHandler.AddSubscription
type PropertyServiceHandlerMockAddSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Optional() *mPropertyServiceHandlerMockAddSubscription {
	mmAddSubscription.optional = true
	return mmAddSubscription
}

// Expect sets up expected params for PropertyServiceHandler.AddSubscription
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) *mPropertyServiceHandlerMockAddSubscription {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceHandlerMockAddSubscriptionExpectation{}
	}

	if mmAddSubscription.defaultExpectation.paramPtrs != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by ExpectParams functions")
	}

	mmAddSubscription.defaultExpectation.params = &PropertyServiceHandlerMockAddSubscriptionParams{ctx, pp1}
	mmAddSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSubscription.expectations {
		if minimock.Equal(e.params, mmAddSubscription.defaultExpectation.params) {
			mmAddSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSubscription.defaultExpectation.params)
		}
	}

	return mmAddSubscription
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.AddSubscription
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockAddSubscription {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceHandlerMockAddSubscriptionExpectation{}
	}

	if mmAddSubscription.defaultExpectation.params != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Expect")
	}

	if mmAddSubscription.defaultExpectation.paramPtrs == nil {
		mmAddSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockAddSubscriptionParamPtrs{}
	}
	mmAddSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.AddSubscription
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.AddSubscriptionRequest]) *mPropertyServiceHandlerMockAddSubscription {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceHandlerMockAddSubscriptionExpectation{}
	}

	if mmAddSubscription.defaultExpectation.params != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Expect")
	}

	if mmAddSubscription.defaultExpectation.paramPtrs == nil {
		mmAddSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockAddSubscriptionParamPtrs{}
	}
	mmAddSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddSubscription
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.AddSubscription
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest])) *mPropertyServiceHandlerMockAddSubscription {
	if mmAddSubscription.mock.inspectFuncAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.AddSubscription")
	}

	mmAddSubscription.mock.inspectFuncAddSubscription = f

	return mmAddSubscription
}

// Return sets up results that will be returned by PropertyServiceHandler.AddSubscription
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Return(pp2 *connect.Response[v1.AddSubscriptionResponse], err error) *PropertyServiceHandlerMock {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceHandlerMockAddSubscriptionExpectation{mock: mmAddSubscription.mock}
	}
	mmAddSubscription.defaultExpectation.results = &PropertyServiceHandlerMockAddSubscriptionResults{pp2, err}
	mmAddSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSubscription.mock
}

// Set uses given function f to mock the PropertyServiceHandler.AddSubscription method
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) (pp2 *connect.Response[v1.AddSubscriptionResponse], err error)) *PropertyServiceHandlerMock {
	if mmAddSubscription.defaultExpectation != nil {
		mmAddSubscription.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.AddSubscription method")
	}

	if len(mmAddSubscription.expectations) > 0 {
		mmAddSubscription.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.AddSubscription method")
	}

	mmAddSubscription.mock.funcAddSubscription = f
	mmAddSubscription.mock.funcAddSubscriptionOrigin = minimock.CallerInfo(1)
	return mmAddSubscription.mock
}

// When sets expectation for the PropertyServiceHandler.AddSubscription which will trigger the result defined by the following
// Then helper
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) When(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) *PropertyServiceHandlerMockAddSubscriptionExpectation {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.AddSubscription mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockAddSubscriptionExpectation{
		mock:               mmAddSubscription.mock,
		params:             &PropertyServiceHandlerMockAddSubscriptionParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockAddSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSubscription.expectations = append(mmAddSubscription.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.AddSubscription return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockAddSubscriptionExpectation) Then(pp2 *connect.Response[v1.AddSubscriptionResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockAddSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.AddSubscription should be invoked
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Times(n uint64) *mPropertyServiceHandlerMockAddSubscription {
	if n == 0 {
		mmAddSubscription.mock.t.Fatalf("Times of PropertyServiceHandlerMock.AddSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSubscription.expectedInvocations, n)
	mmAddSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSubscription
}

func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) invocationsDone() bool {
	if len(mmAddSubscription.expectations) == 0 && mmAddSubscription.defaultExpectation == nil && mmAddSubscription.mock.funcAddSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSubscription.mock.afterAddSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSubscription implements mm_propertyv1connect.PropertyServiceHandler
func (mmAddSubscription *PropertyServiceHandlerMock) AddSubscription(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) (pp2 *connect.Response[v1.AddSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmAddSubscription.beforeAddSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSubscription.afterAddSubscriptionCounter, 1)

	mmAddSubscription.t.Helper()

	if mmAddSubscription.inspectFuncAddSubscription != nil {
		mmAddSubscription.inspectFuncAddSubscription(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockAddSubscriptionParams{ctx, pp1}

	// Record call args
	mmAddSubscription.AddSubscriptionMock.mutex.Lock()
	mmAddSubscription.AddSubscriptionMock.callArgs = append(mmAddSubscription.AddSubscriptionMock.callArgs, &mm_params)
	mmAddSubscription.AddSubscriptionMock.mutex.Unlock()

	for _, e := range mmAddSubscription.AddSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddSubscription.AddSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSubscription.AddSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSubscription.AddSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmAddSubscription.AddSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockAddSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSubscription.t.Errorf("PropertyServiceHandlerMock.AddSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubscription.AddSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddSubscription.t.Errorf("PropertyServiceHandlerMock.AddSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubscription.AddSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSubscription.t.Errorf("PropertyServiceHandlerMock.AddSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSubscription.AddSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSubscription.AddSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSubscription.t.Fatal("No results are set for the PropertyServiceHandlerMock.AddSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddSubscription.funcAddSubscription != nil {
		return mmAddSubscription.funcAddSubscription(ctx, pp1)
	}
	mmAddSubscription.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.AddSubscription. %v %v", ctx, pp1)
	return
}

// AddSubscriptionAfterCounter returns a count of finished PropertyServiceHandlerMock.AddSubscription invocations
func (mmAddSubscription *PropertyServiceHandlerMock) AddSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubscription.afterAddSubscriptionCounter)
}

// AddSubscriptionBeforeCounter returns a count of PropertyServiceHandlerMock.AddSubscription invocations
func (mmAddSubscription *PropertyServiceHandlerMock) AddSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubscription.beforeAddSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.AddSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSubscription *mPropertyServiceHandlerMockAddSubscription) Calls() []*PropertyServiceHandlerMockAddSubscriptionParams {
	mmAddSubscription.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockAddSubscriptionParams, len(mmAddSubscription.callArgs))
	copy(argCopy, mmAddSubscription.callArgs)

	mmAddSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockAddSubscriptionDone returns true if the count of the AddSubscription invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockAddSubscriptionDone() bool {
	if m.AddSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSubscriptionMock.invocationsDone()
}

// MinimockAddSubscriptionInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockAddSubscriptionInspect() {
	for _, e := range m.AddSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSubscriptionCounter := mm_atomic.LoadUint64(&m.afterAddSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSubscriptionMock.defaultExpectation != nil && afterAddSubscriptionCounter < 1 {
		if m.AddSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddSubscription at\n%s", m.AddSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddSubscription at\n%s with params: %#v", m.AddSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.AddSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSubscription != nil && afterAddSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.AddSubscription at\n%s", m.funcAddSubscriptionOrigin)
	}

	if !m.AddSubscriptionMock.invocationsDone() && afterAddSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.AddSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSubscriptionMock.expectedInvocations), m.AddSubscriptionMock.expectedInvocationsOrigin, afterAddSubscriptionCounter)
	}
}

type mPropertyServiceHandlerMockCreateProperty struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockCreatePropertyExpectation
	expectations       []*PropertyServiceHandlerMockCreatePropertyExpectation

	callArgs []*PropertyServiceHandlerMockCreatePropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockCreatePropertyExpectation specifies expectation struct of the PropertyServiceHandler.CreateProperty
type PropertyServiceHandlerMockCreatePropertyExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockCreatePropertyParams
	paramPtrs          *PropertyServiceHandlerMockCreatePropertyParamPtrs
	expectationOrigins PropertyServiceHandlerMockCreatePropertyExpectationOrigins
	results            *PropertyServiceHandlerMockCreatePropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockCreatePropertyParams contains parameters of the PropertyServiceHandler.CreateProperty
type PropertyServiceHandlerMockCreatePropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePropertyRequest]
}

// PropertyServiceHandlerMockCreatePropertyParamPtrs contains pointers to parameters of the PropertyServiceHandler.CreateProperty
type PropertyServiceHandlerMockCreatePropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePropertyRequest]
}

// PropertyServiceHandlerMockCreatePropertyResults contains results of the PropertyServiceHandler.CreateProperty
type PropertyServiceHandlerMockCreatePropertyResults struct {
	pp2 *connect.Response[v1.CreatePropertyResponse]
	err error
}

// PropertyServiceHandlerMockCreatePropertyOrigins contains origins of expectations of the PropertyServiceHandler.CreateProperty
type PropertyServiceHandlerMockCreatePropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Optional() *mPropertyServiceHandlerMockCreateProperty {
	mmCreateProperty.optional = true
	return mmCreateProperty
}

// Expect sets up expected params for PropertyServiceHandler.CreateProperty
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) *mPropertyServiceHandlerMockCreateProperty {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceHandlerMockCreatePropertyExpectation{}
	}

	if mmCreateProperty.defaultExpectation.paramPtrs != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by ExpectParams functions")
	}

	mmCreateProperty.defaultExpectation.params = &PropertyServiceHandlerMockCreatePropertyParams{ctx, pp1}
	mmCreateProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProperty.expectations {
		if minimock.Equal(e.params, mmCreateProperty.defaultExpectation.params) {
			mmCreateProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProperty.defaultExpectation.params)
		}
	}

	return mmCreateProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.CreateProperty
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockCreateProperty {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceHandlerMockCreatePropertyExpectation{}
	}

	if mmCreateProperty.defaultExpectation.params != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Expect")
	}

	if mmCreateProperty.defaultExpectation.paramPtrs == nil {
		mmCreateProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockCreatePropertyParamPtrs{}
	}
	mmCreateProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.CreateProperty
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePropertyRequest]) *mPropertyServiceHandlerMockCreateProperty {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceHandlerMockCreatePropertyExpectation{}
	}

	if mmCreateProperty.defaultExpectation.params != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Expect")
	}

	if mmCreateProperty.defaultExpectation.paramPtrs == nil {
		mmCreateProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockCreatePropertyParamPtrs{}
	}
	mmCreateProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.CreateProperty
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest])) *mPropertyServiceHandlerMockCreateProperty {
	if mmCreateProperty.mock.inspectFuncCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.CreateProperty")
	}

	mmCreateProperty.mock.inspectFuncCreateProperty = f

	return mmCreateProperty
}

// Return sets up results that will be returned by PropertyServiceHandler.CreateProperty
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Return(pp2 *connect.Response[v1.CreatePropertyResponse], err error) *PropertyServiceHandlerMock {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceHandlerMockCreatePropertyExpectation{mock: mmCreateProperty.mock}
	}
	mmCreateProperty.defaultExpectation.results = &PropertyServiceHandlerMockCreatePropertyResults{pp2, err}
	mmCreateProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProperty.mock
}

// Set uses given function f to mock the PropertyServiceHandler.CreateProperty method
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) (pp2 *connect.Response[v1.CreatePropertyResponse], err error)) *PropertyServiceHandlerMock {
	if mmCreateProperty.defaultExpectation != nil {
		mmCreateProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.CreateProperty method")
	}

	if len(mmCreateProperty.expectations) > 0 {
		mmCreateProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.CreateProperty method")
	}

	mmCreateProperty.mock.funcCreateProperty = f
	mmCreateProperty.mock.funcCreatePropertyOrigin = minimock.CallerInfo(1)
	return mmCreateProperty.mock
}

// When sets expectation for the PropertyServiceHandler.CreateProperty which will trigger the result defined by the following
// Then helper
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) When(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) *PropertyServiceHandlerMockCreatePropertyExpectation {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.CreateProperty mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockCreatePropertyExpectation{
		mock:               mmCreateProperty.mock,
		params:             &PropertyServiceHandlerMockCreatePropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockCreatePropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProperty.expectations = append(mmCreateProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.CreateProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockCreatePropertyExpectation) Then(pp2 *connect.Response[v1.CreatePropertyResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockCreatePropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.CreateProperty should be invoked
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Times(n uint64) *mPropertyServiceHandlerMockCreateProperty {
	if n == 0 {
		mmCreateProperty.mock.t.Fatalf("Times of PropertyServiceHandlerMock.CreateProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProperty.expectedInvocations, n)
	mmCreateProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProperty
}

func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) invocationsDone() bool {
	if len(mmCreateProperty.expectations) == 0 && mmCreateProperty.defaultExpectation == nil && mmCreateProperty.mock.funcCreateProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProperty.mock.afterCreatePropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProperty implements mm_propertyv1connect.PropertyServiceHandler
func (mmCreateProperty *PropertyServiceHandlerMock) CreateProperty(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) (pp2 *connect.Response[v1.CreatePropertyResponse], err error) {
	mm_atomic.AddUint64(&mmCreateProperty.beforeCreatePropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProperty.afterCreatePropertyCounter, 1)

	mmCreateProperty.t.Helper()

	if mmCreateProperty.inspectFuncCreateProperty != nil {
		mmCreateProperty.inspectFuncCreateProperty(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockCreatePropertyParams{ctx, pp1}

	// Record call args
	mmCreateProperty.CreatePropertyMock.mutex.Lock()
	mmCreateProperty.CreatePropertyMock.callArgs = append(mmCreateProperty.CreatePropertyMock.callArgs, &mm_params)
	mmCreateProperty.CreatePropertyMock.mutex.Unlock()

	for _, e := range mmCreateProperty.CreatePropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateProperty.CreatePropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProperty.CreatePropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProperty.CreatePropertyMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProperty.CreatePropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockCreatePropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProperty.t.Errorf("PropertyServiceHandlerMock.CreateProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProperty.CreatePropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateProperty.t.Errorf("PropertyServiceHandlerMock.CreateProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProperty.CreatePropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProperty.t.Errorf("PropertyServiceHandlerMock.CreateProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProperty.CreatePropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProperty.CreatePropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProperty.t.Fatal("No results are set for the PropertyServiceHandlerMock.CreateProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateProperty.funcCreateProperty != nil {
		return mmCreateProperty.funcCreateProperty(ctx, pp1)
	}
	mmCreateProperty.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.CreateProperty. %v %v", ctx, pp1)
	return
}

// CreatePropertyAfterCounter returns a count of finished PropertyServiceHandlerMock.CreateProperty invocations
func (mmCreateProperty *PropertyServiceHandlerMock) CreatePropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProperty.afterCreatePropertyCounter)
}

// CreatePropertyBeforeCounter returns a count of PropertyServiceHandlerMock.CreateProperty invocations
func (mmCreateProperty *PropertyServiceHandlerMock) CreatePropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProperty.beforeCreatePropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.CreateProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProperty *mPropertyServiceHandlerMockCreateProperty) Calls() []*PropertyServiceHandlerMockCreatePropertyParams {
	mmCreateProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockCreatePropertyParams, len(mmCreateProperty.callArgs))
	copy(argCopy, mmCreateProperty.callArgs)

	mmCreateProperty.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePropertyDone returns true if the count of the CreateProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockCreatePropertyDone() bool {
	if m.CreatePropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePropertyMock.invocationsDone()
}

// MinimockCreatePropertyInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockCreatePropertyInspect() {
	for _, e := range m.CreatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.CreateProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePropertyCounter := mm_atomic.LoadUint64(&m.afterCreatePropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePropertyMock.defaultExpectation != nil && afterCreatePropertyCounter < 1 {
		if m.CreatePropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.CreateProperty at\n%s", m.CreatePropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.CreateProperty at\n%s with params: %#v", m.CreatePropertyMock.defaultExpectation.expectationOrigins.origin, *m.CreatePropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProperty != nil && afterCreatePropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.CreateProperty at\n%s", m.funcCreatePropertyOrigin)
	}

	if !m.CreatePropertyMock.invocationsDone() && afterCreatePropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.CreateProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePropertyMock.expectedInvocations), m.CreatePropertyMock.expectedInvocationsOrigin, afterCreatePropertyCounter)
	}
}

type mPropertyServiceHandlerMockDeleteLocality struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockDeleteLocalityExpectation
	expectations       []*PropertyServiceHandlerMockDeleteLocalityExpectation

	callArgs []*PropertyServiceHandlerMockDeleteLocalityParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockDeleteLocalityExpectation specifies expectation struct of the PropertyServiceHandler.DeleteLocality
type PropertyServiceHandlerMockDeleteLocalityExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockDeleteLocalityParams
	paramPtrs          *PropertyServiceHandlerMockDeleteLocalityParamPtrs
	expectationOrigins PropertyServiceHandlerMockDeleteLocalityExpectationOrigins
	results            *PropertyServiceHandlerMockDeleteLocalityResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockDeleteLocalityParams contains parameters of the PropertyServiceHandler.DeleteLocality
type PropertyServiceHandlerMockDeleteLocalityParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeleteLocalityRequest]
}

// PropertyServiceHandlerMockDeleteLocalityParamPtrs contains pointers to parameters of the PropertyServiceHandler.DeleteLocality
type PropertyServiceHandlerMockDeleteLocalityParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeleteLocalityRequest]
}

// PropertyServiceHandlerMockDeleteLocalityResults contains results of the PropertyServiceHandler.DeleteLocality
type PropertyServiceHandlerMockDeleteLocalityResults struct {
	pp2 *connect.Response[v1.DeleteLocalityResponse]
	err error
}

// PropertyServiceHandlerMockDeleteLocalityOrigins contains origins of expectations of the PropertyServiceHandler.DeleteLocality
type PropertyServiceHandlerMockDeleteLocalityExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Optional() *mPropertyServiceHandlerMockDeleteLocality {
	mmDeleteLocality.optional = true
	return mmDeleteLocality
}

// Expect sets up expected params for PropertyServiceHandler.DeleteLocality
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Expect(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) *mPropertyServiceHandlerMockDeleteLocality {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceHandlerMockDeleteLocalityExpectation{}
	}

	if mmDeleteLocality.defaultExpectation.paramPtrs != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by ExpectParams functions")
	}

	mmDeleteLocality.defaultExpectation.params = &PropertyServiceHandlerMockDeleteLocalityParams{ctx, pp1}
	mmDeleteLocality.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteLocality.expectations {
		if minimock.Equal(e.params, mmDeleteLocality.defaultExpectation.params) {
			mmDeleteLocality.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteLocality.defaultExpectation.params)
		}
	}

	return mmDeleteLocality
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.DeleteLocality
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockDeleteLocality {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceHandlerMockDeleteLocalityExpectation{}
	}

	if mmDeleteLocality.defaultExpectation.params != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Expect")
	}

	if mmDeleteLocality.defaultExpectation.paramPtrs == nil {
		mmDeleteLocality.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockDeleteLocalityParamPtrs{}
	}
	mmDeleteLocality.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteLocality.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteLocality
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.DeleteLocality
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) ExpectPp1Param2(pp1 *connect.Request[v1.DeleteLocalityRequest]) *mPropertyServiceHandlerMockDeleteLocality {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceHandlerMockDeleteLocalityExpectation{}
	}

	if mmDeleteLocality.defaultExpectation.params != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Expect")
	}

	if mmDeleteLocality.defaultExpectation.paramPtrs == nil {
		mmDeleteLocality.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockDeleteLocalityParamPtrs{}
	}
	mmDeleteLocality.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteLocality.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteLocality
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.DeleteLocality
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest])) *mPropertyServiceHandlerMockDeleteLocality {
	if mmDeleteLocality.mock.inspectFuncDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.DeleteLocality")
	}

	mmDeleteLocality.mock.inspectFuncDeleteLocality = f

	return mmDeleteLocality
}

// Return sets up results that will be returned by PropertyServiceHandler.DeleteLocality
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Return(pp2 *connect.Response[v1.DeleteLocalityResponse], err error) *PropertyServiceHandlerMock {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceHandlerMockDeleteLocalityExpectation{mock: mmDeleteLocality.mock}
	}
	mmDeleteLocality.defaultExpectation.results = &PropertyServiceHandlerMockDeleteLocalityResults{pp2, err}
	mmDeleteLocality.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteLocality.mock
}

// Set uses given function f to mock the PropertyServiceHandler.DeleteLocality method
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) (pp2 *connect.Response[v1.DeleteLocalityResponse], err error)) *PropertyServiceHandlerMock {
	if mmDeleteLocality.defaultExpectation != nil {
		mmDeleteLocality.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.DeleteLocality method")
	}

	if len(mmDeleteLocality.expectations) > 0 {
		mmDeleteLocality.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.DeleteLocality method")
	}

	mmDeleteLocality.mock.funcDeleteLocality = f
	mmDeleteLocality.mock.funcDeleteLocalityOrigin = minimock.CallerInfo(1)
	return mmDeleteLocality.mock
}

// When sets expectation for the PropertyServiceHandler.DeleteLocality which will trigger the result defined by the following
// Then helper
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) When(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) *PropertyServiceHandlerMockDeleteLocalityExpectation {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteLocality mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockDeleteLocalityExpectation{
		mock:               mmDeleteLocality.mock,
		params:             &PropertyServiceHandlerMockDeleteLocalityParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockDeleteLocalityExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteLocality.expectations = append(mmDeleteLocality.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.DeleteLocality return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockDeleteLocalityExpectation) Then(pp2 *connect.Response[v1.DeleteLocalityResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockDeleteLocalityResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.DeleteLocality should be invoked
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Times(n uint64) *mPropertyServiceHandlerMockDeleteLocality {
	if n == 0 {
		mmDeleteLocality.mock.t.Fatalf("Times of PropertyServiceHandlerMock.DeleteLocality mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteLocality.expectedInvocations, n)
	mmDeleteLocality.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteLocality
}

func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) invocationsDone() bool {
	if len(mmDeleteLocality.expectations) == 0 && mmDeleteLocality.defaultExpectation == nil && mmDeleteLocality.mock.funcDeleteLocality == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteLocality.mock.afterDeleteLocalityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteLocality.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteLocality implements mm_propertyv1connect.PropertyServiceHandler
func (mmDeleteLocality *PropertyServiceHandlerMock) DeleteLocality(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) (pp2 *connect.Response[v1.DeleteLocalityResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteLocality.beforeDeleteLocalityCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteLocality.afterDeleteLocalityCounter, 1)

	mmDeleteLocality.t.Helper()

	if mmDeleteLocality.inspectFuncDeleteLocality != nil {
		mmDeleteLocality.inspectFuncDeleteLocality(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockDeleteLocalityParams{ctx, pp1}

	// Record call args
	mmDeleteLocality.DeleteLocalityMock.mutex.Lock()
	mmDeleteLocality.DeleteLocalityMock.callArgs = append(mmDeleteLocality.DeleteLocalityMock.callArgs, &mm_params)
	mmDeleteLocality.DeleteLocalityMock.mutex.Unlock()

	for _, e := range mmDeleteLocality.DeleteLocalityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteLocality.DeleteLocalityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteLocality.DeleteLocalityMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteLocality.DeleteLocalityMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteLocality.DeleteLocalityMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockDeleteLocalityParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteLocality.t.Errorf("PropertyServiceHandlerMock.DeleteLocality got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLocality.DeleteLocalityMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteLocality.t.Errorf("PropertyServiceHandlerMock.DeleteLocality got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLocality.DeleteLocalityMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteLocality.t.Errorf("PropertyServiceHandlerMock.DeleteLocality got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteLocality.DeleteLocalityMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteLocality.DeleteLocalityMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteLocality.t.Fatal("No results are set for the PropertyServiceHandlerMock.DeleteLocality")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteLocality.funcDeleteLocality != nil {
		return mmDeleteLocality.funcDeleteLocality(ctx, pp1)
	}
	mmDeleteLocality.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.DeleteLocality. %v %v", ctx, pp1)
	return
}

// DeleteLocalityAfterCounter returns a count of finished PropertyServiceHandlerMock.DeleteLocality invocations
func (mmDeleteLocality *PropertyServiceHandlerMock) DeleteLocalityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLocality.afterDeleteLocalityCounter)
}

// DeleteLocalityBeforeCounter returns a count of PropertyServiceHandlerMock.DeleteLocality invocations
func (mmDeleteLocality *PropertyServiceHandlerMock) DeleteLocalityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLocality.beforeDeleteLocalityCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.DeleteLocality.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteLocality *mPropertyServiceHandlerMockDeleteLocality) Calls() []*PropertyServiceHandlerMockDeleteLocalityParams {
	mmDeleteLocality.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockDeleteLocalityParams, len(mmDeleteLocality.callArgs))
	copy(argCopy, mmDeleteLocality.callArgs)

	mmDeleteLocality.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteLocalityDone returns true if the count of the DeleteLocality invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockDeleteLocalityDone() bool {
	if m.DeleteLocalityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteLocalityMock.invocationsDone()
}

// MinimockDeleteLocalityInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockDeleteLocalityInspect() {
	for _, e := range m.DeleteLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteLocality at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteLocalityCounter := mm_atomic.LoadUint64(&m.afterDeleteLocalityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteLocalityMock.defaultExpectation != nil && afterDeleteLocalityCounter < 1 {
		if m.DeleteLocalityMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteLocality at\n%s", m.DeleteLocalityMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteLocality at\n%s with params: %#v", m.DeleteLocalityMock.defaultExpectation.expectationOrigins.origin, *m.DeleteLocalityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteLocality != nil && afterDeleteLocalityCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteLocality at\n%s", m.funcDeleteLocalityOrigin)
	}

	if !m.DeleteLocalityMock.invocationsDone() && afterDeleteLocalityCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.DeleteLocality at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteLocalityMock.expectedInvocations), m.DeleteLocalityMock.expectedInvocationsOrigin, afterDeleteLocalityCounter)
	}
}

type mPropertyServiceHandlerMockDeleteProperty struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockDeletePropertyExpectation
	expectations       []*PropertyServiceHandlerMockDeletePropertyExpectation

	callArgs []*PropertyServiceHandlerMockDeletePropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockDeletePropertyExpectation specifies expectation struct of the PropertyServiceHandler.DeleteProperty
type PropertyServiceHandlerMockDeletePropertyExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockDeletePropertyParams
	paramPtrs          *PropertyServiceHandlerMockDeletePropertyParamPtrs
	expectationOrigins PropertyServiceHandlerMockDeletePropertyExpectationOrigins
	results            *PropertyServiceHandlerMockDeletePropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockDeletePropertyParams contains parameters of the PropertyServiceHandler.DeleteProperty
type PropertyServiceHandlerMockDeletePropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeletePropertyRequest]
}

// PropertyServiceHandlerMockDeletePropertyParamPtrs contains pointers to parameters of the PropertyServiceHandler.DeleteProperty
type PropertyServiceHandlerMockDeletePropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeletePropertyRequest]
}

// PropertyServiceHandlerMockDeletePropertyResults contains results of the PropertyServiceHandler.DeleteProperty
type PropertyServiceHandlerMockDeletePropertyResults struct {
	pp2 *connect.Response[v1.DeletePropertyResponse]
	err error
}

// PropertyServiceHandlerMockDeletePropertyOrigins contains origins of expectations of the PropertyServiceHandler.DeleteProperty
type PropertyServiceHandlerMockDeletePropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Optional() *mPropertyServiceHandlerMockDeleteProperty {
	mmDeleteProperty.optional = true
	return mmDeleteProperty
}

// Expect sets up expected params for PropertyServiceHandler.DeleteProperty
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) *mPropertyServiceHandlerMockDeleteProperty {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceHandlerMockDeletePropertyExpectation{}
	}

	if mmDeleteProperty.defaultExpectation.paramPtrs != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by ExpectParams functions")
	}

	mmDeleteProperty.defaultExpectation.params = &PropertyServiceHandlerMockDeletePropertyParams{ctx, pp1}
	mmDeleteProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProperty.expectations {
		if minimock.Equal(e.params, mmDeleteProperty.defaultExpectation.params) {
			mmDeleteProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProperty.defaultExpectation.params)
		}
	}

	return mmDeleteProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.DeleteProperty
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockDeleteProperty {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceHandlerMockDeletePropertyExpectation{}
	}

	if mmDeleteProperty.defaultExpectation.params != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Expect")
	}

	if mmDeleteProperty.defaultExpectation.paramPtrs == nil {
		mmDeleteProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockDeletePropertyParamPtrs{}
	}
	mmDeleteProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.DeleteProperty
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) ExpectPp1Param2(pp1 *connect.Request[v1.DeletePropertyRequest]) *mPropertyServiceHandlerMockDeleteProperty {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceHandlerMockDeletePropertyExpectation{}
	}

	if mmDeleteProperty.defaultExpectation.params != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Expect")
	}

	if mmDeleteProperty.defaultExpectation.paramPtrs == nil {
		mmDeleteProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockDeletePropertyParamPtrs{}
	}
	mmDeleteProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.DeleteProperty
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest])) *mPropertyServiceHandlerMockDeleteProperty {
	if mmDeleteProperty.mock.inspectFuncDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.DeleteProperty")
	}

	mmDeleteProperty.mock.inspectFuncDeleteProperty = f

	return mmDeleteProperty
}

// Return sets up results that will be returned by PropertyServiceHandler.DeleteProperty
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Return(pp2 *connect.Response[v1.DeletePropertyResponse], err error) *PropertyServiceHandlerMock {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceHandlerMockDeletePropertyExpectation{mock: mmDeleteProperty.mock}
	}
	mmDeleteProperty.defaultExpectation.results = &PropertyServiceHandlerMockDeletePropertyResults{pp2, err}
	mmDeleteProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProperty.mock
}

// Set uses given function f to mock the PropertyServiceHandler.DeleteProperty method
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) (pp2 *connect.Response[v1.DeletePropertyResponse], err error)) *PropertyServiceHandlerMock {
	if mmDeleteProperty.defaultExpectation != nil {
		mmDeleteProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.DeleteProperty method")
	}

	if len(mmDeleteProperty.expectations) > 0 {
		mmDeleteProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.DeleteProperty method")
	}

	mmDeleteProperty.mock.funcDeleteProperty = f
	mmDeleteProperty.mock.funcDeletePropertyOrigin = minimock.CallerInfo(1)
	return mmDeleteProperty.mock
}

// When sets expectation for the PropertyServiceHandler.DeleteProperty which will trigger the result defined by the following
// Then helper
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) When(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) *PropertyServiceHandlerMockDeletePropertyExpectation {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteProperty mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockDeletePropertyExpectation{
		mock:               mmDeleteProperty.mock,
		params:             &PropertyServiceHandlerMockDeletePropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockDeletePropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProperty.expectations = append(mmDeleteProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.DeleteProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockDeletePropertyExpectation) Then(pp2 *connect.Response[v1.DeletePropertyResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockDeletePropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.DeleteProperty should be invoked
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Times(n uint64) *mPropertyServiceHandlerMockDeleteProperty {
	if n == 0 {
		mmDeleteProperty.mock.t.Fatalf("Times of PropertyServiceHandlerMock.DeleteProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProperty.expectedInvocations, n)
	mmDeleteProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProperty
}

func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) invocationsDone() bool {
	if len(mmDeleteProperty.expectations) == 0 && mmDeleteProperty.defaultExpectation == nil && mmDeleteProperty.mock.funcDeleteProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProperty.mock.afterDeletePropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProperty implements mm_propertyv1connect.PropertyServiceHandler
func (mmDeleteProperty *PropertyServiceHandlerMock) DeleteProperty(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) (pp2 *connect.Response[v1.DeletePropertyResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteProperty.beforeDeletePropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProperty.afterDeletePropertyCounter, 1)

	mmDeleteProperty.t.Helper()

	if mmDeleteProperty.inspectFuncDeleteProperty != nil {
		mmDeleteProperty.inspectFuncDeleteProperty(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockDeletePropertyParams{ctx, pp1}

	// Record call args
	mmDeleteProperty.DeletePropertyMock.mutex.Lock()
	mmDeleteProperty.DeletePropertyMock.callArgs = append(mmDeleteProperty.DeletePropertyMock.callArgs, &mm_params)
	mmDeleteProperty.DeletePropertyMock.mutex.Unlock()

	for _, e := range mmDeleteProperty.DeletePropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteProperty.DeletePropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProperty.DeletePropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProperty.DeletePropertyMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProperty.DeletePropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockDeletePropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteProperty.t.Errorf("PropertyServiceHandlerMock.DeleteProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProperty.DeletePropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteProperty.t.Errorf("PropertyServiceHandlerMock.DeleteProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProperty.DeletePropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProperty.t.Errorf("PropertyServiceHandlerMock.DeleteProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProperty.DeletePropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProperty.DeletePropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProperty.t.Fatal("No results are set for the PropertyServiceHandlerMock.DeleteProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteProperty.funcDeleteProperty != nil {
		return mmDeleteProperty.funcDeleteProperty(ctx, pp1)
	}
	mmDeleteProperty.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.DeleteProperty. %v %v", ctx, pp1)
	return
}

// DeletePropertyAfterCounter returns a count of finished PropertyServiceHandlerMock.DeleteProperty invocations
func (mmDeleteProperty *PropertyServiceHandlerMock) DeletePropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProperty.afterDeletePropertyCounter)
}

// DeletePropertyBeforeCounter returns a count of PropertyServiceHandlerMock.DeleteProperty invocations
func (mmDeleteProperty *PropertyServiceHandlerMock) DeletePropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProperty.beforeDeletePropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.DeleteProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProperty *mPropertyServiceHandlerMockDeleteProperty) Calls() []*PropertyServiceHandlerMockDeletePropertyParams {
	mmDeleteProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockDeletePropertyParams, len(mmDeleteProperty.callArgs))
	copy(argCopy, mmDeleteProperty.callArgs)

	mmDeleteProperty.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePropertyDone returns true if the count of the DeleteProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockDeletePropertyDone() bool {
	if m.DeletePropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePropertyMock.invocationsDone()
}

// MinimockDeletePropertyInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockDeletePropertyInspect() {
	for _, e := range m.DeletePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePropertyCounter := mm_atomic.LoadUint64(&m.afterDeletePropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePropertyMock.defaultExpectation != nil && afterDeletePropertyCounter < 1 {
		if m.DeletePropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteProperty at\n%s", m.DeletePropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteProperty at\n%s with params: %#v", m.DeletePropertyMock.defaultExpectation.expectationOrigins.origin, *m.DeletePropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProperty != nil && afterDeletePropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteProperty at\n%s", m.funcDeletePropertyOrigin)
	}

	if !m.DeletePropertyMock.invocationsDone() && afterDeletePropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.DeleteProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePropertyMock.expectedInvocations), m.DeletePropertyMock.expectedInvocationsOrigin, afterDeletePropertyCounter)
	}
}

type mPropertyServiceHandlerMockDeleteSubscription struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockDeleteSubscriptionExpectation
	expectations       []*PropertyServiceHandlerMockDeleteSubscriptionExpectation

	callArgs []*PropertyServiceHandlerMockDeleteSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockDeleteSubscriptionExpectation specifies expectation struct of the PropertyServiceHandler.DeleteSubscription
type PropertyServiceHandlerMockDeleteSubscriptionExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockDeleteSubscriptionParams
	paramPtrs          *PropertyServiceHandlerMockDeleteSubscriptionParamPtrs
	expectationOrigins PropertyServiceHandlerMockDeleteSubscriptionExpectationOrigins
	results            *PropertyServiceHandlerMockDeleteSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockDeleteSubscriptionParams contains parameters of the PropertyServiceHandler.DeleteSubscription
type PropertyServiceHandlerMockDeleteSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeleteSubscriptionRequest]
}

// PropertyServiceHandlerMockDeleteSubscriptionParamPtrs contains pointers to parameters of the PropertyServiceHandler.DeleteSubscription
type PropertyServiceHandlerMockDeleteSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeleteSubscriptionRequest]
}

// PropertyServiceHandlerMockDeleteSubscriptionResults contains results of the PropertyServiceHandler.DeleteSubscription
type PropertyServiceHandlerMockDeleteSubscriptionResults struct {
	pp2 *connect.Response[v1.DeleteSubscriptionResponse]
	err error
}

// PropertyServiceHandlerMockDeleteSubscriptionOrigins contains origins of expectations of the PropertyServiceHandler.DeleteSubscription
type PropertyServiceHandlerMockDeleteSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Optional() *mPropertyServiceHandlerMockDeleteSubscription {
	mmDeleteSubscription.optional = true
	return mmDeleteSubscription
}

// Expect sets up expected params for PropertyServiceHandler.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) *mPropertyServiceHandlerMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceHandlerMockDeleteSubscriptionExpectation{}
	}

	if mmDeleteSubscription.defaultExpectation.paramPtrs != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by ExpectParams functions")
	}

	mmDeleteSubscription.defaultExpectation.params = &PropertyServiceHandlerMockDeleteSubscriptionParams{ctx, pp1}
	mmDeleteSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSubscription.expectations {
		if minimock.Equal(e.params, mmDeleteSubscription.defaultExpectation.params) {
			mmDeleteSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscription.defaultExpectation.params)
		}
	}

	return mmDeleteSubscription
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceHandlerMockDeleteSubscriptionExpectation{}
	}

	if mmDeleteSubscription.defaultExpectation.params != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Expect")
	}

	if mmDeleteSubscription.defaultExpectation.paramPtrs == nil {
		mmDeleteSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockDeleteSubscriptionParamPtrs{}
	}
	mmDeleteSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.DeleteSubscriptionRequest]) *mPropertyServiceHandlerMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceHandlerMockDeleteSubscriptionExpectation{}
	}

	if mmDeleteSubscription.defaultExpectation.params != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Expect")
	}

	if mmDeleteSubscription.defaultExpectation.paramPtrs == nil {
		mmDeleteSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockDeleteSubscriptionParamPtrs{}
	}
	mmDeleteSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteSubscription
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest])) *mPropertyServiceHandlerMockDeleteSubscription {
	if mmDeleteSubscription.mock.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.DeleteSubscription")
	}

	mmDeleteSubscription.mock.inspectFuncDeleteSubscription = f

	return mmDeleteSubscription
}

// Return sets up results that will be returned by PropertyServiceHandler.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Return(pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error) *PropertyServiceHandlerMock {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceHandlerMockDeleteSubscriptionExpectation{mock: mmDeleteSubscription.mock}
	}
	mmDeleteSubscription.defaultExpectation.results = &PropertyServiceHandlerMockDeleteSubscriptionResults{pp2, err}
	mmDeleteSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSubscription.mock
}

// Set uses given function f to mock the PropertyServiceHandler.DeleteSubscription method
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) (pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error)) *PropertyServiceHandlerMock {
	if mmDeleteSubscription.defaultExpectation != nil {
		mmDeleteSubscription.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.DeleteSubscription method")
	}

	if len(mmDeleteSubscription.expectations) > 0 {
		mmDeleteSubscription.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.DeleteSubscription method")
	}

	mmDeleteSubscription.mock.funcDeleteSubscription = f
	mmDeleteSubscription.mock.funcDeleteSubscriptionOrigin = minimock.CallerInfo(1)
	return mmDeleteSubscription.mock
}

// When sets expectation for the PropertyServiceHandler.DeleteSubscription which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) When(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) *PropertyServiceHandlerMockDeleteSubscriptionExpectation {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.DeleteSubscription mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockDeleteSubscriptionExpectation{
		mock:               mmDeleteSubscription.mock,
		params:             &PropertyServiceHandlerMockDeleteSubscriptionParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockDeleteSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSubscription.expectations = append(mmDeleteSubscription.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.DeleteSubscription return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockDeleteSubscriptionExpectation) Then(pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockDeleteSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.DeleteSubscription should be invoked
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Times(n uint64) *mPropertyServiceHandlerMockDeleteSubscription {
	if n == 0 {
		mmDeleteSubscription.mock.t.Fatalf("Times of PropertyServiceHandlerMock.DeleteSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSubscription.expectedInvocations, n)
	mmDeleteSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSubscription
}

func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) invocationsDone() bool {
	if len(mmDeleteSubscription.expectations) == 0 && mmDeleteSubscription.defaultExpectation == nil && mmDeleteSubscription.mock.funcDeleteSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSubscription.mock.afterDeleteSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSubscription implements mm_propertyv1connect.PropertyServiceHandler
func (mmDeleteSubscription *PropertyServiceHandlerMock) DeleteSubscription(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) (pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter, 1)

	mmDeleteSubscription.t.Helper()

	if mmDeleteSubscription.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.inspectFuncDeleteSubscription(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockDeleteSubscriptionParams{ctx, pp1}

	// Record call args
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Lock()
	mmDeleteSubscription.DeleteSubscriptionMock.callArgs = append(mmDeleteSubscription.DeleteSubscriptionMock.callArgs, &mm_params)
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Unlock()

	for _, e := range mmDeleteSubscription.DeleteSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockDeleteSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSubscription.t.Errorf("PropertyServiceHandlerMock.DeleteSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteSubscription.t.Errorf("PropertyServiceHandlerMock.DeleteSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscription.t.Errorf("PropertyServiceHandlerMock.DeleteSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscription.t.Fatal("No results are set for the PropertyServiceHandlerMock.DeleteSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteSubscription.funcDeleteSubscription != nil {
		return mmDeleteSubscription.funcDeleteSubscription(ctx, pp1)
	}
	mmDeleteSubscription.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.DeleteSubscription. %v %v", ctx, pp1)
	return
}

// DeleteSubscriptionAfterCounter returns a count of finished PropertyServiceHandlerMock.DeleteSubscription invocations
func (mmDeleteSubscription *PropertyServiceHandlerMock) DeleteSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter)
}

// DeleteSubscriptionBeforeCounter returns a count of PropertyServiceHandlerMock.DeleteSubscription invocations
func (mmDeleteSubscription *PropertyServiceHandlerMock) DeleteSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.DeleteSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscription *mPropertyServiceHandlerMockDeleteSubscription) Calls() []*PropertyServiceHandlerMockDeleteSubscriptionParams {
	mmDeleteSubscription.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockDeleteSubscriptionParams, len(mmDeleteSubscription.callArgs))
	copy(argCopy, mmDeleteSubscription.callArgs)

	mmDeleteSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriptionDone returns true if the count of the DeleteSubscription invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockDeleteSubscriptionDone() bool {
	if m.DeleteSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSubscriptionMock.invocationsDone()
}

// MinimockDeleteSubscriptionInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockDeleteSubscriptionInspect() {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSubscriptionCounter := mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && afterDeleteSubscriptionCounter < 1 {
		if m.DeleteSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteSubscription at\n%s", m.DeleteSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteSubscription at\n%s with params: %#v", m.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && afterDeleteSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.DeleteSubscription at\n%s", m.funcDeleteSubscriptionOrigin)
	}

	if !m.DeleteSubscriptionMock.invocationsDone() && afterDeleteSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.DeleteSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSubscriptionMock.expectedInvocations), m.DeleteSubscriptionMock.expectedInvocationsOrigin, afterDeleteSubscriptionCounter)
	}
}

type mPropertyServiceHandlerMockHistoryOfProperty struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockHistoryOfPropertyExpectation
	expectations       []*PropertyServiceHandlerMockHistoryOfPropertyExpectation

	callArgs []*PropertyServiceHandlerMockHistoryOfPropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockHistoryOfPropertyExpectation specifies expectation struct of the PropertyServiceHandler.HistoryOfProperty
type PropertyServiceHandlerMockHistoryOfPropertyExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockHistoryOfPropertyParams
	paramPtrs          *PropertyServiceHandlerMockHistoryOfPropertyParamPtrs
	expectationOrigins PropertyServiceHandlerMockHistoryOfPropertyExpectationOrigins
	results            *PropertyServiceHandlerMockHistoryOfPropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockHistoryOfPropertyParams contains parameters of the PropertyServiceHandler.HistoryOfProperty
type PropertyServiceHandlerMockHistoryOfPropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.HistoryOfPropertyRequest]
	pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]
}

// PropertyServiceHandlerMockHistoryOfPropertyParamPtrs contains pointers to parameters of the PropertyServiceHandler.HistoryOfProperty
type PropertyServiceHandlerMockHistoryOfPropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.HistoryOfPropertyRequest]
	pp2 **connect.ServerStream[v1.HistoryOfPropertyResponse]
}

// PropertyServiceHandlerMockHistoryOfPropertyResults contains results of the PropertyServiceHandler.HistoryOfProperty
type PropertyServiceHandlerMockHistoryOfPropertyResults struct {
	err error
}

// PropertyServiceHandlerMockHistoryOfPropertyOrigins contains origins of expectations of the PropertyServiceHandler.HistoryOfProperty
type PropertyServiceHandlerMockHistoryOfPropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Optional() *mPropertyServiceHandlerMockHistoryOfProperty {
	mmHistoryOfProperty.optional = true
	return mmHistoryOfProperty
}

// Expect sets up expected params for PropertyServiceHandler.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]) *mPropertyServiceHandlerMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceHandlerMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by ExpectParams functions")
	}

	mmHistoryOfProperty.defaultExpectation.params = &PropertyServiceHandlerMockHistoryOfPropertyParams{ctx, pp1, pp2}
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistoryOfProperty.expectations {
		if minimock.Equal(e.params, mmHistoryOfProperty.defaultExpectation.params) {
			mmHistoryOfProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistoryOfProperty.defaultExpectation.params)
		}
	}

	return mmHistoryOfProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceHandlerMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.params != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Expect")
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs == nil {
		mmHistoryOfProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockHistoryOfPropertyParamPtrs{}
	}
	mmHistoryOfProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHistoryOfProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) ExpectPp1Param2(pp1 *connect.Request[v1.HistoryOfPropertyRequest]) *mPropertyServiceHandlerMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceHandlerMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.params != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Expect")
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs == nil {
		mmHistoryOfProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockHistoryOfPropertyParamPtrs{}
	}
	mmHistoryOfProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmHistoryOfProperty
}

// ExpectPp2Param3 sets up expected param pp2 for PropertyServiceHandler.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) ExpectPp2Param3(pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]) *mPropertyServiceHandlerMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceHandlerMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.params != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Expect")
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs == nil {
		mmHistoryOfProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockHistoryOfPropertyParamPtrs{}
	}
	mmHistoryOfProperty.defaultExpectation.paramPtrs.pp2 = &pp2
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmHistoryOfProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse])) *mPropertyServiceHandlerMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.inspectFuncHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.HistoryOfProperty")
	}

	mmHistoryOfProperty.mock.inspectFuncHistoryOfProperty = f

	return mmHistoryOfProperty
}

// Return sets up results that will be returned by PropertyServiceHandler.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Return(err error) *PropertyServiceHandlerMock {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceHandlerMockHistoryOfPropertyExpectation{mock: mmHistoryOfProperty.mock}
	}
	mmHistoryOfProperty.defaultExpectation.results = &PropertyServiceHandlerMockHistoryOfPropertyResults{err}
	mmHistoryOfProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistoryOfProperty.mock
}

// Set uses given function f to mock the PropertyServiceHandler.HistoryOfProperty method
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]) (err error)) *PropertyServiceHandlerMock {
	if mmHistoryOfProperty.defaultExpectation != nil {
		mmHistoryOfProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.HistoryOfProperty method")
	}

	if len(mmHistoryOfProperty.expectations) > 0 {
		mmHistoryOfProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.HistoryOfProperty method")
	}

	mmHistoryOfProperty.mock.funcHistoryOfProperty = f
	mmHistoryOfProperty.mock.funcHistoryOfPropertyOrigin = minimock.CallerInfo(1)
	return mmHistoryOfProperty.mock
}

// When sets expectation for the PropertyServiceHandler.HistoryOfProperty which will trigger the result defined by the following
// Then helper
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) When(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]) *PropertyServiceHandlerMockHistoryOfPropertyExpectation {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.HistoryOfProperty mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockHistoryOfPropertyExpectation{
		mock:               mmHistoryOfProperty.mock,
		params:             &PropertyServiceHandlerMockHistoryOfPropertyParams{ctx, pp1, pp2},
		expectationOrigins: PropertyServiceHandlerMockHistoryOfPropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistoryOfProperty.expectations = append(mmHistoryOfProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.HistoryOfProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockHistoryOfPropertyExpectation) Then(err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockHistoryOfPropertyResults{err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.HistoryOfProperty should be invoked
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Times(n uint64) *mPropertyServiceHandlerMockHistoryOfProperty {
	if n == 0 {
		mmHistoryOfProperty.mock.t.Fatalf("Times of PropertyServiceHandlerMock.HistoryOfProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistoryOfProperty.expectedInvocations, n)
	mmHistoryOfProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistoryOfProperty
}

func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) invocationsDone() bool {
	if len(mmHistoryOfProperty.expectations) == 0 && mmHistoryOfProperty.defaultExpectation == nil && mmHistoryOfProperty.mock.funcHistoryOfProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistoryOfProperty.mock.afterHistoryOfPropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistoryOfProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HistoryOfProperty implements mm_propertyv1connect.PropertyServiceHandler
func (mmHistoryOfProperty *PropertyServiceHandlerMock) HistoryOfProperty(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest], pp2 *connect.ServerStream[v1.HistoryOfPropertyResponse]) (err error) {
	mm_atomic.AddUint64(&mmHistoryOfProperty.beforeHistoryOfPropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmHistoryOfProperty.afterHistoryOfPropertyCounter, 1)

	mmHistoryOfProperty.t.Helper()

	if mmHistoryOfProperty.inspectFuncHistoryOfProperty != nil {
		mmHistoryOfProperty.inspectFuncHistoryOfProperty(ctx, pp1, pp2)
	}

	mm_params := PropertyServiceHandlerMockHistoryOfPropertyParams{ctx, pp1, pp2}

	// Record call args
	mmHistoryOfProperty.HistoryOfPropertyMock.mutex.Lock()
	mmHistoryOfProperty.HistoryOfPropertyMock.callArgs = append(mmHistoryOfProperty.HistoryOfPropertyMock.callArgs, &mm_params)
	mmHistoryOfProperty.HistoryOfPropertyMock.mutex.Unlock()

	for _, e := range mmHistoryOfProperty.HistoryOfPropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.params
		mm_want_ptrs := mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockHistoryOfPropertyParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHistoryOfProperty.t.Errorf("PropertyServiceHandlerMock.HistoryOfProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmHistoryOfProperty.t.Errorf("PropertyServiceHandlerMock.HistoryOfProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmHistoryOfProperty.t.Errorf("PropertyServiceHandlerMock.HistoryOfProperty got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistoryOfProperty.t.Errorf("PropertyServiceHandlerMock.HistoryOfProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmHistoryOfProperty.t.Fatal("No results are set for the PropertyServiceHandlerMock.HistoryOfProperty")
		}
		return (*mm_results).err
	}
	if mmHistoryOfProperty.funcHistoryOfProperty != nil {
		return mmHistoryOfProperty.funcHistoryOfProperty(ctx, pp1, pp2)
	}
	mmHistoryOfProperty.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.HistoryOfProperty. %v %v %v", ctx, pp1, pp2)
	return
}

// HistoryOfPropertyAfterCounter returns a count of finished PropertyServiceHandlerMock.HistoryOfProperty invocations
func (mmHistoryOfProperty *PropertyServiceHandlerMock) HistoryOfPropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistoryOfProperty.afterHistoryOfPropertyCounter)
}

// HistoryOfPropertyBeforeCounter returns a count of PropertyServiceHandlerMock.HistoryOfProperty invocations
func (mmHistoryOfProperty *PropertyServiceHandlerMock) HistoryOfPropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistoryOfProperty.beforeHistoryOfPropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.HistoryOfProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistoryOfProperty *mPropertyServiceHandlerMockHistoryOfProperty) Calls() []*PropertyServiceHandlerMockHistoryOfPropertyParams {
	mmHistoryOfProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockHistoryOfPropertyParams, len(mmHistoryOfProperty.callArgs))
	copy(argCopy, mmHistoryOfProperty.callArgs)

	mmHistoryOfProperty.mutex.RUnlock()

	return argCopy
}

// MinimockHistoryOfPropertyDone returns true if the count of the HistoryOfProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockHistoryOfPropertyDone() bool {
	if m.HistoryOfPropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistoryOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistoryOfPropertyMock.invocationsDone()
}

// MinimockHistoryOfPropertyInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockHistoryOfPropertyInspect() {
	for _, e := range m.HistoryOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.HistoryOfProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistoryOfPropertyCounter := mm_atomic.LoadUint64(&m.afterHistoryOfPropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistoryOfPropertyMock.defaultExpectation != nil && afterHistoryOfPropertyCounter < 1 {
		if m.HistoryOfPropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.HistoryOfProperty at\n%s", m.HistoryOfPropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.HistoryOfProperty at\n%s with params: %#v", m.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.origin, *m.HistoryOfPropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistoryOfProperty != nil && afterHistoryOfPropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.HistoryOfProperty at\n%s", m.funcHistoryOfPropertyOrigin)
	}

	if !m.HistoryOfPropertyMock.invocationsDone() && afterHistoryOfPropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.HistoryOfProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistoryOfPropertyMock.expectedInvocations), m.HistoryOfPropertyMock.expectedInvocationsOrigin, afterHistoryOfPropertyCounter)
	}
}

type mPropertyServiceHandlerMockListPropertyType struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockListPropertyTypeExpectation
	expectations       []*PropertyServiceHandlerMockListPropertyTypeExpectation

	callArgs []*PropertyServiceHandlerMockListPropertyTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockListPropertyTypeExpectation specifies expectation struct of the PropertyServiceHandler.ListPropertyType
type PropertyServiceHandlerMockListPropertyTypeExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockListPropertyTypeParams
	paramPtrs          *PropertyServiceHandlerMockListPropertyTypeParamPtrs
	expectationOrigins PropertyServiceHandlerMockListPropertyTypeExpectationOrigins
	results            *PropertyServiceHandlerMockListPropertyTypeResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockListPropertyTypeParams contains parameters of the PropertyServiceHandler.ListPropertyType
type PropertyServiceHandlerMockListPropertyTypeParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListPropertyTypeRequest]
	pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]
}

// PropertyServiceHandlerMockListPropertyTypeParamPtrs contains pointers to parameters of the PropertyServiceHandler.ListPropertyType
type PropertyServiceHandlerMockListPropertyTypeParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListPropertyTypeRequest]
	pp2 **connect.ServerStream[v1.ListPropertyTypeResponse]
}

// PropertyServiceHandlerMockListPropertyTypeResults contains results of the PropertyServiceHandler.ListPropertyType
type PropertyServiceHandlerMockListPropertyTypeResults struct {
	err error
}

// PropertyServiceHandlerMockListPropertyTypeOrigins contains origins of expectations of the PropertyServiceHandler.ListPropertyType
type PropertyServiceHandlerMockListPropertyTypeExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Optional() *mPropertyServiceHandlerMockListPropertyType {
	mmListPropertyType.optional = true
	return mmListPropertyType
}

// Expect sets up expected params for PropertyServiceHandler.ListPropertyType
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Expect(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]) *mPropertyServiceHandlerMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceHandlerMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.paramPtrs != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by ExpectParams functions")
	}

	mmListPropertyType.defaultExpectation.params = &PropertyServiceHandlerMockListPropertyTypeParams{ctx, pp1, pp2}
	mmListPropertyType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPropertyType.expectations {
		if minimock.Equal(e.params, mmListPropertyType.defaultExpectation.params) {
			mmListPropertyType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPropertyType.defaultExpectation.params)
		}
	}

	return mmListPropertyType
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.ListPropertyType
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceHandlerMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.params != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Expect")
	}

	if mmListPropertyType.defaultExpectation.paramPtrs == nil {
		mmListPropertyType.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockListPropertyTypeParamPtrs{}
	}
	mmListPropertyType.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPropertyType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPropertyType
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.ListPropertyType
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) ExpectPp1Param2(pp1 *connect.Request[v1.ListPropertyTypeRequest]) *mPropertyServiceHandlerMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceHandlerMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.params != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Expect")
	}

	if mmListPropertyType.defaultExpectation.paramPtrs == nil {
		mmListPropertyType.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockListPropertyTypeParamPtrs{}
	}
	mmListPropertyType.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListPropertyType.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListPropertyType
}

// ExpectPp2Param3 sets up expected param pp2 for PropertyServiceHandler.ListPropertyType
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]) *mPropertyServiceHandlerMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceHandlerMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.params != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Expect")
	}

	if mmListPropertyType.defaultExpectation.paramPtrs == nil {
		mmListPropertyType.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockListPropertyTypeParamPtrs{}
	}
	mmListPropertyType.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListPropertyType.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListPropertyType
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.ListPropertyType
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse])) *mPropertyServiceHandlerMockListPropertyType {
	if mmListPropertyType.mock.inspectFuncListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.ListPropertyType")
	}

	mmListPropertyType.mock.inspectFuncListPropertyType = f

	return mmListPropertyType
}

// Return sets up results that will be returned by PropertyServiceHandler.ListPropertyType
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Return(err error) *PropertyServiceHandlerMock {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceHandlerMockListPropertyTypeExpectation{mock: mmListPropertyType.mock}
	}
	mmListPropertyType.defaultExpectation.results = &PropertyServiceHandlerMockListPropertyTypeResults{err}
	mmListPropertyType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPropertyType.mock
}

// Set uses given function f to mock the PropertyServiceHandler.ListPropertyType method
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]) (err error)) *PropertyServiceHandlerMock {
	if mmListPropertyType.defaultExpectation != nil {
		mmListPropertyType.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.ListPropertyType method")
	}

	if len(mmListPropertyType.expectations) > 0 {
		mmListPropertyType.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.ListPropertyType method")
	}

	mmListPropertyType.mock.funcListPropertyType = f
	mmListPropertyType.mock.funcListPropertyTypeOrigin = minimock.CallerInfo(1)
	return mmListPropertyType.mock
}

// When sets expectation for the PropertyServiceHandler.ListPropertyType which will trigger the result defined by the following
// Then helper
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) When(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]) *PropertyServiceHandlerMockListPropertyTypeExpectation {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceHandlerMock.ListPropertyType mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockListPropertyTypeExpectation{
		mock:               mmListPropertyType.mock,
		params:             &PropertyServiceHandlerMockListPropertyTypeParams{ctx, pp1, pp2},
		expectationOrigins: PropertyServiceHandlerMockListPropertyTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPropertyType.expectations = append(mmListPropertyType.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.ListPropertyType return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockListPropertyTypeExpectation) Then(err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockListPropertyTypeResults{err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.ListPropertyType should be invoked
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Times(n uint64) *mPropertyServiceHandlerMockListPropertyType {
	if n == 0 {
		mmListPropertyType.mock.t.Fatalf("Times of PropertyServiceHandlerMock.ListPropertyType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPropertyType.expectedInvocations, n)
	mmListPropertyType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPropertyType
}

func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) invocationsDone() bool {
	if len(mmListPropertyType.expectations) == 0 && mmListPropertyType.defaultExpectation == nil && mmListPropertyType.mock.funcListPropertyType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPropertyType.mock.afterListPropertyTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPropertyType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPropertyType implements mm_propertyv1connect.PropertyServiceHandler
func (mmListPropertyType *PropertyServiceHandlerMock) ListPropertyType(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest], pp2 *connect.ServerStream[v1.ListPropertyTypeResponse]) (err error) {
	mm_atomic.AddUint64(&mmListPropertyType.beforeListPropertyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmListPropertyType.afterListPropertyTypeCounter, 1)

	mmListPropertyType.t.Helper()

	if mmListPropertyType.inspectFuncListPropertyType != nil {
		mmListPropertyType.inspectFuncListPropertyType(ctx, pp1, pp2)
	}

	mm_params := PropertyServiceHandlerMockListPropertyTypeParams{ctx, pp1, pp2}

	// Record call args
	mmListPropertyType.ListPropertyTypeMock.mutex.Lock()
	mmListPropertyType.ListPropertyTypeMock.callArgs = append(mmListPropertyType.ListPropertyTypeMock.callArgs, &mm_params)
	mmListPropertyType.ListPropertyTypeMock.mutex.Unlock()

	for _, e := range mmListPropertyType.ListPropertyTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListPropertyType.ListPropertyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPropertyType.ListPropertyTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmListPropertyType.ListPropertyTypeMock.defaultExpectation.params
		mm_want_ptrs := mmListPropertyType.ListPropertyTypeMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockListPropertyTypeParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPropertyType.t.Errorf("PropertyServiceHandlerMock.ListPropertyType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListPropertyType.t.Errorf("PropertyServiceHandlerMock.ListPropertyType got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListPropertyType.t.Errorf("PropertyServiceHandlerMock.ListPropertyType got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPropertyType.t.Errorf("PropertyServiceHandlerMock.ListPropertyType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPropertyType.ListPropertyTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmListPropertyType.t.Fatal("No results are set for the PropertyServiceHandlerMock.ListPropertyType")
		}
		return (*mm_results).err
	}
	if mmListPropertyType.funcListPropertyType != nil {
		return mmListPropertyType.funcListPropertyType(ctx, pp1, pp2)
	}
	mmListPropertyType.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.ListPropertyType. %v %v %v", ctx, pp1, pp2)
	return
}

// ListPropertyTypeAfterCounter returns a count of finished PropertyServiceHandlerMock.ListPropertyType invocations
func (mmListPropertyType *PropertyServiceHandlerMock) ListPropertyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPropertyType.afterListPropertyTypeCounter)
}

// ListPropertyTypeBeforeCounter returns a count of PropertyServiceHandlerMock.ListPropertyType invocations
func (mmListPropertyType *PropertyServiceHandlerMock) ListPropertyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPropertyType.beforeListPropertyTypeCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.ListPropertyType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPropertyType *mPropertyServiceHandlerMockListPropertyType) Calls() []*PropertyServiceHandlerMockListPropertyTypeParams {
	mmListPropertyType.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockListPropertyTypeParams, len(mmListPropertyType.callArgs))
	copy(argCopy, mmListPropertyType.callArgs)

	mmListPropertyType.mutex.RUnlock()

	return argCopy
}

// MinimockListPropertyTypeDone returns true if the count of the ListPropertyType invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockListPropertyTypeDone() bool {
	if m.ListPropertyTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPropertyTypeMock.invocationsDone()
}

// MinimockListPropertyTypeInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockListPropertyTypeInspect() {
	for _, e := range m.ListPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListPropertyType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPropertyTypeCounter := mm_atomic.LoadUint64(&m.afterListPropertyTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPropertyTypeMock.defaultExpectation != nil && afterListPropertyTypeCounter < 1 {
		if m.ListPropertyTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListPropertyType at\n%s", m.ListPropertyTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListPropertyType at\n%s with params: %#v", m.ListPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *m.ListPropertyTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPropertyType != nil && afterListPropertyTypeCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListPropertyType at\n%s", m.funcListPropertyTypeOrigin)
	}

	if !m.ListPropertyTypeMock.invocationsDone() && afterListPropertyTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.ListPropertyType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPropertyTypeMock.expectedInvocations), m.ListPropertyTypeMock.expectedInvocationsOrigin, afterListPropertyTypeCounter)
	}
}

type mPropertyServiceHandlerMockListSubscription struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockListSubscriptionExpectation
	expectations       []*PropertyServiceHandlerMockListSubscriptionExpectation

	callArgs []*PropertyServiceHandlerMockListSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockListSubscriptionExpectation specifies expectation struct of the PropertyServiceHandler.ListSubscription
type PropertyServiceHandlerMockListSubscriptionExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockListSubscriptionParams
	paramPtrs          *PropertyServiceHandlerMockListSubscriptionParamPtrs
	expectationOrigins PropertyServiceHandlerMockListSubscriptionExpectationOrigins
	results            *PropertyServiceHandlerMockListSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockListSubscriptionParams contains parameters of the PropertyServiceHandler.ListSubscription
type PropertyServiceHandlerMockListSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListSubscriptionRequest]
	pp2 *connect.ServerStream[v1.ListSubscriptionResponse]
}

// PropertyServiceHandlerMockListSubscriptionParamPtrs contains pointers to parameters of the PropertyServiceHandler.ListSubscription
type PropertyServiceHandlerMockListSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListSubscriptionRequest]
	pp2 **connect.ServerStream[v1.ListSubscriptionResponse]
}

// PropertyServiceHandlerMockListSubscriptionResults contains results of the PropertyServiceHandler.ListSubscription
type PropertyServiceHandlerMockListSubscriptionResults struct {
	err error
}

// PropertyServiceHandlerMockListSubscriptionOrigins contains origins of expectations of the PropertyServiceHandler.ListSubscription
type PropertyServiceHandlerMockListSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Optional() *mPropertyServiceHandlerMockListSubscription {
	mmListSubscription.optional = true
	return mmListSubscription
}

// Expect sets up expected params for PropertyServiceHandler.ListSubscription
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse]) *mPropertyServiceHandlerMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceHandlerMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.paramPtrs != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by ExpectParams functions")
	}

	mmListSubscription.defaultExpectation.params = &PropertyServiceHandlerMockListSubscriptionParams{ctx, pp1, pp2}
	mmListSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSubscription.expectations {
		if minimock.Equal(e.params, mmListSubscription.defaultExpectation.params) {
			mmListSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSubscription.defaultExpectation.params)
		}
	}

	return mmListSubscription
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.ListSubscription
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceHandlerMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.params != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Expect")
	}

	if mmListSubscription.defaultExpectation.paramPtrs == nil {
		mmListSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockListSubscriptionParamPtrs{}
	}
	mmListSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.ListSubscription
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.ListSubscriptionRequest]) *mPropertyServiceHandlerMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceHandlerMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.params != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Expect")
	}

	if mmListSubscription.defaultExpectation.paramPtrs == nil {
		mmListSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockListSubscriptionParamPtrs{}
	}
	mmListSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListSubscription
}

// ExpectPp2Param3 sets up expected param pp2 for PropertyServiceHandler.ListSubscription
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) ExpectPp2Param3(pp2 *connect.ServerStream[v1.ListSubscriptionResponse]) *mPropertyServiceHandlerMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceHandlerMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.params != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Expect")
	}

	if mmListSubscription.defaultExpectation.paramPtrs == nil {
		mmListSubscription.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockListSubscriptionParamPtrs{}
	}
	mmListSubscription.defaultExpectation.paramPtrs.pp2 = &pp2
	mmListSubscription.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmListSubscription
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.ListSubscription
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse])) *mPropertyServiceHandlerMockListSubscription {
	if mmListSubscription.mock.inspectFuncListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.ListSubscription")
	}

	mmListSubscription.mock.inspectFuncListSubscription = f

	return mmListSubscription
}

// Return sets up results that will be returned by PropertyServiceHandler.ListSubscription
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Return(err error) *PropertyServiceHandlerMock {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceHandlerMockListSubscriptionExpectation{mock: mmListSubscription.mock}
	}
	mmListSubscription.defaultExpectation.results = &PropertyServiceHandlerMockListSubscriptionResults{err}
	mmListSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSubscription.mock
}

// Set uses given function f to mock the PropertyServiceHandler.ListSubscription method
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse]) (err error)) *PropertyServiceHandlerMock {
	if mmListSubscription.defaultExpectation != nil {
		mmListSubscription.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.ListSubscription method")
	}

	if len(mmListSubscription.expectations) > 0 {
		mmListSubscription.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.ListSubscription method")
	}

	mmListSubscription.mock.funcListSubscription = f
	mmListSubscription.mock.funcListSubscriptionOrigin = minimock.CallerInfo(1)
	return mmListSubscription.mock
}

// When sets expectation for the PropertyServiceHandler.ListSubscription which will trigger the result defined by the following
// Then helper
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) When(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse]) *PropertyServiceHandlerMockListSubscriptionExpectation {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceHandlerMock.ListSubscription mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockListSubscriptionExpectation{
		mock:               mmListSubscription.mock,
		params:             &PropertyServiceHandlerMockListSubscriptionParams{ctx, pp1, pp2},
		expectationOrigins: PropertyServiceHandlerMockListSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSubscription.expectations = append(mmListSubscription.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.ListSubscription return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockListSubscriptionExpectation) Then(err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockListSubscriptionResults{err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.ListSubscription should be invoked
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Times(n uint64) *mPropertyServiceHandlerMockListSubscription {
	if n == 0 {
		mmListSubscription.mock.t.Fatalf("Times of PropertyServiceHandlerMock.ListSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSubscription.expectedInvocations, n)
	mmListSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSubscription
}

func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) invocationsDone() bool {
	if len(mmListSubscription.expectations) == 0 && mmListSubscription.defaultExpectation == nil && mmListSubscription.mock.funcListSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSubscription.mock.afterListSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSubscription implements mm_propertyv1connect.PropertyServiceHandler
func (mmListSubscription *PropertyServiceHandlerMock) ListSubscription(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest], pp2 *connect.ServerStream[v1.ListSubscriptionResponse]) (err error) {
	mm_atomic.AddUint64(&mmListSubscription.beforeListSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmListSubscription.afterListSubscriptionCounter, 1)

	mmListSubscription.t.Helper()

	if mmListSubscription.inspectFuncListSubscription != nil {
		mmListSubscription.inspectFuncListSubscription(ctx, pp1, pp2)
	}

	mm_params := PropertyServiceHandlerMockListSubscriptionParams{ctx, pp1, pp2}

	// Record call args
	mmListSubscription.ListSubscriptionMock.mutex.Lock()
	mmListSubscription.ListSubscriptionMock.callArgs = append(mmListSubscription.ListSubscriptionMock.callArgs, &mm_params)
	mmListSubscription.ListSubscriptionMock.mutex.Unlock()

	for _, e := range mmListSubscription.ListSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListSubscription.ListSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSubscription.ListSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmListSubscription.ListSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmListSubscription.ListSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockListSubscriptionParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSubscription.t.Errorf("PropertyServiceHandlerMock.ListSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListSubscription.t.Errorf("PropertyServiceHandlerMock.ListSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmListSubscription.t.Errorf("PropertyServiceHandlerMock.ListSubscription got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSubscription.t.Errorf("PropertyServiceHandlerMock.ListSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSubscription.ListSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmListSubscription.t.Fatal("No results are set for the PropertyServiceHandlerMock.ListSubscription")
		}
		return (*mm_results).err
	}
	if mmListSubscription.funcListSubscription != nil {
		return mmListSubscription.funcListSubscription(ctx, pp1, pp2)
	}
	mmListSubscription.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.ListSubscription. %v %v %v", ctx, pp1, pp2)
	return
}

// ListSubscriptionAfterCounter returns a count of finished PropertyServiceHandlerMock.ListSubscription invocations
func (mmListSubscription *PropertyServiceHandlerMock) ListSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubscription.afterListSubscriptionCounter)
}

// ListSubscriptionBeforeCounter returns a count of PropertyServiceHandlerMock.ListSubscription invocations
func (mmListSubscription *PropertyServiceHandlerMock) ListSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubscription.beforeListSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.ListSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSubscription *mPropertyServiceHandlerMockListSubscription) Calls() []*PropertyServiceHandlerMockListSubscriptionParams {
	mmListSubscription.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockListSubscriptionParams, len(mmListSubscription.callArgs))
	copy(argCopy, mmListSubscription.callArgs)

	mmListSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockListSubscriptionDone returns true if the count of the ListSubscription invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockListSubscriptionDone() bool {
	if m.ListSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSubscriptionMock.invocationsDone()
}

// MinimockListSubscriptionInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockListSubscriptionInspect() {
	for _, e := range m.ListSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSubscriptionCounter := mm_atomic.LoadUint64(&m.afterListSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSubscriptionMock.defaultExpectation != nil && afterListSubscriptionCounter < 1 {
		if m.ListSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListSubscription at\n%s", m.ListSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListSubscription at\n%s with params: %#v", m.ListSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.ListSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSubscription != nil && afterListSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.ListSubscription at\n%s", m.funcListSubscriptionOrigin)
	}

	if !m.ListSubscriptionMock.invocationsDone() && afterListSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.ListSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSubscriptionMock.expectedInvocations), m.ListSubscriptionMock.expectedInvocationsOrigin, afterListSubscriptionCounter)
	}
}

type mPropertyServiceHandlerMockSearchProperty struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockSearchPropertyExpectation
	expectations       []*PropertyServiceHandlerMockSearchPropertyExpectation

	callArgs []*PropertyServiceHandlerMockSearchPropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockSearchPropertyExpectation specifies expectation struct of the PropertyServiceHandler.SearchProperty
type PropertyServiceHandlerMockSearchPropertyExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockSearchPropertyParams
	paramPtrs          *PropertyServiceHandlerMockSearchPropertyParamPtrs
	expectationOrigins PropertyServiceHandlerMockSearchPropertyExpectationOrigins
	results            *PropertyServiceHandlerMockSearchPropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockSearchPropertyParams contains parameters of the PropertyServiceHandler.SearchProperty
type PropertyServiceHandlerMockSearchPropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchPropertyRequest]
	pp2 *connect.ServerStream[v1.SearchPropertyResponse]
}

// PropertyServiceHandlerMockSearchPropertyParamPtrs contains pointers to parameters of the PropertyServiceHandler.SearchProperty
type PropertyServiceHandlerMockSearchPropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchPropertyRequest]
	pp2 **connect.ServerStream[v1.SearchPropertyResponse]
}

// PropertyServiceHandlerMockSearchPropertyResults contains results of the PropertyServiceHandler.SearchProperty
type PropertyServiceHandlerMockSearchPropertyResults struct {
	err error
}

// PropertyServiceHandlerMockSearchPropertyOrigins contains origins of expectations of the PropertyServiceHandler.SearchProperty
type PropertyServiceHandlerMockSearchPropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
	originPp2 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Optional() *mPropertyServiceHandlerMockSearchProperty {
	mmSearchProperty.optional = true
	return mmSearchProperty
}

// Expect sets up expected params for PropertyServiceHandler.SearchProperty
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse]) *mPropertyServiceHandlerMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceHandlerMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.paramPtrs != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by ExpectParams functions")
	}

	mmSearchProperty.defaultExpectation.params = &PropertyServiceHandlerMockSearchPropertyParams{ctx, pp1, pp2}
	mmSearchProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchProperty.expectations {
		if minimock.Equal(e.params, mmSearchProperty.defaultExpectation.params) {
			mmSearchProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchProperty.defaultExpectation.params)
		}
	}

	return mmSearchProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.SearchProperty
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceHandlerMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.params != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Expect")
	}

	if mmSearchProperty.defaultExpectation.paramPtrs == nil {
		mmSearchProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockSearchPropertyParamPtrs{}
	}
	mmSearchProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.SearchProperty
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) ExpectPp1Param2(pp1 *connect.Request[v1.SearchPropertyRequest]) *mPropertyServiceHandlerMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceHandlerMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.params != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Expect")
	}

	if mmSearchProperty.defaultExpectation.paramPtrs == nil {
		mmSearchProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockSearchPropertyParamPtrs{}
	}
	mmSearchProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchProperty
}

// ExpectPp2Param3 sets up expected param pp2 for PropertyServiceHandler.SearchProperty
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) ExpectPp2Param3(pp2 *connect.ServerStream[v1.SearchPropertyResponse]) *mPropertyServiceHandlerMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceHandlerMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.params != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Expect")
	}

	if mmSearchProperty.defaultExpectation.paramPtrs == nil {
		mmSearchProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockSearchPropertyParamPtrs{}
	}
	mmSearchProperty.defaultExpectation.paramPtrs.pp2 = &pp2
	mmSearchProperty.defaultExpectation.expectationOrigins.originPp2 = minimock.CallerInfo(1)

	return mmSearchProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.SearchProperty
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse])) *mPropertyServiceHandlerMockSearchProperty {
	if mmSearchProperty.mock.inspectFuncSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.SearchProperty")
	}

	mmSearchProperty.mock.inspectFuncSearchProperty = f

	return mmSearchProperty
}

// Return sets up results that will be returned by PropertyServiceHandler.SearchProperty
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Return(err error) *PropertyServiceHandlerMock {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceHandlerMockSearchPropertyExpectation{mock: mmSearchProperty.mock}
	}
	mmSearchProperty.defaultExpectation.results = &PropertyServiceHandlerMockSearchPropertyResults{err}
	mmSearchProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchProperty.mock
}

// Set uses given function f to mock the PropertyServiceHandler.SearchProperty method
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse]) (err error)) *PropertyServiceHandlerMock {
	if mmSearchProperty.defaultExpectation != nil {
		mmSearchProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.SearchProperty method")
	}

	if len(mmSearchProperty.expectations) > 0 {
		mmSearchProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.SearchProperty method")
	}

	mmSearchProperty.mock.funcSearchProperty = f
	mmSearchProperty.mock.funcSearchPropertyOrigin = minimock.CallerInfo(1)
	return mmSearchProperty.mock
}

// When sets expectation for the PropertyServiceHandler.SearchProperty which will trigger the result defined by the following
// Then helper
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) When(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse]) *PropertyServiceHandlerMockSearchPropertyExpectation {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceHandlerMock.SearchProperty mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockSearchPropertyExpectation{
		mock:               mmSearchProperty.mock,
		params:             &PropertyServiceHandlerMockSearchPropertyParams{ctx, pp1, pp2},
		expectationOrigins: PropertyServiceHandlerMockSearchPropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchProperty.expectations = append(mmSearchProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.SearchProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockSearchPropertyExpectation) Then(err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockSearchPropertyResults{err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.SearchProperty should be invoked
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Times(n uint64) *mPropertyServiceHandlerMockSearchProperty {
	if n == 0 {
		mmSearchProperty.mock.t.Fatalf("Times of PropertyServiceHandlerMock.SearchProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchProperty.expectedInvocations, n)
	mmSearchProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchProperty
}

func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) invocationsDone() bool {
	if len(mmSearchProperty.expectations) == 0 && mmSearchProperty.defaultExpectation == nil && mmSearchProperty.mock.funcSearchProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchProperty.mock.afterSearchPropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchProperty implements mm_propertyv1connect.PropertyServiceHandler
func (mmSearchProperty *PropertyServiceHandlerMock) SearchProperty(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest], pp2 *connect.ServerStream[v1.SearchPropertyResponse]) (err error) {
	mm_atomic.AddUint64(&mmSearchProperty.beforeSearchPropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchProperty.afterSearchPropertyCounter, 1)

	mmSearchProperty.t.Helper()

	if mmSearchProperty.inspectFuncSearchProperty != nil {
		mmSearchProperty.inspectFuncSearchProperty(ctx, pp1, pp2)
	}

	mm_params := PropertyServiceHandlerMockSearchPropertyParams{ctx, pp1, pp2}

	// Record call args
	mmSearchProperty.SearchPropertyMock.mutex.Lock()
	mmSearchProperty.SearchPropertyMock.callArgs = append(mmSearchProperty.SearchPropertyMock.callArgs, &mm_params)
	mmSearchProperty.SearchPropertyMock.mutex.Unlock()

	for _, e := range mmSearchProperty.SearchPropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSearchProperty.SearchPropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchProperty.SearchPropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchProperty.SearchPropertyMock.defaultExpectation.params
		mm_want_ptrs := mmSearchProperty.SearchPropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockSearchPropertyParams{ctx, pp1, pp2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchProperty.t.Errorf("PropertyServiceHandlerMock.SearchProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchProperty.t.Errorf("PropertyServiceHandlerMock.SearchProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

			if mm_want_ptrs.pp2 != nil && !minimock.Equal(*mm_want_ptrs.pp2, mm_got.pp2) {
				mmSearchProperty.t.Errorf("PropertyServiceHandlerMock.SearchProperty got unexpected parameter pp2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.originPp2, *mm_want_ptrs.pp2, mm_got.pp2, minimock.Diff(*mm_want_ptrs.pp2, mm_got.pp2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchProperty.t.Errorf("PropertyServiceHandlerMock.SearchProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchProperty.SearchPropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchProperty.t.Fatal("No results are set for the PropertyServiceHandlerMock.SearchProperty")
		}
		return (*mm_results).err
	}
	if mmSearchProperty.funcSearchProperty != nil {
		return mmSearchProperty.funcSearchProperty(ctx, pp1, pp2)
	}
	mmSearchProperty.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.SearchProperty. %v %v %v", ctx, pp1, pp2)
	return
}

// SearchPropertyAfterCounter returns a count of finished PropertyServiceHandlerMock.SearchProperty invocations
func (mmSearchProperty *PropertyServiceHandlerMock) SearchPropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchProperty.afterSearchPropertyCounter)
}

// SearchPropertyBeforeCounter returns a count of PropertyServiceHandlerMock.SearchProperty invocations
func (mmSearchProperty *PropertyServiceHandlerMock) SearchPropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchProperty.beforeSearchPropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.SearchProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchProperty *mPropertyServiceHandlerMockSearchProperty) Calls() []*PropertyServiceHandlerMockSearchPropertyParams {
	mmSearchProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockSearchPropertyParams, len(mmSearchProperty.callArgs))
	copy(argCopy, mmSearchProperty.callArgs)

	mmSearchProperty.mutex.RUnlock()

	return argCopy
}

// MinimockSearchPropertyDone returns true if the count of the SearchProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockSearchPropertyDone() bool {
	if m.SearchPropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchPropertyMock.invocationsDone()
}

// MinimockSearchPropertyInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockSearchPropertyInspect() {
	for _, e := range m.SearchPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.SearchProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchPropertyCounter := mm_atomic.LoadUint64(&m.afterSearchPropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchPropertyMock.defaultExpectation != nil && afterSearchPropertyCounter < 1 {
		if m.SearchPropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.SearchProperty at\n%s", m.SearchPropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.SearchProperty at\n%s with params: %#v", m.SearchPropertyMock.defaultExpectation.expectationOrigins.origin, *m.SearchPropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchProperty != nil && afterSearchPropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.SearchProperty at\n%s", m.funcSearchPropertyOrigin)
	}

	if !m.SearchPropertyMock.invocationsDone() && afterSearchPropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.SearchProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchPropertyMock.expectedInvocations), m.SearchPropertyMock.expectedInvocationsOrigin, afterSearchPropertyCounter)
	}
}

type mPropertyServiceHandlerMockStateOfProperty struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockStateOfPropertyExpectation
	expectations       []*PropertyServiceHandlerMockStateOfPropertyExpectation

	callArgs []*PropertyServiceHandlerMockStateOfPropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockStateOfPropertyExpectation specifies expectation struct of the PropertyServiceHandler.StateOfProperty
type PropertyServiceHandlerMockStateOfPropertyExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockStateOfPropertyParams
	paramPtrs          *PropertyServiceHandlerMockStateOfPropertyParamPtrs
	expectationOrigins PropertyServiceHandlerMockStateOfPropertyExpectationOrigins
	results            *PropertyServiceHandlerMockStateOfPropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockStateOfPropertyParams contains parameters of the PropertyServiceHandler.StateOfProperty
type PropertyServiceHandlerMockStateOfPropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.StateOfPropertyRequest]
}

// PropertyServiceHandlerMockStateOfPropertyParamPtrs contains pointers to parameters of the PropertyServiceHandler.StateOfProperty
type PropertyServiceHandlerMockStateOfPropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.StateOfPropertyRequest]
}

// PropertyServiceHandlerMockStateOfPropertyResults contains results of the PropertyServiceHandler.StateOfProperty
type PropertyServiceHandlerMockStateOfPropertyResults struct {
	pp2 *connect.Response[v1.StateOfPropertyResponse]
	err error
}

// PropertyServiceHandlerMockStateOfPropertyOrigins contains origins of expectations of the PropertyServiceHandler.StateOfProperty
type PropertyServiceHandlerMockStateOfPropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Optional() *mPropertyServiceHandlerMockStateOfProperty {
	mmStateOfProperty.optional = true
	return mmStateOfProperty
}

// Expect sets up expected params for PropertyServiceHandler.StateOfProperty
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) *mPropertyServiceHandlerMockStateOfProperty {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceHandlerMockStateOfPropertyExpectation{}
	}

	if mmStateOfProperty.defaultExpectation.paramPtrs != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by ExpectParams functions")
	}

	mmStateOfProperty.defaultExpectation.params = &PropertyServiceHandlerMockStateOfPropertyParams{ctx, pp1}
	mmStateOfProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStateOfProperty.expectations {
		if minimock.Equal(e.params, mmStateOfProperty.defaultExpectation.params) {
			mmStateOfProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStateOfProperty.defaultExpectation.params)
		}
	}

	return mmStateOfProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.StateOfProperty
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockStateOfProperty {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceHandlerMockStateOfPropertyExpectation{}
	}

	if mmStateOfProperty.defaultExpectation.params != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Expect")
	}

	if mmStateOfProperty.defaultExpectation.paramPtrs == nil {
		mmStateOfProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockStateOfPropertyParamPtrs{}
	}
	mmStateOfProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmStateOfProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStateOfProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.StateOfProperty
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) ExpectPp1Param2(pp1 *connect.Request[v1.StateOfPropertyRequest]) *mPropertyServiceHandlerMockStateOfProperty {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceHandlerMockStateOfPropertyExpectation{}
	}

	if mmStateOfProperty.defaultExpectation.params != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Expect")
	}

	if mmStateOfProperty.defaultExpectation.paramPtrs == nil {
		mmStateOfProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockStateOfPropertyParamPtrs{}
	}
	mmStateOfProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStateOfProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStateOfProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.StateOfProperty
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest])) *mPropertyServiceHandlerMockStateOfProperty {
	if mmStateOfProperty.mock.inspectFuncStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.StateOfProperty")
	}

	mmStateOfProperty.mock.inspectFuncStateOfProperty = f

	return mmStateOfProperty
}

// Return sets up results that will be returned by PropertyServiceHandler.StateOfProperty
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Return(pp2 *connect.Response[v1.StateOfPropertyResponse], err error) *PropertyServiceHandlerMock {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceHandlerMockStateOfPropertyExpectation{mock: mmStateOfProperty.mock}
	}
	mmStateOfProperty.defaultExpectation.results = &PropertyServiceHandlerMockStateOfPropertyResults{pp2, err}
	mmStateOfProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStateOfProperty.mock
}

// Set uses given function f to mock the PropertyServiceHandler.StateOfProperty method
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) (pp2 *connect.Response[v1.StateOfPropertyResponse], err error)) *PropertyServiceHandlerMock {
	if mmStateOfProperty.defaultExpectation != nil {
		mmStateOfProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.StateOfProperty method")
	}

	if len(mmStateOfProperty.expectations) > 0 {
		mmStateOfProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.StateOfProperty method")
	}

	mmStateOfProperty.mock.funcStateOfProperty = f
	mmStateOfProperty.mock.funcStateOfPropertyOrigin = minimock.CallerInfo(1)
	return mmStateOfProperty.mock
}

// When sets expectation for the PropertyServiceHandler.StateOfProperty which will trigger the result defined by the following
// Then helper
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) When(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) *PropertyServiceHandlerMockStateOfPropertyExpectation {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceHandlerMock.StateOfProperty mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockStateOfPropertyExpectation{
		mock:               mmStateOfProperty.mock,
		params:             &PropertyServiceHandlerMockStateOfPropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockStateOfPropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStateOfProperty.expectations = append(mmStateOfProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.StateOfProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockStateOfPropertyExpectation) Then(pp2 *connect.Response[v1.StateOfPropertyResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockStateOfPropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.StateOfProperty should be invoked
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Times(n uint64) *mPropertyServiceHandlerMockStateOfProperty {
	if n == 0 {
		mmStateOfProperty.mock.t.Fatalf("Times of PropertyServiceHandlerMock.StateOfProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStateOfProperty.expectedInvocations, n)
	mmStateOfProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStateOfProperty
}

func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) invocationsDone() bool {
	if len(mmStateOfProperty.expectations) == 0 && mmStateOfProperty.defaultExpectation == nil && mmStateOfProperty.mock.funcStateOfProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStateOfProperty.mock.afterStateOfPropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStateOfProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StateOfProperty implements mm_propertyv1connect.PropertyServiceHandler
func (mmStateOfProperty *PropertyServiceHandlerMock) StateOfProperty(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) (pp2 *connect.Response[v1.StateOfPropertyResponse], err error) {
	mm_atomic.AddUint64(&mmStateOfProperty.beforeStateOfPropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmStateOfProperty.afterStateOfPropertyCounter, 1)

	mmStateOfProperty.t.Helper()

	if mmStateOfProperty.inspectFuncStateOfProperty != nil {
		mmStateOfProperty.inspectFuncStateOfProperty(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockStateOfPropertyParams{ctx, pp1}

	// Record call args
	mmStateOfProperty.StateOfPropertyMock.mutex.Lock()
	mmStateOfProperty.StateOfPropertyMock.callArgs = append(mmStateOfProperty.StateOfPropertyMock.callArgs, &mm_params)
	mmStateOfProperty.StateOfPropertyMock.mutex.Unlock()

	for _, e := range mmStateOfProperty.StateOfPropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStateOfProperty.StateOfPropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStateOfProperty.StateOfPropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmStateOfProperty.StateOfPropertyMock.defaultExpectation.params
		mm_want_ptrs := mmStateOfProperty.StateOfPropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockStateOfPropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStateOfProperty.t.Errorf("PropertyServiceHandlerMock.StateOfProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStateOfProperty.StateOfPropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStateOfProperty.t.Errorf("PropertyServiceHandlerMock.StateOfProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStateOfProperty.StateOfPropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStateOfProperty.t.Errorf("PropertyServiceHandlerMock.StateOfProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStateOfProperty.StateOfPropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStateOfProperty.StateOfPropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmStateOfProperty.t.Fatal("No results are set for the PropertyServiceHandlerMock.StateOfProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStateOfProperty.funcStateOfProperty != nil {
		return mmStateOfProperty.funcStateOfProperty(ctx, pp1)
	}
	mmStateOfProperty.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.StateOfProperty. %v %v", ctx, pp1)
	return
}

// StateOfPropertyAfterCounter returns a count of finished PropertyServiceHandlerMock.StateOfProperty invocations
func (mmStateOfProperty *PropertyServiceHandlerMock) StateOfPropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStateOfProperty.afterStateOfPropertyCounter)
}

// StateOfPropertyBeforeCounter returns a count of PropertyServiceHandlerMock.StateOfProperty invocations
func (mmStateOfProperty *PropertyServiceHandlerMock) StateOfPropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStateOfProperty.beforeStateOfPropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.StateOfProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStateOfProperty *mPropertyServiceHandlerMockStateOfProperty) Calls() []*PropertyServiceHandlerMockStateOfPropertyParams {
	mmStateOfProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockStateOfPropertyParams, len(mmStateOfProperty.callArgs))
	copy(argCopy, mmStateOfProperty.callArgs)

	mmStateOfProperty.mutex.RUnlock()

	return argCopy
}

// MinimockStateOfPropertyDone returns true if the count of the StateOfProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockStateOfPropertyDone() bool {
	if m.StateOfPropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StateOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StateOfPropertyMock.invocationsDone()
}

// MinimockStateOfPropertyInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockStateOfPropertyInspect() {
	for _, e := range m.StateOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.StateOfProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStateOfPropertyCounter := mm_atomic.LoadUint64(&m.afterStateOfPropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StateOfPropertyMock.defaultExpectation != nil && afterStateOfPropertyCounter < 1 {
		if m.StateOfPropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.StateOfProperty at\n%s", m.StateOfPropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.StateOfProperty at\n%s with params: %#v", m.StateOfPropertyMock.defaultExpectation.expectationOrigins.origin, *m.StateOfPropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStateOfProperty != nil && afterStateOfPropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.StateOfProperty at\n%s", m.funcStateOfPropertyOrigin)
	}

	if !m.StateOfPropertyMock.invocationsDone() && afterStateOfPropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.StateOfProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StateOfPropertyMock.expectedInvocations), m.StateOfPropertyMock.expectedInvocationsOrigin, afterStateOfPropertyCounter)
	}
}

type mPropertyServiceHandlerMockUpdateProperty struct {
	optional           bool
	mock               *PropertyServiceHandlerMock
	defaultExpectation *PropertyServiceHandlerMockUpdatePropertyExpectation
	expectations       []*PropertyServiceHandlerMockUpdatePropertyExpectation

	callArgs []*PropertyServiceHandlerMockUpdatePropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceHandlerMockUpdatePropertyExpectation specifies expectation struct of the PropertyServiceHandler.UpdateProperty
type PropertyServiceHandlerMockUpdatePropertyExpectation struct {
	mock               *PropertyServiceHandlerMock
	params             *PropertyServiceHandlerMockUpdatePropertyParams
	paramPtrs          *PropertyServiceHandlerMockUpdatePropertyParamPtrs
	expectationOrigins PropertyServiceHandlerMockUpdatePropertyExpectationOrigins
	results            *PropertyServiceHandlerMockUpdatePropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceHandlerMockUpdatePropertyParams contains parameters of the PropertyServiceHandler.UpdateProperty
type PropertyServiceHandlerMockUpdatePropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdatePropertyRequest]
}

// PropertyServiceHandlerMockUpdatePropertyParamPtrs contains pointers to parameters of the PropertyServiceHandler.UpdateProperty
type PropertyServiceHandlerMockUpdatePropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdatePropertyRequest]
}

// PropertyServiceHandlerMockUpdatePropertyResults contains results of the PropertyServiceHandler.UpdateProperty
type PropertyServiceHandlerMockUpdatePropertyResults struct {
	pp2 *connect.Response[v1.UpdatePropertyResponse]
	err error
}

// PropertyServiceHandlerMockUpdatePropertyOrigins contains origins of expectations of the PropertyServiceHandler.UpdateProperty
type PropertyServiceHandlerMockUpdatePropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Optional() *mPropertyServiceHandlerMockUpdateProperty {
	mmUpdateProperty.optional = true
	return mmUpdateProperty
}

// Expect sets up expected params for PropertyServiceHandler.UpdateProperty
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) *mPropertyServiceHandlerMockUpdateProperty {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceHandlerMockUpdatePropertyExpectation{}
	}

	if mmUpdateProperty.defaultExpectation.paramPtrs != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by ExpectParams functions")
	}

	mmUpdateProperty.defaultExpectation.params = &PropertyServiceHandlerMockUpdatePropertyParams{ctx, pp1}
	mmUpdateProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateProperty.expectations {
		if minimock.Equal(e.params, mmUpdateProperty.defaultExpectation.params) {
			mmUpdateProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateProperty.defaultExpectation.params)
		}
	}

	return mmUpdateProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceHandler.UpdateProperty
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceHandlerMockUpdateProperty {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceHandlerMockUpdatePropertyExpectation{}
	}

	if mmUpdateProperty.defaultExpectation.params != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Expect")
	}

	if mmUpdateProperty.defaultExpectation.paramPtrs == nil {
		mmUpdateProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockUpdatePropertyParamPtrs{}
	}
	mmUpdateProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceHandler.UpdateProperty
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) ExpectPp1Param2(pp1 *connect.Request[v1.UpdatePropertyRequest]) *mPropertyServiceHandlerMockUpdateProperty {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceHandlerMockUpdatePropertyExpectation{}
	}

	if mmUpdateProperty.defaultExpectation.params != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Expect")
	}

	if mmUpdateProperty.defaultExpectation.paramPtrs == nil {
		mmUpdateProperty.defaultExpectation.paramPtrs = &PropertyServiceHandlerMockUpdatePropertyParamPtrs{}
	}
	mmUpdateProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceHandler.UpdateProperty
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest])) *mPropertyServiceHandlerMockUpdateProperty {
	if mmUpdateProperty.mock.inspectFuncUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceHandlerMock.UpdateProperty")
	}

	mmUpdateProperty.mock.inspectFuncUpdateProperty = f

	return mmUpdateProperty
}

// Return sets up results that will be returned by PropertyServiceHandler.UpdateProperty
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Return(pp2 *connect.Response[v1.UpdatePropertyResponse], err error) *PropertyServiceHandlerMock {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceHandlerMockUpdatePropertyExpectation{mock: mmUpdateProperty.mock}
	}
	mmUpdateProperty.defaultExpectation.results = &PropertyServiceHandlerMockUpdatePropertyResults{pp2, err}
	mmUpdateProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateProperty.mock
}

// Set uses given function f to mock the PropertyServiceHandler.UpdateProperty method
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) (pp2 *connect.Response[v1.UpdatePropertyResponse], err error)) *PropertyServiceHandlerMock {
	if mmUpdateProperty.defaultExpectation != nil {
		mmUpdateProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceHandler.UpdateProperty method")
	}

	if len(mmUpdateProperty.expectations) > 0 {
		mmUpdateProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceHandler.UpdateProperty method")
	}

	mmUpdateProperty.mock.funcUpdateProperty = f
	mmUpdateProperty.mock.funcUpdatePropertyOrigin = minimock.CallerInfo(1)
	return mmUpdateProperty.mock
}

// When sets expectation for the PropertyServiceHandler.UpdateProperty which will trigger the result defined by the following
// Then helper
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) When(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) *PropertyServiceHandlerMockUpdatePropertyExpectation {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceHandlerMock.UpdateProperty mock is already set by Set")
	}

	expectation := &PropertyServiceHandlerMockUpdatePropertyExpectation{
		mock:               mmUpdateProperty.mock,
		params:             &PropertyServiceHandlerMockUpdatePropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceHandlerMockUpdatePropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateProperty.expectations = append(mmUpdateProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceHandler.UpdateProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceHandlerMockUpdatePropertyExpectation) Then(pp2 *connect.Response[v1.UpdatePropertyResponse], err error) *PropertyServiceHandlerMock {
	e.results = &PropertyServiceHandlerMockUpdatePropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceHandler.UpdateProperty should be invoked
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Times(n uint64) *mPropertyServiceHandlerMockUpdateProperty {
	if n == 0 {
		mmUpdateProperty.mock.t.Fatalf("Times of PropertyServiceHandlerMock.UpdateProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateProperty.expectedInvocations, n)
	mmUpdateProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateProperty
}

func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) invocationsDone() bool {
	if len(mmUpdateProperty.expectations) == 0 && mmUpdateProperty.defaultExpectation == nil && mmUpdateProperty.mock.funcUpdateProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateProperty.mock.afterUpdatePropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateProperty implements mm_propertyv1connect.PropertyServiceHandler
func (mmUpdateProperty *PropertyServiceHandlerMock) UpdateProperty(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) (pp2 *connect.Response[v1.UpdatePropertyResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateProperty.beforeUpdatePropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateProperty.afterUpdatePropertyCounter, 1)

	mmUpdateProperty.t.Helper()

	if mmUpdateProperty.inspectFuncUpdateProperty != nil {
		mmUpdateProperty.inspectFuncUpdateProperty(ctx, pp1)
	}

	mm_params := PropertyServiceHandlerMockUpdatePropertyParams{ctx, pp1}

	// Record call args
	mmUpdateProperty.UpdatePropertyMock.mutex.Lock()
	mmUpdateProperty.UpdatePropertyMock.callArgs = append(mmUpdateProperty.UpdatePropertyMock.callArgs, &mm_params)
	mmUpdateProperty.UpdatePropertyMock.mutex.Unlock()

	for _, e := range mmUpdateProperty.UpdatePropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateProperty.UpdatePropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateProperty.UpdatePropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateProperty.UpdatePropertyMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateProperty.UpdatePropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceHandlerMockUpdatePropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateProperty.t.Errorf("PropertyServiceHandlerMock.UpdateProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateProperty.UpdatePropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateProperty.t.Errorf("PropertyServiceHandlerMock.UpdateProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateProperty.UpdatePropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateProperty.t.Errorf("PropertyServiceHandlerMock.UpdateProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateProperty.UpdatePropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateProperty.UpdatePropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateProperty.t.Fatal("No results are set for the PropertyServiceHandlerMock.UpdateProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateProperty.funcUpdateProperty != nil {
		return mmUpdateProperty.funcUpdateProperty(ctx, pp1)
	}
	mmUpdateProperty.t.Fatalf("Unexpected call to PropertyServiceHandlerMock.UpdateProperty. %v %v", ctx, pp1)
	return
}

// UpdatePropertyAfterCounter returns a count of finished PropertyServiceHandlerMock.UpdateProperty invocations
func (mmUpdateProperty *PropertyServiceHandlerMock) UpdatePropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProperty.afterUpdatePropertyCounter)
}

// UpdatePropertyBeforeCounter returns a count of PropertyServiceHandlerMock.UpdateProperty invocations
func (mmUpdateProperty *PropertyServiceHandlerMock) UpdatePropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProperty.beforeUpdatePropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceHandlerMock.UpdateProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateProperty *mPropertyServiceHandlerMockUpdateProperty) Calls() []*PropertyServiceHandlerMockUpdatePropertyParams {
	mmUpdateProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceHandlerMockUpdatePropertyParams, len(mmUpdateProperty.callArgs))
	copy(argCopy, mmUpdateProperty.callArgs)

	mmUpdateProperty.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePropertyDone returns true if the count of the UpdateProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceHandlerMock) MinimockUpdatePropertyDone() bool {
	if m.UpdatePropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePropertyMock.invocationsDone()
}

// MinimockUpdatePropertyInspect logs each unmet expectation
func (m *PropertyServiceHandlerMock) MinimockUpdatePropertyInspect() {
	for _, e := range m.UpdatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.UpdateProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePropertyCounter := mm_atomic.LoadUint64(&m.afterUpdatePropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePropertyMock.defaultExpectation != nil && afterUpdatePropertyCounter < 1 {
		if m.UpdatePropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.UpdateProperty at\n%s", m.UpdatePropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceHandlerMock.UpdateProperty at\n%s with params: %#v", m.UpdatePropertyMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateProperty != nil && afterUpdatePropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceHandlerMock.UpdateProperty at\n%s", m.funcUpdatePropertyOrigin)
	}

	if !m.UpdatePropertyMock.invocationsDone() && afterUpdatePropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceHandlerMock.UpdateProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePropertyMock.expectedInvocations), m.UpdatePropertyMock.expectedInvocationsOrigin, afterUpdatePropertyCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PropertyServiceHandlerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddLocalityInspect()

			m.MinimockAddPropertyTypeInspect()

			m.MinimockAddSubscriptionInspect()

			m.MinimockCreatePropertyInspect()

			m.MinimockDeleteLocalityInspect()

			m.MinimockDeletePropertyInspect()

			m.MinimockDeleteSubscriptionInspect()

			m.MinimockHistoryOfPropertyInspect()

			m.MinimockListPropertyTypeInspect()

			m.MinimockListSubscriptionInspect()

			m.MinimockSearchPropertyInspect()

			m.MinimockStateOfPropertyInspect()

			m.MinimockUpdatePropertyInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PropertyServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PropertyServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddLocalityDone() &&
		m.MinimockAddPropertyTypeDone() &&
		m.MinimockAddSubscriptionDone() &&
		m.MinimockCreatePropertyDone() &&
		m.MinimockDeleteLocalityDone() &&
		m.MinimockDeletePropertyDone() &&
		m.MinimockDeleteSubscriptionDone() &&
		m.MinimockHistoryOfPropertyDone() &&
		m.MinimockListPropertyTypeDone() &&
		m.MinimockListSubscriptionDone() &&
		m.MinimockSearchPropertyDone() &&
		m.MinimockStateOfPropertyDone() &&
		m.MinimockUpdatePropertyDone()
}
