// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i buf.build/gen/go/antinvestor/property/connectrpc/go/property/v1/propertyv1connect.PropertyServiceClient -o property_handler.gen.go -n PropertyServiceClientMock -p mocks

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	v1 "buf.build/gen/go/antinvestor/property/protocolbuffers/go/property/v1"
	connect "connectrpc.com/connect"
	"github.com/gojuno/minimock/v3"
)

// PropertyServiceClientMock implements mm_propertyv1connect.PropertyServiceClient
type PropertyServiceClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddLocality          func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) (pp2 *connect.Response[v1.AddLocalityResponse], err error)
	funcAddLocalityOrigin    string
	inspectFuncAddLocality   func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest])
	afterAddLocalityCounter  uint64
	beforeAddLocalityCounter uint64
	AddLocalityMock          mPropertyServiceClientMockAddLocality

	funcAddPropertyType          func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) (pp2 *connect.Response[v1.AddPropertyTypeResponse], err error)
	funcAddPropertyTypeOrigin    string
	inspectFuncAddPropertyType   func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest])
	afterAddPropertyTypeCounter  uint64
	beforeAddPropertyTypeCounter uint64
	AddPropertyTypeMock          mPropertyServiceClientMockAddPropertyType

	funcAddSubscription          func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) (pp2 *connect.Response[v1.AddSubscriptionResponse], err error)
	funcAddSubscriptionOrigin    string
	inspectFuncAddSubscription   func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest])
	afterAddSubscriptionCounter  uint64
	beforeAddSubscriptionCounter uint64
	AddSubscriptionMock          mPropertyServiceClientMockAddSubscription

	funcCreateProperty          func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) (pp2 *connect.Response[v1.CreatePropertyResponse], err error)
	funcCreatePropertyOrigin    string
	inspectFuncCreateProperty   func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest])
	afterCreatePropertyCounter  uint64
	beforeCreatePropertyCounter uint64
	CreatePropertyMock          mPropertyServiceClientMockCreateProperty

	funcDeleteLocality          func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) (pp2 *connect.Response[v1.DeleteLocalityResponse], err error)
	funcDeleteLocalityOrigin    string
	inspectFuncDeleteLocality   func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest])
	afterDeleteLocalityCounter  uint64
	beforeDeleteLocalityCounter uint64
	DeleteLocalityMock          mPropertyServiceClientMockDeleteLocality

	funcDeleteProperty          func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) (pp2 *connect.Response[v1.DeletePropertyResponse], err error)
	funcDeletePropertyOrigin    string
	inspectFuncDeleteProperty   func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest])
	afterDeletePropertyCounter  uint64
	beforeDeletePropertyCounter uint64
	DeletePropertyMock          mPropertyServiceClientMockDeleteProperty

	funcDeleteSubscription          func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) (pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error)
	funcDeleteSubscriptionOrigin    string
	inspectFuncDeleteSubscription   func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest])
	afterDeleteSubscriptionCounter  uint64
	beforeDeleteSubscriptionCounter uint64
	DeleteSubscriptionMock          mPropertyServiceClientMockDeleteSubscription

	funcHistoryOfProperty          func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest]) (pp2 *connect.ServerStreamForClient[v1.HistoryOfPropertyResponse], err error)
	funcHistoryOfPropertyOrigin    string
	inspectFuncHistoryOfProperty   func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest])
	afterHistoryOfPropertyCounter  uint64
	beforeHistoryOfPropertyCounter uint64
	HistoryOfPropertyMock          mPropertyServiceClientMockHistoryOfProperty

	funcListPropertyType          func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPropertyTypeResponse], err error)
	funcListPropertyTypeOrigin    string
	inspectFuncListPropertyType   func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest])
	afterListPropertyTypeCounter  uint64
	beforeListPropertyTypeCounter uint64
	ListPropertyTypeMock          mPropertyServiceClientMockListPropertyType

	funcListSubscription          func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListSubscriptionResponse], err error)
	funcListSubscriptionOrigin    string
	inspectFuncListSubscription   func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest])
	afterListSubscriptionCounter  uint64
	beforeListSubscriptionCounter uint64
	ListSubscriptionMock          mPropertyServiceClientMockListSubscription

	funcSearchProperty          func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchPropertyResponse], err error)
	funcSearchPropertyOrigin    string
	inspectFuncSearchProperty   func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest])
	afterSearchPropertyCounter  uint64
	beforeSearchPropertyCounter uint64
	SearchPropertyMock          mPropertyServiceClientMockSearchProperty

	funcStateOfProperty          func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) (pp2 *connect.Response[v1.StateOfPropertyResponse], err error)
	funcStateOfPropertyOrigin    string
	inspectFuncStateOfProperty   func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest])
	afterStateOfPropertyCounter  uint64
	beforeStateOfPropertyCounter uint64
	StateOfPropertyMock          mPropertyServiceClientMockStateOfProperty

	funcUpdateProperty          func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) (pp2 *connect.Response[v1.UpdatePropertyResponse], err error)
	funcUpdatePropertyOrigin    string
	inspectFuncUpdateProperty   func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest])
	afterUpdatePropertyCounter  uint64
	beforeUpdatePropertyCounter uint64
	UpdatePropertyMock          mPropertyServiceClientMockUpdateProperty
}

// NewPropertyServiceClientMock returns a mock for mm_propertyv1connect.PropertyServiceClient
func NewPropertyServiceClientMock(t minimock.Tester) *PropertyServiceClientMock {
	m := &PropertyServiceClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddLocalityMock = mPropertyServiceClientMockAddLocality{mock: m}
	m.AddLocalityMock.callArgs = []*PropertyServiceClientMockAddLocalityParams{}

	m.AddPropertyTypeMock = mPropertyServiceClientMockAddPropertyType{mock: m}
	m.AddPropertyTypeMock.callArgs = []*PropertyServiceClientMockAddPropertyTypeParams{}

	m.AddSubscriptionMock = mPropertyServiceClientMockAddSubscription{mock: m}
	m.AddSubscriptionMock.callArgs = []*PropertyServiceClientMockAddSubscriptionParams{}

	m.CreatePropertyMock = mPropertyServiceClientMockCreateProperty{mock: m}
	m.CreatePropertyMock.callArgs = []*PropertyServiceClientMockCreatePropertyParams{}

	m.DeleteLocalityMock = mPropertyServiceClientMockDeleteLocality{mock: m}
	m.DeleteLocalityMock.callArgs = []*PropertyServiceClientMockDeleteLocalityParams{}

	m.DeletePropertyMock = mPropertyServiceClientMockDeleteProperty{mock: m}
	m.DeletePropertyMock.callArgs = []*PropertyServiceClientMockDeletePropertyParams{}

	m.DeleteSubscriptionMock = mPropertyServiceClientMockDeleteSubscription{mock: m}
	m.DeleteSubscriptionMock.callArgs = []*PropertyServiceClientMockDeleteSubscriptionParams{}

	m.HistoryOfPropertyMock = mPropertyServiceClientMockHistoryOfProperty{mock: m}
	m.HistoryOfPropertyMock.callArgs = []*PropertyServiceClientMockHistoryOfPropertyParams{}

	m.ListPropertyTypeMock = mPropertyServiceClientMockListPropertyType{mock: m}
	m.ListPropertyTypeMock.callArgs = []*PropertyServiceClientMockListPropertyTypeParams{}

	m.ListSubscriptionMock = mPropertyServiceClientMockListSubscription{mock: m}
	m.ListSubscriptionMock.callArgs = []*PropertyServiceClientMockListSubscriptionParams{}

	m.SearchPropertyMock = mPropertyServiceClientMockSearchProperty{mock: m}
	m.SearchPropertyMock.callArgs = []*PropertyServiceClientMockSearchPropertyParams{}

	m.StateOfPropertyMock = mPropertyServiceClientMockStateOfProperty{mock: m}
	m.StateOfPropertyMock.callArgs = []*PropertyServiceClientMockStateOfPropertyParams{}

	m.UpdatePropertyMock = mPropertyServiceClientMockUpdateProperty{mock: m}
	m.UpdatePropertyMock.callArgs = []*PropertyServiceClientMockUpdatePropertyParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPropertyServiceClientMockAddLocality struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockAddLocalityExpectation
	expectations       []*PropertyServiceClientMockAddLocalityExpectation

	callArgs []*PropertyServiceClientMockAddLocalityParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockAddLocalityExpectation specifies expectation struct of the PropertyServiceClient.AddLocality
type PropertyServiceClientMockAddLocalityExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockAddLocalityParams
	paramPtrs          *PropertyServiceClientMockAddLocalityParamPtrs
	expectationOrigins PropertyServiceClientMockAddLocalityExpectationOrigins
	results            *PropertyServiceClientMockAddLocalityResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockAddLocalityParams contains parameters of the PropertyServiceClient.AddLocality
type PropertyServiceClientMockAddLocalityParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddLocalityRequest]
}

// PropertyServiceClientMockAddLocalityParamPtrs contains pointers to parameters of the PropertyServiceClient.AddLocality
type PropertyServiceClientMockAddLocalityParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddLocalityRequest]
}

// PropertyServiceClientMockAddLocalityResults contains results of the PropertyServiceClient.AddLocality
type PropertyServiceClientMockAddLocalityResults struct {
	pp2 *connect.Response[v1.AddLocalityResponse]
	err error
}

// PropertyServiceClientMockAddLocalityOrigins contains origins of expectations of the PropertyServiceClient.AddLocality
type PropertyServiceClientMockAddLocalityExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Optional() *mPropertyServiceClientMockAddLocality {
	mmAddLocality.optional = true
	return mmAddLocality
}

// Expect sets up expected params for PropertyServiceClient.AddLocality
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Expect(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) *mPropertyServiceClientMockAddLocality {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceClientMockAddLocalityExpectation{}
	}

	if mmAddLocality.defaultExpectation.paramPtrs != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by ExpectParams functions")
	}

	mmAddLocality.defaultExpectation.params = &PropertyServiceClientMockAddLocalityParams{ctx, pp1}
	mmAddLocality.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddLocality.expectations {
		if minimock.Equal(e.params, mmAddLocality.defaultExpectation.params) {
			mmAddLocality.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddLocality.defaultExpectation.params)
		}
	}

	return mmAddLocality
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.AddLocality
func (mmAddLocality *mPropertyServiceClientMockAddLocality) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockAddLocality {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceClientMockAddLocalityExpectation{}
	}

	if mmAddLocality.defaultExpectation.params != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Expect")
	}

	if mmAddLocality.defaultExpectation.paramPtrs == nil {
		mmAddLocality.defaultExpectation.paramPtrs = &PropertyServiceClientMockAddLocalityParamPtrs{}
	}
	mmAddLocality.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddLocality.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddLocality
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.AddLocality
func (mmAddLocality *mPropertyServiceClientMockAddLocality) ExpectPp1Param2(pp1 *connect.Request[v1.AddLocalityRequest]) *mPropertyServiceClientMockAddLocality {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceClientMockAddLocalityExpectation{}
	}

	if mmAddLocality.defaultExpectation.params != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Expect")
	}

	if mmAddLocality.defaultExpectation.paramPtrs == nil {
		mmAddLocality.defaultExpectation.paramPtrs = &PropertyServiceClientMockAddLocalityParamPtrs{}
	}
	mmAddLocality.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddLocality.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddLocality
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.AddLocality
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest])) *mPropertyServiceClientMockAddLocality {
	if mmAddLocality.mock.inspectFuncAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.AddLocality")
	}

	mmAddLocality.mock.inspectFuncAddLocality = f

	return mmAddLocality
}

// Return sets up results that will be returned by PropertyServiceClient.AddLocality
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Return(pp2 *connect.Response[v1.AddLocalityResponse], err error) *PropertyServiceClientMock {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Set")
	}

	if mmAddLocality.defaultExpectation == nil {
		mmAddLocality.defaultExpectation = &PropertyServiceClientMockAddLocalityExpectation{mock: mmAddLocality.mock}
	}
	mmAddLocality.defaultExpectation.results = &PropertyServiceClientMockAddLocalityResults{pp2, err}
	mmAddLocality.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddLocality.mock
}

// Set uses given function f to mock the PropertyServiceClient.AddLocality method
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) (pp2 *connect.Response[v1.AddLocalityResponse], err error)) *PropertyServiceClientMock {
	if mmAddLocality.defaultExpectation != nil {
		mmAddLocality.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.AddLocality method")
	}

	if len(mmAddLocality.expectations) > 0 {
		mmAddLocality.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.AddLocality method")
	}

	mmAddLocality.mock.funcAddLocality = f
	mmAddLocality.mock.funcAddLocalityOrigin = minimock.CallerInfo(1)
	return mmAddLocality.mock
}

// When sets expectation for the PropertyServiceClient.AddLocality which will trigger the result defined by the following
// Then helper
func (mmAddLocality *mPropertyServiceClientMockAddLocality) When(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) *PropertyServiceClientMockAddLocalityExpectation {
	if mmAddLocality.mock.funcAddLocality != nil {
		mmAddLocality.mock.t.Fatalf("PropertyServiceClientMock.AddLocality mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockAddLocalityExpectation{
		mock:               mmAddLocality.mock,
		params:             &PropertyServiceClientMockAddLocalityParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockAddLocalityExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddLocality.expectations = append(mmAddLocality.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.AddLocality return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockAddLocalityExpectation) Then(pp2 *connect.Response[v1.AddLocalityResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockAddLocalityResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.AddLocality should be invoked
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Times(n uint64) *mPropertyServiceClientMockAddLocality {
	if n == 0 {
		mmAddLocality.mock.t.Fatalf("Times of PropertyServiceClientMock.AddLocality mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddLocality.expectedInvocations, n)
	mmAddLocality.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddLocality
}

func (mmAddLocality *mPropertyServiceClientMockAddLocality) invocationsDone() bool {
	if len(mmAddLocality.expectations) == 0 && mmAddLocality.defaultExpectation == nil && mmAddLocality.mock.funcAddLocality == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddLocality.mock.afterAddLocalityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddLocality.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddLocality implements mm_propertyv1connect.PropertyServiceClient
func (mmAddLocality *PropertyServiceClientMock) AddLocality(ctx context.Context, pp1 *connect.Request[v1.AddLocalityRequest]) (pp2 *connect.Response[v1.AddLocalityResponse], err error) {
	mm_atomic.AddUint64(&mmAddLocality.beforeAddLocalityCounter, 1)
	defer mm_atomic.AddUint64(&mmAddLocality.afterAddLocalityCounter, 1)

	mmAddLocality.t.Helper()

	if mmAddLocality.inspectFuncAddLocality != nil {
		mmAddLocality.inspectFuncAddLocality(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockAddLocalityParams{ctx, pp1}

	// Record call args
	mmAddLocality.AddLocalityMock.mutex.Lock()
	mmAddLocality.AddLocalityMock.callArgs = append(mmAddLocality.AddLocalityMock.callArgs, &mm_params)
	mmAddLocality.AddLocalityMock.mutex.Unlock()

	for _, e := range mmAddLocality.AddLocalityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddLocality.AddLocalityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddLocality.AddLocalityMock.defaultExpectation.Counter, 1)
		mm_want := mmAddLocality.AddLocalityMock.defaultExpectation.params
		mm_want_ptrs := mmAddLocality.AddLocalityMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockAddLocalityParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddLocality.t.Errorf("PropertyServiceClientMock.AddLocality got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddLocality.AddLocalityMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddLocality.t.Errorf("PropertyServiceClientMock.AddLocality got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddLocality.AddLocalityMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddLocality.t.Errorf("PropertyServiceClientMock.AddLocality got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddLocality.AddLocalityMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddLocality.AddLocalityMock.defaultExpectation.results
		if mm_results == nil {
			mmAddLocality.t.Fatal("No results are set for the PropertyServiceClientMock.AddLocality")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddLocality.funcAddLocality != nil {
		return mmAddLocality.funcAddLocality(ctx, pp1)
	}
	mmAddLocality.t.Fatalf("Unexpected call to PropertyServiceClientMock.AddLocality. %v %v", ctx, pp1)
	return
}

// AddLocalityAfterCounter returns a count of finished PropertyServiceClientMock.AddLocality invocations
func (mmAddLocality *PropertyServiceClientMock) AddLocalityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLocality.afterAddLocalityCounter)
}

// AddLocalityBeforeCounter returns a count of PropertyServiceClientMock.AddLocality invocations
func (mmAddLocality *PropertyServiceClientMock) AddLocalityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLocality.beforeAddLocalityCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.AddLocality.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddLocality *mPropertyServiceClientMockAddLocality) Calls() []*PropertyServiceClientMockAddLocalityParams {
	mmAddLocality.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockAddLocalityParams, len(mmAddLocality.callArgs))
	copy(argCopy, mmAddLocality.callArgs)

	mmAddLocality.mutex.RUnlock()

	return argCopy
}

// MinimockAddLocalityDone returns true if the count of the AddLocality invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockAddLocalityDone() bool {
	if m.AddLocalityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddLocalityMock.invocationsDone()
}

// MinimockAddLocalityInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockAddLocalityInspect() {
	for _, e := range m.AddLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddLocality at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddLocalityCounter := mm_atomic.LoadUint64(&m.afterAddLocalityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddLocalityMock.defaultExpectation != nil && afterAddLocalityCounter < 1 {
		if m.AddLocalityMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddLocality at\n%s", m.AddLocalityMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddLocality at\n%s with params: %#v", m.AddLocalityMock.defaultExpectation.expectationOrigins.origin, *m.AddLocalityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddLocality != nil && afterAddLocalityCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.AddLocality at\n%s", m.funcAddLocalityOrigin)
	}

	if !m.AddLocalityMock.invocationsDone() && afterAddLocalityCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.AddLocality at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddLocalityMock.expectedInvocations), m.AddLocalityMock.expectedInvocationsOrigin, afterAddLocalityCounter)
	}
}

type mPropertyServiceClientMockAddPropertyType struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockAddPropertyTypeExpectation
	expectations       []*PropertyServiceClientMockAddPropertyTypeExpectation

	callArgs []*PropertyServiceClientMockAddPropertyTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockAddPropertyTypeExpectation specifies expectation struct of the PropertyServiceClient.AddPropertyType
type PropertyServiceClientMockAddPropertyTypeExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockAddPropertyTypeParams
	paramPtrs          *PropertyServiceClientMockAddPropertyTypeParamPtrs
	expectationOrigins PropertyServiceClientMockAddPropertyTypeExpectationOrigins
	results            *PropertyServiceClientMockAddPropertyTypeResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockAddPropertyTypeParams contains parameters of the PropertyServiceClient.AddPropertyType
type PropertyServiceClientMockAddPropertyTypeParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddPropertyTypeRequest]
}

// PropertyServiceClientMockAddPropertyTypeParamPtrs contains pointers to parameters of the PropertyServiceClient.AddPropertyType
type PropertyServiceClientMockAddPropertyTypeParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddPropertyTypeRequest]
}

// PropertyServiceClientMockAddPropertyTypeResults contains results of the PropertyServiceClient.AddPropertyType
type PropertyServiceClientMockAddPropertyTypeResults struct {
	pp2 *connect.Response[v1.AddPropertyTypeResponse]
	err error
}

// PropertyServiceClientMockAddPropertyTypeOrigins contains origins of expectations of the PropertyServiceClient.AddPropertyType
type PropertyServiceClientMockAddPropertyTypeExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Optional() *mPropertyServiceClientMockAddPropertyType {
	mmAddPropertyType.optional = true
	return mmAddPropertyType
}

// Expect sets up expected params for PropertyServiceClient.AddPropertyType
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Expect(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) *mPropertyServiceClientMockAddPropertyType {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceClientMockAddPropertyTypeExpectation{}
	}

	if mmAddPropertyType.defaultExpectation.paramPtrs != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by ExpectParams functions")
	}

	mmAddPropertyType.defaultExpectation.params = &PropertyServiceClientMockAddPropertyTypeParams{ctx, pp1}
	mmAddPropertyType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddPropertyType.expectations {
		if minimock.Equal(e.params, mmAddPropertyType.defaultExpectation.params) {
			mmAddPropertyType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddPropertyType.defaultExpectation.params)
		}
	}

	return mmAddPropertyType
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.AddPropertyType
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockAddPropertyType {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceClientMockAddPropertyTypeExpectation{}
	}

	if mmAddPropertyType.defaultExpectation.params != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Expect")
	}

	if mmAddPropertyType.defaultExpectation.paramPtrs == nil {
		mmAddPropertyType.defaultExpectation.paramPtrs = &PropertyServiceClientMockAddPropertyTypeParamPtrs{}
	}
	mmAddPropertyType.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddPropertyType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddPropertyType
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.AddPropertyType
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) ExpectPp1Param2(pp1 *connect.Request[v1.AddPropertyTypeRequest]) *mPropertyServiceClientMockAddPropertyType {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceClientMockAddPropertyTypeExpectation{}
	}

	if mmAddPropertyType.defaultExpectation.params != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Expect")
	}

	if mmAddPropertyType.defaultExpectation.paramPtrs == nil {
		mmAddPropertyType.defaultExpectation.paramPtrs = &PropertyServiceClientMockAddPropertyTypeParamPtrs{}
	}
	mmAddPropertyType.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddPropertyType.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddPropertyType
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.AddPropertyType
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest])) *mPropertyServiceClientMockAddPropertyType {
	if mmAddPropertyType.mock.inspectFuncAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.AddPropertyType")
	}

	mmAddPropertyType.mock.inspectFuncAddPropertyType = f

	return mmAddPropertyType
}

// Return sets up results that will be returned by PropertyServiceClient.AddPropertyType
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Return(pp2 *connect.Response[v1.AddPropertyTypeResponse], err error) *PropertyServiceClientMock {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Set")
	}

	if mmAddPropertyType.defaultExpectation == nil {
		mmAddPropertyType.defaultExpectation = &PropertyServiceClientMockAddPropertyTypeExpectation{mock: mmAddPropertyType.mock}
	}
	mmAddPropertyType.defaultExpectation.results = &PropertyServiceClientMockAddPropertyTypeResults{pp2, err}
	mmAddPropertyType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddPropertyType.mock
}

// Set uses given function f to mock the PropertyServiceClient.AddPropertyType method
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) (pp2 *connect.Response[v1.AddPropertyTypeResponse], err error)) *PropertyServiceClientMock {
	if mmAddPropertyType.defaultExpectation != nil {
		mmAddPropertyType.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.AddPropertyType method")
	}

	if len(mmAddPropertyType.expectations) > 0 {
		mmAddPropertyType.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.AddPropertyType method")
	}

	mmAddPropertyType.mock.funcAddPropertyType = f
	mmAddPropertyType.mock.funcAddPropertyTypeOrigin = minimock.CallerInfo(1)
	return mmAddPropertyType.mock
}

// When sets expectation for the PropertyServiceClient.AddPropertyType which will trigger the result defined by the following
// Then helper
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) When(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) *PropertyServiceClientMockAddPropertyTypeExpectation {
	if mmAddPropertyType.mock.funcAddPropertyType != nil {
		mmAddPropertyType.mock.t.Fatalf("PropertyServiceClientMock.AddPropertyType mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockAddPropertyTypeExpectation{
		mock:               mmAddPropertyType.mock,
		params:             &PropertyServiceClientMockAddPropertyTypeParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockAddPropertyTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddPropertyType.expectations = append(mmAddPropertyType.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.AddPropertyType return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockAddPropertyTypeExpectation) Then(pp2 *connect.Response[v1.AddPropertyTypeResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockAddPropertyTypeResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.AddPropertyType should be invoked
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Times(n uint64) *mPropertyServiceClientMockAddPropertyType {
	if n == 0 {
		mmAddPropertyType.mock.t.Fatalf("Times of PropertyServiceClientMock.AddPropertyType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddPropertyType.expectedInvocations, n)
	mmAddPropertyType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddPropertyType
}

func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) invocationsDone() bool {
	if len(mmAddPropertyType.expectations) == 0 && mmAddPropertyType.defaultExpectation == nil && mmAddPropertyType.mock.funcAddPropertyType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddPropertyType.mock.afterAddPropertyTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddPropertyType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddPropertyType implements mm_propertyv1connect.PropertyServiceClient
func (mmAddPropertyType *PropertyServiceClientMock) AddPropertyType(ctx context.Context, pp1 *connect.Request[v1.AddPropertyTypeRequest]) (pp2 *connect.Response[v1.AddPropertyTypeResponse], err error) {
	mm_atomic.AddUint64(&mmAddPropertyType.beforeAddPropertyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmAddPropertyType.afterAddPropertyTypeCounter, 1)

	mmAddPropertyType.t.Helper()

	if mmAddPropertyType.inspectFuncAddPropertyType != nil {
		mmAddPropertyType.inspectFuncAddPropertyType(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockAddPropertyTypeParams{ctx, pp1}

	// Record call args
	mmAddPropertyType.AddPropertyTypeMock.mutex.Lock()
	mmAddPropertyType.AddPropertyTypeMock.callArgs = append(mmAddPropertyType.AddPropertyTypeMock.callArgs, &mm_params)
	mmAddPropertyType.AddPropertyTypeMock.mutex.Unlock()

	for _, e := range mmAddPropertyType.AddPropertyTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddPropertyType.AddPropertyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.params
		mm_want_ptrs := mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockAddPropertyTypeParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddPropertyType.t.Errorf("PropertyServiceClientMock.AddPropertyType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddPropertyType.t.Errorf("PropertyServiceClientMock.AddPropertyType got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddPropertyType.t.Errorf("PropertyServiceClientMock.AddPropertyType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddPropertyType.AddPropertyTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmAddPropertyType.t.Fatal("No results are set for the PropertyServiceClientMock.AddPropertyType")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddPropertyType.funcAddPropertyType != nil {
		return mmAddPropertyType.funcAddPropertyType(ctx, pp1)
	}
	mmAddPropertyType.t.Fatalf("Unexpected call to PropertyServiceClientMock.AddPropertyType. %v %v", ctx, pp1)
	return
}

// AddPropertyTypeAfterCounter returns a count of finished PropertyServiceClientMock.AddPropertyType invocations
func (mmAddPropertyType *PropertyServiceClientMock) AddPropertyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPropertyType.afterAddPropertyTypeCounter)
}

// AddPropertyTypeBeforeCounter returns a count of PropertyServiceClientMock.AddPropertyType invocations
func (mmAddPropertyType *PropertyServiceClientMock) AddPropertyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddPropertyType.beforeAddPropertyTypeCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.AddPropertyType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddPropertyType *mPropertyServiceClientMockAddPropertyType) Calls() []*PropertyServiceClientMockAddPropertyTypeParams {
	mmAddPropertyType.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockAddPropertyTypeParams, len(mmAddPropertyType.callArgs))
	copy(argCopy, mmAddPropertyType.callArgs)

	mmAddPropertyType.mutex.RUnlock()

	return argCopy
}

// MinimockAddPropertyTypeDone returns true if the count of the AddPropertyType invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockAddPropertyTypeDone() bool {
	if m.AddPropertyTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddPropertyTypeMock.invocationsDone()
}

// MinimockAddPropertyTypeInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockAddPropertyTypeInspect() {
	for _, e := range m.AddPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddPropertyType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddPropertyTypeCounter := mm_atomic.LoadUint64(&m.afterAddPropertyTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddPropertyTypeMock.defaultExpectation != nil && afterAddPropertyTypeCounter < 1 {
		if m.AddPropertyTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddPropertyType at\n%s", m.AddPropertyTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddPropertyType at\n%s with params: %#v", m.AddPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *m.AddPropertyTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddPropertyType != nil && afterAddPropertyTypeCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.AddPropertyType at\n%s", m.funcAddPropertyTypeOrigin)
	}

	if !m.AddPropertyTypeMock.invocationsDone() && afterAddPropertyTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.AddPropertyType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddPropertyTypeMock.expectedInvocations), m.AddPropertyTypeMock.expectedInvocationsOrigin, afterAddPropertyTypeCounter)
	}
}

type mPropertyServiceClientMockAddSubscription struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockAddSubscriptionExpectation
	expectations       []*PropertyServiceClientMockAddSubscriptionExpectation

	callArgs []*PropertyServiceClientMockAddSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockAddSubscriptionExpectation specifies expectation struct of the PropertyServiceClient.AddSubscription
type PropertyServiceClientMockAddSubscriptionExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockAddSubscriptionParams
	paramPtrs          *PropertyServiceClientMockAddSubscriptionParamPtrs
	expectationOrigins PropertyServiceClientMockAddSubscriptionExpectationOrigins
	results            *PropertyServiceClientMockAddSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockAddSubscriptionParams contains parameters of the PropertyServiceClient.AddSubscription
type PropertyServiceClientMockAddSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.AddSubscriptionRequest]
}

// PropertyServiceClientMockAddSubscriptionParamPtrs contains pointers to parameters of the PropertyServiceClient.AddSubscription
type PropertyServiceClientMockAddSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.AddSubscriptionRequest]
}

// PropertyServiceClientMockAddSubscriptionResults contains results of the PropertyServiceClient.AddSubscription
type PropertyServiceClientMockAddSubscriptionResults struct {
	pp2 *connect.Response[v1.AddSubscriptionResponse]
	err error
}

// PropertyServiceClientMockAddSubscriptionOrigins contains origins of expectations of the PropertyServiceClient.AddSubscription
type PropertyServiceClientMockAddSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Optional() *mPropertyServiceClientMockAddSubscription {
	mmAddSubscription.optional = true
	return mmAddSubscription
}

// Expect sets up expected params for PropertyServiceClient.AddSubscription
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) *mPropertyServiceClientMockAddSubscription {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceClientMockAddSubscriptionExpectation{}
	}

	if mmAddSubscription.defaultExpectation.paramPtrs != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by ExpectParams functions")
	}

	mmAddSubscription.defaultExpectation.params = &PropertyServiceClientMockAddSubscriptionParams{ctx, pp1}
	mmAddSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSubscription.expectations {
		if minimock.Equal(e.params, mmAddSubscription.defaultExpectation.params) {
			mmAddSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSubscription.defaultExpectation.params)
		}
	}

	return mmAddSubscription
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.AddSubscription
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockAddSubscription {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceClientMockAddSubscriptionExpectation{}
	}

	if mmAddSubscription.defaultExpectation.params != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Expect")
	}

	if mmAddSubscription.defaultExpectation.paramPtrs == nil {
		mmAddSubscription.defaultExpectation.paramPtrs = &PropertyServiceClientMockAddSubscriptionParamPtrs{}
	}
	mmAddSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.AddSubscription
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.AddSubscriptionRequest]) *mPropertyServiceClientMockAddSubscription {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceClientMockAddSubscriptionExpectation{}
	}

	if mmAddSubscription.defaultExpectation.params != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Expect")
	}

	if mmAddSubscription.defaultExpectation.paramPtrs == nil {
		mmAddSubscription.defaultExpectation.paramPtrs = &PropertyServiceClientMockAddSubscriptionParamPtrs{}
	}
	mmAddSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmAddSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmAddSubscription
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.AddSubscription
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest])) *mPropertyServiceClientMockAddSubscription {
	if mmAddSubscription.mock.inspectFuncAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.AddSubscription")
	}

	mmAddSubscription.mock.inspectFuncAddSubscription = f

	return mmAddSubscription
}

// Return sets up results that will be returned by PropertyServiceClient.AddSubscription
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Return(pp2 *connect.Response[v1.AddSubscriptionResponse], err error) *PropertyServiceClientMock {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Set")
	}

	if mmAddSubscription.defaultExpectation == nil {
		mmAddSubscription.defaultExpectation = &PropertyServiceClientMockAddSubscriptionExpectation{mock: mmAddSubscription.mock}
	}
	mmAddSubscription.defaultExpectation.results = &PropertyServiceClientMockAddSubscriptionResults{pp2, err}
	mmAddSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSubscription.mock
}

// Set uses given function f to mock the PropertyServiceClient.AddSubscription method
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) (pp2 *connect.Response[v1.AddSubscriptionResponse], err error)) *PropertyServiceClientMock {
	if mmAddSubscription.defaultExpectation != nil {
		mmAddSubscription.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.AddSubscription method")
	}

	if len(mmAddSubscription.expectations) > 0 {
		mmAddSubscription.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.AddSubscription method")
	}

	mmAddSubscription.mock.funcAddSubscription = f
	mmAddSubscription.mock.funcAddSubscriptionOrigin = minimock.CallerInfo(1)
	return mmAddSubscription.mock
}

// When sets expectation for the PropertyServiceClient.AddSubscription which will trigger the result defined by the following
// Then helper
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) When(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) *PropertyServiceClientMockAddSubscriptionExpectation {
	if mmAddSubscription.mock.funcAddSubscription != nil {
		mmAddSubscription.mock.t.Fatalf("PropertyServiceClientMock.AddSubscription mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockAddSubscriptionExpectation{
		mock:               mmAddSubscription.mock,
		params:             &PropertyServiceClientMockAddSubscriptionParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockAddSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSubscription.expectations = append(mmAddSubscription.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.AddSubscription return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockAddSubscriptionExpectation) Then(pp2 *connect.Response[v1.AddSubscriptionResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockAddSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.AddSubscription should be invoked
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Times(n uint64) *mPropertyServiceClientMockAddSubscription {
	if n == 0 {
		mmAddSubscription.mock.t.Fatalf("Times of PropertyServiceClientMock.AddSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSubscription.expectedInvocations, n)
	mmAddSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSubscription
}

func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) invocationsDone() bool {
	if len(mmAddSubscription.expectations) == 0 && mmAddSubscription.defaultExpectation == nil && mmAddSubscription.mock.funcAddSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSubscription.mock.afterAddSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSubscription implements mm_propertyv1connect.PropertyServiceClient
func (mmAddSubscription *PropertyServiceClientMock) AddSubscription(ctx context.Context, pp1 *connect.Request[v1.AddSubscriptionRequest]) (pp2 *connect.Response[v1.AddSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmAddSubscription.beforeAddSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSubscription.afterAddSubscriptionCounter, 1)

	mmAddSubscription.t.Helper()

	if mmAddSubscription.inspectFuncAddSubscription != nil {
		mmAddSubscription.inspectFuncAddSubscription(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockAddSubscriptionParams{ctx, pp1}

	// Record call args
	mmAddSubscription.AddSubscriptionMock.mutex.Lock()
	mmAddSubscription.AddSubscriptionMock.callArgs = append(mmAddSubscription.AddSubscriptionMock.callArgs, &mm_params)
	mmAddSubscription.AddSubscriptionMock.mutex.Unlock()

	for _, e := range mmAddSubscription.AddSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAddSubscription.AddSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSubscription.AddSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSubscription.AddSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmAddSubscription.AddSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockAddSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSubscription.t.Errorf("PropertyServiceClientMock.AddSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubscription.AddSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmAddSubscription.t.Errorf("PropertyServiceClientMock.AddSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSubscription.AddSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSubscription.t.Errorf("PropertyServiceClientMock.AddSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSubscription.AddSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSubscription.AddSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSubscription.t.Fatal("No results are set for the PropertyServiceClientMock.AddSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAddSubscription.funcAddSubscription != nil {
		return mmAddSubscription.funcAddSubscription(ctx, pp1)
	}
	mmAddSubscription.t.Fatalf("Unexpected call to PropertyServiceClientMock.AddSubscription. %v %v", ctx, pp1)
	return
}

// AddSubscriptionAfterCounter returns a count of finished PropertyServiceClientMock.AddSubscription invocations
func (mmAddSubscription *PropertyServiceClientMock) AddSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubscription.afterAddSubscriptionCounter)
}

// AddSubscriptionBeforeCounter returns a count of PropertyServiceClientMock.AddSubscription invocations
func (mmAddSubscription *PropertyServiceClientMock) AddSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSubscription.beforeAddSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.AddSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSubscription *mPropertyServiceClientMockAddSubscription) Calls() []*PropertyServiceClientMockAddSubscriptionParams {
	mmAddSubscription.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockAddSubscriptionParams, len(mmAddSubscription.callArgs))
	copy(argCopy, mmAddSubscription.callArgs)

	mmAddSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockAddSubscriptionDone returns true if the count of the AddSubscription invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockAddSubscriptionDone() bool {
	if m.AddSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSubscriptionMock.invocationsDone()
}

// MinimockAddSubscriptionInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockAddSubscriptionInspect() {
	for _, e := range m.AddSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSubscriptionCounter := mm_atomic.LoadUint64(&m.afterAddSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSubscriptionMock.defaultExpectation != nil && afterAddSubscriptionCounter < 1 {
		if m.AddSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddSubscription at\n%s", m.AddSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.AddSubscription at\n%s with params: %#v", m.AddSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.AddSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSubscription != nil && afterAddSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.AddSubscription at\n%s", m.funcAddSubscriptionOrigin)
	}

	if !m.AddSubscriptionMock.invocationsDone() && afterAddSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.AddSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSubscriptionMock.expectedInvocations), m.AddSubscriptionMock.expectedInvocationsOrigin, afterAddSubscriptionCounter)
	}
}

type mPropertyServiceClientMockCreateProperty struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockCreatePropertyExpectation
	expectations       []*PropertyServiceClientMockCreatePropertyExpectation

	callArgs []*PropertyServiceClientMockCreatePropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockCreatePropertyExpectation specifies expectation struct of the PropertyServiceClient.CreateProperty
type PropertyServiceClientMockCreatePropertyExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockCreatePropertyParams
	paramPtrs          *PropertyServiceClientMockCreatePropertyParamPtrs
	expectationOrigins PropertyServiceClientMockCreatePropertyExpectationOrigins
	results            *PropertyServiceClientMockCreatePropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockCreatePropertyParams contains parameters of the PropertyServiceClient.CreateProperty
type PropertyServiceClientMockCreatePropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.CreatePropertyRequest]
}

// PropertyServiceClientMockCreatePropertyParamPtrs contains pointers to parameters of the PropertyServiceClient.CreateProperty
type PropertyServiceClientMockCreatePropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.CreatePropertyRequest]
}

// PropertyServiceClientMockCreatePropertyResults contains results of the PropertyServiceClient.CreateProperty
type PropertyServiceClientMockCreatePropertyResults struct {
	pp2 *connect.Response[v1.CreatePropertyResponse]
	err error
}

// PropertyServiceClientMockCreatePropertyOrigins contains origins of expectations of the PropertyServiceClient.CreateProperty
type PropertyServiceClientMockCreatePropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Optional() *mPropertyServiceClientMockCreateProperty {
	mmCreateProperty.optional = true
	return mmCreateProperty
}

// Expect sets up expected params for PropertyServiceClient.CreateProperty
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) *mPropertyServiceClientMockCreateProperty {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceClientMockCreatePropertyExpectation{}
	}

	if mmCreateProperty.defaultExpectation.paramPtrs != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by ExpectParams functions")
	}

	mmCreateProperty.defaultExpectation.params = &PropertyServiceClientMockCreatePropertyParams{ctx, pp1}
	mmCreateProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProperty.expectations {
		if minimock.Equal(e.params, mmCreateProperty.defaultExpectation.params) {
			mmCreateProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProperty.defaultExpectation.params)
		}
	}

	return mmCreateProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.CreateProperty
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockCreateProperty {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceClientMockCreatePropertyExpectation{}
	}

	if mmCreateProperty.defaultExpectation.params != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Expect")
	}

	if mmCreateProperty.defaultExpectation.paramPtrs == nil {
		mmCreateProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockCreatePropertyParamPtrs{}
	}
	mmCreateProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.CreateProperty
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) ExpectPp1Param2(pp1 *connect.Request[v1.CreatePropertyRequest]) *mPropertyServiceClientMockCreateProperty {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceClientMockCreatePropertyExpectation{}
	}

	if mmCreateProperty.defaultExpectation.params != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Expect")
	}

	if mmCreateProperty.defaultExpectation.paramPtrs == nil {
		mmCreateProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockCreatePropertyParamPtrs{}
	}
	mmCreateProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmCreateProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmCreateProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.CreateProperty
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest])) *mPropertyServiceClientMockCreateProperty {
	if mmCreateProperty.mock.inspectFuncCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.CreateProperty")
	}

	mmCreateProperty.mock.inspectFuncCreateProperty = f

	return mmCreateProperty
}

// Return sets up results that will be returned by PropertyServiceClient.CreateProperty
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Return(pp2 *connect.Response[v1.CreatePropertyResponse], err error) *PropertyServiceClientMock {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Set")
	}

	if mmCreateProperty.defaultExpectation == nil {
		mmCreateProperty.defaultExpectation = &PropertyServiceClientMockCreatePropertyExpectation{mock: mmCreateProperty.mock}
	}
	mmCreateProperty.defaultExpectation.results = &PropertyServiceClientMockCreatePropertyResults{pp2, err}
	mmCreateProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProperty.mock
}

// Set uses given function f to mock the PropertyServiceClient.CreateProperty method
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) (pp2 *connect.Response[v1.CreatePropertyResponse], err error)) *PropertyServiceClientMock {
	if mmCreateProperty.defaultExpectation != nil {
		mmCreateProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.CreateProperty method")
	}

	if len(mmCreateProperty.expectations) > 0 {
		mmCreateProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.CreateProperty method")
	}

	mmCreateProperty.mock.funcCreateProperty = f
	mmCreateProperty.mock.funcCreatePropertyOrigin = minimock.CallerInfo(1)
	return mmCreateProperty.mock
}

// When sets expectation for the PropertyServiceClient.CreateProperty which will trigger the result defined by the following
// Then helper
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) When(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) *PropertyServiceClientMockCreatePropertyExpectation {
	if mmCreateProperty.mock.funcCreateProperty != nil {
		mmCreateProperty.mock.t.Fatalf("PropertyServiceClientMock.CreateProperty mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockCreatePropertyExpectation{
		mock:               mmCreateProperty.mock,
		params:             &PropertyServiceClientMockCreatePropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockCreatePropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProperty.expectations = append(mmCreateProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.CreateProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockCreatePropertyExpectation) Then(pp2 *connect.Response[v1.CreatePropertyResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockCreatePropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.CreateProperty should be invoked
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Times(n uint64) *mPropertyServiceClientMockCreateProperty {
	if n == 0 {
		mmCreateProperty.mock.t.Fatalf("Times of PropertyServiceClientMock.CreateProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProperty.expectedInvocations, n)
	mmCreateProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProperty
}

func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) invocationsDone() bool {
	if len(mmCreateProperty.expectations) == 0 && mmCreateProperty.defaultExpectation == nil && mmCreateProperty.mock.funcCreateProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProperty.mock.afterCreatePropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProperty implements mm_propertyv1connect.PropertyServiceClient
func (mmCreateProperty *PropertyServiceClientMock) CreateProperty(ctx context.Context, pp1 *connect.Request[v1.CreatePropertyRequest]) (pp2 *connect.Response[v1.CreatePropertyResponse], err error) {
	mm_atomic.AddUint64(&mmCreateProperty.beforeCreatePropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProperty.afterCreatePropertyCounter, 1)

	mmCreateProperty.t.Helper()

	if mmCreateProperty.inspectFuncCreateProperty != nil {
		mmCreateProperty.inspectFuncCreateProperty(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockCreatePropertyParams{ctx, pp1}

	// Record call args
	mmCreateProperty.CreatePropertyMock.mutex.Lock()
	mmCreateProperty.CreatePropertyMock.callArgs = append(mmCreateProperty.CreatePropertyMock.callArgs, &mm_params)
	mmCreateProperty.CreatePropertyMock.mutex.Unlock()

	for _, e := range mmCreateProperty.CreatePropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmCreateProperty.CreatePropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProperty.CreatePropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProperty.CreatePropertyMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProperty.CreatePropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockCreatePropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProperty.t.Errorf("PropertyServiceClientMock.CreateProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProperty.CreatePropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmCreateProperty.t.Errorf("PropertyServiceClientMock.CreateProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProperty.CreatePropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProperty.t.Errorf("PropertyServiceClientMock.CreateProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProperty.CreatePropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProperty.CreatePropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProperty.t.Fatal("No results are set for the PropertyServiceClientMock.CreateProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmCreateProperty.funcCreateProperty != nil {
		return mmCreateProperty.funcCreateProperty(ctx, pp1)
	}
	mmCreateProperty.t.Fatalf("Unexpected call to PropertyServiceClientMock.CreateProperty. %v %v", ctx, pp1)
	return
}

// CreatePropertyAfterCounter returns a count of finished PropertyServiceClientMock.CreateProperty invocations
func (mmCreateProperty *PropertyServiceClientMock) CreatePropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProperty.afterCreatePropertyCounter)
}

// CreatePropertyBeforeCounter returns a count of PropertyServiceClientMock.CreateProperty invocations
func (mmCreateProperty *PropertyServiceClientMock) CreatePropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProperty.beforeCreatePropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.CreateProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProperty *mPropertyServiceClientMockCreateProperty) Calls() []*PropertyServiceClientMockCreatePropertyParams {
	mmCreateProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockCreatePropertyParams, len(mmCreateProperty.callArgs))
	copy(argCopy, mmCreateProperty.callArgs)

	mmCreateProperty.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePropertyDone returns true if the count of the CreateProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockCreatePropertyDone() bool {
	if m.CreatePropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePropertyMock.invocationsDone()
}

// MinimockCreatePropertyInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockCreatePropertyInspect() {
	for _, e := range m.CreatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.CreateProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePropertyCounter := mm_atomic.LoadUint64(&m.afterCreatePropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePropertyMock.defaultExpectation != nil && afterCreatePropertyCounter < 1 {
		if m.CreatePropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.CreateProperty at\n%s", m.CreatePropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.CreateProperty at\n%s with params: %#v", m.CreatePropertyMock.defaultExpectation.expectationOrigins.origin, *m.CreatePropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProperty != nil && afterCreatePropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.CreateProperty at\n%s", m.funcCreatePropertyOrigin)
	}

	if !m.CreatePropertyMock.invocationsDone() && afterCreatePropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.CreateProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePropertyMock.expectedInvocations), m.CreatePropertyMock.expectedInvocationsOrigin, afterCreatePropertyCounter)
	}
}

type mPropertyServiceClientMockDeleteLocality struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockDeleteLocalityExpectation
	expectations       []*PropertyServiceClientMockDeleteLocalityExpectation

	callArgs []*PropertyServiceClientMockDeleteLocalityParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockDeleteLocalityExpectation specifies expectation struct of the PropertyServiceClient.DeleteLocality
type PropertyServiceClientMockDeleteLocalityExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockDeleteLocalityParams
	paramPtrs          *PropertyServiceClientMockDeleteLocalityParamPtrs
	expectationOrigins PropertyServiceClientMockDeleteLocalityExpectationOrigins
	results            *PropertyServiceClientMockDeleteLocalityResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockDeleteLocalityParams contains parameters of the PropertyServiceClient.DeleteLocality
type PropertyServiceClientMockDeleteLocalityParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeleteLocalityRequest]
}

// PropertyServiceClientMockDeleteLocalityParamPtrs contains pointers to parameters of the PropertyServiceClient.DeleteLocality
type PropertyServiceClientMockDeleteLocalityParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeleteLocalityRequest]
}

// PropertyServiceClientMockDeleteLocalityResults contains results of the PropertyServiceClient.DeleteLocality
type PropertyServiceClientMockDeleteLocalityResults struct {
	pp2 *connect.Response[v1.DeleteLocalityResponse]
	err error
}

// PropertyServiceClientMockDeleteLocalityOrigins contains origins of expectations of the PropertyServiceClient.DeleteLocality
type PropertyServiceClientMockDeleteLocalityExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Optional() *mPropertyServiceClientMockDeleteLocality {
	mmDeleteLocality.optional = true
	return mmDeleteLocality
}

// Expect sets up expected params for PropertyServiceClient.DeleteLocality
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Expect(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) *mPropertyServiceClientMockDeleteLocality {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceClientMockDeleteLocalityExpectation{}
	}

	if mmDeleteLocality.defaultExpectation.paramPtrs != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by ExpectParams functions")
	}

	mmDeleteLocality.defaultExpectation.params = &PropertyServiceClientMockDeleteLocalityParams{ctx, pp1}
	mmDeleteLocality.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteLocality.expectations {
		if minimock.Equal(e.params, mmDeleteLocality.defaultExpectation.params) {
			mmDeleteLocality.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteLocality.defaultExpectation.params)
		}
	}

	return mmDeleteLocality
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.DeleteLocality
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockDeleteLocality {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceClientMockDeleteLocalityExpectation{}
	}

	if mmDeleteLocality.defaultExpectation.params != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Expect")
	}

	if mmDeleteLocality.defaultExpectation.paramPtrs == nil {
		mmDeleteLocality.defaultExpectation.paramPtrs = &PropertyServiceClientMockDeleteLocalityParamPtrs{}
	}
	mmDeleteLocality.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteLocality.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteLocality
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.DeleteLocality
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) ExpectPp1Param2(pp1 *connect.Request[v1.DeleteLocalityRequest]) *mPropertyServiceClientMockDeleteLocality {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceClientMockDeleteLocalityExpectation{}
	}

	if mmDeleteLocality.defaultExpectation.params != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Expect")
	}

	if mmDeleteLocality.defaultExpectation.paramPtrs == nil {
		mmDeleteLocality.defaultExpectation.paramPtrs = &PropertyServiceClientMockDeleteLocalityParamPtrs{}
	}
	mmDeleteLocality.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteLocality.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteLocality
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.DeleteLocality
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest])) *mPropertyServiceClientMockDeleteLocality {
	if mmDeleteLocality.mock.inspectFuncDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.DeleteLocality")
	}

	mmDeleteLocality.mock.inspectFuncDeleteLocality = f

	return mmDeleteLocality
}

// Return sets up results that will be returned by PropertyServiceClient.DeleteLocality
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Return(pp2 *connect.Response[v1.DeleteLocalityResponse], err error) *PropertyServiceClientMock {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Set")
	}

	if mmDeleteLocality.defaultExpectation == nil {
		mmDeleteLocality.defaultExpectation = &PropertyServiceClientMockDeleteLocalityExpectation{mock: mmDeleteLocality.mock}
	}
	mmDeleteLocality.defaultExpectation.results = &PropertyServiceClientMockDeleteLocalityResults{pp2, err}
	mmDeleteLocality.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteLocality.mock
}

// Set uses given function f to mock the PropertyServiceClient.DeleteLocality method
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) (pp2 *connect.Response[v1.DeleteLocalityResponse], err error)) *PropertyServiceClientMock {
	if mmDeleteLocality.defaultExpectation != nil {
		mmDeleteLocality.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.DeleteLocality method")
	}

	if len(mmDeleteLocality.expectations) > 0 {
		mmDeleteLocality.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.DeleteLocality method")
	}

	mmDeleteLocality.mock.funcDeleteLocality = f
	mmDeleteLocality.mock.funcDeleteLocalityOrigin = minimock.CallerInfo(1)
	return mmDeleteLocality.mock
}

// When sets expectation for the PropertyServiceClient.DeleteLocality which will trigger the result defined by the following
// Then helper
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) When(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) *PropertyServiceClientMockDeleteLocalityExpectation {
	if mmDeleteLocality.mock.funcDeleteLocality != nil {
		mmDeleteLocality.mock.t.Fatalf("PropertyServiceClientMock.DeleteLocality mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockDeleteLocalityExpectation{
		mock:               mmDeleteLocality.mock,
		params:             &PropertyServiceClientMockDeleteLocalityParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockDeleteLocalityExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteLocality.expectations = append(mmDeleteLocality.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.DeleteLocality return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockDeleteLocalityExpectation) Then(pp2 *connect.Response[v1.DeleteLocalityResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockDeleteLocalityResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.DeleteLocality should be invoked
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Times(n uint64) *mPropertyServiceClientMockDeleteLocality {
	if n == 0 {
		mmDeleteLocality.mock.t.Fatalf("Times of PropertyServiceClientMock.DeleteLocality mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteLocality.expectedInvocations, n)
	mmDeleteLocality.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteLocality
}

func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) invocationsDone() bool {
	if len(mmDeleteLocality.expectations) == 0 && mmDeleteLocality.defaultExpectation == nil && mmDeleteLocality.mock.funcDeleteLocality == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteLocality.mock.afterDeleteLocalityCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteLocality.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteLocality implements mm_propertyv1connect.PropertyServiceClient
func (mmDeleteLocality *PropertyServiceClientMock) DeleteLocality(ctx context.Context, pp1 *connect.Request[v1.DeleteLocalityRequest]) (pp2 *connect.Response[v1.DeleteLocalityResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteLocality.beforeDeleteLocalityCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteLocality.afterDeleteLocalityCounter, 1)

	mmDeleteLocality.t.Helper()

	if mmDeleteLocality.inspectFuncDeleteLocality != nil {
		mmDeleteLocality.inspectFuncDeleteLocality(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockDeleteLocalityParams{ctx, pp1}

	// Record call args
	mmDeleteLocality.DeleteLocalityMock.mutex.Lock()
	mmDeleteLocality.DeleteLocalityMock.callArgs = append(mmDeleteLocality.DeleteLocalityMock.callArgs, &mm_params)
	mmDeleteLocality.DeleteLocalityMock.mutex.Unlock()

	for _, e := range mmDeleteLocality.DeleteLocalityMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteLocality.DeleteLocalityMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteLocality.DeleteLocalityMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteLocality.DeleteLocalityMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteLocality.DeleteLocalityMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockDeleteLocalityParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteLocality.t.Errorf("PropertyServiceClientMock.DeleteLocality got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLocality.DeleteLocalityMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteLocality.t.Errorf("PropertyServiceClientMock.DeleteLocality got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLocality.DeleteLocalityMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteLocality.t.Errorf("PropertyServiceClientMock.DeleteLocality got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteLocality.DeleteLocalityMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteLocality.DeleteLocalityMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteLocality.t.Fatal("No results are set for the PropertyServiceClientMock.DeleteLocality")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteLocality.funcDeleteLocality != nil {
		return mmDeleteLocality.funcDeleteLocality(ctx, pp1)
	}
	mmDeleteLocality.t.Fatalf("Unexpected call to PropertyServiceClientMock.DeleteLocality. %v %v", ctx, pp1)
	return
}

// DeleteLocalityAfterCounter returns a count of finished PropertyServiceClientMock.DeleteLocality invocations
func (mmDeleteLocality *PropertyServiceClientMock) DeleteLocalityAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLocality.afterDeleteLocalityCounter)
}

// DeleteLocalityBeforeCounter returns a count of PropertyServiceClientMock.DeleteLocality invocations
func (mmDeleteLocality *PropertyServiceClientMock) DeleteLocalityBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLocality.beforeDeleteLocalityCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.DeleteLocality.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteLocality *mPropertyServiceClientMockDeleteLocality) Calls() []*PropertyServiceClientMockDeleteLocalityParams {
	mmDeleteLocality.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockDeleteLocalityParams, len(mmDeleteLocality.callArgs))
	copy(argCopy, mmDeleteLocality.callArgs)

	mmDeleteLocality.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteLocalityDone returns true if the count of the DeleteLocality invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockDeleteLocalityDone() bool {
	if m.DeleteLocalityMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteLocalityMock.invocationsDone()
}

// MinimockDeleteLocalityInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockDeleteLocalityInspect() {
	for _, e := range m.DeleteLocalityMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteLocality at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteLocalityCounter := mm_atomic.LoadUint64(&m.afterDeleteLocalityCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteLocalityMock.defaultExpectation != nil && afterDeleteLocalityCounter < 1 {
		if m.DeleteLocalityMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteLocality at\n%s", m.DeleteLocalityMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteLocality at\n%s with params: %#v", m.DeleteLocalityMock.defaultExpectation.expectationOrigins.origin, *m.DeleteLocalityMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteLocality != nil && afterDeleteLocalityCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteLocality at\n%s", m.funcDeleteLocalityOrigin)
	}

	if !m.DeleteLocalityMock.invocationsDone() && afterDeleteLocalityCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.DeleteLocality at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteLocalityMock.expectedInvocations), m.DeleteLocalityMock.expectedInvocationsOrigin, afterDeleteLocalityCounter)
	}
}

type mPropertyServiceClientMockDeleteProperty struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockDeletePropertyExpectation
	expectations       []*PropertyServiceClientMockDeletePropertyExpectation

	callArgs []*PropertyServiceClientMockDeletePropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockDeletePropertyExpectation specifies expectation struct of the PropertyServiceClient.DeleteProperty
type PropertyServiceClientMockDeletePropertyExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockDeletePropertyParams
	paramPtrs          *PropertyServiceClientMockDeletePropertyParamPtrs
	expectationOrigins PropertyServiceClientMockDeletePropertyExpectationOrigins
	results            *PropertyServiceClientMockDeletePropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockDeletePropertyParams contains parameters of the PropertyServiceClient.DeleteProperty
type PropertyServiceClientMockDeletePropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeletePropertyRequest]
}

// PropertyServiceClientMockDeletePropertyParamPtrs contains pointers to parameters of the PropertyServiceClient.DeleteProperty
type PropertyServiceClientMockDeletePropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeletePropertyRequest]
}

// PropertyServiceClientMockDeletePropertyResults contains results of the PropertyServiceClient.DeleteProperty
type PropertyServiceClientMockDeletePropertyResults struct {
	pp2 *connect.Response[v1.DeletePropertyResponse]
	err error
}

// PropertyServiceClientMockDeletePropertyOrigins contains origins of expectations of the PropertyServiceClient.DeleteProperty
type PropertyServiceClientMockDeletePropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Optional() *mPropertyServiceClientMockDeleteProperty {
	mmDeleteProperty.optional = true
	return mmDeleteProperty
}

// Expect sets up expected params for PropertyServiceClient.DeleteProperty
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) *mPropertyServiceClientMockDeleteProperty {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceClientMockDeletePropertyExpectation{}
	}

	if mmDeleteProperty.defaultExpectation.paramPtrs != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by ExpectParams functions")
	}

	mmDeleteProperty.defaultExpectation.params = &PropertyServiceClientMockDeletePropertyParams{ctx, pp1}
	mmDeleteProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProperty.expectations {
		if minimock.Equal(e.params, mmDeleteProperty.defaultExpectation.params) {
			mmDeleteProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProperty.defaultExpectation.params)
		}
	}

	return mmDeleteProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.DeleteProperty
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockDeleteProperty {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceClientMockDeletePropertyExpectation{}
	}

	if mmDeleteProperty.defaultExpectation.params != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Expect")
	}

	if mmDeleteProperty.defaultExpectation.paramPtrs == nil {
		mmDeleteProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockDeletePropertyParamPtrs{}
	}
	mmDeleteProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.DeleteProperty
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) ExpectPp1Param2(pp1 *connect.Request[v1.DeletePropertyRequest]) *mPropertyServiceClientMockDeleteProperty {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceClientMockDeletePropertyExpectation{}
	}

	if mmDeleteProperty.defaultExpectation.params != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Expect")
	}

	if mmDeleteProperty.defaultExpectation.paramPtrs == nil {
		mmDeleteProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockDeletePropertyParamPtrs{}
	}
	mmDeleteProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.DeleteProperty
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest])) *mPropertyServiceClientMockDeleteProperty {
	if mmDeleteProperty.mock.inspectFuncDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.DeleteProperty")
	}

	mmDeleteProperty.mock.inspectFuncDeleteProperty = f

	return mmDeleteProperty
}

// Return sets up results that will be returned by PropertyServiceClient.DeleteProperty
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Return(pp2 *connect.Response[v1.DeletePropertyResponse], err error) *PropertyServiceClientMock {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Set")
	}

	if mmDeleteProperty.defaultExpectation == nil {
		mmDeleteProperty.defaultExpectation = &PropertyServiceClientMockDeletePropertyExpectation{mock: mmDeleteProperty.mock}
	}
	mmDeleteProperty.defaultExpectation.results = &PropertyServiceClientMockDeletePropertyResults{pp2, err}
	mmDeleteProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProperty.mock
}

// Set uses given function f to mock the PropertyServiceClient.DeleteProperty method
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) (pp2 *connect.Response[v1.DeletePropertyResponse], err error)) *PropertyServiceClientMock {
	if mmDeleteProperty.defaultExpectation != nil {
		mmDeleteProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.DeleteProperty method")
	}

	if len(mmDeleteProperty.expectations) > 0 {
		mmDeleteProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.DeleteProperty method")
	}

	mmDeleteProperty.mock.funcDeleteProperty = f
	mmDeleteProperty.mock.funcDeletePropertyOrigin = minimock.CallerInfo(1)
	return mmDeleteProperty.mock
}

// When sets expectation for the PropertyServiceClient.DeleteProperty which will trigger the result defined by the following
// Then helper
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) When(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) *PropertyServiceClientMockDeletePropertyExpectation {
	if mmDeleteProperty.mock.funcDeleteProperty != nil {
		mmDeleteProperty.mock.t.Fatalf("PropertyServiceClientMock.DeleteProperty mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockDeletePropertyExpectation{
		mock:               mmDeleteProperty.mock,
		params:             &PropertyServiceClientMockDeletePropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockDeletePropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProperty.expectations = append(mmDeleteProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.DeleteProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockDeletePropertyExpectation) Then(pp2 *connect.Response[v1.DeletePropertyResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockDeletePropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.DeleteProperty should be invoked
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Times(n uint64) *mPropertyServiceClientMockDeleteProperty {
	if n == 0 {
		mmDeleteProperty.mock.t.Fatalf("Times of PropertyServiceClientMock.DeleteProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProperty.expectedInvocations, n)
	mmDeleteProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProperty
}

func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) invocationsDone() bool {
	if len(mmDeleteProperty.expectations) == 0 && mmDeleteProperty.defaultExpectation == nil && mmDeleteProperty.mock.funcDeleteProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProperty.mock.afterDeletePropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProperty implements mm_propertyv1connect.PropertyServiceClient
func (mmDeleteProperty *PropertyServiceClientMock) DeleteProperty(ctx context.Context, pp1 *connect.Request[v1.DeletePropertyRequest]) (pp2 *connect.Response[v1.DeletePropertyResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteProperty.beforeDeletePropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProperty.afterDeletePropertyCounter, 1)

	mmDeleteProperty.t.Helper()

	if mmDeleteProperty.inspectFuncDeleteProperty != nil {
		mmDeleteProperty.inspectFuncDeleteProperty(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockDeletePropertyParams{ctx, pp1}

	// Record call args
	mmDeleteProperty.DeletePropertyMock.mutex.Lock()
	mmDeleteProperty.DeletePropertyMock.callArgs = append(mmDeleteProperty.DeletePropertyMock.callArgs, &mm_params)
	mmDeleteProperty.DeletePropertyMock.mutex.Unlock()

	for _, e := range mmDeleteProperty.DeletePropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteProperty.DeletePropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProperty.DeletePropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProperty.DeletePropertyMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProperty.DeletePropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockDeletePropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteProperty.t.Errorf("PropertyServiceClientMock.DeleteProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProperty.DeletePropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteProperty.t.Errorf("PropertyServiceClientMock.DeleteProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProperty.DeletePropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProperty.t.Errorf("PropertyServiceClientMock.DeleteProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProperty.DeletePropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProperty.DeletePropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProperty.t.Fatal("No results are set for the PropertyServiceClientMock.DeleteProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteProperty.funcDeleteProperty != nil {
		return mmDeleteProperty.funcDeleteProperty(ctx, pp1)
	}
	mmDeleteProperty.t.Fatalf("Unexpected call to PropertyServiceClientMock.DeleteProperty. %v %v", ctx, pp1)
	return
}

// DeletePropertyAfterCounter returns a count of finished PropertyServiceClientMock.DeleteProperty invocations
func (mmDeleteProperty *PropertyServiceClientMock) DeletePropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProperty.afterDeletePropertyCounter)
}

// DeletePropertyBeforeCounter returns a count of PropertyServiceClientMock.DeleteProperty invocations
func (mmDeleteProperty *PropertyServiceClientMock) DeletePropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProperty.beforeDeletePropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.DeleteProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProperty *mPropertyServiceClientMockDeleteProperty) Calls() []*PropertyServiceClientMockDeletePropertyParams {
	mmDeleteProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockDeletePropertyParams, len(mmDeleteProperty.callArgs))
	copy(argCopy, mmDeleteProperty.callArgs)

	mmDeleteProperty.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePropertyDone returns true if the count of the DeleteProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockDeletePropertyDone() bool {
	if m.DeletePropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePropertyMock.invocationsDone()
}

// MinimockDeletePropertyInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockDeletePropertyInspect() {
	for _, e := range m.DeletePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePropertyCounter := mm_atomic.LoadUint64(&m.afterDeletePropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePropertyMock.defaultExpectation != nil && afterDeletePropertyCounter < 1 {
		if m.DeletePropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteProperty at\n%s", m.DeletePropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteProperty at\n%s with params: %#v", m.DeletePropertyMock.defaultExpectation.expectationOrigins.origin, *m.DeletePropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProperty != nil && afterDeletePropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteProperty at\n%s", m.funcDeletePropertyOrigin)
	}

	if !m.DeletePropertyMock.invocationsDone() && afterDeletePropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.DeleteProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePropertyMock.expectedInvocations), m.DeletePropertyMock.expectedInvocationsOrigin, afterDeletePropertyCounter)
	}
}

type mPropertyServiceClientMockDeleteSubscription struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockDeleteSubscriptionExpectation
	expectations       []*PropertyServiceClientMockDeleteSubscriptionExpectation

	callArgs []*PropertyServiceClientMockDeleteSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockDeleteSubscriptionExpectation specifies expectation struct of the PropertyServiceClient.DeleteSubscription
type PropertyServiceClientMockDeleteSubscriptionExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockDeleteSubscriptionParams
	paramPtrs          *PropertyServiceClientMockDeleteSubscriptionParamPtrs
	expectationOrigins PropertyServiceClientMockDeleteSubscriptionExpectationOrigins
	results            *PropertyServiceClientMockDeleteSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockDeleteSubscriptionParams contains parameters of the PropertyServiceClient.DeleteSubscription
type PropertyServiceClientMockDeleteSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.DeleteSubscriptionRequest]
}

// PropertyServiceClientMockDeleteSubscriptionParamPtrs contains pointers to parameters of the PropertyServiceClient.DeleteSubscription
type PropertyServiceClientMockDeleteSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.DeleteSubscriptionRequest]
}

// PropertyServiceClientMockDeleteSubscriptionResults contains results of the PropertyServiceClient.DeleteSubscription
type PropertyServiceClientMockDeleteSubscriptionResults struct {
	pp2 *connect.Response[v1.DeleteSubscriptionResponse]
	err error
}

// PropertyServiceClientMockDeleteSubscriptionOrigins contains origins of expectations of the PropertyServiceClient.DeleteSubscription
type PropertyServiceClientMockDeleteSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Optional() *mPropertyServiceClientMockDeleteSubscription {
	mmDeleteSubscription.optional = true
	return mmDeleteSubscription
}

// Expect sets up expected params for PropertyServiceClient.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) *mPropertyServiceClientMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceClientMockDeleteSubscriptionExpectation{}
	}

	if mmDeleteSubscription.defaultExpectation.paramPtrs != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by ExpectParams functions")
	}

	mmDeleteSubscription.defaultExpectation.params = &PropertyServiceClientMockDeleteSubscriptionParams{ctx, pp1}
	mmDeleteSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSubscription.expectations {
		if minimock.Equal(e.params, mmDeleteSubscription.defaultExpectation.params) {
			mmDeleteSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscription.defaultExpectation.params)
		}
	}

	return mmDeleteSubscription
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceClientMockDeleteSubscriptionExpectation{}
	}

	if mmDeleteSubscription.defaultExpectation.params != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Expect")
	}

	if mmDeleteSubscription.defaultExpectation.paramPtrs == nil {
		mmDeleteSubscription.defaultExpectation.paramPtrs = &PropertyServiceClientMockDeleteSubscriptionParamPtrs{}
	}
	mmDeleteSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.DeleteSubscriptionRequest]) *mPropertyServiceClientMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceClientMockDeleteSubscriptionExpectation{}
	}

	if mmDeleteSubscription.defaultExpectation.params != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Expect")
	}

	if mmDeleteSubscription.defaultExpectation.paramPtrs == nil {
		mmDeleteSubscription.defaultExpectation.paramPtrs = &PropertyServiceClientMockDeleteSubscriptionParamPtrs{}
	}
	mmDeleteSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmDeleteSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmDeleteSubscription
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest])) *mPropertyServiceClientMockDeleteSubscription {
	if mmDeleteSubscription.mock.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.DeleteSubscription")
	}

	mmDeleteSubscription.mock.inspectFuncDeleteSubscription = f

	return mmDeleteSubscription
}

// Return sets up results that will be returned by PropertyServiceClient.DeleteSubscription
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Return(pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error) *PropertyServiceClientMock {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &PropertyServiceClientMockDeleteSubscriptionExpectation{mock: mmDeleteSubscription.mock}
	}
	mmDeleteSubscription.defaultExpectation.results = &PropertyServiceClientMockDeleteSubscriptionResults{pp2, err}
	mmDeleteSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSubscription.mock
}

// Set uses given function f to mock the PropertyServiceClient.DeleteSubscription method
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) (pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error)) *PropertyServiceClientMock {
	if mmDeleteSubscription.defaultExpectation != nil {
		mmDeleteSubscription.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.DeleteSubscription method")
	}

	if len(mmDeleteSubscription.expectations) > 0 {
		mmDeleteSubscription.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.DeleteSubscription method")
	}

	mmDeleteSubscription.mock.funcDeleteSubscription = f
	mmDeleteSubscription.mock.funcDeleteSubscriptionOrigin = minimock.CallerInfo(1)
	return mmDeleteSubscription.mock
}

// When sets expectation for the PropertyServiceClient.DeleteSubscription which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) When(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) *PropertyServiceClientMockDeleteSubscriptionExpectation {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("PropertyServiceClientMock.DeleteSubscription mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockDeleteSubscriptionExpectation{
		mock:               mmDeleteSubscription.mock,
		params:             &PropertyServiceClientMockDeleteSubscriptionParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockDeleteSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSubscription.expectations = append(mmDeleteSubscription.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.DeleteSubscription return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockDeleteSubscriptionExpectation) Then(pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockDeleteSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.DeleteSubscription should be invoked
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Times(n uint64) *mPropertyServiceClientMockDeleteSubscription {
	if n == 0 {
		mmDeleteSubscription.mock.t.Fatalf("Times of PropertyServiceClientMock.DeleteSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSubscription.expectedInvocations, n)
	mmDeleteSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSubscription
}

func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) invocationsDone() bool {
	if len(mmDeleteSubscription.expectations) == 0 && mmDeleteSubscription.defaultExpectation == nil && mmDeleteSubscription.mock.funcDeleteSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSubscription.mock.afterDeleteSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSubscription implements mm_propertyv1connect.PropertyServiceClient
func (mmDeleteSubscription *PropertyServiceClientMock) DeleteSubscription(ctx context.Context, pp1 *connect.Request[v1.DeleteSubscriptionRequest]) (pp2 *connect.Response[v1.DeleteSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter, 1)

	mmDeleteSubscription.t.Helper()

	if mmDeleteSubscription.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.inspectFuncDeleteSubscription(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockDeleteSubscriptionParams{ctx, pp1}

	// Record call args
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Lock()
	mmDeleteSubscription.DeleteSubscriptionMock.callArgs = append(mmDeleteSubscription.DeleteSubscriptionMock.callArgs, &mm_params)
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Unlock()

	for _, e := range mmDeleteSubscription.DeleteSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockDeleteSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSubscription.t.Errorf("PropertyServiceClientMock.DeleteSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmDeleteSubscription.t.Errorf("PropertyServiceClientMock.DeleteSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscription.t.Errorf("PropertyServiceClientMock.DeleteSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscription.t.Fatal("No results are set for the PropertyServiceClientMock.DeleteSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDeleteSubscription.funcDeleteSubscription != nil {
		return mmDeleteSubscription.funcDeleteSubscription(ctx, pp1)
	}
	mmDeleteSubscription.t.Fatalf("Unexpected call to PropertyServiceClientMock.DeleteSubscription. %v %v", ctx, pp1)
	return
}

// DeleteSubscriptionAfterCounter returns a count of finished PropertyServiceClientMock.DeleteSubscription invocations
func (mmDeleteSubscription *PropertyServiceClientMock) DeleteSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter)
}

// DeleteSubscriptionBeforeCounter returns a count of PropertyServiceClientMock.DeleteSubscription invocations
func (mmDeleteSubscription *PropertyServiceClientMock) DeleteSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.DeleteSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscription *mPropertyServiceClientMockDeleteSubscription) Calls() []*PropertyServiceClientMockDeleteSubscriptionParams {
	mmDeleteSubscription.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockDeleteSubscriptionParams, len(mmDeleteSubscription.callArgs))
	copy(argCopy, mmDeleteSubscription.callArgs)

	mmDeleteSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriptionDone returns true if the count of the DeleteSubscription invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockDeleteSubscriptionDone() bool {
	if m.DeleteSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSubscriptionMock.invocationsDone()
}

// MinimockDeleteSubscriptionInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockDeleteSubscriptionInspect() {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSubscriptionCounter := mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && afterDeleteSubscriptionCounter < 1 {
		if m.DeleteSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteSubscription at\n%s", m.DeleteSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteSubscription at\n%s with params: %#v", m.DeleteSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && afterDeleteSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.DeleteSubscription at\n%s", m.funcDeleteSubscriptionOrigin)
	}

	if !m.DeleteSubscriptionMock.invocationsDone() && afterDeleteSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.DeleteSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSubscriptionMock.expectedInvocations), m.DeleteSubscriptionMock.expectedInvocationsOrigin, afterDeleteSubscriptionCounter)
	}
}

type mPropertyServiceClientMockHistoryOfProperty struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockHistoryOfPropertyExpectation
	expectations       []*PropertyServiceClientMockHistoryOfPropertyExpectation

	callArgs []*PropertyServiceClientMockHistoryOfPropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockHistoryOfPropertyExpectation specifies expectation struct of the PropertyServiceClient.HistoryOfProperty
type PropertyServiceClientMockHistoryOfPropertyExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockHistoryOfPropertyParams
	paramPtrs          *PropertyServiceClientMockHistoryOfPropertyParamPtrs
	expectationOrigins PropertyServiceClientMockHistoryOfPropertyExpectationOrigins
	results            *PropertyServiceClientMockHistoryOfPropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockHistoryOfPropertyParams contains parameters of the PropertyServiceClient.HistoryOfProperty
type PropertyServiceClientMockHistoryOfPropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.HistoryOfPropertyRequest]
}

// PropertyServiceClientMockHistoryOfPropertyParamPtrs contains pointers to parameters of the PropertyServiceClient.HistoryOfProperty
type PropertyServiceClientMockHistoryOfPropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.HistoryOfPropertyRequest]
}

// PropertyServiceClientMockHistoryOfPropertyResults contains results of the PropertyServiceClient.HistoryOfProperty
type PropertyServiceClientMockHistoryOfPropertyResults struct {
	pp2 *connect.ServerStreamForClient[v1.HistoryOfPropertyResponse]
	err error
}

// PropertyServiceClientMockHistoryOfPropertyOrigins contains origins of expectations of the PropertyServiceClient.HistoryOfProperty
type PropertyServiceClientMockHistoryOfPropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Optional() *mPropertyServiceClientMockHistoryOfProperty {
	mmHistoryOfProperty.optional = true
	return mmHistoryOfProperty
}

// Expect sets up expected params for PropertyServiceClient.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest]) *mPropertyServiceClientMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceClientMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by ExpectParams functions")
	}

	mmHistoryOfProperty.defaultExpectation.params = &PropertyServiceClientMockHistoryOfPropertyParams{ctx, pp1}
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistoryOfProperty.expectations {
		if minimock.Equal(e.params, mmHistoryOfProperty.defaultExpectation.params) {
			mmHistoryOfProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistoryOfProperty.defaultExpectation.params)
		}
	}

	return mmHistoryOfProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceClientMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.params != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Expect")
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs == nil {
		mmHistoryOfProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockHistoryOfPropertyParamPtrs{}
	}
	mmHistoryOfProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmHistoryOfProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) ExpectPp1Param2(pp1 *connect.Request[v1.HistoryOfPropertyRequest]) *mPropertyServiceClientMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceClientMockHistoryOfPropertyExpectation{}
	}

	if mmHistoryOfProperty.defaultExpectation.params != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Expect")
	}

	if mmHistoryOfProperty.defaultExpectation.paramPtrs == nil {
		mmHistoryOfProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockHistoryOfPropertyParamPtrs{}
	}
	mmHistoryOfProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmHistoryOfProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmHistoryOfProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest])) *mPropertyServiceClientMockHistoryOfProperty {
	if mmHistoryOfProperty.mock.inspectFuncHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.HistoryOfProperty")
	}

	mmHistoryOfProperty.mock.inspectFuncHistoryOfProperty = f

	return mmHistoryOfProperty
}

// Return sets up results that will be returned by PropertyServiceClient.HistoryOfProperty
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Return(pp2 *connect.ServerStreamForClient[v1.HistoryOfPropertyResponse], err error) *PropertyServiceClientMock {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Set")
	}

	if mmHistoryOfProperty.defaultExpectation == nil {
		mmHistoryOfProperty.defaultExpectation = &PropertyServiceClientMockHistoryOfPropertyExpectation{mock: mmHistoryOfProperty.mock}
	}
	mmHistoryOfProperty.defaultExpectation.results = &PropertyServiceClientMockHistoryOfPropertyResults{pp2, err}
	mmHistoryOfProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistoryOfProperty.mock
}

// Set uses given function f to mock the PropertyServiceClient.HistoryOfProperty method
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest]) (pp2 *connect.ServerStreamForClient[v1.HistoryOfPropertyResponse], err error)) *PropertyServiceClientMock {
	if mmHistoryOfProperty.defaultExpectation != nil {
		mmHistoryOfProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.HistoryOfProperty method")
	}

	if len(mmHistoryOfProperty.expectations) > 0 {
		mmHistoryOfProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.HistoryOfProperty method")
	}

	mmHistoryOfProperty.mock.funcHistoryOfProperty = f
	mmHistoryOfProperty.mock.funcHistoryOfPropertyOrigin = minimock.CallerInfo(1)
	return mmHistoryOfProperty.mock
}

// When sets expectation for the PropertyServiceClient.HistoryOfProperty which will trigger the result defined by the following
// Then helper
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) When(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest]) *PropertyServiceClientMockHistoryOfPropertyExpectation {
	if mmHistoryOfProperty.mock.funcHistoryOfProperty != nil {
		mmHistoryOfProperty.mock.t.Fatalf("PropertyServiceClientMock.HistoryOfProperty mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockHistoryOfPropertyExpectation{
		mock:               mmHistoryOfProperty.mock,
		params:             &PropertyServiceClientMockHistoryOfPropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockHistoryOfPropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistoryOfProperty.expectations = append(mmHistoryOfProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.HistoryOfProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockHistoryOfPropertyExpectation) Then(pp2 *connect.ServerStreamForClient[v1.HistoryOfPropertyResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockHistoryOfPropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.HistoryOfProperty should be invoked
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Times(n uint64) *mPropertyServiceClientMockHistoryOfProperty {
	if n == 0 {
		mmHistoryOfProperty.mock.t.Fatalf("Times of PropertyServiceClientMock.HistoryOfProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistoryOfProperty.expectedInvocations, n)
	mmHistoryOfProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistoryOfProperty
}

func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) invocationsDone() bool {
	if len(mmHistoryOfProperty.expectations) == 0 && mmHistoryOfProperty.defaultExpectation == nil && mmHistoryOfProperty.mock.funcHistoryOfProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistoryOfProperty.mock.afterHistoryOfPropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistoryOfProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HistoryOfProperty implements mm_propertyv1connect.PropertyServiceClient
func (mmHistoryOfProperty *PropertyServiceClientMock) HistoryOfProperty(ctx context.Context, pp1 *connect.Request[v1.HistoryOfPropertyRequest]) (pp2 *connect.ServerStreamForClient[v1.HistoryOfPropertyResponse], err error) {
	mm_atomic.AddUint64(&mmHistoryOfProperty.beforeHistoryOfPropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmHistoryOfProperty.afterHistoryOfPropertyCounter, 1)

	mmHistoryOfProperty.t.Helper()

	if mmHistoryOfProperty.inspectFuncHistoryOfProperty != nil {
		mmHistoryOfProperty.inspectFuncHistoryOfProperty(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockHistoryOfPropertyParams{ctx, pp1}

	// Record call args
	mmHistoryOfProperty.HistoryOfPropertyMock.mutex.Lock()
	mmHistoryOfProperty.HistoryOfPropertyMock.callArgs = append(mmHistoryOfProperty.HistoryOfPropertyMock.callArgs, &mm_params)
	mmHistoryOfProperty.HistoryOfPropertyMock.mutex.Unlock()

	for _, e := range mmHistoryOfProperty.HistoryOfPropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.params
		mm_want_ptrs := mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockHistoryOfPropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHistoryOfProperty.t.Errorf("PropertyServiceClientMock.HistoryOfProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmHistoryOfProperty.t.Errorf("PropertyServiceClientMock.HistoryOfProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistoryOfProperty.t.Errorf("PropertyServiceClientMock.HistoryOfProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistoryOfProperty.HistoryOfPropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmHistoryOfProperty.t.Fatal("No results are set for the PropertyServiceClientMock.HistoryOfProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmHistoryOfProperty.funcHistoryOfProperty != nil {
		return mmHistoryOfProperty.funcHistoryOfProperty(ctx, pp1)
	}
	mmHistoryOfProperty.t.Fatalf("Unexpected call to PropertyServiceClientMock.HistoryOfProperty. %v %v", ctx, pp1)
	return
}

// HistoryOfPropertyAfterCounter returns a count of finished PropertyServiceClientMock.HistoryOfProperty invocations
func (mmHistoryOfProperty *PropertyServiceClientMock) HistoryOfPropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistoryOfProperty.afterHistoryOfPropertyCounter)
}

// HistoryOfPropertyBeforeCounter returns a count of PropertyServiceClientMock.HistoryOfProperty invocations
func (mmHistoryOfProperty *PropertyServiceClientMock) HistoryOfPropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistoryOfProperty.beforeHistoryOfPropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.HistoryOfProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistoryOfProperty *mPropertyServiceClientMockHistoryOfProperty) Calls() []*PropertyServiceClientMockHistoryOfPropertyParams {
	mmHistoryOfProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockHistoryOfPropertyParams, len(mmHistoryOfProperty.callArgs))
	copy(argCopy, mmHistoryOfProperty.callArgs)

	mmHistoryOfProperty.mutex.RUnlock()

	return argCopy
}

// MinimockHistoryOfPropertyDone returns true if the count of the HistoryOfProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockHistoryOfPropertyDone() bool {
	if m.HistoryOfPropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistoryOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistoryOfPropertyMock.invocationsDone()
}

// MinimockHistoryOfPropertyInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockHistoryOfPropertyInspect() {
	for _, e := range m.HistoryOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.HistoryOfProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistoryOfPropertyCounter := mm_atomic.LoadUint64(&m.afterHistoryOfPropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistoryOfPropertyMock.defaultExpectation != nil && afterHistoryOfPropertyCounter < 1 {
		if m.HistoryOfPropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.HistoryOfProperty at\n%s", m.HistoryOfPropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.HistoryOfProperty at\n%s with params: %#v", m.HistoryOfPropertyMock.defaultExpectation.expectationOrigins.origin, *m.HistoryOfPropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistoryOfProperty != nil && afterHistoryOfPropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.HistoryOfProperty at\n%s", m.funcHistoryOfPropertyOrigin)
	}

	if !m.HistoryOfPropertyMock.invocationsDone() && afterHistoryOfPropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.HistoryOfProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistoryOfPropertyMock.expectedInvocations), m.HistoryOfPropertyMock.expectedInvocationsOrigin, afterHistoryOfPropertyCounter)
	}
}

type mPropertyServiceClientMockListPropertyType struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockListPropertyTypeExpectation
	expectations       []*PropertyServiceClientMockListPropertyTypeExpectation

	callArgs []*PropertyServiceClientMockListPropertyTypeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockListPropertyTypeExpectation specifies expectation struct of the PropertyServiceClient.ListPropertyType
type PropertyServiceClientMockListPropertyTypeExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockListPropertyTypeParams
	paramPtrs          *PropertyServiceClientMockListPropertyTypeParamPtrs
	expectationOrigins PropertyServiceClientMockListPropertyTypeExpectationOrigins
	results            *PropertyServiceClientMockListPropertyTypeResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockListPropertyTypeParams contains parameters of the PropertyServiceClient.ListPropertyType
type PropertyServiceClientMockListPropertyTypeParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListPropertyTypeRequest]
}

// PropertyServiceClientMockListPropertyTypeParamPtrs contains pointers to parameters of the PropertyServiceClient.ListPropertyType
type PropertyServiceClientMockListPropertyTypeParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListPropertyTypeRequest]
}

// PropertyServiceClientMockListPropertyTypeResults contains results of the PropertyServiceClient.ListPropertyType
type PropertyServiceClientMockListPropertyTypeResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListPropertyTypeResponse]
	err error
}

// PropertyServiceClientMockListPropertyTypeOrigins contains origins of expectations of the PropertyServiceClient.ListPropertyType
type PropertyServiceClientMockListPropertyTypeExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Optional() *mPropertyServiceClientMockListPropertyType {
	mmListPropertyType.optional = true
	return mmListPropertyType
}

// Expect sets up expected params for PropertyServiceClient.ListPropertyType
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Expect(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest]) *mPropertyServiceClientMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceClientMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.paramPtrs != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by ExpectParams functions")
	}

	mmListPropertyType.defaultExpectation.params = &PropertyServiceClientMockListPropertyTypeParams{ctx, pp1}
	mmListPropertyType.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPropertyType.expectations {
		if minimock.Equal(e.params, mmListPropertyType.defaultExpectation.params) {
			mmListPropertyType.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPropertyType.defaultExpectation.params)
		}
	}

	return mmListPropertyType
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.ListPropertyType
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceClientMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.params != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Expect")
	}

	if mmListPropertyType.defaultExpectation.paramPtrs == nil {
		mmListPropertyType.defaultExpectation.paramPtrs = &PropertyServiceClientMockListPropertyTypeParamPtrs{}
	}
	mmListPropertyType.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPropertyType.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPropertyType
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.ListPropertyType
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) ExpectPp1Param2(pp1 *connect.Request[v1.ListPropertyTypeRequest]) *mPropertyServiceClientMockListPropertyType {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceClientMockListPropertyTypeExpectation{}
	}

	if mmListPropertyType.defaultExpectation.params != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Expect")
	}

	if mmListPropertyType.defaultExpectation.paramPtrs == nil {
		mmListPropertyType.defaultExpectation.paramPtrs = &PropertyServiceClientMockListPropertyTypeParamPtrs{}
	}
	mmListPropertyType.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListPropertyType.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListPropertyType
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.ListPropertyType
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest])) *mPropertyServiceClientMockListPropertyType {
	if mmListPropertyType.mock.inspectFuncListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.ListPropertyType")
	}

	mmListPropertyType.mock.inspectFuncListPropertyType = f

	return mmListPropertyType
}

// Return sets up results that will be returned by PropertyServiceClient.ListPropertyType
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Return(pp2 *connect.ServerStreamForClient[v1.ListPropertyTypeResponse], err error) *PropertyServiceClientMock {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Set")
	}

	if mmListPropertyType.defaultExpectation == nil {
		mmListPropertyType.defaultExpectation = &PropertyServiceClientMockListPropertyTypeExpectation{mock: mmListPropertyType.mock}
	}
	mmListPropertyType.defaultExpectation.results = &PropertyServiceClientMockListPropertyTypeResults{pp2, err}
	mmListPropertyType.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPropertyType.mock
}

// Set uses given function f to mock the PropertyServiceClient.ListPropertyType method
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPropertyTypeResponse], err error)) *PropertyServiceClientMock {
	if mmListPropertyType.defaultExpectation != nil {
		mmListPropertyType.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.ListPropertyType method")
	}

	if len(mmListPropertyType.expectations) > 0 {
		mmListPropertyType.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.ListPropertyType method")
	}

	mmListPropertyType.mock.funcListPropertyType = f
	mmListPropertyType.mock.funcListPropertyTypeOrigin = minimock.CallerInfo(1)
	return mmListPropertyType.mock
}

// When sets expectation for the PropertyServiceClient.ListPropertyType which will trigger the result defined by the following
// Then helper
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) When(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest]) *PropertyServiceClientMockListPropertyTypeExpectation {
	if mmListPropertyType.mock.funcListPropertyType != nil {
		mmListPropertyType.mock.t.Fatalf("PropertyServiceClientMock.ListPropertyType mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockListPropertyTypeExpectation{
		mock:               mmListPropertyType.mock,
		params:             &PropertyServiceClientMockListPropertyTypeParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockListPropertyTypeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPropertyType.expectations = append(mmListPropertyType.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.ListPropertyType return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockListPropertyTypeExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListPropertyTypeResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockListPropertyTypeResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.ListPropertyType should be invoked
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Times(n uint64) *mPropertyServiceClientMockListPropertyType {
	if n == 0 {
		mmListPropertyType.mock.t.Fatalf("Times of PropertyServiceClientMock.ListPropertyType mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPropertyType.expectedInvocations, n)
	mmListPropertyType.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPropertyType
}

func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) invocationsDone() bool {
	if len(mmListPropertyType.expectations) == 0 && mmListPropertyType.defaultExpectation == nil && mmListPropertyType.mock.funcListPropertyType == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPropertyType.mock.afterListPropertyTypeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPropertyType.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPropertyType implements mm_propertyv1connect.PropertyServiceClient
func (mmListPropertyType *PropertyServiceClientMock) ListPropertyType(ctx context.Context, pp1 *connect.Request[v1.ListPropertyTypeRequest]) (pp2 *connect.ServerStreamForClient[v1.ListPropertyTypeResponse], err error) {
	mm_atomic.AddUint64(&mmListPropertyType.beforeListPropertyTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmListPropertyType.afterListPropertyTypeCounter, 1)

	mmListPropertyType.t.Helper()

	if mmListPropertyType.inspectFuncListPropertyType != nil {
		mmListPropertyType.inspectFuncListPropertyType(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockListPropertyTypeParams{ctx, pp1}

	// Record call args
	mmListPropertyType.ListPropertyTypeMock.mutex.Lock()
	mmListPropertyType.ListPropertyTypeMock.callArgs = append(mmListPropertyType.ListPropertyTypeMock.callArgs, &mm_params)
	mmListPropertyType.ListPropertyTypeMock.mutex.Unlock()

	for _, e := range mmListPropertyType.ListPropertyTypeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListPropertyType.ListPropertyTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPropertyType.ListPropertyTypeMock.defaultExpectation.Counter, 1)
		mm_want := mmListPropertyType.ListPropertyTypeMock.defaultExpectation.params
		mm_want_ptrs := mmListPropertyType.ListPropertyTypeMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockListPropertyTypeParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPropertyType.t.Errorf("PropertyServiceClientMock.ListPropertyType got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListPropertyType.t.Errorf("PropertyServiceClientMock.ListPropertyType got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPropertyType.t.Errorf("PropertyServiceClientMock.ListPropertyType got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPropertyType.ListPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPropertyType.ListPropertyTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmListPropertyType.t.Fatal("No results are set for the PropertyServiceClientMock.ListPropertyType")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListPropertyType.funcListPropertyType != nil {
		return mmListPropertyType.funcListPropertyType(ctx, pp1)
	}
	mmListPropertyType.t.Fatalf("Unexpected call to PropertyServiceClientMock.ListPropertyType. %v %v", ctx, pp1)
	return
}

// ListPropertyTypeAfterCounter returns a count of finished PropertyServiceClientMock.ListPropertyType invocations
func (mmListPropertyType *PropertyServiceClientMock) ListPropertyTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPropertyType.afterListPropertyTypeCounter)
}

// ListPropertyTypeBeforeCounter returns a count of PropertyServiceClientMock.ListPropertyType invocations
func (mmListPropertyType *PropertyServiceClientMock) ListPropertyTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPropertyType.beforeListPropertyTypeCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.ListPropertyType.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPropertyType *mPropertyServiceClientMockListPropertyType) Calls() []*PropertyServiceClientMockListPropertyTypeParams {
	mmListPropertyType.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockListPropertyTypeParams, len(mmListPropertyType.callArgs))
	copy(argCopy, mmListPropertyType.callArgs)

	mmListPropertyType.mutex.RUnlock()

	return argCopy
}

// MinimockListPropertyTypeDone returns true if the count of the ListPropertyType invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockListPropertyTypeDone() bool {
	if m.ListPropertyTypeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPropertyTypeMock.invocationsDone()
}

// MinimockListPropertyTypeInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockListPropertyTypeInspect() {
	for _, e := range m.ListPropertyTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.ListPropertyType at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPropertyTypeCounter := mm_atomic.LoadUint64(&m.afterListPropertyTypeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPropertyTypeMock.defaultExpectation != nil && afterListPropertyTypeCounter < 1 {
		if m.ListPropertyTypeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.ListPropertyType at\n%s", m.ListPropertyTypeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.ListPropertyType at\n%s with params: %#v", m.ListPropertyTypeMock.defaultExpectation.expectationOrigins.origin, *m.ListPropertyTypeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPropertyType != nil && afterListPropertyTypeCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.ListPropertyType at\n%s", m.funcListPropertyTypeOrigin)
	}

	if !m.ListPropertyTypeMock.invocationsDone() && afterListPropertyTypeCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.ListPropertyType at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPropertyTypeMock.expectedInvocations), m.ListPropertyTypeMock.expectedInvocationsOrigin, afterListPropertyTypeCounter)
	}
}

type mPropertyServiceClientMockListSubscription struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockListSubscriptionExpectation
	expectations       []*PropertyServiceClientMockListSubscriptionExpectation

	callArgs []*PropertyServiceClientMockListSubscriptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockListSubscriptionExpectation specifies expectation struct of the PropertyServiceClient.ListSubscription
type PropertyServiceClientMockListSubscriptionExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockListSubscriptionParams
	paramPtrs          *PropertyServiceClientMockListSubscriptionParamPtrs
	expectationOrigins PropertyServiceClientMockListSubscriptionExpectationOrigins
	results            *PropertyServiceClientMockListSubscriptionResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockListSubscriptionParams contains parameters of the PropertyServiceClient.ListSubscription
type PropertyServiceClientMockListSubscriptionParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.ListSubscriptionRequest]
}

// PropertyServiceClientMockListSubscriptionParamPtrs contains pointers to parameters of the PropertyServiceClient.ListSubscription
type PropertyServiceClientMockListSubscriptionParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.ListSubscriptionRequest]
}

// PropertyServiceClientMockListSubscriptionResults contains results of the PropertyServiceClient.ListSubscription
type PropertyServiceClientMockListSubscriptionResults struct {
	pp2 *connect.ServerStreamForClient[v1.ListSubscriptionResponse]
	err error
}

// PropertyServiceClientMockListSubscriptionOrigins contains origins of expectations of the PropertyServiceClient.ListSubscription
type PropertyServiceClientMockListSubscriptionExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Optional() *mPropertyServiceClientMockListSubscription {
	mmListSubscription.optional = true
	return mmListSubscription
}

// Expect sets up expected params for PropertyServiceClient.ListSubscription
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Expect(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest]) *mPropertyServiceClientMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceClientMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.paramPtrs != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by ExpectParams functions")
	}

	mmListSubscription.defaultExpectation.params = &PropertyServiceClientMockListSubscriptionParams{ctx, pp1}
	mmListSubscription.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListSubscription.expectations {
		if minimock.Equal(e.params, mmListSubscription.defaultExpectation.params) {
			mmListSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSubscription.defaultExpectation.params)
		}
	}

	return mmListSubscription
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.ListSubscription
func (mmListSubscription *mPropertyServiceClientMockListSubscription) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceClientMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.params != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Expect")
	}

	if mmListSubscription.defaultExpectation.paramPtrs == nil {
		mmListSubscription.defaultExpectation.paramPtrs = &PropertyServiceClientMockListSubscriptionParamPtrs{}
	}
	mmListSubscription.defaultExpectation.paramPtrs.ctx = &ctx
	mmListSubscription.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListSubscription
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.ListSubscription
func (mmListSubscription *mPropertyServiceClientMockListSubscription) ExpectPp1Param2(pp1 *connect.Request[v1.ListSubscriptionRequest]) *mPropertyServiceClientMockListSubscription {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceClientMockListSubscriptionExpectation{}
	}

	if mmListSubscription.defaultExpectation.params != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Expect")
	}

	if mmListSubscription.defaultExpectation.paramPtrs == nil {
		mmListSubscription.defaultExpectation.paramPtrs = &PropertyServiceClientMockListSubscriptionParamPtrs{}
	}
	mmListSubscription.defaultExpectation.paramPtrs.pp1 = &pp1
	mmListSubscription.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmListSubscription
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.ListSubscription
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest])) *mPropertyServiceClientMockListSubscription {
	if mmListSubscription.mock.inspectFuncListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.ListSubscription")
	}

	mmListSubscription.mock.inspectFuncListSubscription = f

	return mmListSubscription
}

// Return sets up results that will be returned by PropertyServiceClient.ListSubscription
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Return(pp2 *connect.ServerStreamForClient[v1.ListSubscriptionResponse], err error) *PropertyServiceClientMock {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Set")
	}

	if mmListSubscription.defaultExpectation == nil {
		mmListSubscription.defaultExpectation = &PropertyServiceClientMockListSubscriptionExpectation{mock: mmListSubscription.mock}
	}
	mmListSubscription.defaultExpectation.results = &PropertyServiceClientMockListSubscriptionResults{pp2, err}
	mmListSubscription.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListSubscription.mock
}

// Set uses given function f to mock the PropertyServiceClient.ListSubscription method
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Set(f func(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListSubscriptionResponse], err error)) *PropertyServiceClientMock {
	if mmListSubscription.defaultExpectation != nil {
		mmListSubscription.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.ListSubscription method")
	}

	if len(mmListSubscription.expectations) > 0 {
		mmListSubscription.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.ListSubscription method")
	}

	mmListSubscription.mock.funcListSubscription = f
	mmListSubscription.mock.funcListSubscriptionOrigin = minimock.CallerInfo(1)
	return mmListSubscription.mock
}

// When sets expectation for the PropertyServiceClient.ListSubscription which will trigger the result defined by the following
// Then helper
func (mmListSubscription *mPropertyServiceClientMockListSubscription) When(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest]) *PropertyServiceClientMockListSubscriptionExpectation {
	if mmListSubscription.mock.funcListSubscription != nil {
		mmListSubscription.mock.t.Fatalf("PropertyServiceClientMock.ListSubscription mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockListSubscriptionExpectation{
		mock:               mmListSubscription.mock,
		params:             &PropertyServiceClientMockListSubscriptionParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockListSubscriptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListSubscription.expectations = append(mmListSubscription.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.ListSubscription return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockListSubscriptionExpectation) Then(pp2 *connect.ServerStreamForClient[v1.ListSubscriptionResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockListSubscriptionResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.ListSubscription should be invoked
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Times(n uint64) *mPropertyServiceClientMockListSubscription {
	if n == 0 {
		mmListSubscription.mock.t.Fatalf("Times of PropertyServiceClientMock.ListSubscription mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListSubscription.expectedInvocations, n)
	mmListSubscription.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListSubscription
}

func (mmListSubscription *mPropertyServiceClientMockListSubscription) invocationsDone() bool {
	if len(mmListSubscription.expectations) == 0 && mmListSubscription.defaultExpectation == nil && mmListSubscription.mock.funcListSubscription == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListSubscription.mock.afterListSubscriptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListSubscription.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListSubscription implements mm_propertyv1connect.PropertyServiceClient
func (mmListSubscription *PropertyServiceClientMock) ListSubscription(ctx context.Context, pp1 *connect.Request[v1.ListSubscriptionRequest]) (pp2 *connect.ServerStreamForClient[v1.ListSubscriptionResponse], err error) {
	mm_atomic.AddUint64(&mmListSubscription.beforeListSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmListSubscription.afterListSubscriptionCounter, 1)

	mmListSubscription.t.Helper()

	if mmListSubscription.inspectFuncListSubscription != nil {
		mmListSubscription.inspectFuncListSubscription(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockListSubscriptionParams{ctx, pp1}

	// Record call args
	mmListSubscription.ListSubscriptionMock.mutex.Lock()
	mmListSubscription.ListSubscriptionMock.callArgs = append(mmListSubscription.ListSubscriptionMock.callArgs, &mm_params)
	mmListSubscription.ListSubscriptionMock.mutex.Unlock()

	for _, e := range mmListSubscription.ListSubscriptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListSubscription.ListSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSubscription.ListSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmListSubscription.ListSubscriptionMock.defaultExpectation.params
		mm_want_ptrs := mmListSubscription.ListSubscriptionMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockListSubscriptionParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListSubscription.t.Errorf("PropertyServiceClientMock.ListSubscription got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmListSubscription.t.Errorf("PropertyServiceClientMock.ListSubscription got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSubscription.t.Errorf("PropertyServiceClientMock.ListSubscription got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListSubscription.ListSubscriptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSubscription.ListSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmListSubscription.t.Fatal("No results are set for the PropertyServiceClientMock.ListSubscription")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListSubscription.funcListSubscription != nil {
		return mmListSubscription.funcListSubscription(ctx, pp1)
	}
	mmListSubscription.t.Fatalf("Unexpected call to PropertyServiceClientMock.ListSubscription. %v %v", ctx, pp1)
	return
}

// ListSubscriptionAfterCounter returns a count of finished PropertyServiceClientMock.ListSubscription invocations
func (mmListSubscription *PropertyServiceClientMock) ListSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubscription.afterListSubscriptionCounter)
}

// ListSubscriptionBeforeCounter returns a count of PropertyServiceClientMock.ListSubscription invocations
func (mmListSubscription *PropertyServiceClientMock) ListSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSubscription.beforeListSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.ListSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSubscription *mPropertyServiceClientMockListSubscription) Calls() []*PropertyServiceClientMockListSubscriptionParams {
	mmListSubscription.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockListSubscriptionParams, len(mmListSubscription.callArgs))
	copy(argCopy, mmListSubscription.callArgs)

	mmListSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockListSubscriptionDone returns true if the count of the ListSubscription invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockListSubscriptionDone() bool {
	if m.ListSubscriptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListSubscriptionMock.invocationsDone()
}

// MinimockListSubscriptionInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockListSubscriptionInspect() {
	for _, e := range m.ListSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.ListSubscription at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListSubscriptionCounter := mm_atomic.LoadUint64(&m.afterListSubscriptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListSubscriptionMock.defaultExpectation != nil && afterListSubscriptionCounter < 1 {
		if m.ListSubscriptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.ListSubscription at\n%s", m.ListSubscriptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.ListSubscription at\n%s with params: %#v", m.ListSubscriptionMock.defaultExpectation.expectationOrigins.origin, *m.ListSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSubscription != nil && afterListSubscriptionCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.ListSubscription at\n%s", m.funcListSubscriptionOrigin)
	}

	if !m.ListSubscriptionMock.invocationsDone() && afterListSubscriptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.ListSubscription at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListSubscriptionMock.expectedInvocations), m.ListSubscriptionMock.expectedInvocationsOrigin, afterListSubscriptionCounter)
	}
}

type mPropertyServiceClientMockSearchProperty struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockSearchPropertyExpectation
	expectations       []*PropertyServiceClientMockSearchPropertyExpectation

	callArgs []*PropertyServiceClientMockSearchPropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockSearchPropertyExpectation specifies expectation struct of the PropertyServiceClient.SearchProperty
type PropertyServiceClientMockSearchPropertyExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockSearchPropertyParams
	paramPtrs          *PropertyServiceClientMockSearchPropertyParamPtrs
	expectationOrigins PropertyServiceClientMockSearchPropertyExpectationOrigins
	results            *PropertyServiceClientMockSearchPropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockSearchPropertyParams contains parameters of the PropertyServiceClient.SearchProperty
type PropertyServiceClientMockSearchPropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.SearchPropertyRequest]
}

// PropertyServiceClientMockSearchPropertyParamPtrs contains pointers to parameters of the PropertyServiceClient.SearchProperty
type PropertyServiceClientMockSearchPropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.SearchPropertyRequest]
}

// PropertyServiceClientMockSearchPropertyResults contains results of the PropertyServiceClient.SearchProperty
type PropertyServiceClientMockSearchPropertyResults struct {
	pp2 *connect.ServerStreamForClient[v1.SearchPropertyResponse]
	err error
}

// PropertyServiceClientMockSearchPropertyOrigins contains origins of expectations of the PropertyServiceClient.SearchProperty
type PropertyServiceClientMockSearchPropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Optional() *mPropertyServiceClientMockSearchProperty {
	mmSearchProperty.optional = true
	return mmSearchProperty
}

// Expect sets up expected params for PropertyServiceClient.SearchProperty
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest]) *mPropertyServiceClientMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceClientMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.paramPtrs != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by ExpectParams functions")
	}

	mmSearchProperty.defaultExpectation.params = &PropertyServiceClientMockSearchPropertyParams{ctx, pp1}
	mmSearchProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSearchProperty.expectations {
		if minimock.Equal(e.params, mmSearchProperty.defaultExpectation.params) {
			mmSearchProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSearchProperty.defaultExpectation.params)
		}
	}

	return mmSearchProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.SearchProperty
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceClientMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.params != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Expect")
	}

	if mmSearchProperty.defaultExpectation.paramPtrs == nil {
		mmSearchProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockSearchPropertyParamPtrs{}
	}
	mmSearchProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmSearchProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSearchProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.SearchProperty
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) ExpectPp1Param2(pp1 *connect.Request[v1.SearchPropertyRequest]) *mPropertyServiceClientMockSearchProperty {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceClientMockSearchPropertyExpectation{}
	}

	if mmSearchProperty.defaultExpectation.params != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Expect")
	}

	if mmSearchProperty.defaultExpectation.paramPtrs == nil {
		mmSearchProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockSearchPropertyParamPtrs{}
	}
	mmSearchProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmSearchProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmSearchProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.SearchProperty
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest])) *mPropertyServiceClientMockSearchProperty {
	if mmSearchProperty.mock.inspectFuncSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.SearchProperty")
	}

	mmSearchProperty.mock.inspectFuncSearchProperty = f

	return mmSearchProperty
}

// Return sets up results that will be returned by PropertyServiceClient.SearchProperty
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Return(pp2 *connect.ServerStreamForClient[v1.SearchPropertyResponse], err error) *PropertyServiceClientMock {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Set")
	}

	if mmSearchProperty.defaultExpectation == nil {
		mmSearchProperty.defaultExpectation = &PropertyServiceClientMockSearchPropertyExpectation{mock: mmSearchProperty.mock}
	}
	mmSearchProperty.defaultExpectation.results = &PropertyServiceClientMockSearchPropertyResults{pp2, err}
	mmSearchProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSearchProperty.mock
}

// Set uses given function f to mock the PropertyServiceClient.SearchProperty method
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchPropertyResponse], err error)) *PropertyServiceClientMock {
	if mmSearchProperty.defaultExpectation != nil {
		mmSearchProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.SearchProperty method")
	}

	if len(mmSearchProperty.expectations) > 0 {
		mmSearchProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.SearchProperty method")
	}

	mmSearchProperty.mock.funcSearchProperty = f
	mmSearchProperty.mock.funcSearchPropertyOrigin = minimock.CallerInfo(1)
	return mmSearchProperty.mock
}

// When sets expectation for the PropertyServiceClient.SearchProperty which will trigger the result defined by the following
// Then helper
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) When(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest]) *PropertyServiceClientMockSearchPropertyExpectation {
	if mmSearchProperty.mock.funcSearchProperty != nil {
		mmSearchProperty.mock.t.Fatalf("PropertyServiceClientMock.SearchProperty mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockSearchPropertyExpectation{
		mock:               mmSearchProperty.mock,
		params:             &PropertyServiceClientMockSearchPropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockSearchPropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSearchProperty.expectations = append(mmSearchProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.SearchProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockSearchPropertyExpectation) Then(pp2 *connect.ServerStreamForClient[v1.SearchPropertyResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockSearchPropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.SearchProperty should be invoked
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Times(n uint64) *mPropertyServiceClientMockSearchProperty {
	if n == 0 {
		mmSearchProperty.mock.t.Fatalf("Times of PropertyServiceClientMock.SearchProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSearchProperty.expectedInvocations, n)
	mmSearchProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSearchProperty
}

func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) invocationsDone() bool {
	if len(mmSearchProperty.expectations) == 0 && mmSearchProperty.defaultExpectation == nil && mmSearchProperty.mock.funcSearchProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSearchProperty.mock.afterSearchPropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSearchProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SearchProperty implements mm_propertyv1connect.PropertyServiceClient
func (mmSearchProperty *PropertyServiceClientMock) SearchProperty(ctx context.Context, pp1 *connect.Request[v1.SearchPropertyRequest]) (pp2 *connect.ServerStreamForClient[v1.SearchPropertyResponse], err error) {
	mm_atomic.AddUint64(&mmSearchProperty.beforeSearchPropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmSearchProperty.afterSearchPropertyCounter, 1)

	mmSearchProperty.t.Helper()

	if mmSearchProperty.inspectFuncSearchProperty != nil {
		mmSearchProperty.inspectFuncSearchProperty(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockSearchPropertyParams{ctx, pp1}

	// Record call args
	mmSearchProperty.SearchPropertyMock.mutex.Lock()
	mmSearchProperty.SearchPropertyMock.callArgs = append(mmSearchProperty.SearchPropertyMock.callArgs, &mm_params)
	mmSearchProperty.SearchPropertyMock.mutex.Unlock()

	for _, e := range mmSearchProperty.SearchPropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSearchProperty.SearchPropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSearchProperty.SearchPropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmSearchProperty.SearchPropertyMock.defaultExpectation.params
		mm_want_ptrs := mmSearchProperty.SearchPropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockSearchPropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSearchProperty.t.Errorf("PropertyServiceClientMock.SearchProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmSearchProperty.t.Errorf("PropertyServiceClientMock.SearchProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSearchProperty.t.Errorf("PropertyServiceClientMock.SearchProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSearchProperty.SearchPropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSearchProperty.SearchPropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmSearchProperty.t.Fatal("No results are set for the PropertyServiceClientMock.SearchProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSearchProperty.funcSearchProperty != nil {
		return mmSearchProperty.funcSearchProperty(ctx, pp1)
	}
	mmSearchProperty.t.Fatalf("Unexpected call to PropertyServiceClientMock.SearchProperty. %v %v", ctx, pp1)
	return
}

// SearchPropertyAfterCounter returns a count of finished PropertyServiceClientMock.SearchProperty invocations
func (mmSearchProperty *PropertyServiceClientMock) SearchPropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchProperty.afterSearchPropertyCounter)
}

// SearchPropertyBeforeCounter returns a count of PropertyServiceClientMock.SearchProperty invocations
func (mmSearchProperty *PropertyServiceClientMock) SearchPropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSearchProperty.beforeSearchPropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.SearchProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSearchProperty *mPropertyServiceClientMockSearchProperty) Calls() []*PropertyServiceClientMockSearchPropertyParams {
	mmSearchProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockSearchPropertyParams, len(mmSearchProperty.callArgs))
	copy(argCopy, mmSearchProperty.callArgs)

	mmSearchProperty.mutex.RUnlock()

	return argCopy
}

// MinimockSearchPropertyDone returns true if the count of the SearchProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockSearchPropertyDone() bool {
	if m.SearchPropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SearchPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SearchPropertyMock.invocationsDone()
}

// MinimockSearchPropertyInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockSearchPropertyInspect() {
	for _, e := range m.SearchPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.SearchProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSearchPropertyCounter := mm_atomic.LoadUint64(&m.afterSearchPropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SearchPropertyMock.defaultExpectation != nil && afterSearchPropertyCounter < 1 {
		if m.SearchPropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.SearchProperty at\n%s", m.SearchPropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.SearchProperty at\n%s with params: %#v", m.SearchPropertyMock.defaultExpectation.expectationOrigins.origin, *m.SearchPropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSearchProperty != nil && afterSearchPropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.SearchProperty at\n%s", m.funcSearchPropertyOrigin)
	}

	if !m.SearchPropertyMock.invocationsDone() && afterSearchPropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.SearchProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SearchPropertyMock.expectedInvocations), m.SearchPropertyMock.expectedInvocationsOrigin, afterSearchPropertyCounter)
	}
}

type mPropertyServiceClientMockStateOfProperty struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockStateOfPropertyExpectation
	expectations       []*PropertyServiceClientMockStateOfPropertyExpectation

	callArgs []*PropertyServiceClientMockStateOfPropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockStateOfPropertyExpectation specifies expectation struct of the PropertyServiceClient.StateOfProperty
type PropertyServiceClientMockStateOfPropertyExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockStateOfPropertyParams
	paramPtrs          *PropertyServiceClientMockStateOfPropertyParamPtrs
	expectationOrigins PropertyServiceClientMockStateOfPropertyExpectationOrigins
	results            *PropertyServiceClientMockStateOfPropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockStateOfPropertyParams contains parameters of the PropertyServiceClient.StateOfProperty
type PropertyServiceClientMockStateOfPropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.StateOfPropertyRequest]
}

// PropertyServiceClientMockStateOfPropertyParamPtrs contains pointers to parameters of the PropertyServiceClient.StateOfProperty
type PropertyServiceClientMockStateOfPropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.StateOfPropertyRequest]
}

// PropertyServiceClientMockStateOfPropertyResults contains results of the PropertyServiceClient.StateOfProperty
type PropertyServiceClientMockStateOfPropertyResults struct {
	pp2 *connect.Response[v1.StateOfPropertyResponse]
	err error
}

// PropertyServiceClientMockStateOfPropertyOrigins contains origins of expectations of the PropertyServiceClient.StateOfProperty
type PropertyServiceClientMockStateOfPropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Optional() *mPropertyServiceClientMockStateOfProperty {
	mmStateOfProperty.optional = true
	return mmStateOfProperty
}

// Expect sets up expected params for PropertyServiceClient.StateOfProperty
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) *mPropertyServiceClientMockStateOfProperty {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceClientMockStateOfPropertyExpectation{}
	}

	if mmStateOfProperty.defaultExpectation.paramPtrs != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by ExpectParams functions")
	}

	mmStateOfProperty.defaultExpectation.params = &PropertyServiceClientMockStateOfPropertyParams{ctx, pp1}
	mmStateOfProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStateOfProperty.expectations {
		if minimock.Equal(e.params, mmStateOfProperty.defaultExpectation.params) {
			mmStateOfProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStateOfProperty.defaultExpectation.params)
		}
	}

	return mmStateOfProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.StateOfProperty
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockStateOfProperty {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceClientMockStateOfPropertyExpectation{}
	}

	if mmStateOfProperty.defaultExpectation.params != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Expect")
	}

	if mmStateOfProperty.defaultExpectation.paramPtrs == nil {
		mmStateOfProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockStateOfPropertyParamPtrs{}
	}
	mmStateOfProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmStateOfProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStateOfProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.StateOfProperty
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) ExpectPp1Param2(pp1 *connect.Request[v1.StateOfPropertyRequest]) *mPropertyServiceClientMockStateOfProperty {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceClientMockStateOfPropertyExpectation{}
	}

	if mmStateOfProperty.defaultExpectation.params != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Expect")
	}

	if mmStateOfProperty.defaultExpectation.paramPtrs == nil {
		mmStateOfProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockStateOfPropertyParamPtrs{}
	}
	mmStateOfProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmStateOfProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmStateOfProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.StateOfProperty
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest])) *mPropertyServiceClientMockStateOfProperty {
	if mmStateOfProperty.mock.inspectFuncStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.StateOfProperty")
	}

	mmStateOfProperty.mock.inspectFuncStateOfProperty = f

	return mmStateOfProperty
}

// Return sets up results that will be returned by PropertyServiceClient.StateOfProperty
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Return(pp2 *connect.Response[v1.StateOfPropertyResponse], err error) *PropertyServiceClientMock {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Set")
	}

	if mmStateOfProperty.defaultExpectation == nil {
		mmStateOfProperty.defaultExpectation = &PropertyServiceClientMockStateOfPropertyExpectation{mock: mmStateOfProperty.mock}
	}
	mmStateOfProperty.defaultExpectation.results = &PropertyServiceClientMockStateOfPropertyResults{pp2, err}
	mmStateOfProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStateOfProperty.mock
}

// Set uses given function f to mock the PropertyServiceClient.StateOfProperty method
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) (pp2 *connect.Response[v1.StateOfPropertyResponse], err error)) *PropertyServiceClientMock {
	if mmStateOfProperty.defaultExpectation != nil {
		mmStateOfProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.StateOfProperty method")
	}

	if len(mmStateOfProperty.expectations) > 0 {
		mmStateOfProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.StateOfProperty method")
	}

	mmStateOfProperty.mock.funcStateOfProperty = f
	mmStateOfProperty.mock.funcStateOfPropertyOrigin = minimock.CallerInfo(1)
	return mmStateOfProperty.mock
}

// When sets expectation for the PropertyServiceClient.StateOfProperty which will trigger the result defined by the following
// Then helper
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) When(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) *PropertyServiceClientMockStateOfPropertyExpectation {
	if mmStateOfProperty.mock.funcStateOfProperty != nil {
		mmStateOfProperty.mock.t.Fatalf("PropertyServiceClientMock.StateOfProperty mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockStateOfPropertyExpectation{
		mock:               mmStateOfProperty.mock,
		params:             &PropertyServiceClientMockStateOfPropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockStateOfPropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmStateOfProperty.expectations = append(mmStateOfProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.StateOfProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockStateOfPropertyExpectation) Then(pp2 *connect.Response[v1.StateOfPropertyResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockStateOfPropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.StateOfProperty should be invoked
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Times(n uint64) *mPropertyServiceClientMockStateOfProperty {
	if n == 0 {
		mmStateOfProperty.mock.t.Fatalf("Times of PropertyServiceClientMock.StateOfProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStateOfProperty.expectedInvocations, n)
	mmStateOfProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStateOfProperty
}

func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) invocationsDone() bool {
	if len(mmStateOfProperty.expectations) == 0 && mmStateOfProperty.defaultExpectation == nil && mmStateOfProperty.mock.funcStateOfProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStateOfProperty.mock.afterStateOfPropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStateOfProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StateOfProperty implements mm_propertyv1connect.PropertyServiceClient
func (mmStateOfProperty *PropertyServiceClientMock) StateOfProperty(ctx context.Context, pp1 *connect.Request[v1.StateOfPropertyRequest]) (pp2 *connect.Response[v1.StateOfPropertyResponse], err error) {
	mm_atomic.AddUint64(&mmStateOfProperty.beforeStateOfPropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmStateOfProperty.afterStateOfPropertyCounter, 1)

	mmStateOfProperty.t.Helper()

	if mmStateOfProperty.inspectFuncStateOfProperty != nil {
		mmStateOfProperty.inspectFuncStateOfProperty(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockStateOfPropertyParams{ctx, pp1}

	// Record call args
	mmStateOfProperty.StateOfPropertyMock.mutex.Lock()
	mmStateOfProperty.StateOfPropertyMock.callArgs = append(mmStateOfProperty.StateOfPropertyMock.callArgs, &mm_params)
	mmStateOfProperty.StateOfPropertyMock.mutex.Unlock()

	for _, e := range mmStateOfProperty.StateOfPropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmStateOfProperty.StateOfPropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStateOfProperty.StateOfPropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmStateOfProperty.StateOfPropertyMock.defaultExpectation.params
		mm_want_ptrs := mmStateOfProperty.StateOfPropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockStateOfPropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStateOfProperty.t.Errorf("PropertyServiceClientMock.StateOfProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStateOfProperty.StateOfPropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmStateOfProperty.t.Errorf("PropertyServiceClientMock.StateOfProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStateOfProperty.StateOfPropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStateOfProperty.t.Errorf("PropertyServiceClientMock.StateOfProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStateOfProperty.StateOfPropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStateOfProperty.StateOfPropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmStateOfProperty.t.Fatal("No results are set for the PropertyServiceClientMock.StateOfProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmStateOfProperty.funcStateOfProperty != nil {
		return mmStateOfProperty.funcStateOfProperty(ctx, pp1)
	}
	mmStateOfProperty.t.Fatalf("Unexpected call to PropertyServiceClientMock.StateOfProperty. %v %v", ctx, pp1)
	return
}

// StateOfPropertyAfterCounter returns a count of finished PropertyServiceClientMock.StateOfProperty invocations
func (mmStateOfProperty *PropertyServiceClientMock) StateOfPropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStateOfProperty.afterStateOfPropertyCounter)
}

// StateOfPropertyBeforeCounter returns a count of PropertyServiceClientMock.StateOfProperty invocations
func (mmStateOfProperty *PropertyServiceClientMock) StateOfPropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStateOfProperty.beforeStateOfPropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.StateOfProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStateOfProperty *mPropertyServiceClientMockStateOfProperty) Calls() []*PropertyServiceClientMockStateOfPropertyParams {
	mmStateOfProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockStateOfPropertyParams, len(mmStateOfProperty.callArgs))
	copy(argCopy, mmStateOfProperty.callArgs)

	mmStateOfProperty.mutex.RUnlock()

	return argCopy
}

// MinimockStateOfPropertyDone returns true if the count of the StateOfProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockStateOfPropertyDone() bool {
	if m.StateOfPropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StateOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StateOfPropertyMock.invocationsDone()
}

// MinimockStateOfPropertyInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockStateOfPropertyInspect() {
	for _, e := range m.StateOfPropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.StateOfProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStateOfPropertyCounter := mm_atomic.LoadUint64(&m.afterStateOfPropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StateOfPropertyMock.defaultExpectation != nil && afterStateOfPropertyCounter < 1 {
		if m.StateOfPropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.StateOfProperty at\n%s", m.StateOfPropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.StateOfProperty at\n%s with params: %#v", m.StateOfPropertyMock.defaultExpectation.expectationOrigins.origin, *m.StateOfPropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStateOfProperty != nil && afterStateOfPropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.StateOfProperty at\n%s", m.funcStateOfPropertyOrigin)
	}

	if !m.StateOfPropertyMock.invocationsDone() && afterStateOfPropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.StateOfProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StateOfPropertyMock.expectedInvocations), m.StateOfPropertyMock.expectedInvocationsOrigin, afterStateOfPropertyCounter)
	}
}

type mPropertyServiceClientMockUpdateProperty struct {
	optional           bool
	mock               *PropertyServiceClientMock
	defaultExpectation *PropertyServiceClientMockUpdatePropertyExpectation
	expectations       []*PropertyServiceClientMockUpdatePropertyExpectation

	callArgs []*PropertyServiceClientMockUpdatePropertyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PropertyServiceClientMockUpdatePropertyExpectation specifies expectation struct of the PropertyServiceClient.UpdateProperty
type PropertyServiceClientMockUpdatePropertyExpectation struct {
	mock               *PropertyServiceClientMock
	params             *PropertyServiceClientMockUpdatePropertyParams
	paramPtrs          *PropertyServiceClientMockUpdatePropertyParamPtrs
	expectationOrigins PropertyServiceClientMockUpdatePropertyExpectationOrigins
	results            *PropertyServiceClientMockUpdatePropertyResults
	returnOrigin       string
	Counter            uint64
}

// PropertyServiceClientMockUpdatePropertyParams contains parameters of the PropertyServiceClient.UpdateProperty
type PropertyServiceClientMockUpdatePropertyParams struct {
	ctx context.Context
	pp1 *connect.Request[v1.UpdatePropertyRequest]
}

// PropertyServiceClientMockUpdatePropertyParamPtrs contains pointers to parameters of the PropertyServiceClient.UpdateProperty
type PropertyServiceClientMockUpdatePropertyParamPtrs struct {
	ctx *context.Context
	pp1 **connect.Request[v1.UpdatePropertyRequest]
}

// PropertyServiceClientMockUpdatePropertyResults contains results of the PropertyServiceClient.UpdateProperty
type PropertyServiceClientMockUpdatePropertyResults struct {
	pp2 *connect.Response[v1.UpdatePropertyResponse]
	err error
}

// PropertyServiceClientMockUpdatePropertyOrigins contains origins of expectations of the PropertyServiceClient.UpdateProperty
type PropertyServiceClientMockUpdatePropertyExpectationOrigins struct {
	origin    string
	originCtx string
	originPp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Optional() *mPropertyServiceClientMockUpdateProperty {
	mmUpdateProperty.optional = true
	return mmUpdateProperty
}

// Expect sets up expected params for PropertyServiceClient.UpdateProperty
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Expect(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) *mPropertyServiceClientMockUpdateProperty {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceClientMockUpdatePropertyExpectation{}
	}

	if mmUpdateProperty.defaultExpectation.paramPtrs != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by ExpectParams functions")
	}

	mmUpdateProperty.defaultExpectation.params = &PropertyServiceClientMockUpdatePropertyParams{ctx, pp1}
	mmUpdateProperty.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateProperty.expectations {
		if minimock.Equal(e.params, mmUpdateProperty.defaultExpectation.params) {
			mmUpdateProperty.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateProperty.defaultExpectation.params)
		}
	}

	return mmUpdateProperty
}

// ExpectCtxParam1 sets up expected param ctx for PropertyServiceClient.UpdateProperty
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) ExpectCtxParam1(ctx context.Context) *mPropertyServiceClientMockUpdateProperty {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceClientMockUpdatePropertyExpectation{}
	}

	if mmUpdateProperty.defaultExpectation.params != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Expect")
	}

	if mmUpdateProperty.defaultExpectation.paramPtrs == nil {
		mmUpdateProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockUpdatePropertyParamPtrs{}
	}
	mmUpdateProperty.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateProperty.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateProperty
}

// ExpectPp1Param2 sets up expected param pp1 for PropertyServiceClient.UpdateProperty
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) ExpectPp1Param2(pp1 *connect.Request[v1.UpdatePropertyRequest]) *mPropertyServiceClientMockUpdateProperty {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceClientMockUpdatePropertyExpectation{}
	}

	if mmUpdateProperty.defaultExpectation.params != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Expect")
	}

	if mmUpdateProperty.defaultExpectation.paramPtrs == nil {
		mmUpdateProperty.defaultExpectation.paramPtrs = &PropertyServiceClientMockUpdatePropertyParamPtrs{}
	}
	mmUpdateProperty.defaultExpectation.paramPtrs.pp1 = &pp1
	mmUpdateProperty.defaultExpectation.expectationOrigins.originPp1 = minimock.CallerInfo(1)

	return mmUpdateProperty
}

// Inspect accepts an inspector function that has same arguments as the PropertyServiceClient.UpdateProperty
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Inspect(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest])) *mPropertyServiceClientMockUpdateProperty {
	if mmUpdateProperty.mock.inspectFuncUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("Inspect function is already set for PropertyServiceClientMock.UpdateProperty")
	}

	mmUpdateProperty.mock.inspectFuncUpdateProperty = f

	return mmUpdateProperty
}

// Return sets up results that will be returned by PropertyServiceClient.UpdateProperty
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Return(pp2 *connect.Response[v1.UpdatePropertyResponse], err error) *PropertyServiceClientMock {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Set")
	}

	if mmUpdateProperty.defaultExpectation == nil {
		mmUpdateProperty.defaultExpectation = &PropertyServiceClientMockUpdatePropertyExpectation{mock: mmUpdateProperty.mock}
	}
	mmUpdateProperty.defaultExpectation.results = &PropertyServiceClientMockUpdatePropertyResults{pp2, err}
	mmUpdateProperty.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateProperty.mock
}

// Set uses given function f to mock the PropertyServiceClient.UpdateProperty method
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Set(f func(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) (pp2 *connect.Response[v1.UpdatePropertyResponse], err error)) *PropertyServiceClientMock {
	if mmUpdateProperty.defaultExpectation != nil {
		mmUpdateProperty.mock.t.Fatalf("Default expectation is already set for the PropertyServiceClient.UpdateProperty method")
	}

	if len(mmUpdateProperty.expectations) > 0 {
		mmUpdateProperty.mock.t.Fatalf("Some expectations are already set for the PropertyServiceClient.UpdateProperty method")
	}

	mmUpdateProperty.mock.funcUpdateProperty = f
	mmUpdateProperty.mock.funcUpdatePropertyOrigin = minimock.CallerInfo(1)
	return mmUpdateProperty.mock
}

// When sets expectation for the PropertyServiceClient.UpdateProperty which will trigger the result defined by the following
// Then helper
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) When(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) *PropertyServiceClientMockUpdatePropertyExpectation {
	if mmUpdateProperty.mock.funcUpdateProperty != nil {
		mmUpdateProperty.mock.t.Fatalf("PropertyServiceClientMock.UpdateProperty mock is already set by Set")
	}

	expectation := &PropertyServiceClientMockUpdatePropertyExpectation{
		mock:               mmUpdateProperty.mock,
		params:             &PropertyServiceClientMockUpdatePropertyParams{ctx, pp1},
		expectationOrigins: PropertyServiceClientMockUpdatePropertyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateProperty.expectations = append(mmUpdateProperty.expectations, expectation)
	return expectation
}

// Then sets up PropertyServiceClient.UpdateProperty return parameters for the expectation previously defined by the When method
func (e *PropertyServiceClientMockUpdatePropertyExpectation) Then(pp2 *connect.Response[v1.UpdatePropertyResponse], err error) *PropertyServiceClientMock {
	e.results = &PropertyServiceClientMockUpdatePropertyResults{pp2, err}
	return e.mock
}

// Times sets number of times PropertyServiceClient.UpdateProperty should be invoked
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Times(n uint64) *mPropertyServiceClientMockUpdateProperty {
	if n == 0 {
		mmUpdateProperty.mock.t.Fatalf("Times of PropertyServiceClientMock.UpdateProperty mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateProperty.expectedInvocations, n)
	mmUpdateProperty.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateProperty
}

func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) invocationsDone() bool {
	if len(mmUpdateProperty.expectations) == 0 && mmUpdateProperty.defaultExpectation == nil && mmUpdateProperty.mock.funcUpdateProperty == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateProperty.mock.afterUpdatePropertyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateProperty.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateProperty implements mm_propertyv1connect.PropertyServiceClient
func (mmUpdateProperty *PropertyServiceClientMock) UpdateProperty(ctx context.Context, pp1 *connect.Request[v1.UpdatePropertyRequest]) (pp2 *connect.Response[v1.UpdatePropertyResponse], err error) {
	mm_atomic.AddUint64(&mmUpdateProperty.beforeUpdatePropertyCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateProperty.afterUpdatePropertyCounter, 1)

	mmUpdateProperty.t.Helper()

	if mmUpdateProperty.inspectFuncUpdateProperty != nil {
		mmUpdateProperty.inspectFuncUpdateProperty(ctx, pp1)
	}

	mm_params := PropertyServiceClientMockUpdatePropertyParams{ctx, pp1}

	// Record call args
	mmUpdateProperty.UpdatePropertyMock.mutex.Lock()
	mmUpdateProperty.UpdatePropertyMock.callArgs = append(mmUpdateProperty.UpdatePropertyMock.callArgs, &mm_params)
	mmUpdateProperty.UpdatePropertyMock.mutex.Unlock()

	for _, e := range mmUpdateProperty.UpdatePropertyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpdateProperty.UpdatePropertyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateProperty.UpdatePropertyMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateProperty.UpdatePropertyMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateProperty.UpdatePropertyMock.defaultExpectation.paramPtrs

		mm_got := PropertyServiceClientMockUpdatePropertyParams{ctx, pp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateProperty.t.Errorf("PropertyServiceClientMock.UpdateProperty got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateProperty.UpdatePropertyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pp1 != nil && !minimock.Equal(*mm_want_ptrs.pp1, mm_got.pp1) {
				mmUpdateProperty.t.Errorf("PropertyServiceClientMock.UpdateProperty got unexpected parameter pp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateProperty.UpdatePropertyMock.defaultExpectation.expectationOrigins.originPp1, *mm_want_ptrs.pp1, mm_got.pp1, minimock.Diff(*mm_want_ptrs.pp1, mm_got.pp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateProperty.t.Errorf("PropertyServiceClientMock.UpdateProperty got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateProperty.UpdatePropertyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateProperty.UpdatePropertyMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateProperty.t.Fatal("No results are set for the PropertyServiceClientMock.UpdateProperty")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpdateProperty.funcUpdateProperty != nil {
		return mmUpdateProperty.funcUpdateProperty(ctx, pp1)
	}
	mmUpdateProperty.t.Fatalf("Unexpected call to PropertyServiceClientMock.UpdateProperty. %v %v", ctx, pp1)
	return
}

// UpdatePropertyAfterCounter returns a count of finished PropertyServiceClientMock.UpdateProperty invocations
func (mmUpdateProperty *PropertyServiceClientMock) UpdatePropertyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProperty.afterUpdatePropertyCounter)
}

// UpdatePropertyBeforeCounter returns a count of PropertyServiceClientMock.UpdateProperty invocations
func (mmUpdateProperty *PropertyServiceClientMock) UpdatePropertyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProperty.beforeUpdatePropertyCounter)
}

// Calls returns a list of arguments used in each call to PropertyServiceClientMock.UpdateProperty.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateProperty *mPropertyServiceClientMockUpdateProperty) Calls() []*PropertyServiceClientMockUpdatePropertyParams {
	mmUpdateProperty.mutex.RLock()

	argCopy := make([]*PropertyServiceClientMockUpdatePropertyParams, len(mmUpdateProperty.callArgs))
	copy(argCopy, mmUpdateProperty.callArgs)

	mmUpdateProperty.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePropertyDone returns true if the count of the UpdateProperty invocations corresponds
// the number of defined expectations
func (m *PropertyServiceClientMock) MinimockUpdatePropertyDone() bool {
	if m.UpdatePropertyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdatePropertyMock.invocationsDone()
}

// MinimockUpdatePropertyInspect logs each unmet expectation
func (m *PropertyServiceClientMock) MinimockUpdatePropertyInspect() {
	for _, e := range m.UpdatePropertyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PropertyServiceClientMock.UpdateProperty at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdatePropertyCounter := mm_atomic.LoadUint64(&m.afterUpdatePropertyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePropertyMock.defaultExpectation != nil && afterUpdatePropertyCounter < 1 {
		if m.UpdatePropertyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PropertyServiceClientMock.UpdateProperty at\n%s", m.UpdatePropertyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PropertyServiceClientMock.UpdateProperty at\n%s with params: %#v", m.UpdatePropertyMock.defaultExpectation.expectationOrigins.origin, *m.UpdatePropertyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateProperty != nil && afterUpdatePropertyCounter < 1 {
		m.t.Errorf("Expected call to PropertyServiceClientMock.UpdateProperty at\n%s", m.funcUpdatePropertyOrigin)
	}

	if !m.UpdatePropertyMock.invocationsDone() && afterUpdatePropertyCounter > 0 {
		m.t.Errorf("Expected %d calls to PropertyServiceClientMock.UpdateProperty at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdatePropertyMock.expectedInvocations), m.UpdatePropertyMock.expectedInvocationsOrigin, afterUpdatePropertyCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PropertyServiceClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddLocalityInspect()

			m.MinimockAddPropertyTypeInspect()

			m.MinimockAddSubscriptionInspect()

			m.MinimockCreatePropertyInspect()

			m.MinimockDeleteLocalityInspect()

			m.MinimockDeletePropertyInspect()

			m.MinimockDeleteSubscriptionInspect()

			m.MinimockHistoryOfPropertyInspect()

			m.MinimockListPropertyTypeInspect()

			m.MinimockListSubscriptionInspect()

			m.MinimockSearchPropertyInspect()

			m.MinimockStateOfPropertyInspect()

			m.MinimockUpdatePropertyInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PropertyServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PropertyServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddLocalityDone() &&
		m.MinimockAddPropertyTypeDone() &&
		m.MinimockAddSubscriptionDone() &&
		m.MinimockCreatePropertyDone() &&
		m.MinimockDeleteLocalityDone() &&
		m.MinimockDeletePropertyDone() &&
		m.MinimockDeleteSubscriptionDone() &&
		m.MinimockHistoryOfPropertyDone() &&
		m.MinimockListPropertyTypeDone() &&
		m.MinimockListSubscriptionDone() &&
		m.MinimockSearchPropertyDone() &&
		m.MinimockStateOfPropertyDone() &&
		m.MinimockUpdatePropertyDone()
}
